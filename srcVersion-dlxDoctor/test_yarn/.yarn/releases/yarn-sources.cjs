#!/usr/bin/env node
/* eslint-disable */
//prettier-ignore
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module2) => () => {
    if (!module2) {
      module2 = {exports: {}};
      callback(module2.exports, module2);
    }
    return module2.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __exportStar = (target, module2, desc) => {
    __markAsModule(target);
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    if (module2 && module2.__esModule)
      return module2;
    return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fromentries-npm-1.2.0-7bbcba0f9c-daae12847b.zip\node_modules\fromentries\index.js
  var require_fromentries = __commonJS((exports2, module2) => {
    module2.exports = function fromEntries2(iterable) {
      return [...iterable].reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
      }, {});
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip\node_modules\isexe\windows.js
  var require_windows = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs9 = require("fs");
    function checkPathExt(path6, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path6.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path6, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path6, options);
    }
    function isexe(path6, options, cb) {
      fs9.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path6, options));
      });
    }
    function sync(path6, options) {
      return checkStat(fs9.statSync(path6), path6, options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip\node_modules\isexe\mode.js
  var require_mode = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs9 = require("fs");
    function isexe(path6, options, cb) {
      fs9.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path6, options) {
      return checkStat(fs9.statSync(path6), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod2 = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
      return ret;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip\node_modules\isexe\index.js
  var require_isexe = __commonJS((exports2, module2) => {
    var fs9 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path6, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path6, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path6, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path6, options) {
      try {
        return core.sync(path6, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\which-npm-2.0.2-320ddf72f7-ea9b1db126.zip\node_modules\which\which.js
  var require_which = __commonJS((exports2, module2) => {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path6 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, {pathExt: pathExtExe});
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\path-key-npm-3.1.1-0e66ea8321-e44aa3ca9f.zip\node_modules\path-key\index.js
  var require_path_key = __commonJS((exports2, module2) => {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\lib\util\resolveCommand.js
  var require_resolveCommand = __commonJS((exports2, module2) => {
    "use strict";
    var path6 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({env})],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\lib\util\escape.js
  var require_escape = __commonJS((exports2, module2) => {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\shebang-regex-npm-3.0.0-899a0cd65e-ea18044ffa.zip\node_modules\shebang-regex\index.js
  var require_shebang_regex = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = /^#!(.*)/;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\shebang-command-npm-2.0.0-eb2b01921d-85aa394d8c.zip\node_modules\shebang-command\index.js
  var require_shebang_command = __commonJS((exports2, module2) => {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match2 = string.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path6, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary = path6.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\lib\util\readShebang.js
  var require_readShebang = __commonJS((exports2, module2) => {
    "use strict";
    var fs9 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs9.openSync(command, "r");
        fs9.readSync(fd, buffer, 0, size, 0);
        fs9.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\lib\parse.js
  var require_parse = __commonJS((exports2, module2) => {
    "use strict";
    var path6 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse4(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\lib\enoent.js
  var require_enoent = __commonJS((exports2, module2) => {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip\node_modules\cross-spawn\index.js
  var require_cross_spawn = __commonJS((exports2, module2) => {
    "use strict";
    var cp = require("child_process");
    var parse4 = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse4(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse4(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse4;
    module2.exports._enoent = enoent;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip\node_modules\color-name\index.js
  var require_color_name = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip\node_modules\color-convert\conversions.js
  var require_conversions = __commonJS((exports2, module2) => {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {channels: 3, labels: "rgb"},
      hsl: {channels: 3, labels: "hsl"},
      hsv: {channels: 3, labels: "hsv"},
      hwb: {channels: 3, labels: "hwb"},
      cmyk: {channels: 4, labels: "cmyk"},
      xyz: {channels: 3, labels: "xyz"},
      lab: {channels: 3, labels: "lab"},
      lch: {channels: 3, labels: "lch"},
      hex: {channels: 1, labels: ["hex"]},
      keyword: {channels: 1, labels: ["keyword"]},
      ansi16: {channels: 1, labels: ["ansi16"]},
      ansi256: {channels: 1, labels: ["ansi256"]},
      hcg: {channels: 3, labels: ["h", "c", "g"]},
      apple: {channels: 3, labels: ["r16", "g16", "b16"]},
      gray: {channels: 1, labels: ["gray"]}
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const {channels, labels} = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t22;
      let t32;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t22 = l * (1 + s);
      } else {
        t22 = l + s - l * s;
      }
      const t1 = 2 * l - t22;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t32 = h + 1 / 3 * -(i - 1);
        if (t32 < 0) {
          t32++;
        }
        if (t32 > 1) {
          t32--;
        }
        if (6 * t32 < 1) {
          val = t1 + (t22 - t1) * 6 * t32;
        } else if (2 * t32 < 1) {
          val = t22;
        } else if (3 * t32 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t32) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t7 = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t7, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t7];
        case 3:
          return [p, q, v];
        case 4:
          return [t7, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip\node_modules\color-convert\route.js
  var require_route = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path6 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path6.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path6;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip\node_modules\color-convert\index.js
  var require_color_convert = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ansi-styles-npm-4.2.0-1fc112ccec-d24bf14e9d.zip\node_modules\ansi-styles\index.js
  var require_ansi_styles = __commonJS((exports2, module2) => {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get4) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get4();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip\node_modules\has-flag\index.js
  var require_has_flag = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip\node_modules\supports-color\index.js
  var require_supports_color = __commonJS((exports2, module2) => {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("GITHUB_ACTIONS" in env) {
        return 1;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor2(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor2(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor2(true, tty.isatty(2)))
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\chalk-npm-3.0.0-e813208025-4018b0c812.zip\node_modules\chalk\source\util.js
  var require_util = __commonJS((exports2, module2) => {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\chalk-npm-3.0.0-e813208025-4018b0c812.zip\node_modules\chalk\source\templates.js
  var require_templates = __commonJS((exports2, module2) => {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk2, styles)(string));
          styles.push({inverse, styles: parseStyle(style)});
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\chalk-npm-3.0.0-e813208025-4018b0c812.zip\node_modules\chalk\source\index.js
  var require_source = __commonJS((exports2, module2) => {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level > 3 || options.level < 0) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {value: builder});
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {value: builder});
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        return applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      builder.__proto__ = proto;
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle2 = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const {openAll, closeAll} = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk3, ...strings) => {
      const [firstString] = strings;
      if (!Array.isArray(firstString)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
    chalk2.stderr.supportsColor = stderrColor;
    chalk2.Level = {
      None: 0,
      Basic: 1,
      Ansi256: 2,
      TrueColor: 3,
      0: "None",
      1: "Basic",
      2: "Ansi256",
      3: "TrueColor"
    };
    module2.exports = chalk2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ansi-regex-npm-5.0.0-9c076068d9-cbd9b5c9db.zip\node_modules\ansi-regex\index.js
  var require_ansi_regex = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = ({onlyFirst = false} = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\strip-ansi-npm-6.0.0-904613e9eb-10568c91ca.zip\node_modules\strip-ansi\index.js
  var require_strip_ansi = __commonJS((exports2, module2) => {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\typanion-npm-3.2.1-d7aec05187-db18b79efd.zip\node_modules\typanion\lib\index.mjs
  var require_lib = __commonJS((exports2) => {
    __export(exports2, {
      KeyRelationship: () => KeyRelationship,
      applyCascade: () => applyCascade3,
      base64RegExp: () => base64RegExp,
      colorStringAlphaRegExp: () => colorStringAlphaRegExp,
      colorStringRegExp: () => colorStringRegExp,
      computeKey: () => computeKey,
      getPrintable: () => getPrintable,
      hasExactLength: () => hasExactLength,
      hasForbiddenKeys: () => hasForbiddenKeys,
      hasKeyRelationship: () => hasKeyRelationship,
      hasMaxLength: () => hasMaxLength,
      hasMinLength: () => hasMinLength,
      hasMutuallyExclusiveKeys: () => hasMutuallyExclusiveKeys,
      hasRequiredKeys: () => hasRequiredKeys,
      hasUniqueItems: () => hasUniqueItems,
      isArray: () => isArray,
      isAtLeast: () => isAtLeast,
      isAtMost: () => isAtMost,
      isBase64: () => isBase64,
      isBoolean: () => isBoolean,
      isDate: () => isDate2,
      isDict: () => isDict,
      isEnum: () => isEnum5,
      isHexColor: () => isHexColor,
      isISO8601: () => isISO8601,
      isInExclusiveRange: () => isInExclusiveRange,
      isInInclusiveRange: () => isInInclusiveRange,
      isInstanceOf: () => isInstanceOf,
      isInteger: () => isInteger,
      isJSON: () => isJSON,
      isLiteral: () => isLiteral,
      isLowerCase: () => isLowerCase,
      isNegative: () => isNegative,
      isNullable: () => isNullable,
      isNumber: () => isNumber,
      isObject: () => isObject,
      isOneOf: () => isOneOf,
      isOptional: () => isOptional,
      isPositive: () => isPositive,
      isString: () => isString3,
      isTuple: () => isTuple,
      isUUID4: () => isUUID4,
      isUnknown: () => isUnknown,
      isUpperCase: () => isUpperCase,
      iso8601RegExp: () => iso8601RegExp,
      makeCoercionFn: () => makeCoercionFn,
      makeSetter: () => makeSetter,
      makeTrait: () => makeTrait,
      makeValidator: () => makeValidator,
      matchesRegExp: () => matchesRegExp3,
      plural: () => plural,
      pushError: () => pushError,
      simpleKeyRegExp: () => simpleKeyRegExp,
      uuid4RegExp: () => uuid4RegExp
    });
    var simpleKeyRegExp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
    var colorStringRegExp = /^#[0-9a-f]{6}$/i;
    var colorStringAlphaRegExp = /^#[0-9a-f]{6}([0-9a-f]{2})?$/i;
    var base64RegExp = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    var uuid4RegExp = /^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89aAbB][a-f0-9]{3}-[a-f0-9]{12}$/i;
    var iso8601RegExp = /^(?:[1-9]\d{3}(-?)(?:(?:0[1-9]|1[0-2])\1(?:0[1-9]|1\d|2[0-8])|(?:0[13-9]|1[0-2])\1(?:29|30)|(?:0[13578]|1[02])(?:\1)31|00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[0-5]))|(?:[1-9]\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)(?:(-?)02(?:\2)29|-?366))T(?:[01]\d|2[0-3])(:?)[0-5]\d(?:\3[0-5]\d)?(?:Z|[+-][01]\d(?:\3[0-5]\d)?)$/;
    var makeTrait = (value) => () => {
      return value;
    };
    function makeValidator({test}) {
      return makeTrait(test)();
    }
    function getPrintable(value) {
      if (value === null)
        return `null`;
      if (value === void 0)
        return `undefined`;
      if (value === ``)
        return `an empty string`;
      return JSON.stringify(value);
    }
    function computeKey(state, key) {
      var _a2, _b, _c;
      if (typeof key === `number`) {
        return `${(_a2 = state === null || state === void 0 ? void 0 : state.p) !== null && _a2 !== void 0 ? _a2 : `.`}[${key}]`;
      } else if (simpleKeyRegExp.test(key)) {
        return `${(_b = state === null || state === void 0 ? void 0 : state.p) !== null && _b !== void 0 ? _b : ``}.${key}`;
      } else {
        return `${(_c = state === null || state === void 0 ? void 0 : state.p) !== null && _c !== void 0 ? _c : `.`}[${JSON.stringify(key)}]`;
      }
    }
    function makeCoercionFn(target, key) {
      return (v) => {
        const previous = target[key];
        target[key] = v;
        return makeCoercionFn(target, key).bind(null, previous);
      };
    }
    function makeSetter(target, key) {
      return (v) => {
        target[key] = v;
      };
    }
    function plural(n, singular, plural2) {
      return n === 1 ? singular : plural2;
    }
    function pushError({errors: errors4, p} = {}, message) {
      errors4 === null || errors4 === void 0 ? void 0 : errors4.push(`${p !== null && p !== void 0 ? p : `.`}: ${message}`);
      return false;
    }
    var isUnknown = () => makeValidator({
      test: (value, state) => {
        return true;
      }
    });
    function isLiteral(expected) {
      return makeValidator({
        test: (value, state) => {
          if (value !== expected)
            return pushError(state, `Expected a literal (got ${getPrintable(expected)})`);
          return true;
        }
      });
    }
    var isString3 = () => makeValidator({
      test: (value, state) => {
        if (typeof value !== `string`)
          return pushError(state, `Expected a string (got ${getPrintable(value)})`);
        return true;
      }
    });
    function isEnum5(enumSpec) {
      const valuesArray = Array.isArray(enumSpec) ? enumSpec : Object.values(enumSpec);
      const values = new Set(valuesArray);
      return makeValidator({
        test: (value, state) => {
          if (!values.has(value))
            return pushError(state, `Expected a valid enumeration value (got ${getPrintable(value)})`);
          return true;
        }
      });
    }
    var BOOLEAN_COERCIONS = new Map([
      [`true`, true],
      [`True`, true],
      [`1`, true],
      [1, true],
      [`false`, false],
      [`False`, false],
      [`0`, false],
      [0, false]
    ]);
    var isBoolean = () => makeValidator({
      test: (value, state) => {
        var _a2;
        if (typeof value !== `boolean`) {
          if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
              return pushError(state, `Unbound coercion result`);
            const coercion = BOOLEAN_COERCIONS.get(value);
            if (typeof coercion !== `undefined`) {
              state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, coercion)]);
              return true;
            }
          }
          return pushError(state, `Expected a boolean (got ${getPrintable(value)})`);
        }
        return true;
      }
    });
    var isNumber = () => makeValidator({
      test: (value, state) => {
        var _a2;
        if (typeof value !== `number`) {
          if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
              return pushError(state, `Unbound coercion result`);
            let coercion;
            if (typeof value === `string`) {
              let val;
              try {
                val = JSON.parse(value);
              } catch (_b) {
              }
              if (typeof val === `number`) {
                if (JSON.stringify(val) === value) {
                  coercion = val;
                } else {
                  return pushError(state, `Received a number that can't be safely represented by the runtime (${value})`);
                }
              }
            }
            if (typeof coercion !== `undefined`) {
              state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, coercion)]);
              return true;
            }
          }
          return pushError(state, `Expected a number (got ${getPrintable(value)})`);
        }
        return true;
      }
    });
    var isDate2 = () => makeValidator({
      test: (value, state) => {
        var _a2;
        if (!(value instanceof Date)) {
          if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
              return pushError(state, `Unbound coercion result`);
            let coercion;
            if (typeof value === `string` && iso8601RegExp.test(value)) {
              coercion = new Date(value);
            } else {
              let timestamp;
              if (typeof value === `string`) {
                let val;
                try {
                  val = JSON.parse(value);
                } catch (_b) {
                }
                if (typeof val === `number`) {
                  timestamp = val;
                }
              } else if (typeof value === `number`) {
                timestamp = value;
              }
              if (typeof timestamp !== `undefined`) {
                if (Number.isSafeInteger(timestamp) || !Number.isSafeInteger(timestamp * 1e3)) {
                  coercion = new Date(timestamp * 1e3);
                } else {
                  return pushError(state, `Received a timestamp that can't be safely represented by the runtime (${value})`);
                }
              }
            }
            if (typeof coercion !== `undefined`) {
              state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, coercion)]);
              return true;
            }
          }
          return pushError(state, `Expected a date (got ${getPrintable(value)})`);
        }
        return true;
      }
    });
    var isArray = (spec, {delimiter} = {}) => makeValidator({
      test: (value, state) => {
        var _a2;
        if (typeof value === `string` && typeof delimiter !== `undefined`) {
          if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
              return pushError(state, `Unbound coercion result`);
            value = value.split(delimiter);
            state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, value)]);
          }
        }
        if (!Array.isArray(value))
          return pushError(state, `Expected an array (got ${getPrintable(value)})`);
        let valid = true;
        for (let t7 = 0, T = value.length; t7 < T; ++t7) {
          valid = spec(value[t7], Object.assign(Object.assign({}, state), {p: computeKey(state, t7), coercion: makeCoercionFn(value, t7)})) && valid;
          if (!valid && (state === null || state === void 0 ? void 0 : state.errors) == null) {
            break;
          }
        }
        return valid;
      }
    });
    var isTuple = (spec, {delimiter} = {}) => {
      const lengthValidator = hasExactLength(spec.length);
      return makeValidator({
        test: (value, state) => {
          var _a2;
          if (typeof value === `string` && typeof delimiter !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
              if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
                return pushError(state, `Unbound coercion result`);
              value = value.split(delimiter);
              state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, value)]);
            }
          }
          if (!Array.isArray(value))
            return pushError(state, `Expected a tuple (got ${getPrintable(value)})`);
          let valid = lengthValidator(value, Object.assign({}, state));
          for (let t7 = 0, T = value.length; t7 < T && t7 < spec.length; ++t7) {
            valid = spec[t7](value[t7], Object.assign(Object.assign({}, state), {p: computeKey(state, t7), coercion: makeCoercionFn(value, t7)})) && valid;
            if (!valid && (state === null || state === void 0 ? void 0 : state.errors) == null) {
              break;
            }
          }
          return valid;
        }
      });
    };
    var isDict = (spec, {keys: keySpec = null} = {}) => makeValidator({
      test: (value, state) => {
        if (typeof value !== `object` || value === null)
          return pushError(state, `Expected an object (got ${getPrintable(value)})`);
        const keys = Object.keys(value);
        let valid = true;
        for (let t7 = 0, T = keys.length && (valid || (state === null || state === void 0 ? void 0 : state.errors) != null); t7 < T; ++t7) {
          const key = keys[t7];
          const sub = value[key];
          if (key === `__proto__` || key === `constructor`) {
            valid = pushError(Object.assign(Object.assign({}, state), {p: computeKey(state, key)}), `Unsafe property name`);
            continue;
          }
          if (keySpec !== null && !keySpec(key, state)) {
            valid = false;
            continue;
          }
          if (!spec(sub, Object.assign(Object.assign({}, state), {p: computeKey(state, key), coercion: makeCoercionFn(value, key)}))) {
            valid = false;
            continue;
          }
        }
        return valid;
      }
    });
    var isObject = (props, {extra: extraSpec = null} = {}) => {
      const specKeys = Object.keys(props);
      return makeValidator({
        test: (value, state) => {
          if (typeof value !== `object` || value === null)
            return pushError(state, `Expected an object (got ${getPrintable(value)})`);
          const keys = new Set([...specKeys, ...Object.keys(value)]);
          const extra = {};
          let valid = true;
          for (const key of keys) {
            if (key === `constructor` || key === `__proto__`) {
              valid = pushError(Object.assign(Object.assign({}, state), {p: computeKey(state, key)}), `Unsafe property name`);
            } else {
              const spec = Object.prototype.hasOwnProperty.call(props, key) ? props[key] : void 0;
              const sub = Object.prototype.hasOwnProperty.call(value, key) ? value[key] : void 0;
              if (typeof spec !== `undefined`) {
                valid = spec(sub, Object.assign(Object.assign({}, state), {p: computeKey(state, key), coercion: makeCoercionFn(value, key)})) && valid;
              } else if (extraSpec === null) {
                valid = pushError(Object.assign(Object.assign({}, state), {p: computeKey(state, key)}), `Extraneous property (got ${getPrintable(sub)})`);
              } else {
                Object.defineProperty(extra, key, {
                  enumerable: true,
                  get: () => sub,
                  set: makeSetter(value, key)
                });
              }
            }
            if (!valid && (state === null || state === void 0 ? void 0 : state.errors) == null) {
              break;
            }
          }
          if (extraSpec !== null && (valid || (state === null || state === void 0 ? void 0 : state.errors) != null))
            valid = extraSpec(extra, state) && valid;
          return valid;
        }
      });
    };
    var isInstanceOf = (constructor) => makeValidator({
      test: (value, state) => {
        if (!(value instanceof constructor))
          return pushError(state, `Expected an instance of ${constructor.name} (got ${getPrintable(value)})`);
        return true;
      }
    });
    var isOneOf = (specs, {exclusive = false} = {}) => makeValidator({
      test: (value, state) => {
        var _a2, _b, _c;
        const matches = [];
        const errorBuffer = typeof (state === null || state === void 0 ? void 0 : state.errors) !== `undefined` ? [] : void 0;
        for (let t7 = 0, T = specs.length; t7 < T; ++t7) {
          const subErrors = typeof (state === null || state === void 0 ? void 0 : state.errors) !== `undefined` ? [] : void 0;
          const subCoercions = typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined` ? [] : void 0;
          if (specs[t7](value, Object.assign(Object.assign({}, state), {errors: subErrors, coercions: subCoercions, p: `${(_a2 = state === null || state === void 0 ? void 0 : state.p) !== null && _a2 !== void 0 ? _a2 : `.`}#${t7 + 1}`}))) {
            matches.push([`#${t7 + 1}`, subCoercions]);
            if (!exclusive) {
              break;
            }
          } else {
            errorBuffer === null || errorBuffer === void 0 ? void 0 : errorBuffer.push(subErrors[0]);
          }
        }
        if (matches.length === 1) {
          const [, subCoercions] = matches[0];
          if (typeof subCoercions !== `undefined`)
            (_b = state === null || state === void 0 ? void 0 : state.coercions) === null || _b === void 0 ? void 0 : _b.push(...subCoercions);
          return true;
        }
        if (matches.length > 1)
          pushError(state, `Expected to match exactly a single predicate (matched ${matches.join(`, `)})`);
        else
          (_c = state === null || state === void 0 ? void 0 : state.errors) === null || _c === void 0 ? void 0 : _c.push(...errorBuffer);
        return false;
      }
    });
    var applyCascade3 = (spec, followups) => makeValidator({
      test: (value, state) => {
        var _a2, _b;
        const context = {value};
        const subCoercion = typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined` ? makeCoercionFn(context, `value`) : void 0;
        const subCoercions = typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined` ? [] : void 0;
        if (!spec(value, Object.assign(Object.assign({}, state), {coercion: subCoercion, coercions: subCoercions})))
          return false;
        const reverts = [];
        if (typeof subCoercions !== `undefined`)
          for (const [, coercion] of subCoercions)
            reverts.push(coercion());
        try {
          if (typeof (state === null || state === void 0 ? void 0 : state.coercions) !== `undefined`) {
            if (typeof (state === null || state === void 0 ? void 0 : state.coercion) === `undefined`)
              return pushError(state, `Unbound coercion result`);
            if (context.value !== value)
              state.coercions.push([(_a2 = state.p) !== null && _a2 !== void 0 ? _a2 : `.`, state.coercion.bind(null, context.value)]);
            (_b = state === null || state === void 0 ? void 0 : state.coercions) === null || _b === void 0 ? void 0 : _b.push(...subCoercions);
          }
          return followups.every((spec2) => {
            return spec2(context.value, state);
          });
        } finally {
          for (const revert of reverts) {
            revert();
          }
        }
      }
    });
    var isOptional = (spec) => makeValidator({
      test: (value, state) => {
        if (typeof value === `undefined`)
          return true;
        return spec(value, state);
      }
    });
    var isNullable = (spec) => makeValidator({
      test: (value, state) => {
        if (value === null)
          return true;
        return spec(value, state);
      }
    });
    var hasMinLength = (length) => makeValidator({
      test: (value, state) => {
        if (!(value.length >= length))
          return pushError(state, `Expected to have a length of at least ${length} elements (got ${value.length})`);
        return true;
      }
    });
    var hasMaxLength = (length) => makeValidator({
      test: (value, state) => {
        if (!(value.length <= length))
          return pushError(state, `Expected to have a length of at most ${length} elements (got ${value.length})`);
        return true;
      }
    });
    var hasExactLength = (length) => makeValidator({
      test: (value, state) => {
        if (!(value.length === length))
          return pushError(state, `Expected to have a length of exactly ${length} elements (got ${value.length})`);
        return true;
      }
    });
    var hasUniqueItems = ({map} = {}) => makeValidator({
      test: (value, state) => {
        const set = new Set();
        const dup = new Set();
        for (let t7 = 0, T = value.length; t7 < T; ++t7) {
          const sub = value[t7];
          const key = typeof map !== `undefined` ? map(sub) : sub;
          if (set.has(key)) {
            if (dup.has(key))
              continue;
            pushError(state, `Expected to contain unique elements; got a duplicate with ${getPrintable(value)}`);
            dup.add(key);
          } else {
            set.add(key);
          }
        }
        return dup.size === 0;
      }
    });
    var isNegative = () => makeValidator({
      test: (value, state) => {
        if (!(value <= 0))
          return pushError(state, `Expected to be negative (got ${value})`);
        return true;
      }
    });
    var isPositive = () => makeValidator({
      test: (value, state) => {
        if (!(value >= 0))
          return pushError(state, `Expected to be positive (got ${value})`);
        return true;
      }
    });
    var isAtLeast = (n) => makeValidator({
      test: (value, state) => {
        if (!(value >= n))
          return pushError(state, `Expected to be at least ${n} (got ${value})`);
        return true;
      }
    });
    var isAtMost = (n) => makeValidator({
      test: (value, state) => {
        if (!(value <= n))
          return pushError(state, `Expected to be at most ${n} (got ${value})`);
        return true;
      }
    });
    var isInInclusiveRange = (a, b) => makeValidator({
      test: (value, state) => {
        if (!(value >= a && value <= b))
          return pushError(state, `Expected to be in the [${a}; ${b}] range (got ${value})`);
        return true;
      }
    });
    var isInExclusiveRange = (a, b) => makeValidator({
      test: (value, state) => {
        if (!(value >= a && value < b))
          return pushError(state, `Expected to be in the [${a}; ${b}[ range (got ${value})`);
        return true;
      }
    });
    var isInteger = ({unsafe = false} = {}) => makeValidator({
      test: (value, state) => {
        if (value !== Math.round(value))
          return pushError(state, `Expected to be an integer (got ${value})`);
        if (!Number.isSafeInteger(value))
          return pushError(state, `Expected to be a safe integer (got ${value})`);
        return true;
      }
    });
    var matchesRegExp3 = (regExp) => makeValidator({
      test: (value, state) => {
        if (!regExp.test(value))
          return pushError(state, `Expected to match the pattern ${regExp.toString()} (got ${getPrintable(value)})`);
        return true;
      }
    });
    var isLowerCase = () => makeValidator({
      test: (value, state) => {
        if (value !== value.toLowerCase())
          return pushError(state, `Expected to be all-lowercase (got ${value})`);
        return true;
      }
    });
    var isUpperCase = () => makeValidator({
      test: (value, state) => {
        if (value !== value.toUpperCase())
          return pushError(state, `Expected to be all-uppercase (got ${value})`);
        return true;
      }
    });
    var isUUID4 = () => makeValidator({
      test: (value, state) => {
        if (!uuid4RegExp.test(value))
          return pushError(state, `Expected to be a valid UUID v4 (got ${getPrintable(value)})`);
        return true;
      }
    });
    var isISO8601 = () => makeValidator({
      test: (value, state) => {
        if (!iso8601RegExp.test(value))
          return pushError(state, `Expected to be a valid ISO 8601 date string (got ${getPrintable(value)})`);
        return false;
      }
    });
    var isHexColor = ({alpha = false}) => makeValidator({
      test: (value, state) => {
        const res = alpha ? colorStringRegExp.test(value) : colorStringAlphaRegExp.test(value);
        if (!res)
          return pushError(state, `Expected to be a valid hexadecimal color string (got ${getPrintable(value)})`);
        return true;
      }
    });
    var isBase64 = () => makeValidator({
      test: (value, state) => {
        if (!base64RegExp.test(value))
          return pushError(state, `Expected to be a valid base 64 string (got ${getPrintable(value)})`);
        return true;
      }
    });
    var isJSON = (spec = isUnknown()) => makeValidator({
      test: (value, state) => {
        let data;
        try {
          data = JSON.parse(value);
        } catch (_a2) {
          return pushError(state, `Expected to be a valid JSON string (got ${getPrintable(value)})`);
        }
        return spec(data, state);
      }
    });
    var hasRequiredKeys = (requiredKeys) => {
      const requiredSet = new Set(requiredKeys);
      return makeValidator({
        test: (value, state) => {
          const keys = new Set(Object.keys(value));
          const problems = [];
          for (const key of requiredSet)
            if (!keys.has(key))
              problems.push(key);
          if (problems.length > 0)
            return pushError(state, `Missing required ${plural(problems.length, `property`, `properties`)} ${problems.map((name) => `"${name}"`).join(`, `)}`);
          return true;
        }
      });
    };
    var hasForbiddenKeys = (forbiddenKeys) => {
      const forbiddenSet = new Set(forbiddenKeys);
      return makeValidator({
        test: (value, state) => {
          const keys = new Set(Object.keys(value));
          const problems = [];
          for (const key of forbiddenSet)
            if (keys.has(key))
              problems.push(key);
          if (problems.length > 0)
            return pushError(state, `Forbidden ${plural(problems.length, `property`, `properties`)} ${problems.map((name) => `"${name}"`).join(`, `)}`);
          return true;
        }
      });
    };
    var hasMutuallyExclusiveKeys = (exclusiveKeys) => {
      const exclusiveSet = new Set(exclusiveKeys);
      return makeValidator({
        test: (value, state) => {
          const keys = new Set(Object.keys(value));
          const used = [];
          for (const key of exclusiveSet)
            if (keys.has(key))
              used.push(key);
          if (used.length > 1)
            return pushError(state, `Mutually exclusive properties ${used.map((name) => `"${name}"`).join(`, `)}`);
          return true;
        }
      });
    };
    var KeyRelationship;
    (function(KeyRelationship2) {
      KeyRelationship2["Forbids"] = "Forbids";
      KeyRelationship2["Requires"] = "Requires";
    })(KeyRelationship || (KeyRelationship = {}));
    var keyRelationships = {
      [KeyRelationship.Forbids]: {
        expect: false,
        message: `forbids using`
      },
      [KeyRelationship.Requires]: {
        expect: true,
        message: `requires using`
      }
    };
    var hasKeyRelationship = (subject, relationship, others) => {
      const otherSet = new Set(others);
      const spec = keyRelationships[relationship];
      return makeValidator({
        test: (value, state) => {
          const keys = new Set(Object.keys(value));
          if (!keys.has(subject))
            return true;
          const problems = [];
          for (const key of otherSet)
            if (keys.has(key) !== spec.expect)
              problems.push(key);
          if (problems.length >= 1)
            return pushError(state, `Property "${subject}" ${spec.message} ${plural(problems.length, `property`, `properties`)} ${problems.map((name) => `"${name}"`).join(`, `)}`);
          return true;
        }
      });
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\utils.js
  var require_utils = __commonJS((exports2) => {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\stringify.js
  var require_stringify = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\is-number-npm-7.0.0-060086935c-eec6e506c6.zip\node_modules\is-number\index.js
  var require_is_number = __commonJS((exports2, module2) => {
    /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\to-regex-range-npm-5.0.1-f1e8263b00-2b6001e314.zip\node_modules\to-regex-range\index.js
  var require_to_regex_range = __commonJS((exports2, module2) => {
    /*!
     * to-regex-range <https://github.com/micromatch/to-regex-range>
     *
     * Copyright (c) 2015-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = {relaxZeros: true, ...options};
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = {min, max, a, b};
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start2, stop, options) {
      if (start2 === stop) {
        return {pattern: start2, count: [], digits: 0};
      }
      let zipped = zip(start2, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return {pattern, count: [count], digits};
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start2 = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start2), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start2 = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start2 = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let {string} = ele;
        if (!intersection && !contains2(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains2(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start2 = 0, stop = ""] = digits;
      if (stop || start2 > 1) {
        return `{${start2 + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fill-range-npm-7.0.1-b8b1817caa-efca43d59b.zip\node_modules\fill-range\index.js
  var require_fill_range = __commonJS((exports2, module2) => {
    /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start2, end, options) => {
      if (typeof start2 === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, {wrap: false, ...options});
      }
      let start2 = String.fromCharCode(a);
      if (a === b)
        return start2;
      let stop = String.fromCharCode(b);
      return `[${start2}-${stop}]`;
    };
    var toRegex = (start2, end, options) => {
      if (Array.isArray(start2)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start2.join("|")})` : start2.join("|");
      }
      return toRegexRange(start2, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start2, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start2, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start2, end, step = 1, options = {}) => {
      let a = Number(start2);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start2, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start2);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start2, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start2, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = {negatives: [], positives: []};
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
      }
      return range;
    };
    var fillLetters = (start2, end, step = 1, options = {}) => {
      if (!isNumber(start2) && start2.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start2, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start2}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, {wrap: false, options});
      }
      return range;
    };
    var fill = (start2, end, step, options = {}) => {
      if (end == null && isValidValue(start2)) {
        return [start2];
      }
      if (!isValidValue(start2) || !isValidValue(end)) {
        return invalidRange(start2, end, options);
      }
      if (typeof step === "function") {
        return fill(start2, end, 1, {transform: step});
      }
      if (isObject(step)) {
        return fill(start2, end, 0, step);
      }
      let opts = {...options};
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start2, end, 1, step);
      }
      if (isNumber(start2) && isNumber(end)) {
        return fillNumbers(start2, end, step, opts);
      }
      return fillLetters(start2, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\compile.js
  var require_compile = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk3 = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, {...options, wrap: false, toRegex: true});
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk3(child, node);
          }
        }
        return output;
      };
      return walk3(ast);
    };
    module2.exports = compile;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\expand.js
  var require_expand = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk3 = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk3(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk3(ast));
    };
    module2.exports = expand;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\constants.js
  var require_constants = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\lib\parse.js
  var require_parse2 = __commonJS((exports2, module2) => {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse4 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = {type: "root", input, nodes: []};
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({type: "bos"});
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({type: "text", value: "\\" + value});
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({type: "paren", nodes: []});
          stack.push(block);
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({type: "text", value});
            continue;
          }
          block = stack.pop();
          push({type: "text", value});
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({type: "open", value});
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({type: "text", value});
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({type, value});
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, {type: "text", value: stringify(block)}];
          }
          push({type: "comma", value});
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({type: "text", value});
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({type: "dot", value});
          continue;
        }
        push({type: "text", value});
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({type: "eos"});
      return ast;
    };
    module2.exports = parse4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\braces-npm-3.0.2-782240b28a-f3493181c3.zip\node_modules\braces\index.js
  var require_braces = __commonJS((exports2, module2) => {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse4 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse4(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\lib\constants.js
  var require_constants2 = __commonJS((exports2, module2) => {
    "use strict";
    var path6 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path6.sep,
      extglobChars(chars) {
        return {
          "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
          "?": {type: "qmark", open: "(?:", close: ")?"},
          "+": {type: "plus", open: "(?:", close: ")+"},
          "*": {type: "star", open: "(?:", close: ")*"},
          "@": {type: "at", open: "(?:", close: ")"}
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\lib\utils.js
  var require_utils2 = __commonJS((exports2) => {
    "use strict";
    var path6 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path6.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\lib\scan.js
  var require_scan = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start2 = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = {value: "", depth: 0, isGlob: false};
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = {value: "", depth: 0, isGlob: false};
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start2 + 1) {
            start2 += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
          }
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start2) {
          negated = token.negated = true;
          start2++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start2 > 0) {
        prefix = str.slice(0, start2);
        str = str.slice(start2);
        lastIndex -= start2;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start: start2,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start2;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start2 !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\lib\parse.js
  var require_parse3 = __commonJS((exports2, module2) => {
    "use strict";
    var constants3 = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants3;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse4 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = {...options};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = {type: "bos", value: "", output: opts.prepend || ""};
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants3.globChars(win32);
      const EXTGLOB_CHARS = constants3.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index];
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({type, value: value2, output: state.output ? "" : ONE_CHAR});
        push({type: "paren", extglob: true, value: advance(), output});
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.prev.type === "bos" && eos()) {
            state.negatedExtglob = true;
          }
        }
        push({type: "paren", extglob: true, value, output});
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({type: "text", value});
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance() || "";
          } else {
            value += advance() || "";
          }
          if (state.brackets === 0) {
            push({type: "text", value});
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({value});
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({value});
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({type: "text", value});
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({type: "paren", value});
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({type: "paren", value, output: state.parens ? ")" : "\\)"});
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({type: "bracket", value});
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({value});
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({type: "text", value, output: value});
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t7 of toks) {
              state.output += t7.output || t7.value;
            }
          }
          push({type: "brace", value, output});
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({type: "text", value});
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({type: "comma", value, output});
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({type: "slash", value, output: SLASH_LITERAL});
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({type: "text", value, output: DOT_LITERAL});
            continue;
          }
          push({type: "dot", value, output: DOT_LITERAL});
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({type: "text", value, output});
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({type: "qmark", value, output: QMARK_NO_DOT});
            continue;
          }
          push({type: "qmark", value, output: QMARK});
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({type: "plus", value, output: PLUS_LITERAL});
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({type: "plus", value});
            continue;
          }
          push({type: "plus", value: PLUS_LITERAL});
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({type: "at", extglob: true, value, output: ""});
            continue;
          }
          push({type: "text", value});
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push({type: "text", value});
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({type: "star", value, output: ""});
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({type: "star", value, output: ""});
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = {type: "star", value, output: star};
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse4.fastpaths = (input, options) => {
      const opts = {...options};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants3.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = {negated: false, prefix: ""};
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            const source2 = create(match2[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match2[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\lib\picomatch.js
  var require_picomatch = __commonJS((exports2, module2) => {
    "use strict";
    var path6 = require("path");
    var scan = require_scan();
    var parse4 = require_parse3();
    var utils = require_utils2();
    var constants3 = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch3 of fns) {
            const state2 = isMatch3(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored3 = () => false;
      if (opts.ignore) {
        const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
        isIgnored3 = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const {isMatch: isMatch3, match: match2, output} = picomatch.test(input, regex, options, {glob, posix});
        const result = {glob, state, regex, posix, input, output, match: match2, isMatch: isMatch3};
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch3 === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored3(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, {glob, posix} = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return {isMatch: false, output: ""};
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format ? format(input) : input;
      if (match2 === false) {
        output = format ? format(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch.matchBase(input, regex, options, posix);
        } else {
          match2 = regex.exec(output);
        }
      }
      return {isMatch: Boolean(match2), match: match2, output};
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path6.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse4(pattern, {...options, fastpaths: false});
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return parsed.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${parsed.output})${append}`;
      if (parsed && parsed.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = parsed;
      }
      return regex;
    };
    picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      const opts = options || {};
      let parsed = {negated: false, fastpaths: true};
      let prefix = "";
      let output;
      if (input.startsWith("./")) {
        input = input.slice(2);
        prefix = parsed.prefix = "./";
      }
      if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        output = parse4.fastpaths(input, options);
      }
      if (output === void 0) {
        parsed = parse4(input, options);
        parsed.prefix = prefix + (parsed.prefix || "");
      } else {
        parsed.output = output;
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants3;
    module2.exports = picomatch;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\picomatch-npm-2.2.2-1ce736a913-20fa75e0a5.zip\node_modules\picomatch\index.js
  var require_picomatch2 = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = require_picomatch();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\micromatch-npm-4.0.2-f059c00e51-0cb0e11d64.zip\node_modules\micromatch\index.js
  var require_micromatch = __commonJS((exports2, module2) => {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => typeof val === "string" && (val === "" || val === "./");
    var micromatch12 = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch3 = picomatch(String(patterns[i]), {...options, onResult}, true);
        let negated = isMatch3.state.negated || isMatch3.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch3(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch12.match = micromatch12;
    micromatch12.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch12.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch12.any = micromatch12.isMatch;
    micromatch12.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch12(list, patterns, {...options, onResult});
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch12.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch12.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch12.isMatch(str, pattern, {...options, contains: true});
    };
    micromatch12.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch12(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch12.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch3 = picomatch(String(pattern), options);
        if (items.some((item) => isMatch3(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch12.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch3 = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch3(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch12.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch12.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), {...options, capture: true});
      let match2 = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch12.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch12.scan = (...args) => picomatch.scan(...args);
    micromatch12.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch12.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch12.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch12.braces(pattern, {...options, expand: true});
    };
    module2.exports = micromatch12;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\miscUtils.ts
  var require_miscUtils = __commonJS((exports) => {
    __export(exports, {
      BufferStream: () => BufferStream,
      DefaultStream: () => DefaultStream,
      assertNever: () => assertNever,
      bufferStream: () => bufferStream,
      buildIgnorePattern: () => buildIgnorePattern,
      convertMapsToIndexableObjects: () => convertMapsToIndexableObjects,
      dynamicRequire: () => dynamicRequire,
      dynamicRequireNoCache: () => dynamicRequireNoCache,
      escapeRegExp: () => escapeRegExp,
      getArrayWithDefault: () => getArrayWithDefault,
      getFactoryWithDefault: () => getFactoryWithDefault,
      getMapWithDefault: () => getMapWithDefault,
      getSetWithDefault: () => getSetWithDefault,
      isIndexableObject: () => isIndexableObject,
      mapAndFilter: () => mapAndFilter,
      mapAndFind: () => mapAndFind,
      overrideType: () => overrideType,
      parseBoolean: () => parseBoolean,
      parseOptionalBoolean: () => parseOptionalBoolean,
      prettifyAsyncErrors: () => prettifyAsyncErrors,
      prettifySyncErrors: () => prettifySyncErrors,
      releaseAfterUseAsync: () => releaseAfterUseAsync,
      replaceEnvVariables: () => replaceEnvVariables,
      sortMap: () => sortMap,
      tryParseOptionalBoolean: () => tryParseOptionalBoolean,
      validateEnum: () => validateEnum
    });
    var import_micromatch15 = __toModule(require_micromatch());
    var import_stream8 = __toModule(require("stream"));
    function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
    }
    function overrideType(val) {
    }
    function assertNever(arg) {
      throw new Error(`Assertion failed: Unexpected object '${arg}'`);
    }
    function validateEnum(def, value) {
      if (!Object.values(def).includes(value))
        throw new Error(`Assertion failed: Invalid value for enumeration`);
      return value;
    }
    function mapAndFilter(iterable, cb) {
      const output = [];
      for (const value of iterable) {
        const out = cb(value);
        if (out !== mapAndFilterSkip) {
          output.push(out);
        }
      }
      return output;
    }
    var mapAndFilterSkip = Symbol();
    mapAndFilter.skip = mapAndFilterSkip;
    function mapAndFind(iterable, cb) {
      for (const value of iterable) {
        const out = cb(value);
        if (out !== mapAndFindSkip) {
          return out;
        }
      }
      return void 0;
    }
    var mapAndFindSkip = Symbol();
    mapAndFind.skip = mapAndFindSkip;
    function isIndexableObject(value) {
      return typeof value === `object` && value !== null;
    }
    function convertMapsToIndexableObjects(arg) {
      if (arg instanceof Map)
        arg = Object.fromEntries(arg);
      if (isIndexableObject(arg)) {
        for (const key of Object.keys(arg)) {
          const value = arg[key];
          if (isIndexableObject(value)) {
            arg[key] = convertMapsToIndexableObjects(value);
          }
        }
      }
      return arg;
    }
    function getFactoryWithDefault(map, key, factory) {
      let value = map.get(key);
      if (typeof value === `undefined`)
        map.set(key, value = factory());
      return value;
    }
    function getArrayWithDefault(map, key) {
      let value = map.get(key);
      if (typeof value === `undefined`)
        map.set(key, value = []);
      return value;
    }
    function getSetWithDefault(map, key) {
      let value = map.get(key);
      if (typeof value === `undefined`)
        map.set(key, value = new Set());
      return value;
    }
    function getMapWithDefault(map, key) {
      let value = map.get(key);
      if (typeof value === `undefined`)
        map.set(key, value = new Map());
      return value;
    }
    async function releaseAfterUseAsync(fn, cleanup) {
      if (cleanup == null)
        return await fn();
      try {
        return await fn();
      } finally {
        await cleanup();
      }
    }
    async function prettifyAsyncErrors(fn, update) {
      try {
        return await fn();
      } catch (error) {
        error.message = update(error.message);
        throw error;
      }
    }
    function prettifySyncErrors(fn, update) {
      try {
        return fn();
      } catch (error) {
        error.message = update(error.message);
        throw error;
      }
    }
    async function bufferStream(stream) {
      return await new Promise((resolve, reject) => {
        const chunks = [];
        stream.on(`error`, (error) => {
          reject(error);
        });
        stream.on(`data`, (chunk) => {
          chunks.push(chunk);
        });
        stream.on(`end`, () => {
          resolve(Buffer.concat(chunks));
        });
      });
    }
    var BufferStream = class extends import_stream8.Transform {
      constructor() {
        super(...arguments);
        this.chunks = [];
      }
      _transform(chunk, encoding, cb) {
        if (encoding !== `buffer` || !Buffer.isBuffer(chunk))
          throw new Error(`Assertion failed: BufferStream only accept buffers`);
        this.chunks.push(chunk);
        cb(null, null);
      }
      _flush(cb) {
        cb(null, Buffer.concat(this.chunks));
      }
    };
    var DefaultStream = class extends import_stream8.Transform {
      constructor(ifEmpty = Buffer.alloc(0)) {
        super();
        this.active = true;
        this.ifEmpty = ifEmpty;
      }
      _transform(chunk, encoding, cb) {
        if (encoding !== `buffer` || !Buffer.isBuffer(chunk))
          throw new Error(`Assertion failed: DefaultStream only accept buffers`);
        this.active = false;
        cb(null, chunk);
      }
      _flush(cb) {
        if (this.active && this.ifEmpty.length > 0) {
          cb(null, this.ifEmpty);
        } else {
          cb(null);
        }
      }
    };
    var dynamicRequire = eval(`require`);
    function dynamicRequireNoCache(path) {
      const physicalPath = npath.fromPortablePath(path);
      const currentCacheEntry = dynamicRequire.cache[physicalPath];
      delete dynamicRequire.cache[physicalPath];
      let result;
      try {
        result = dynamicRequire(physicalPath);
        const freshCacheEntry = dynamicRequire.cache[physicalPath];
        const dynamicModule = eval(`module`);
        const freshCacheIndex = dynamicModule.children.indexOf(freshCacheEntry);
        if (freshCacheIndex !== -1) {
          dynamicModule.children.splice(freshCacheIndex, 1);
        }
      } finally {
        dynamicRequire.cache[physicalPath] = currentCacheEntry;
      }
      return result;
    }
    function sortMap(values, mappers) {
      const asArray = Array.from(values);
      if (!Array.isArray(mappers))
        mappers = [mappers];
      const stringified = [];
      for (const mapper of mappers)
        stringified.push(asArray.map((value) => mapper(value)));
      const indices = asArray.map((_, index) => index);
      indices.sort((a, b) => {
        for (const layer of stringified) {
          const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
          if (comparison !== 0) {
            return comparison;
          }
        }
        return 0;
      });
      return indices.map((index) => {
        return asArray[index];
      });
    }
    function buildIgnorePattern(ignorePatterns) {
      if (ignorePatterns.length === 0)
        return null;
      return ignorePatterns.map((pattern) => {
        return `(${import_micromatch15.default.makeRe(pattern, {
          windows: false
        }).source})`;
      }).join(`|`);
    }
    function replaceEnvVariables(value, {env}) {
      const regex = /\${(?<variableName>[\d\w_]+)(?<colon>:)?(?:-(?<fallback>[^}]*))?}/g;
      return value.replace(regex, (...args) => {
        const {variableName, colon, fallback} = args[args.length - 1];
        const variableExist = Object.prototype.hasOwnProperty.call(env, variableName);
        const variableValue = env[variableName];
        if (variableValue)
          return variableValue;
        if (variableExist && !colon)
          return variableValue;
        if (fallback != null)
          return fallback;
        throw new UsageError(`Environment variable not found (${variableName})`);
      });
    }
    function parseBoolean(value) {
      switch (value) {
        case `true`:
        case `1`:
        case 1:
        case true: {
          return true;
        }
        case `false`:
        case `0`:
        case 0:
        case false: {
          return false;
        }
        default: {
          throw new Error(`Couldn't parse "${value}" as a boolean`);
        }
      }
    }
    function parseOptionalBoolean(value) {
      if (typeof value === `undefined`)
        return value;
      return parseBoolean(value);
    }
    function tryParseOptionalBoolean(value) {
      try {
        return parseOptionalBoolean(value);
      } catch {
        return null;
      }
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\internal\constants.js
  var require_constants3 = __commonJS((exports2, module2) => {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\internal\debug.js
  var require_debug = __commonJS((exports2, module2) => {
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\internal\re.js
  var require_re = __commonJS((exports2, module2) => {
    var {MAX_SAFE_COMPONENT_LENGTH} = require_constants3();
    var debug2 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t7 = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug2(index, value);
      t7[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t7.NUMERICIDENTIFIER]})\\.(${src[t7.NUMERICIDENTIFIER]})\\.(${src[t7.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t7.NUMERICIDENTIFIERLOOSE]})\\.(${src[t7.NUMERICIDENTIFIERLOOSE]})\\.(${src[t7.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t7.NUMERICIDENTIFIER]}|${src[t7.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t7.NUMERICIDENTIFIERLOOSE]}|${src[t7.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t7.PRERELEASEIDENTIFIER]}(?:\\.${src[t7.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t7.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t7.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t7.BUILDIDENTIFIER]}(?:\\.${src[t7.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t7.MAINVERSION]}${src[t7.PRERELEASE]}?${src[t7.BUILD]}?`);
    createToken("FULL", `^${src[t7.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t7.MAINVERSIONLOOSE]}${src[t7.PRERELEASELOOSE]}?${src[t7.BUILD]}?`);
    createToken("LOOSE", `^${src[t7.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t7.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t7.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t7.XRANGEIDENTIFIER]})(?:\\.(${src[t7.XRANGEIDENTIFIER]})(?:\\.(${src[t7.XRANGEIDENTIFIER]})(?:${src[t7.PRERELEASE]})?${src[t7.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t7.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t7.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t7.XRANGEIDENTIFIERLOOSE]})(?:${src[t7.PRERELEASELOOSE]})?${src[t7.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t7.GTLT]}\\s*${src[t7.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t7.GTLT]}\\s*${src[t7.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t7.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t7.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t7.LONETILDE]}${src[t7.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t7.LONETILDE]}${src[t7.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t7.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t7.LONECARET]}${src[t7.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t7.LONECARET]}${src[t7.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t7.GTLT]}\\s*(${src[t7.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t7.GTLT]}\\s*(${src[t7.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t7.GTLT]}\\s*(${src[t7.LOOSEPLAIN]}|${src[t7.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t7.XRANGEPLAIN]})\\s+-\\s+(${src[t7.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t7.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t7.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\internal\identifiers.js
  var require_identifiers = __commonJS((exports2, module2) => {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\classes\semver.js
  var require_semver = __commonJS((exports2, module2) => {
    var debug2 = require_debug();
    var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants3();
    var {re, t: t7} = require_re();
    var {compareIdentifiers} = require_identifiers();
    var SemVer2 = class {
      constructor(version, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (version instanceof SemVer2) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug2("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t7.LOOSE] : re[t7.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer2)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer2(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer2)) {
          other = new SemVer2(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer2)) {
          other = new SemVer2(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer2)) {
          other = new SemVer2(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\parse.js
  var require_parse4 = __commonJS((exports2, module2) => {
    var {MAX_LENGTH} = require_constants3();
    var {re, t: t7} = require_re();
    var SemVer2 = require_semver();
    var parse4 = (version, options) => {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer2) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t7.LOOSE] : re[t7.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer2(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\valid.js
  var require_valid = __commonJS((exports2, module2) => {
    var parse4 = require_parse4();
    var valid = (version, options) => {
      const v = parse4(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\clean.js
  var require_clean = __commonJS((exports2, module2) => {
    var parse4 = require_parse4();
    var clean3 = (version, options) => {
      const s = parse4(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean3;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\inc.js
  var require_inc = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer2(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\compare.js
  var require_compare = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var compare = (a, b, loose) => new SemVer2(a, loose).compare(new SemVer2(b, loose));
    module2.exports = compare;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\eq.js
  var require_eq = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\diff.js
  var require_diff = __commonJS((exports2, module2) => {
    var parse4 = require_parse4();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse4(version1);
        const v2 = parse4(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\major.js
  var require_major = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var major = (a, loose) => new SemVer2(a, loose).major;
    module2.exports = major;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\minor.js
  var require_minor = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var minor = (a, loose) => new SemVer2(a, loose).minor;
    module2.exports = minor;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\patch.js
  var require_patch = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var patch7 = (a, loose) => new SemVer2(a, loose).patch;
    module2.exports = patch7;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\prerelease.js
  var require_prerelease = __commonJS((exports2, module2) => {
    var parse4 = require_parse4();
    var prerelease = (version, options) => {
      const parsed = parse4(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\rcompare.js
  var require_rcompare = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\compare-loose.js
  var require_compare_loose = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\compare-build.js
  var require_compare_build = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer2(a, loose);
      const versionB = new SemVer2(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\sort.js
  var require_sort = __commonJS((exports2, module2) => {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\rsort.js
  var require_rsort = __commonJS((exports2, module2) => {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\gt.js
  var require_gt = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\lt.js
  var require_lt = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\neq.js
  var require_neq = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\gte.js
  var require_gte = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\lte.js
  var require_lte = __commonJS((exports2, module2) => {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\cmp.js
  var require_cmp = __commonJS((exports2, module2) => {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\coerce.js
  var require_coerce = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var parse4 = require_parse4();
    var {re, t: t7} = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer2) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version.match(re[t7.COERCE]);
      } else {
        let next;
        while ((next = re[t7.COERCERTL].exec(version)) && (!match2 || match2.index + match2[0].length !== version.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          re[t7.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t7.COERCERTL].lastIndex = -1;
      }
      if (match2 === null)
        return null;
      return parse4(`${match2[2]}.${match2[3] || "0"}.${match2[4] || "0"}`, options);
    };
    module2.exports = coerce;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\classes\range.js
  var require_range = __commonJS((exports2, module2) => {
    var Range = class {
      constructor(range, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const loose = this.options.loose;
        range = range.trim();
        const hr = loose ? re[t7.HYPHENRANGELOOSE] : re[t7.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range);
        range = range.replace(re[t7.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range, re[t7.COMPARATORTRIM]);
        range = range.replace(re[t7.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t7.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t7.COMPARATORLOOSE] : re[t7.COMPARATOR];
        return range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer2(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var Comparator = require_comparator();
    var debug2 = require_debug();
    var SemVer2 = require_semver();
    var {
      re,
      t: t7,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t7.TILDELOOSE] : re[t7.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re[t7.CARETLOOSE] : re[t7.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t7.XRANGELOOSE] : re[t7.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t7.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t7.GTE0PRE : t7.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug2(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\classes\comparator.js
  var require_comparator = __commonJS((exports2, module2) => {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t7.COMPARATORLOOSE] : re[t7.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer2(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug2("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer2(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var {re, t: t7} = require_re();
    var cmp = require_cmp();
    var debug2 = require_debug();
    var SemVer2 = require_semver();
    var Range = require_range();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\functions\satisfies.js
  var require_satisfies = __commonJS((exports2, module2) => {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\to-comparators.js
  var require_to_comparators = __commonJS((exports2, module2) => {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\max-satisfying.js
  var require_max_satisfying = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer2(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\min-satisfying.js
  var require_min_satisfying = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer2(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\min-version.js
  var require_min_version = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer2("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer2("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        comparators.forEach((comparator) => {
          const compver = new SemVer2(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\valid.js
  var require_valid2 = __commonJS((exports2, module2) => {
    var Range = require_range();
    var validRange2 = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\outside.js
  var require_outside = __commonJS((exports2, module2) => {
    var SemVer2 = require_semver();
    var Comparator = require_comparator();
    var {ANY} = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer2(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\gtr.js
  var require_gtr = __commonJS((exports2, module2) => {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\ltr.js
  var require_ltr = __commonJS((exports2, module2) => {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\intersects.js
  var require_intersects = __commonJS((exports2, module2) => {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\simplify.js
  var require_simplify = __commonJS((exports2, module2) => {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\ranges\subset.js
  var require_subset = __commonJS((exports2, module2) => {
    var Range = require_range();
    var {ANY} = require_comparator();
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options) => {
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub.length === 1 && sub[0].semver === ANY)
        return dom.length === 1 && dom[0].semver === ANY;
      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-7.3.2-161b023bbb-bceb46d396.zip\node_modules\semver\index.js
  var require_semver2 = __commonJS((exports2, module2) => {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants3().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse4(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\array-union-npm-2.1.0-4e4852b221-93af542eb8.zip\node_modules\array-union\index.js
  var require_array_union = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\merge2-npm-1.3.0-a272445bb5-0b2ffca431.zip\node_modules\merge2\index.js
  var require_merge2 = __commonJS((exports2, module2) => {
    "use strict";
    var Stream = require("stream");
    var PassThrough8 = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge22;
    function merge22() {
      const streamsQueue = [];
      let merging = false;
      const args = slice.call(arguments);
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null)
        args.pop();
      else
        options = {};
      const doEnd = options.end !== false;
      if (options.objectMode == null)
        options.objectMode = true;
      if (options.highWaterMark == null)
        options.highWaterMark = 64 * 1024;
      const mergedStream = PassThrough8(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging)
          return;
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams))
          streams = [streams];
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0)
            return;
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            next();
          }
          if (stream._readableState.endEmitted)
            return next();
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          stream.pipe(mergedStream, {end: false});
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++)
          pipe(streams[i]);
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        return doEnd && mergedStream.end();
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length)
        addStream.apply(null, args);
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe)
          streams = streams.pipe(PassThrough8(options));
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++)
          streams[i] = pauseStreams(streams[i], options);
      }
      return streams;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\array.js
  var require_array = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\errno.js
  var require_errno = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\fs.js
  var require_fs = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\path.js
  var require_path = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path6.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\is-extglob-npm-2.1.1-0870ea68b5-ca623e2c56.zip\node_modules\is-extglob\index.js
  var require_is_extglob = __commonJS((exports2, module2) => {
    /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2016, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match2[2])
          return true;
        str = str.slice(match2.index + match2[0].length);
      }
      return false;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\is-glob-npm-4.0.1-341760116f-98cd4f715f.zip\node_modules\is-glob\index.js
  var require_is_glob = __commonJS((exports2, module2) => {
    /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    var isExtglob = require_is_extglob();
    var chars = {"{": "}", "(": ")", "[": "]"};
    var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var regex = strictRegex;
      var match2;
      if (options && options.strict === false) {
        regex = relaxedRegex;
      }
      while (match2 = regex.exec(str)) {
        if (match2[2])
          return true;
        var idx = match2.index + match2[0].length;
        var open = match2[1];
        var close = open ? chars[open] : null;
        if (open && close) {
          var n = str.indexOf(close, idx);
          if (n !== -1) {
            idx = n + 1;
          }
        }
        str = str.slice(idx);
      }
      return false;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\glob-parent-npm-5.1.0-8e781a1aff-da8fb21548.zip\node_modules\glob-parent\index.js
  var require_glob_parent = __commonJS((exports2, module2) => {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
    var globby3 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({flipBackslashes: true}, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby3.test(str));
      return str.replace(escaped, "$1");
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\pattern.js
  var require_pattern = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var globParent = require_glob_parent();
    var micromatch12 = require_micromatch();
    var picomatch = require_picomatch2();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getBaseDirectory(pattern) {
      return globParent(pattern, {flipBackslashes: false});
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path6.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch12.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      const info = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {parts: true}));
      if (info.parts.length === 0) {
        return [pattern];
      }
      return info.parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch12.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\stream.js
  var require_stream = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var merge22 = require_merge2();
    function merge3(streams) {
      const mergedStream = merge22(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge3;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\string.js
  var require_string = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function isString3(input) {
      return typeof input === "string";
    }
    exports2.isString = isString3;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\utils\index.js
  var require_utils3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs9 = require_fs();
    exports2.fs = fs9;
    var path6 = require_path();
    exports2.path = path6;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\managers\tasks.js
  var require_tasks = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    function generate2(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate2;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
      if ("." in positivePatternsGroup) {
        const task = convertPatternGroupToTask(".", positive, negative, dynamic);
        return [task];
      }
      return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.stat-npm-2.0.3-be9eaa5ef7-1bfdb2f419.zip\node_modules\@nodelib\fs.stat\out\providers\async.js
  var require_async = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function read(path6, settings, callback) {
      settings.fs.lstat(path6, (lstatError, lstat) => {
        if (lstatError !== null) {
          return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path6, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return callFailureCallback(callback, statError);
            }
            return callSuccessCallback(callback, lstat);
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.stat-npm-2.0.3-be9eaa5ef7-1bfdb2f419.zip\node_modules\@nodelib\fs.stat\out\providers\sync.js
  var require_sync = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function read(path6, settings) {
      const lstat = settings.fs.lstatSync(path6);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path6);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.stat-npm-2.0.3-be9eaa5ef7-1bfdb2f419.zip\node_modules\@nodelib\fs.stat\out\adapters\fs.js
  var require_fs2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs9 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs9.lstat,
      stat: fs9.stat,
      lstatSync: fs9.lstatSync,
      statSync: fs9.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.stat-npm-2.0.3-be9eaa5ef7-1bfdb2f419.zip\node_modules\@nodelib\fs.stat\out\settings.js
  var require_settings = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs9 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs9.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
    };
    exports2.default = Settings;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.stat-npm-2.0.3-be9eaa5ef7-1bfdb2f419.zip\node_modules\@nodelib\fs.stat\out\index.js
  var require_out = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path6, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path6, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path6, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\run-parallel-npm-1.1.9-83c6b2d620-a05ca86e99.zip\node_modules\run-parallel\index.js
  var require_run_parallel = __commonJS((exports2, module2) => {
    module2.exports = runParallel;
    function runParallel(tasks, cb) {
      var results, pending, keys;
      var isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          process.nextTick(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\constants.js
  var require_constants4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\utils\fs.js
  var require_fs3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\utils\index.js
  var require_utils4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs9 = require_fs3();
    exports2.fs = fs9;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\providers\async.js
  var require_async2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
      }
      return readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, {withFileTypes: true}, (readdirError, dirents) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        }));
        if (!settings.followSymbolicLinks) {
          return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return done(statError);
            }
            return done(null, entry);
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          return done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => `${directory}${settings.pathSegmentSeparator}${name}`);
        const tasks = filepaths.map((filepath) => {
          return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          const entries = [];
          names.forEach((name, index) => {
            const stats = results[index];
            const entry = {
              name,
              path: filepaths[index],
              dirent: utils.fs.createDirentFromStats(name, stats)
            };
            if (settings.stats) {
              entry.stats = stats;
            }
            entries.push(entry);
          });
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\providers\sync.js
  var require_sync2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, {withFileTypes: true});
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\adapters\fs.js
  var require_fs4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs9 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs9.lstat,
      stat: fs9.stat,
      lstatSync: fs9.lstatSync,
      statSync: fs9.statSync,
      readdir: fs9.readdir,
      readdirSync: fs9.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\settings.js
  var require_settings2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var fsStat = require_out();
    var fs9 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs9.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
    };
    exports2.default = Settings;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.scandir-npm-2.1.3-92e0b8f0d5-1f100655dd.zip\node_modules\@nodelib\fs.scandir\out\index.js
  var require_out2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path6, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path6, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path6, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\reusify-npm-1.0.4-95ac4aec11-08ef02ed05.zip\node_modules\reusify\reusify.js
  var require_reusify = __commonJS((exports2, module2) => {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get4() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get: get4,
        release
      };
    }
    module2.exports = reusify;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fastq-npm-1.6.0-b53b5275fa-c33b194bc3.zip\node_modules\fastq\queue.js
  var require_queue = __commonJS((exports2, module2) => {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      var cache2 = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        unshift,
        empty: noop,
        kill,
        killAndDrain
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache2.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache2.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        self2.value = null;
        self2.callback = noop;
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    module2.exports = fastqueue;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\readers\common.js
  var require_common = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[\\/]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\readers\reader.js
  var require_reader = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var common = require_common();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\readers\async.js
  var require_async3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = {directory, base};
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            return done(error, void 0);
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\providers\async.js
  var require_async4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.add(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\providers\stream.js
  var require_stream2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: this._reader.destroy.bind(this._reader)
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\readers\sync.js
  var require_sync3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsScandir = require_out2();
    var common = require_common();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
      }
      _pushToQueue(directory, base) {
        this._queue.add({directory, base});
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.add(entry);
      }
    };
    exports2.default = SyncReader;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\providers\sync.js
  var require_sync4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\settings.js
  var require_settings3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
    };
    exports2.default = Settings;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@nodelib-fs.walk-npm-1.2.4-1ae6c97d00-f4bffba16c.zip\node_modules\@nodelib\fs.walk\out\index.js
  var require_out3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk3(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk3;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\readers\reader.js
  var require_reader2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path6.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\readers\stream.js
  var require_stream3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({objectMode: true});
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\matchers\matcher.js
  var require_matcher = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\matchers\partial.js
  var require_partial = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match2 = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match2) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\filters\deep.js
  var require_deep = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        const depth = this._getEntryLevel(basePath, entry.path);
        if (this._isSkippedByDeep(depth)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(entryDepth) {
        return entryDepth >= this._settings.deep;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _getEntryLevel(basePath, entryPath) {
        const basePathDepth = basePath.split("/").length;
        const entryPathDepth = entryPath.split("/").length;
        return entryPathDepth - (basePath === "" ? 0 : basePathDepth);
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, negativeRe) {
        return !utils.pattern.matchAny(entryPath, negativeRe);
      }
    };
    exports2.default = DeepFilter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\filters\entry.js
  var require_entry = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique) {
          if (this._isDuplicateEntry(entry)) {
            return false;
          }
          this._createIndexRecord(entry);
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        return this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entry, negativeRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entry.path);
        return this._isMatchToPatterns(fullpath, negativeRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
      }
    };
    exports2.default = EntryFilter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\filters\error.js
  var require_error = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\transformers\entry.js
  var require_entry2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), {path: filepath});
      }
    };
    exports2.default = EntryTransformer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\provider.js
  var require_provider = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path6 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path6.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\async.js
  var require_async5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require_stream3();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\stream.js
  var require_stream4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({objectMode: true, read: () => {
        }});
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\readers\sync.js
  var require_sync5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\providers\sync.js
  var require_sync6 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\settings.js
  var require_settings4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs9 = require("fs");
    var os2 = require("os");
    var CPU_COUNT = os2.cpus().length;
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs9.lstat,
      lstatSync: fs9.lstatSync,
      stat: fs9.stat,
      statSync: fs9.statSync,
      readdir: fs9.readdir,
      readdirSync: fs9.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fast-glob-npm-3.2.2-5f42de738e-be3e486275.zip\node_modules\fast-glob\out\index.js
  var require_out4 = __commonJS((exports2, module2) => {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async5();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\path-type-npm-4.0.0-10d47fc86a-ef5835f2eb.zip\node_modules\path-type\index.js
  var require_path_type = __commonJS((exports2) => {
    "use strict";
    var {promisify: promisify4} = require("util");
    var fs9 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify4(fs9[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs9[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\dir-glob-npm-3.0.1-1aea628b1b-687fa3bd60.zip\node_modules\dir-glob\index.js
  var require_dir_glob = __commonJS((exports2, module2) => {
    "use strict";
    var path6 = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath7 = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path6.isAbsolute(pth) ? pth : path6.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path6.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path6.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path6.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path6.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path6.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath7(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath7(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ignore-npm-5.1.4-fd6cc2dff0-215721af97.zip\node_modules\ignore\index.js
  var require_ignore = __commonJS((exports2, module2) => {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, {value});
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match2, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match2 : "");
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match2) => match2.indexOf("\\") === 0 ? " " : ""
      ],
      [
        /\\\s/g,
        () => " "
      ],
      [
        /[\\^$.|*+(){]/g,
        (match2) => `\\${match2}`
      ],
      [
        /\[([^\]/]*)($|\])/g,
        (match2, p1, p2) => p2 === "]" ? `[${sanitizeRange(p1)}]` : `\\${match2}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /(?:[^*])$/,
        (match2) => /\/$/.test(match2) ? `${match2}$` : `${match2}(?=$|\\/$)`
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ],
      [
        /\\\\\\/g,
        () => "\\"
      ]
    ];
    var regexCache = Object.create(null);
    var makeRegex = (pattern, negative, ignorecase) => {
      const r = regexCache[pattern];
      if (r) {
        return r;
      }
      const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
      return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString3 = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString3(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignorecase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, negative, ignorecase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path6, originalPath, doThrow) => {
      if (!isString3(path6)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path6) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path6)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path6) => REGEX_TEST_INVALID_PATH.test(path6);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true
      } = {}) {
        this._rules = [];
        this._ignorecase = ignorecase;
        define2(this, KEY_IGNORE, true);
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignorecase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString3(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path6, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const {negative} = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path6);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache2, checkUnignored, slices) {
        const path6 = originalPath && checkPath.convert(originalPath);
        checkPath(path6, originalPath, throwError);
        return this._t(path6, cache2, checkUnignored, slices);
      }
      _t(path6, cache2, checkUnignored, slices) {
        if (path6 in cache2) {
          return cache2[path6];
        }
        if (!slices) {
          slices = path6.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path6] = this._testOne(path6, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache2, checkUnignored, slices);
        return cache2[path6] = parent.ignored ? parent : this._testOne(path6, checkUnignored);
      }
      ignores(path6) {
        return this._test(path6, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path6) => !this.ignores(path6);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path6) {
        return this._test(path6, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var returnFalse = () => false;
    var isPathValid = (path6) => checkPath(path6 && checkPath.convert(path6), path6, returnFalse);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path6) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\slash-npm-3.0.0-b87de2279a-fc3e8597d8.zip\node_modules\slash\index.js
  var require_slash = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (path6) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path6);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path6);
      if (isExtendedLengthPath || hasNonAscii) {
        return path6;
      }
      return path6.replace(/\\/g, "/");
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\globby-npm-11.0.1-b32c0f1cff-e7239e9e46.zip\node_modules\globby\gitignore.js
  var require_gitignore = __commonJS((exports2, module2) => {
    "use strict";
    var {promisify: promisify4} = require("util");
    var fs9 = require("fs");
    var path6 = require("path");
    var fastGlob2 = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP2 = promisify4(fs9.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path6.posix.join(base, ignore.slice(1));
      }
      return path6.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path6.relative(options.cwd, path6.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      return files.reduce((ignores, file) => {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
        return ignores;
      }, gitIgnore());
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path6.isAbsolute(p)) {
        if (p.startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path6.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path6.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path6.join(cwd, file);
      const content = await readFileP2(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path6.join(cwd, file);
      const content = fs9.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return {ignore, cwd};
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob2("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob2.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\globby-npm-11.0.1-b32c0f1cff-e7239e9e46.zip\node_modules\globby\stream-utils.js
  var require_stream_utils = __commonJS((exports2, module2) => {
    "use strict";
    var {Transform: Transform3} = require("stream");
    var ObjectTransform = class extends Transform3 {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\globby-npm-11.0.1-b32c0f1cff-e7239e9e46.zip\node_modules\globby\index.js
  var require_globby = __commonJS((exports2, module2) => {
    "use strict";
    var fs9 = require("fs");
    var arrayUnion = require_array_union();
    var merge22 = require_merge2();
    var fastGlob2 = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var {FilterStream, UniqueStream} = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat;
      try {
        stat = fs9.statSync(options.cwd);
      } catch (_) {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs9.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
      };
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter(isNegative).map((pattern2) => pattern2.slice(1));
        const options = {
          ...taskOptions,
          ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({pattern, options});
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = {
          ...options,
          files: task.options.expandDirectories
        };
      } else if (typeof task.options.expandDirectories === "object") {
        options = {
          ...options,
          ...task.options.expandDirectories
        };
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const {options} = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob2(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = globTasks.reduce((tasks2, task) => {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        return tasks2.concat(newTask);
      }, []);
      const filter = getFilterSync(options);
      return tasks.reduce((matches, task) => arrayUnion(matches, fastGlob2.sync(task.pattern, task.options)), []).filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = globTasks.reduce((tasks2, task) => {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        return tasks2.concat(newTask);
      }, []);
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge22(tasks.map((task) => fastGlob2.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob2.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tunnel-npm-0.0.6-b1c0830ea4-78fbb1a55a.zip\node_modules\tunnel\lib\tunnel.js
  var require_tunnel = __commonJS((exports2) => {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({request: req}, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2("tunneling socket could not be established, statusCode=%d", res.statusCode);
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.debug = debug2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tunnel-npm-0.0.6-b1c0830ea4-78fbb1a55a.zip\node_modules\tunnel\index.js
  var require_tunnel2 = __commonJS((exports2, module2) => {
    module2.exports = require_tunnel();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@sindresorhus-is-npm-3.1.2-bcdc8ac1e4-da0047761e.zip\node_modules\@sindresorhus\is\dist\index.js
  var require_dist = __commonJS((exports2, module2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var typedArrayTypeNames = [
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function isTypedArrayName(name) {
      return typedArrayTypeNames.includes(name);
    }
    var objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      ...typedArrayTypeNames
    ];
    function isObjectTypeName(name) {
      return objectTypeNames.includes(name);
    }
    var primitiveTypeNames = [
      "null",
      "undefined",
      "string",
      "number",
      "bigint",
      "boolean",
      "symbol"
    ];
    function isPrimitiveTypeName(name) {
      return primitiveTypeNames.includes(name);
    }
    function isOfType(type) {
      return (value) => typeof value === type;
    }
    var {toString} = Object.prototype;
    var getObjectType = (value) => {
      const objectTypeName = toString.call(value).slice(8, -1);
      if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return "HTMLElement";
      }
      if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    };
    var isObjectOfType = (type) => (value) => getObjectType(value) === type;
    function is(value) {
      if (value === null) {
        return "null";
      }
      switch (typeof value) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "function":
          return "Function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        default:
      }
      if (is.observable(value)) {
        return "Observable";
      }
      if (is.array(value)) {
        return "Array";
      }
      if (is.buffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    is.undefined = isOfType("undefined");
    is.string = isOfType("string");
    var isNumberType = isOfType("number");
    is.number = (value) => isNumberType(value) && !is.nan(value);
    is.bigint = isOfType("bigint");
    is.function_ = isOfType("function");
    is.null_ = (value) => value === null;
    is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
    is.boolean = (value) => value === true || value === false;
    is.symbol = isOfType("symbol");
    is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
    is.array = (value, assertion) => {
      if (!Array.isArray(value)) {
        return false;
      }
      if (!is.function_(assertion)) {
        return true;
      }
      return value.every(assertion);
    };
    is.buffer = (value) => {
      var _a2, _b, _c, _d;
      return (_d = (_c = (_b = (_a2 = value) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
    };
    is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
    is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
    is.iterable = (value) => {
      var _a2;
      return is.function_((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.iterator]);
    };
    is.asyncIterable = (value) => {
      var _a2;
      return is.function_((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2[Symbol.asyncIterator]);
    };
    is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
    is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
    is.nativePromise = (value) => isObjectOfType("Promise")(value);
    var hasPromiseAPI = (value) => {
      var _a2, _b;
      return is.function_((_a2 = value) === null || _a2 === void 0 ? void 0 : _a2.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
    };
    is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
    is.generatorFunction = isObjectOfType("GeneratorFunction");
    is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
    is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
    is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
    is.regExp = isObjectOfType("RegExp");
    is.date = isObjectOfType("Date");
    is.error = isObjectOfType("Error");
    is.map = (value) => isObjectOfType("Map")(value);
    is.set = (value) => isObjectOfType("Set")(value);
    is.weakMap = (value) => isObjectOfType("WeakMap")(value);
    is.weakSet = (value) => isObjectOfType("WeakSet")(value);
    is.int8Array = isObjectOfType("Int8Array");
    is.uint8Array = isObjectOfType("Uint8Array");
    is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
    is.int16Array = isObjectOfType("Int16Array");
    is.uint16Array = isObjectOfType("Uint16Array");
    is.int32Array = isObjectOfType("Int32Array");
    is.uint32Array = isObjectOfType("Uint32Array");
    is.float32Array = isObjectOfType("Float32Array");
    is.float64Array = isObjectOfType("Float64Array");
    is.bigInt64Array = isObjectOfType("BigInt64Array");
    is.bigUint64Array = isObjectOfType("BigUint64Array");
    is.arrayBuffer = isObjectOfType("ArrayBuffer");
    is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
    is.dataView = isObjectOfType("DataView");
    is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
    is.urlInstance = (value) => isObjectOfType("URL")(value);
    is.urlString = (value) => {
      if (!is.string(value)) {
        return false;
      }
      try {
        new URL(value);
        return true;
      } catch (_a2) {
        return false;
      }
    };
    is.truthy = (value) => Boolean(value);
    is.falsy = (value) => !value;
    is.nan = (value) => Number.isNaN(value);
    is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
    is.integer = (value) => Number.isInteger(value);
    is.safeInteger = (value) => Number.isSafeInteger(value);
    is.plainObject = (value) => {
      if (toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.getPrototypeOf({});
    };
    is.typedArray = (value) => isTypedArrayName(getObjectType(value));
    var isValidLength = (value) => is.safeInteger(value) && value >= 0;
    is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
    is.inRange = (value, range) => {
      if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
      }
      if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
      }
      throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
    };
    var NODE_TYPE_ELEMENT = 1;
    var DOM_PROPERTIES_TO_CHECK = [
      "innerHTML",
      "ownerDocument",
      "style",
      "attributes",
      "nodeValue"
    ];
    is.domElement = (value) => {
      return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
    };
    is.observable = (value) => {
      var _a2, _b, _c, _d;
      if (!value) {
        return false;
      }
      if (value === ((_b = (_a2 = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a2))) {
        return true;
      }
      if (value === ((_d = (_c = value)["@@observable"]) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
      }
      return false;
    };
    is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
    is.infinite = (value) => value === Infinity || value === -Infinity;
    var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
    is.evenInteger = isAbsoluteMod2(0);
    is.oddInteger = isAbsoluteMod2(1);
    is.emptyArray = (value) => is.array(value) && value.length === 0;
    is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
    is.emptyString = (value) => is.string(value) && value.length === 0;
    is.nonEmptyString = (value) => is.string(value) && value.length > 0;
    var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
    is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
    is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
    is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
    is.emptySet = (value) => is.set(value) && value.size === 0;
    is.nonEmptySet = (value) => is.set(value) && value.size > 0;
    is.emptyMap = (value) => is.map(value) && value.size === 0;
    is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
    var predicateOnArray = (method, predicate, values) => {
      if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
      }
      if (values.length === 0) {
        throw new TypeError("Invalid number of values");
      }
      return method.call(values, predicate);
    };
    is.any = (predicate, ...values) => {
      const predicates = is.array(predicate) ? predicate : [predicate];
      return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
    };
    is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
    var assertType = (condition, description, value) => {
      if (!condition) {
        throw new TypeError(`Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`);
      }
    };
    exports2.assert = {
      undefined: (value) => assertType(is.undefined(value), "undefined", value),
      string: (value) => assertType(is.string(value), "string", value),
      number: (value) => assertType(is.number(value), "number", value),
      bigint: (value) => assertType(is.bigint(value), "bigint", value),
      function_: (value) => assertType(is.function_(value), "Function", value),
      null_: (value) => assertType(is.null_(value), "null", value),
      class_: (value) => assertType(is.class_(value), "Class", value),
      boolean: (value) => assertType(is.boolean(value), "boolean", value),
      symbol: (value) => assertType(is.symbol(value), "symbol", value),
      numericString: (value) => assertType(is.numericString(value), "string with a number", value),
      array: (value, assertion) => {
        const assert = assertType;
        assert(is.array(value), "Array", value);
        if (assertion) {
          value.forEach(assertion);
        }
      },
      buffer: (value) => assertType(is.buffer(value), "Buffer", value),
      nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
      object: (value) => assertType(is.object(value), "Object", value),
      iterable: (value) => assertType(is.iterable(value), "Iterable", value),
      asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
      generator: (value) => assertType(is.generator(value), "Generator", value),
      asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
      nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
      promise: (value) => assertType(is.promise(value), "Promise", value),
      generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
      asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
      asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
      boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
      regExp: (value) => assertType(is.regExp(value), "RegExp", value),
      date: (value) => assertType(is.date(value), "Date", value),
      error: (value) => assertType(is.error(value), "Error", value),
      map: (value) => assertType(is.map(value), "Map", value),
      set: (value) => assertType(is.set(value), "Set", value),
      weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
      weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
      int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
      uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
      uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
      int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
      uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
      int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
      uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
      float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
      float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
      bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
      bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
      arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
      sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
      dataView: (value) => assertType(is.dataView(value), "DataView", value),
      urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
      urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
      truthy: (value) => assertType(is.truthy(value), "truthy", value),
      falsy: (value) => assertType(is.falsy(value), "falsy", value),
      nan: (value) => assertType(is.nan(value), "NaN", value),
      primitive: (value) => assertType(is.primitive(value), "primitive", value),
      integer: (value) => assertType(is.integer(value), "integer", value),
      safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
      plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
      typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
      arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
      domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
      observable: (value) => assertType(is.observable(value), "Observable", value),
      nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
      infinite: (value) => assertType(is.infinite(value), "infinite number", value),
      emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
      nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
      emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
      nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
      emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
      emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
      nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
      emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
      nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
      emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
      nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
      evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
      oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
      directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
      inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
      any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values),
      all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values)
    };
    Object.defineProperties(is, {
      class: {
        value: is.class_
      },
      function: {
        value: is.function_
      },
      null: {
        value: is.null_
      }
    });
    Object.defineProperties(exports2.assert, {
      class: {
        value: exports2.assert.class_
      },
      function: {
        value: exports2.assert.function_
      },
      null: {
        value: exports2.assert.null_
      }
    });
    exports2.default = is;
    module2.exports = is;
    module2.exports.default = is;
    module2.exports.assert = exports2.assert;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\p-cancelable-npm-2.0.0-5f988ffca4-966065f056.zip\node_modules\p-cancelable\index.js
  var require_p_cancelable = __commonJS((exports2, module2) => {
    "use strict";
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return (...arguments_) => {
          return new PCancelable((resolve, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve, reject) => {
          this._reject = reject;
          const onResolve = (value) => {
            this._isPending = false;
            resolve(value);
          };
          const onReject = (error) => {
            this._isPending = false;
            reject(error);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
          }
        }
        this._isCanceled = true;
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\defer-to-connect-npm-2.0.0-ef0ce813c8-0453938bfc.zip\node_modules\defer-to-connect\dist\source\index.js
  var require_source2 = __commonJS((exports2, module2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var tls_1 = require("tls");
    var deferToConnect = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = {connect};
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (socket instanceof tls_1.TLSSocket && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports2.default = deferToConnect;
    module2.exports = deferToConnect;
    module2.exports.default = deferToConnect;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@szmarczak-http-timer-npm-4.0.5-03463d10ab-13d8f71dbd.zip\node_modules\@szmarczak\http-timer\dist\source\index.js
  var require_source3 = __commonJS((exports2, module2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var defer_to_connect_1 = require_source2();
    var nodejsMajorVersion = Number(process.versions.node.split(".")[0]);
    var timer = (request2) => {
      const timings = {
        start: Date.now(),
        socket: void 0,
        lookup: void 0,
        connect: void 0,
        secureConnect: void 0,
        upload: void 0,
        response: void 0,
        end: void 0,
        error: void 0,
        abort: void 0,
        phases: {
          wait: void 0,
          dns: void 0,
          tcp: void 0,
          tls: void 0,
          request: void 0,
          firstByte: void 0,
          download: void 0,
          total: void 0
        }
      };
      request2.timings = timings;
      const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
          if (event === "error") {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
            origin.emit = emit;
          }
          return emit(event, ...args);
        };
      };
      handleError(request2);
      request2.prependOnceListener("abort", () => {
        timings.abort = Date.now();
        if (!timings.response || nodejsMajorVersion >= 13) {
          timings.phases.total = Date.now() - timings.start;
        }
      });
      const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        const lookupListener = () => {
          timings.lookup = Date.now();
          timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener("lookup", lookupListener);
        defer_to_connect_1.default(socket, {
          connect: () => {
            timings.connect = Date.now();
            if (timings.lookup === void 0) {
              socket.removeListener("lookup", lookupListener);
              timings.lookup = timings.connect;
              timings.phases.dns = timings.lookup - timings.socket;
            }
            timings.phases.tcp = timings.connect - timings.lookup;
          },
          secureConnect: () => {
            timings.secureConnect = Date.now();
            timings.phases.tls = timings.secureConnect - timings.connect;
          }
        });
      };
      if (request2.socket) {
        onSocket(request2.socket);
      } else {
        request2.prependOnceListener("socket", onSocket);
      }
      const onUpload = () => {
        var _a2;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - (_a2 = timings.secureConnect, _a2 !== null && _a2 !== void 0 ? _a2 : timings.connect);
      };
      const writableFinished = () => {
        if (typeof request2.writableFinished === "boolean") {
          return request2.writableFinished;
        }
        return request2.finished && request2.outputSize === 0 && (!request2.socket || request2.socket.writableLength === 0);
      };
      if (writableFinished()) {
        onUpload();
      } else {
        request2.prependOnceListener("finish", onUpload);
      }
      request2.prependOnceListener("response", (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener("end", () => {
          timings.end = Date.now();
          timings.phases.download = timings.end - timings.response;
          timings.phases.total = timings.end - timings.start;
        });
      });
      return timings;
    };
    exports2.default = timer;
    module2.exports = timer;
    module2.exports.default = timer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cacheable-lookup-npm-5.0.3-8cec59984a-a51e3ddb82.zip\node_modules\cacheable-lookup\source\index.js
  var require_source4 = __commonJS((exports2, module2) => {
    "use strict";
    var {
      V4MAPPED,
      ADDRCONFIG,
      ALL,
      promises: {
        Resolver: AsyncResolver
      },
      lookup: dnsLookup
    } = require("dns");
    var {promisify: promisify4} = require("util");
    var os2 = require("os");
    var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
    var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
    var kExpires = Symbol("expires");
    var supportsALL = typeof ALL === "number";
    var verifyAgent = (agent) => {
      if (!(agent && typeof agent.createConnection === "function")) {
        throw new Error("Expected an Agent instance as the first argument");
      }
    };
    var map4to6 = (entries) => {
      for (const entry of entries) {
        if (entry.family === 6) {
          continue;
        }
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
      }
    };
    var getIfaceInfo = () => {
      let has4 = false;
      let has6 = false;
      for (const device of Object.values(os2.networkInterfaces())) {
        for (const iface of device) {
          if (iface.internal) {
            continue;
          }
          if (iface.family === "IPv6") {
            has6 = true;
          } else {
            has4 = true;
          }
          if (has4 && has6) {
            return {has4, has6};
          }
        }
      }
      return {has4, has6};
    };
    var isIterable = (map) => {
      return Symbol.iterator in map;
    };
    var ttl = {ttl: true};
    var all = {all: true};
    var CacheableLookup = class {
      constructor({
        cache: cache2 = new Map(),
        maxTtl = Infinity,
        fallbackDuration = 3600,
        errorTtl = 0.15,
        resolver = new AsyncResolver(),
        lookup = dnsLookup
      } = {}) {
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache2;
        this._resolver = resolver;
        this._dnsLookup = promisify4(lookup);
        if (this._resolver instanceof AsyncResolver) {
          this._resolve4 = this._resolver.resolve4.bind(this._resolver);
          this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
          this._resolve4 = promisify4(this._resolver.resolve4.bind(this._resolver));
          this._resolve6 = promisify4(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = new Set();
        if (fallbackDuration < 1) {
          this._fallback = false;
        } else {
          this._fallback = true;
          const interval = setInterval(() => {
            this._hostnamesToFallback.clear();
          }, fallbackDuration * 1e3);
          if (interval.unref) {
            interval.unref();
          }
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
      }
      set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
      }
      get servers() {
        return this._resolver.getServers();
      }
      lookup(hostname, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "number") {
          options = {
            family: options
          };
        }
        if (!callback) {
          throw new Error("Callback must be a function.");
        }
        this.lookupAsync(hostname, options).then((result) => {
          if (options.all) {
            callback(null, result);
          } else {
            callback(null, result.address, result.family, result.expires, result.ttl);
          }
        }, callback);
      }
      async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") {
          options = {
            family: options
          };
        }
        let cached = await this.query(hostname);
        if (options.family === 6) {
          const filtered = cached.filter((entry) => entry.family === 6);
          if (options.hints & V4MAPPED) {
            if (supportsALL && options.hints & ALL || filtered.length === 0) {
              map4to6(cached);
            } else {
              cached = filtered;
            }
          } else {
            cached = filtered;
          }
        } else if (options.family === 4) {
          cached = cached.filter((entry) => entry.family === 4);
        }
        if (options.hints & ADDRCONFIG) {
          const {_iface} = this;
          cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
          const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
          error.code = "ENOTFOUND";
          error.hostname = hostname;
          throw error;
        }
        if (options.all) {
          return cached;
        }
        return cached[0];
      }
      async query(hostname) {
        let cached = await this._cache.get(hostname);
        if (!cached) {
          const pending = this._pending[hostname];
          if (pending) {
            cached = await pending;
          } else {
            const newPromise = this.queryAndCache(hostname);
            this._pending[hostname] = newPromise;
            cached = await newPromise;
          }
        }
        cached = cached.map((entry) => {
          return {...entry};
        });
        return cached;
      }
      async _resolve(hostname) {
        const wrap = async (promise) => {
          try {
            return await promise;
          } catch (error) {
            if (error.code === "ENODATA" || error.code === "ENOTFOUND") {
              return [];
            }
            throw error;
          }
        };
        const [A, AAAA] = await Promise.all([
          this._resolve4(hostname, ttl),
          this._resolve6(hostname, ttl)
        ].map((promise) => wrap(promise)));
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now2 = Date.now();
        for (const entry of A) {
          entry.family = 4;
          entry.expires = now2 + entry.ttl * 1e3;
          aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA) {
          entry.family = 6;
          entry.expires = now2 + entry.ttl * 1e3;
          aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
          if (AAAA.length > 0) {
            cacheTtl = Math.min(aTtl, aaaaTtl);
          } else {
            cacheTtl = aTtl;
          }
        } else {
          cacheTtl = aaaaTtl;
        }
        return {
          entries: [
            ...A,
            ...AAAA
          ],
          cacheTtl
        };
      }
      async _lookup(hostname) {
        try {
          const entries = await this._dnsLookup(hostname, {
            all: true
          });
          return {
            entries,
            cacheTtl: 0
          };
        } catch (_) {
          return {
            entries: [],
            cacheTtl: 0
          };
        }
      }
      async _set(hostname, data, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
          cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
          data[kExpires] = Date.now() + cacheTtl;
          try {
            await this._cache.set(hostname, data, cacheTtl);
          } catch (error) {
            this.lookupAsync = async () => {
              const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
              cacheError.cause = error;
              throw cacheError;
            };
          }
          if (isIterable(this._cache)) {
            this._tick(cacheTtl);
          }
        }
      }
      async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) {
          return this._dnsLookup(hostname, all);
        }
        try {
          let query = await this._resolve(hostname);
          if (query.entries.length === 0 && this._fallback) {
            query = await this._lookup(hostname);
            if (query.entries.length !== 0) {
              this._hostnamesToFallback.add(hostname);
            }
          }
          const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
          await this._set(hostname, query.entries, cacheTtl);
          delete this._pending[hostname];
          return query.entries;
        } catch (error) {
          delete this._pending[hostname];
          throw error;
        }
      }
      _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
          clearTimeout(this._removalTimeout);
          this._nextRemovalTime = ms;
          this._removalTimeout = setTimeout(() => {
            this._nextRemovalTime = false;
            let nextExpiry = Infinity;
            const now2 = Date.now();
            for (const [hostname, entries] of this._cache) {
              const expires = entries[kExpires];
              if (now2 >= expires) {
                this._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
            if (nextExpiry !== Infinity) {
              this._tick(nextExpiry - now2);
            }
          }, ms);
          if (this._removalTimeout.unref) {
            this._removalTimeout.unref();
          }
        }
      }
      install(agent) {
        verifyAgent(agent);
        if (kCacheableLookupCreateConnection in agent) {
          throw new Error("CacheableLookup has been already installed");
        }
        agent[kCacheableLookupCreateConnection] = agent.createConnection;
        agent[kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback) => {
          if (!("lookup" in options)) {
            options.lookup = this.lookup;
          }
          return agent[kCacheableLookupCreateConnection](options, callback);
        };
      }
      uninstall(agent) {
        verifyAgent(agent);
        if (agent[kCacheableLookupCreateConnection]) {
          if (agent[kCacheableLookupInstance] !== this) {
            throw new Error("The agent is not owned by this CacheableLookup instance");
          }
          agent.createConnection = agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupInstance];
        }
      }
      updateInterfaceInfo() {
        const {_iface} = this;
        this._iface = getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
          this._cache.clear();
        }
      }
      clear(hostname) {
        if (hostname) {
          this._cache.delete(hostname);
          return;
        }
        this._cache.clear();
      }
    };
    module2.exports = CacheableLookup;
    module2.exports.default = CacheableLookup;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\normalize-url-npm-4.5.0-14a0c5430f-09794941db.zip\node_modules\normalize-url\index.js
  var require_normalize_url = __commonJS((exports2, module2) => {
    "use strict";
    var URLParser = typeof URL === "undefined" ? require("url").URL : URL;
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters) => {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    };
    var normalizeDataURL = (urlString, {stripHash}) => {
      const parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/);
      if (!parts) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      const mediaType = parts[1].split(";");
      const body = parts[2];
      const hash = stripHash ? "" : parts[3];
      let base64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        base64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes = mediaType.map((attribute) => {
        let [key, value = ""] = attribute.split("=").map((string) => string.trim());
        if (key === "charset") {
          value = value.toLowerCase();
          if (value === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value ? `=${value}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes
      ];
      if (base64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${base64 ? body.trim() : body}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = {
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true,
        ...options
      };
      if (Reflect.has(options, "normalizeHttps")) {
        throw new Error("options.normalizeHttps is renamed to options.forceHttp");
      }
      if (Reflect.has(options, "normalizeHttp")) {
        throw new Error("options.normalizeHttp is renamed to options.forceHttps");
      }
      if (Reflect.has(options, "stripFragment")) {
        throw new Error("options.stripFragment is renamed to options.stripHash");
      }
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URLParser(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, (_, p1) => {
          if (/^(?!\/)/g.test(p1)) {
            return `${p1}/`;
          }
          return "/";
        });
      }
      if (urlObj.pathname) {
        urlObj.pathname = decodeURI(urlObj.pathname);
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      urlString = urlObj.toString();
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module2.exports = normalizeUrl;
    module2.exports.default = normalizeUrl;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\wrappy-npm-1.0.2-916de4d4b3-519fcda0fc.zip\node_modules\wrappy\wrappy.js
  var require_wrappy = __commonJS((exports2, module2) => {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\once-npm-1.3.3-595f0882a4-c68086bafe.zip\node_modules\once\once.js
  var require_once = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\end-of-stream-npm-1.1.0-318d442be5-1a078bec4b.zip\node_modules\end-of-stream\index.js
  var require_end_of_stream = __commonJS((exports2, module2) => {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback();
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback();
      };
      var onexit = function(exitCode) {
        callback(exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onclose = function() {
        if (readable && !(rs && rs.ended))
          return callback(new Error("premature close"));
        if (writable && !(ws && ws.ended))
          return callback(new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", callback);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", callback);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\pump-npm-3.0.0-0080bf6a7a-5464d5cf6c.zip\node_modules\pump\index.js
  var require_pump = __commonJS((exports2, module2) => {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs9 = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs9)
        return false;
      return (stream instanceof (fs9.ReadStream || noop) || stream instanceof (fs9.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, {readable: reading, writable: writing}, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\get-stream-npm-5.1.0-29a3aa3558-599dad0b6b.zip\node_modules\get-stream\buffer-stream.js
  var require_buffer_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {PassThrough: PassThroughStream} = require("stream");
    module2.exports = (options) => {
      options = {...options};
      const {array} = options;
      let {encoding} = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({objectMode});
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\get-stream-npm-5.1.0-29a3aa3558-599dad0b6b.zip\node_modules\get-stream\index.js
  var require_get_stream = __commonJS((exports2, module2) => {
    "use strict";
    var pump = require_pump();
    var bufferStream4 = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const {maxBuffer} = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream4(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: "buffer"});
    module2.exports.array = (stream, options) => getStream(stream, {...options, array: true});
    module2.exports.MaxBufferError = MaxBufferError;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http-cache-semantics-npm-4.0.2-9d4864c5e1-67844ad18d.zip\node_modules\http-cache-semantics\index.js
  var require_http_cache_semantics = __commonJS((exports2, module2) => {
    "use strict";
    var statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];
    var understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];
    var hopByHopHeaders = {
      date: true,
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/\s*,\s*/);
      for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {shared, cacheHeuristic, immutableMinTimeToLive, ignoreCargoCult, trustServerDate, _fromObject} = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._trustServerDate = trustServerDate !== void 0 ? trustServerDate : true;
        this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1;
        this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {"cache-control": formatCacheControl(this._rescc)});
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (!res.headers["cache-control"] && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.indexOf(this._status) !== -1 && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc.public || this._rescc["max-age"] || this._rescc["s-maxage"] || statusCodeCacheableByDefault.indexOf(this._status) !== -1));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      date() {
        if (this._trustServerDate) {
          return this._serverDate();
        }
        return this._responseTime;
      }
      _serverDate() {
        const dateValue = Date.parse(this._resHeaders.date);
        if (isFinite(dateValue)) {
          const maxClockDrift = 8 * 3600 * 1e3;
          const clockDrift = Math.abs(this._responseTime - dateValue);
          if (clockDrift < maxClockDrift) {
            return dateValue;
          }
        }
        return this._responseTime;
      }
      age() {
        let age = Math.max(0, (this._responseTime - this.date()) / 1e3);
        if (this._resHeaders.age) {
          let ageValue = this._ageValue();
          if (ageValue > age)
            age = ageValue;
        }
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        const ageValue = parseInt(this._resHeaders.age);
        return isFinite(ageValue) ? ageValue : 0;
      }
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return parseInt(this._rescc["s-maxage"], 10);
          }
        }
        if (this._rescc["max-age"]) {
          return parseInt(this._rescc["max-age"], 10);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const dateValue = this._serverDate();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < dateValue) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - dateValue) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && dateValue > lastModified) {
            return Math.max(defaultMinTtl, (dateValue - lastModified) / 1e3 * this._cacheHeuristic);
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        return Math.max(0, this.maxAge() - this.age()) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, {_fromObject: obj});
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      revalidatedPolicy(request2, response) {
        this._assertRequestHasHeaders(request2);
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request2, response),
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request2, newResponse, {shared: this._isShared, cacheHeuristic: this._cacheHeuristic, immutableMinTimeToLive: this._immutableMinTtl, trustServerDate: this._trustServerDate}),
          modified: false,
          matches: true
        };
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lowercase-keys-npm-2.0.0-1876065a32-4da67f4186.zip\node_modules\lowercase-keys\index.js
  var require_lowercase_keys = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (object) => {
      const result = {};
      for (const [key, value] of Object.entries(object)) {
        result[key.toLowerCase()] = value;
      }
      return result;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\responselike-npm-2.0.0-7813864e97-11d8225dd8.zip\node_modules\responselike\src\index.js
  var require_src = __commonJS((exports2, module2) => {
    "use strict";
    var Readable6 = require("stream").Readable;
    var lowercaseKeys = require_lowercase_keys();
    var Response = class extends Readable6 {
      constructor(statusCode, headers, body, url) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys(headers);
        this.body = body;
        this.url = url;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module2.exports = Response;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mimic-response-npm-1.0.1-f6f85dde84-64b43c717e.zip\node_modules\mimic-response\index.js
  var require_mimic_response = __commonJS((exports2, module2) => {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module2.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop of fromProps) {
        if (prop in toStream) {
          continue;
        }
        toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\clone-response-npm-1.0.2-135ae8239d-71832f9219.zip\node_modules\clone-response\src\index.js
  var require_src2 = __commonJS((exports2, module2) => {
    "use strict";
    var PassThrough8 = require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response) => {
      if (!(response && response.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone2 = new PassThrough8();
      mimicResponse(response, clone2);
      return response.pipe(clone2);
    };
    module2.exports = cloneResponse;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\json-buffer-npm-3.0.1-f8f6d20603-78011309cb.zip\node_modules\json-buffer\index.js
  var require_json_buffer = __commonJS((exports2) => {
    exports2.stringify = function stringify(o) {
      if (typeof o == "undefined")
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && typeof o === "object") {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o) {
          var ignore = typeof o[k] == "function" || !array && typeof o[k] === "undefined";
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify(k) + ":" + stringify(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if (typeof o === "string") {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if (typeof o === "undefined") {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if (typeof value === "string") {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\keyv-npm-4.0.0-941f620aa2-cd446a9a97.zip\node_modules\keyv\src\index.js
  var require_src3 = __commonJS((exports2, module2) => {
    "use strict";
    var EventEmitter3 = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (opts) => {
      const adapters = {
        redis: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql"
      };
      if (opts.adapter || opts.uri) {
        const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
        return new (require(adapters[adapter]))(opts);
      }
      return new Map();
    };
    var Keyv = class extends EventEmitter3 {
      constructor(uri, opts) {
        super();
        this.opts = Object.assign({
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse
        }, typeof uri === "string" ? {uri} : uri, opts);
        if (!this.opts.store) {
          const adapterOpts = Object.assign({}, this.opts);
          this.opts.store = loadStore(adapterOpts);
        }
        if (typeof this.opts.store.on === "function") {
          this.opts.store.on("error", (err) => this.emit("error", err));
        }
        this.opts.store.namespace = this.opts.namespace;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      get(key, opts) {
        key = this._getKeyPrefix(key);
        const {store} = this.opts;
        return Promise.resolve().then(() => store.get(key)).then((data) => {
          return typeof data === "string" ? this.opts.deserialize(data) : data;
        }).then((data) => {
          if (data === void 0) {
            return void 0;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            this.delete(key);
            return void 0;
          }
          return opts && opts.raw ? data : data.value;
        });
      }
      set(key, value, ttl) {
        key = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const {store} = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          value = {value, expires};
          return this.opts.serialize(value);
        }).then((value2) => store.set(key, value2, ttl)).then(() => true);
      }
      delete(key) {
        key = this._getKeyPrefix(key);
        const {store} = this.opts;
        return Promise.resolve().then(() => store.delete(key));
      }
      clear() {
        const {store} = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
    };
    module2.exports = Keyv;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\cacheable-request-npm-7.0.1-d870be2496-fe0b6f3b8a.zip\node_modules\cacheable-request\src\index.js
  var require_src4 = __commonJS((exports2, module2) => {
    "use strict";
    var EventEmitter3 = require("events");
    var urlLib2 = require("url");
    var normalizeUrl = require_normalize_url();
    var getStream = require_get_stream();
    var CachePolicy = require_http_cache_semantics();
    var Response = require_src();
    var lowercaseKeys = require_lowercase_keys();
    var cloneResponse = require_src2();
    var Keyv = require_src3();
    var CacheableRequest = class {
      constructor(request2, cacheAdapter) {
        if (typeof request2 !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request2);
      }
      createCacheableRequest(request2) {
        return (opts, cb) => {
          let url;
          if (typeof opts === "string") {
            url = normalizeUrlObject(urlLib2.parse(opts));
            opts = {};
          } else if (opts instanceof urlLib2.URL) {
            url = normalizeUrlObject(urlLib2.parse(opts.toString()));
            opts = {};
          } else {
            const [pathname, ...searchParts] = (opts.path || "").split("?");
            const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
            url = normalizeUrlObject({...opts, pathname, search});
          }
          opts = {
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false,
            ...opts,
            ...urlObjectToRequestOptions(url)
          };
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter3();
          const normalizedUrlString = normalizeUrl(urlLib2.format(url), {
            stripWWW: false,
            removeTrailingSlash: false,
            stripAuthentication: false
          });
          const key = `${opts.method}:${normalizedUrlString}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise((resolve) => {
              requestErrorCallback = () => {
                if (!requestErrored) {
                  requestErrored = true;
                  resolve();
                }
              };
            });
            const handler = (response) => {
              if (revalidate && !opts2.forceRefresh) {
                response.status = response.statusCode;
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response, opts2);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                (async () => {
                  try {
                    const bodyPromise = getStream.buffer(response);
                    await Promise.race([
                      requestErrorPromise,
                      new Promise((resolve) => response.once("end", resolve))
                    ]);
                    if (requestErrored) {
                      return;
                    }
                    const body = await bodyPromise;
                    const value = {
                      cachePolicy: response.cachePolicy.toObject(),
                      url: response.url,
                      statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                      body
                    };
                    let ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                    if (opts2.maxTtl) {
                      ttl = ttl ? Math.min(ttl, opts2.maxTtl) : opts2.maxTtl;
                    }
                    await this.cache.set(key, value, ttl);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              } else if (opts2.cache && revalidate) {
                (async () => {
                  try {
                    await this.cache.delete(key);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request2(opts2, handler);
              req.once("error", requestErrorCallback);
              req.once("abort", requestErrorCallback);
              ee.emit("request", req);
            } catch (error) {
              ee.emit("error", new CacheableRequest.RequestError(error));
            }
          };
          (async () => {
            const get4 = async (opts2) => {
              await Promise.resolve();
              const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
              if (typeof cacheEntry === "undefined") {
                return makeRequest(opts2);
              }
              const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
              if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
                const headers = policy.responseHeaders();
                const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                response.cachePolicy = policy;
                response.fromCache = true;
                ee.emit("response", response);
                if (typeof cb === "function") {
                  cb(response);
                }
              } else {
                revalidate = cacheEntry;
                opts2.headers = policy.revalidationHeaders(opts2);
                makeRequest(opts2);
              }
            };
            const errorHandler = (error) => ee.emit("error", new CacheableRequest.CacheError(error));
            this.cache.once("error", errorHandler);
            ee.on("response", () => this.cache.removeListener("error", errorHandler));
            try {
              await get4(opts);
            } catch (error) {
              if (opts.automaticFailover && !madeRequest) {
                makeRequest(opts);
              }
              ee.emit("error", new CacheableRequest.CacheError(error));
            }
          })();
          return ee;
        };
      }
    };
    function urlObjectToRequestOptions(url) {
      const options = {...url};
      options.path = `${url.pathname || "/"}${url.search || ""}`;
      delete options.pathname;
      delete options.search;
      return options;
    }
    function normalizeUrlObject(url) {
      return {
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || "localhost",
        port: url.port,
        pathname: url.pathname,
        search: url.search
      };
    }
    CacheableRequest.RequestError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "RequestError";
        Object.assign(this, error);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "CacheError";
        Object.assign(this, error);
      }
    };
    module2.exports = CacheableRequest;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mimic-response-npm-3.1.0-a4a24b4e96-cfbf19f66d.zip\node_modules\mimic-response\index.js
  var require_mimic_response2 = __commonJS((exports2, module2) => {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\decompress-response-npm-6.0.0-359de2878c-bb8b8c42be.zip\node_modules\decompress-response\index.js
  var require_decompress_response = __commonJS((exports2, module2) => {
    "use strict";
    var {Transform: Transform3, PassThrough: PassThrough8} = require("stream");
    var zlib3 = require("zlib");
    var mimicResponse = require_mimic_response2();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib3.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform3({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough8({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib3.createBrotliDecompress() : zlib3.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\quick-lru-npm-5.1.1-e38e0edce3-fafb2b2fa1.zip\node_modules\quick-lru\index.js
  var require_quick_lru = __commonJS((exports2, module2) => {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\agent.js
  var require_agent = __commonJS((exports2, module2) => {
    "use strict";
    var EventEmitter3 = require("events");
    var tls = require("tls");
    var http2 = require("http2");
    var QuickLRU = require_quick_lru();
    var kCurrentStreamsCount = Symbol("currentStreamsCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var nameKeys = [
      "maxDeflateDynamicTableSize",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "localAddress",
      "path",
      "rejectUnauthorized",
      "minDHSize",
      "ca",
      "cert",
      "clientCertEngine",
      "ciphers",
      "key",
      "pfx",
      "servername",
      "minVersion",
      "maxVersion",
      "secureProtocol",
      "crl",
      "honorCipherOrder",
      "ecdhCurve",
      "dhparam",
      "secureOptions",
      "sessionIdContext"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => {
      return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    };
    var closeCoveredSessions = (where, session) => {
      for (const coveredSession of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (const session of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var getSessions = ({agent, isFree}) => {
      const result = {};
      for (const normalizedOptions in agent.sessions) {
        const sessions = agent.sessions[normalizedOptions];
        const filtered = sessions.filter((session) => {
          const result2 = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
          return isFree ? result2 : !result2;
        });
        if (filtered.length !== 0) {
          result[normalizedOptions] = filtered;
        }
      }
      return result;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamsCount] === 0) {
        session.close();
      }
    };
    var Agent = class extends EventEmitter3 {
      constructor({timeout = 6e4, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxFreeSessions = maxFreeSessions;
        this._freeSessionsCount = 0;
        this._sessionsCount = 0;
        this.settings = {
          enablePush: false
        };
        this.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});
      }
      static normalizeOrigin(url, servername) {
        if (typeof url === "string") {
          url = new URL(url);
        }
        if (servername && url.hostname !== servername) {
          url.hostname = servername;
        }
        return url.origin;
      }
      normalizeOptions(options) {
        let normalized = "";
        if (options) {
          for (const key of nameKeys) {
            if (options[key]) {
              normalized += `:${options[key]}`;
            }
          }
        }
        return normalized;
      }
      _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
        if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
          return;
        }
        const item = this.queue[normalizedOptions][normalizedOrigin];
        if (this._sessionsCount < this.maxSessions && !item.completed) {
          item.completed = true;
          item();
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners)) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{resolve, reject}];
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);
          if (normalizedOrigin === void 0) {
            for (const {reject: reject2} of listeners) {
              reject2(new TypeError("The `origin` argument needs to be a string or an URL object"));
            }
            return;
          }
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (const session of sessions) {
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (session[kOriginSet].includes(normalizedOrigin)) {
                const sessionCurrentStreamsCount = session[kCurrentStreamsCount];
                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                  continue;
                }
                if (!optimalSession) {
                  maxConcurrentStreams = sessionMaxConcurrentStreams;
                }
                if (sessionCurrentStreamsCount > currentStreamsCount) {
                  optimalSession = session;
                  currentStreamsCount = sessionCurrentStreamsCount;
                }
              }
            }
            if (optimalSession) {
              if (listeners.length !== 1) {
                for (const {reject: reject2} of listeners) {
                  const error = new Error(`Expected the length of listeners to be 1, got ${listeners.length}.
Please report this to https://github.com/szmarczak/http2-wrapper/`);
                  reject2(error);
                }
                return;
              }
              listeners[0].resolve(optimalSession);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {};
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (Object.keys(this.queue[normalizedOptions]).length === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = () => {
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            try {
              const session = http2.connect(origin, {
                createConnection: this.createConnection,
                settings: this.settings,
                session: this.tlsSessionCache.get(name),
                ...options
              });
              session[kCurrentStreamsCount] = 0;
              session[kGracefullyClosing] = false;
              const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
              let wasFree = true;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error) => {
                for (const {reject: reject2} of listeners) {
                  reject2(error);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                if (receivedSettings) {
                  if (wasFree) {
                    this._freeSessionsCount--;
                  }
                  this._sessionsCount--;
                  const where = this.sessions[normalizedOptions];
                  where.splice(where.indexOf(session), 1);
                  if (where.length === 0) {
                    delete this.sessions[normalizedOptions];
                  }
                } else {
                  const error = new Error("Session closed without receiving a SETTINGS frame");
                  error.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (const {reject: reject2} of listeners) {
                    reject2(error);
                  }
                  removeFromQueue();
                }
                this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              });
              const processListeners = () => {
                if (!(normalizedOptions in this.queue) || !isFree()) {
                  return;
                }
                for (const origin2 of session[kOriginSet]) {
                  if (origin2 in this.queue[normalizedOptions]) {
                    const {listeners: listeners2} = this.queue[normalizedOptions][origin2];
                    while (listeners2.length !== 0 && isFree()) {
                      listeners2.shift().resolve(session);
                    }
                    const where = this.queue[normalizedOptions];
                    if (where[origin2].listeners.length === 0) {
                      delete where[origin2];
                      if (Object.keys(where).length === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = session.originSet;
                if (!isFree()) {
                  return;
                }
                processListeners();
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                session.ref();
                session.unref();
                this._sessionsCount++;
                if (entry.destroyed) {
                  const error = new Error("Agent has been destroyed");
                  for (const listener of listeners) {
                    listener.reject(error);
                  }
                  session.destroy();
                  return;
                }
                session[kOriginSet] = session.originSet;
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                this._freeSessionsCount += 1;
                receivedSettings = true;
                this.emit("session", session);
                processListeners();
                removeFromQueue();
                if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
                  session.close();
                }
                if (listeners.length !== 0) {
                  this.getSession(normalizedOrigin, options, listeners);
                  listeners.length = 0;
                }
                session.on("remoteSettings", () => {
                  processListeners();
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream = session[kRequest](headers, streamOptions);
                session.ref();
                ++session[kCurrentStreamsCount];
                if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
                  this._freeSessionsCount--;
                }
                stream.once("close", () => {
                  wasFree = isFree();
                  --session[kCurrentStreamsCount];
                  if (!session.destroyed && !session.closed) {
                    closeSessionIfCovered(this.sessions[normalizedOptions], session);
                    if (isFree() && !session.closed) {
                      if (!wasFree) {
                        this._freeSessionsCount++;
                        wasFree = true;
                      }
                      const isEmpty = session[kCurrentStreamsCount] === 0;
                      if (isEmpty) {
                        session.unref();
                      }
                      if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {
                        session.close();
                      } else {
                        closeCoveredSessions(this.sessions[normalizedOptions], session);
                        processListeners();
                      }
                    }
                  }
                });
                return stream;
              };
            } catch (error) {
              for (const listener of listeners) {
                listener.reject(error);
              }
              removeFromQueue();
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                resolve(session.request(headers, streamOptions));
              } catch (error) {
                reject(error);
              }
            }
          }]);
        });
      }
      createConnection(origin, options) {
        return Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname || origin.host;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        return tls.connect(port, host, options);
      }
      closeFreeSessions() {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            if (session[kCurrentStreamsCount] === 0) {
              session.close();
            }
          }
        }
      }
      destroy(reason) {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            session.destroy(reason);
          }
        }
        for (const entriesOfAuthority of Object.values(this.queue)) {
          for (const entry of Object.values(entriesOfAuthority)) {
            entry.destroyed = true;
          }
        }
        this.queue = {};
      }
      get freeSessions() {
        return getSessions({agent: this, isFree: true});
      }
      get busySessions() {
        return getSessions({agent: this, isFree: false});
      }
    };
    Agent.kCurrentStreamsCount = kCurrentStreamsCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\incoming-message.js
  var require_incoming_message = __commonJS((exports2, module2) => {
    "use strict";
    var {Readable: Readable6} = require("stream");
    var IncomingMessage = class extends Readable6 {
      constructor(socket, highWaterMark) {
        super({
          highWaterMark,
          autoDestroy: false
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this.connection = socket;
        this._dumped = false;
      }
      _destroy(error) {
        this.req._request.destroy(error);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\utils\url-to-options.js
  var require_url_to_options = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (url) => {
      const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (typeof url.port === "string" && url.port.length !== 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\utils\proxy-events.js
  var require_proxy_events = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\utils\is-request-pseudo-header.js
  var require_is_request_pseudo_header = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\utils\errors.js
  var require_errors = __commonJS((exports2, module2) => {
    "use strict";
    var makeError4 = (Base, key, getMessage3) => {
      module2.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage3 === "string" ? getMessage3 : getMessage3(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError4(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError4(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
      return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
    });
    makeError4(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
      return `Cannot ${args[0]} headers after they are sent to the client`;
    });
    makeError4(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
      return `${args[0]} must be a valid HTTP token [${args[1]}]`;
    });
    makeError4(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
      return `Invalid value "${args[0]} for header "${args[1]}"`;
    });
    makeError4(TypeError, "ERR_INVALID_CHAR", (args) => {
      return `Invalid character in ${args[0]} [${args[1]}]`;
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\client-request.js
  var require_client_request = __commonJS((exports2, module2) => {
    "use strict";
    var http2 = require("http2");
    var {Writable: Writable5} = require("stream");
    var {Agent, globalAgent} = require_agent();
    var IncomingMessage = require_incoming_message();
    var urlToOptions = require_url_to_options();
    var proxyEvents = require_proxy_events();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT,
      ERR_INVALID_HTTP_TOKEN,
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_METHOD_CONNECT
    } = http2.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    var ClientRequest = class extends Writable5 {
      constructor(input, options, callback) {
        super({
          autoDestroy: false
        });
        const hasInput = typeof input === "string" || input instanceof URL;
        if (hasInput) {
          input = urlToOptions(input instanceof URL ? input : new URL(input));
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = hasInput ? input : {...input};
        } else {
          options = {...input, ...options};
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
        } else if (options.agent === false) {
          this.agent = new Agent({maxFreeSessions: 0});
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          if (typeof options.createConnection === "function") {
            this.agent = new Agent({maxFreeSessions: 0});
            this.agent.createConnection = options.createConnection;
          } else {
            this.agent = globalAgent;
          }
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["Agent-like Object", "undefined", "false"], options.agent);
        }
        if (options.protocol && options.protocol !== "https:") {
          throw new ERR_INVALID_PROTOCOL(options.protocol, "https:");
        }
        const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;
        const host = options.hostname || options.host || "localhost";
        delete options.hostname;
        delete options.host;
        delete options.port;
        const {timeout} = options;
        options.timeout = void 0;
        this[kHeaders] = Object.create(null);
        this[kJobs] = [];
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        this.path = options.path;
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        if (options.headers) {
          for (const [header, value] of Object.entries(options.headers)) {
            this.setHeader(header, value);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        if (port === 443) {
          this[kOrigin] = `https://${host}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = host;
          }
        } else {
          this[kOrigin] = `https://${host}:${port}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = `${host}:${port}`;
          }
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        return this[kHeaders][HTTP2_HEADER_PATH];
      }
      set path(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_PATH] = value;
        }
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        if (this.destroyed) {
          return;
        }
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody) {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      _destroy(error, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        }
        callback(error);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream) => {
          this._request = stream;
          if (this.destroyed) {
            stream.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents(stream, this, ["timeout", "continue", "close", "error"]);
          }
          const waitForEnd = (fn) => {
            return (...args) => {
              if (!this.writable && !this.destroyed) {
                fn(...args);
              } else {
                this.once("finish", () => {
                  fn(...args);
                });
              }
            };
          };
          stream.once("response", waitForEnd((headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
            this.res = response;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              if (this.aborted) {
                response.aborted = true;
                response.emit("aborted");
              } else {
                response.complete = true;
                response.socket = null;
                response.connection = null;
              }
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream.destroy();
              }
            } else {
              stream.on("data", (chunk) => {
                if (!response._dumped && !response.push(chunk)) {
                  stream.pause();
                }
              });
              stream.once("end", () => {
                response.push(null);
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          }));
          stream.once("headers", waitForEnd((headers) => this.emit("information", {statusCode: headers[HTTP2_HEADER_STATUS]})));
          stream.once("trailers", waitForEnd((trailers, flags, rawTrailers) => {
            const {res} = this;
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          }));
          const {socket} = stream.session;
          this.socket = socket;
          this.connection = socket;
          for (const job of this[kJobs]) {
            job();
          }
          this.emit("socket", this.socket);
        };
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        } else {
          this.reusedSocket = true;
          try {
            onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        }
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
          throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
        }
        if (typeof value === "undefined") {
          throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
        }
        if (isInvalidHeaderValue.test(value)) {
          throw new ERR_INVALID_CHAR("header content", name);
        }
        this[kHeaders][name.toLowerCase()] = value;
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\resolve-alpn-npm-1.0.0-f655c150b7-17baee01c0.zip\node_modules\resolve-alpn\index.js
  var require_resolve_alpn = __commonJS((exports2, module2) => {
    "use strict";
    var tls = require("tls");
    module2.exports = (options = {}) => new Promise((resolve, reject) => {
      const socket = tls.connect(options, () => {
        if (options.resolveSocket) {
          socket.off("error", reject);
          resolve({alpnProtocol: socket.alpnProtocol, socket});
        } else {
          socket.destroy();
          resolve({alpnProtocol: socket.alpnProtocol});
        }
      });
      socket.on("error", reject);
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\utils\calculate-server-name.js
  var require_calculate_server_name = __commonJS((exports2, module2) => {
    "use strict";
    var net = require("net");
    module2.exports = (options) => {
      let servername = options.host;
      const hostHeader = options.headers && options.headers.host;
      if (hostHeader) {
        if (hostHeader.startsWith("[")) {
          const index = hostHeader.indexOf("]");
          if (index === -1) {
            servername = hostHeader;
          } else {
            servername = hostHeader.slice(1, -1);
          }
        } else {
          servername = hostHeader.split(":", 1)[0];
        }
      }
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\auto.js
  var require_auto = __commonJS((exports2, module2) => {
    "use strict";
    var http = require("http");
    var https = require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var urlToOptions = require_url_to_options();
    var cache2 = new QuickLRU({maxSize: 100});
    var queue = new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = {shouldKeepAlive: true};
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var resolveProtocol = async (options) => {
      const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache2.has(name)) {
        if (queue.has(name)) {
          const result = await queue.get(name);
          return result.alpnProtocol;
        }
        const {path: path6, agent} = options;
        options.path = options.socketPath;
        const resultPromise = resolveALPN(options);
        queue.set(name, resultPromise);
        try {
          const {socket, alpnProtocol} = await resultPromise;
          cache2.set(name, alpnProtocol);
          options.path = path6;
          if (alpnProtocol === "h2") {
            socket.destroy();
          } else {
            const {globalAgent} = https;
            const defaultCreateConnection = https.Agent.prototype.createConnection;
            if (agent) {
              if (agent.createConnection === defaultCreateConnection) {
                installSocket(agent, socket, options);
              } else {
                socket.destroy();
              }
            } else if (globalAgent.createConnection === defaultCreateConnection) {
              installSocket(globalAgent, socket, options);
            } else {
              socket.destroy();
            }
          }
          queue.delete(name);
          return alpnProtocol;
        } catch (error) {
          queue.delete(name);
          throw error;
        }
      }
      return cache2.get(name);
    };
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string" || input instanceof URL) {
        input = urlToOptions(new URL(input));
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      options = {
        ALPNProtocols: ["h2", "http/1.1"],
        ...input,
        ...options,
        resolveSocket: true
      };
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;
      const agents = options.agent;
      if (agents) {
        if (agents.addRequest) {
          throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");
        }
        options.agent = agents[isHttps ? "https" : "http"];
      }
      if (isHttps) {
        const protocol = await resolveProtocol(options);
        if (protocol === "h2") {
          if (agents) {
            options.agent = agents.http2;
          }
          return new Http2ClientRequest(options, callback);
        }
      }
      return http.request(options, callback);
    };
    module2.exports.protocolCache = cache2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\http2-wrapper-npm-1.0.0-beta.5.2-3ea360ab61-74db457c83.zip\node_modules\http2-wrapper\source\index.js
  var require_source5 = __commonJS((exports2, module2) => {
    "use strict";
    var http2 = require("http2");
    var agent = require_agent();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var request2 = (url, options, callback) => {
      return new ClientRequest(url, options, callback);
    };
    var get4 = (url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    };
    module2.exports = {
      ...http2,
      ClientRequest,
      IncomingMessage,
      ...agent,
      request: request2,
      get: get4,
      auto
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\is-form-data.js
  var require_is_form_data = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var is_1 = require_dist();
    exports2.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\get-body-size.js
  var require_get_body_size = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs_1 = require("fs");
    var util_1 = require("util");
    var is_1 = require_dist();
    var is_form_data_1 = require_is_form_data();
    var statAsync = util_1.promisify(fs_1.stat);
    exports2.default = async (body, headers) => {
      if (headers && "content-length" in headers) {
        return Number(headers["content-length"]);
      }
      if (!body) {
        return 0;
      }
      if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
      }
      if (is_1.default.buffer(body)) {
        return body.length;
      }
      if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
      }
      if (body instanceof fs_1.ReadStream) {
        const {size} = await statAsync(body.path);
        return size;
      }
      return void 0;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\proxy-events.js
  var require_proxy_events2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function default_1(from, to, events) {
      const fns = {};
      for (const event of events) {
        fns[event] = (...args) => {
          to.emit(event, ...args);
        };
        from.on(event, fns[event]);
      }
      return () => {
        for (const event of events) {
          from.off(event, fns[event]);
        }
      };
    }
    exports2.default = default_1;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\unhandle.js
  var require_unhandle = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.default = () => {
      const handlers = [];
      return {
        once(origin, event, fn) {
          origin.once(event, fn);
          handlers.push({origin, event, fn});
        },
        unhandleAll() {
          for (const handler of handlers) {
            const {origin, event, fn} = handler;
            origin.removeListener(event, fn);
          }
          handlers.length = 0;
        }
      };
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\timed-out.js
  var require_timed_out = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.TimeoutError = void 0;
    var net = require("net");
    var unhandle_1 = require_unhandle();
    var reentry = Symbol("reentry");
    var noop = () => {
    };
    var TimeoutError = class extends Error {
      constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
      }
    };
    exports2.TimeoutError = TimeoutError;
    exports2.default = (request2, delays, options) => {
      if (reentry in request2) {
        return noop;
      }
      request2[reentry] = true;
      const cancelers = [];
      const {once, unhandleAll} = unhandle_1.default();
      const addTimeout = (delay, callback, event) => {
        var _a2;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a2 = timeout.unref) === null || _a2 === void 0 ? void 0 : _a2.call(timeout);
        const cancel = () => {
          clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
      };
      const {host, hostname} = options;
      const timeoutHandler = (delay, event) => {
        request2.destroy(new TimeoutError(delay, event));
      };
      const cancelTimeouts = () => {
        for (const cancel of cancelers) {
          cancel();
        }
        unhandleAll();
      };
      request2.once("error", (error) => {
        cancelTimeouts();
        if (request2.listenerCount("error") === 0) {
          throw error;
        }
      });
      request2.once("close", cancelTimeouts);
      once(request2, "response", (response) => {
        once(response, "end", cancelTimeouts);
      });
      if (typeof delays.request !== "undefined") {
        addTimeout(delays.request, timeoutHandler, "request");
      }
      if (typeof delays.socket !== "undefined") {
        const socketTimeoutHandler = () => {
          timeoutHandler(delays.socket, "socket");
        };
        request2.setTimeout(delays.socket, socketTimeoutHandler);
        cancelers.push(() => {
          request2.removeListener("timeout", socketTimeoutHandler);
        });
      }
      once(request2, "socket", (socket) => {
        var _a2;
        const {socketPath} = request2;
        if (socket.connecting) {
          const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a2 = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a2 !== void 0 ? _a2 : "") !== 0);
          if (typeof delays.lookup !== "undefined" && !hasPath && typeof socket.address().address === "undefined") {
            const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
            once(socket, "lookup", cancelTimeout);
          }
          if (typeof delays.connect !== "undefined") {
            const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
            if (hasPath) {
              once(socket, "connect", timeConnect());
            } else {
              once(socket, "lookup", (error) => {
                if (error === null) {
                  once(socket, "connect", timeConnect());
                }
              });
            }
          }
          if (typeof delays.secureConnect !== "undefined" && options.protocol === "https:") {
            once(socket, "connect", () => {
              const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
              once(socket, "secureConnect", cancelTimeout);
            });
          }
        }
        if (typeof delays.send !== "undefined") {
          const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
          if (socket.connecting) {
            once(socket, "connect", () => {
              once(request2, "upload-complete", timeRequest());
            });
          } else {
            once(request2, "upload-complete", timeRequest());
          }
        }
      });
      if (typeof delays.response !== "undefined") {
        once(request2, "upload-complete", () => {
          const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
          once(request2, "response", cancelTimeout);
        });
      }
      return cancelTimeouts;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\url-to-options.js
  var require_url_to_options2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var is_1 = require_dist();
    exports2.default = (url) => {
      url = url;
      const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (is_1.default.string(url.port) && url.port.length !== 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\options-to-url.js
  var require_options_to_url = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var url_1 = require("url");
    var keys = [
      "protocol",
      "host",
      "hostname",
      "port",
      "pathname",
      "search"
    ];
    exports2.default = (origin, options) => {
      var _a2, _b;
      if (options.path) {
        if (options.pathname) {
          throw new TypeError("Parameters `path` and `pathname` are mutually exclusive.");
        }
        if (options.search) {
          throw new TypeError("Parameters `path` and `search` are mutually exclusive.");
        }
        if (options.searchParams) {
          throw new TypeError("Parameters `path` and `searchParams` are mutually exclusive.");
        }
      }
      if (options.search && options.searchParams) {
        throw new TypeError("Parameters `search` and `searchParams` are mutually exclusive.");
      }
      if (!origin) {
        if (!options.protocol) {
          throw new TypeError("No URL protocol specified");
        }
        origin = `${options.protocol}//${(_b = (_a2 = options.hostname) !== null && _a2 !== void 0 ? _a2 : options.host) !== null && _b !== void 0 ? _b : ""}`;
      }
      const url = new url_1.URL(origin);
      if (options.path) {
        const searchIndex = options.path.indexOf("?");
        if (searchIndex === -1) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.slice(0, searchIndex);
          options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
      }
      for (const key of keys) {
        if (options[key]) {
          url[key] = options[key].toString();
        }
      }
      return url;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\weakable-map.js
  var require_weakable_map = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var WeakableMap = class {
      constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
      }
      set(key, value) {
        if (typeof key === "object") {
          this.weakMap.set(key, value);
        } else {
          this.map.set(key, value);
        }
      }
      get(key) {
        if (typeof key === "object") {
          return this.weakMap.get(key);
        }
        return this.map.get(key);
      }
      has(key) {
        if (typeof key === "object") {
          return this.weakMap.has(key);
        }
        return this.map.has(key);
      }
    };
    exports2.default = WeakableMap;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\get-buffer.js
  var require_get_buffer = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var getBuffer = async (stream) => {
      const chunks = [];
      let length = 0;
      for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
      }
      if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
      }
      return Buffer.from(chunks.join(""));
    };
    exports2.default = getBuffer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\dns-ip-version.js
  var require_dns_ip_version = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.dnsLookupIpVersionToFamily = exports2.isDnsLookupIpVersion = void 0;
    var conversionTable = {
      auto: 0,
      ipv4: 4,
      ipv6: 6
    };
    exports2.isDnsLookupIpVersion = (value) => {
      return value in conversionTable;
    };
    exports2.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
      if (exports2.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
      }
      throw new Error("Invalid DNS lookup IP version");
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\utils\is-response-ok.js
  var require_is_response_ok = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isResponseOk = void 0;
    exports2.isResponseOk = (response) => {
      const {statusCode} = response;
      const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
      return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\utils\deprecation-warning.js
  var require_deprecation_warning = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var alreadyWarned = new Set();
    exports2.default = (message) => {
      if (alreadyWarned.has(message)) {
        return;
      }
      alreadyWarned.add(message);
      process.emitWarning(`Got: ${message}`, {
        type: "DeprecationWarning"
      });
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\as-promise\normalize-arguments.js
  var require_normalize_arguments = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var is_1 = require_dist();
    var normalizeArguments = (options, defaults) => {
      if (is_1.default.null_(options.encoding)) {
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      }
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
      if (options.responseType === void 0) {
        options.responseType = "text";
      }
      const {retry} = options;
      if (defaults) {
        options.retry = {...defaults.retry};
      } else {
        options.retry = {
          calculateDelay: (retryObject) => retryObject.computedValue,
          limit: 0,
          methods: [],
          statusCodes: [],
          errorCodes: [],
          maxRetryAfter: void 0
        };
      }
      if (is_1.default.object(retry)) {
        options.retry = {
          ...options.retry,
          ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map((method) => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
      } else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
      }
      if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));
      }
      if (is_1.default.object(options.pagination)) {
        if (defaults) {
          options.pagination = {
            ...defaults.pagination,
            ...options.pagination
          };
        }
        const {pagination} = options;
        if (!is_1.default.function_(pagination.transform)) {
          throw new Error("`options.pagination.transform` must be implemented");
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
          throw new Error("`options.pagination.shouldContinue` must be implemented");
        }
        if (!is_1.default.function_(pagination.filter)) {
          throw new TypeError("`options.pagination.filter` must be implemented");
        }
        if (!is_1.default.function_(pagination.paginate)) {
          throw new Error("`options.pagination.paginate` must be implemented");
        }
      }
      if (options.responseType === "json" && options.headers.accept === void 0) {
        options.headers.accept = "application/json";
      }
      return options;
    };
    exports2.default = normalizeArguments;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\calculate-retry-delay.js
  var require_calculate_retry_delay = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.retryAfterStatusCodes = void 0;
    exports2.retryAfterStatusCodes = new Set([413, 429, 503]);
    var calculateRetryDelay = ({attemptCount, retryOptions, error, retryAfter}) => {
      if (attemptCount > retryOptions.limit) {
        return 0;
      }
      const hasMethod = retryOptions.methods.includes(error.options.method);
      const hasErrorCode = retryOptions.errorCodes.includes(error.code);
      const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
      if (!hasMethod || !hasErrorCode && !hasStatusCode) {
        return 0;
      }
      if (error.response) {
        if (retryAfter) {
          if (retryOptions.maxRetryAfter === void 0 || retryAfter > retryOptions.maxRetryAfter) {
            return 0;
          }
          return retryAfter;
        }
        if (error.response.statusCode === 413) {
          return 0;
        }
      }
      const noise = Math.random() * 100;
      return 2 ** (attemptCount - 1) * 1e3 + noise;
    };
    exports2.default = calculateRetryDelay;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\core\index.js
  var require_core = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.UnsupportedProtocolError = exports2.ReadError = exports2.TimeoutError = exports2.UploadError = exports2.CacheError = exports2.HTTPError = exports2.MaxRedirectsError = exports2.RequestError = exports2.setNonEnumerableProperties = exports2.knownHookEvents = exports2.withoutBody = exports2.kIsNormalizedAlready = void 0;
    var util_1 = require("util");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var url_1 = require("url");
    var http = require("http");
    var http_1 = require("http");
    var https = require("https");
    var http_timer_1 = require_source3();
    var cacheable_lookup_1 = require_source4();
    var CacheableRequest = require_src4();
    var decompressResponse = require_decompress_response();
    var http2wrapper = require_source5();
    var lowercaseKeys = require_lowercase_keys();
    var is_1 = require_dist();
    var get_body_size_1 = require_get_body_size();
    var is_form_data_1 = require_is_form_data();
    var proxy_events_1 = require_proxy_events2();
    var timed_out_1 = require_timed_out();
    var url_to_options_1 = require_url_to_options2();
    var options_to_url_1 = require_options_to_url();
    var weakable_map_1 = require_weakable_map();
    var get_buffer_1 = require_get_buffer();
    var dns_ip_version_1 = require_dns_ip_version();
    var is_response_ok_1 = require_is_response_ok();
    var deprecation_warning_1 = require_deprecation_warning();
    var normalize_arguments_1 = require_normalize_arguments();
    var calculate_retry_delay_1 = require_calculate_retry_delay();
    var globalDnsCache = new cacheable_lookup_1.default();
    var kRequest = Symbol("request");
    var kResponse = Symbol("response");
    var kResponseSize = Symbol("responseSize");
    var kDownloadedSize = Symbol("downloadedSize");
    var kBodySize = Symbol("bodySize");
    var kUploadedSize = Symbol("uploadedSize");
    var kServerResponsesPiped = Symbol("serverResponsesPiped");
    var kUnproxyEvents = Symbol("unproxyEvents");
    var kIsFromCache = Symbol("isFromCache");
    var kCancelTimeouts = Symbol("cancelTimeouts");
    var kStartedReading = Symbol("startedReading");
    var kStopReading = Symbol("stopReading");
    var kTriggerRead = Symbol("triggerRead");
    var kBody = Symbol("body");
    var kJobs = Symbol("jobs");
    var kOriginalResponse = Symbol("originalResponse");
    var kRetryTimeout = Symbol("retryTimeout");
    exports2.kIsNormalizedAlready = Symbol("isNormalizedAlready");
    var supportsBrotli = is_1.default.string(process.versions.brotli);
    exports2.withoutBody = new Set(["GET", "HEAD"]);
    exports2.knownHookEvents = [
      "init",
      "beforeRequest",
      "beforeRedirect",
      "beforeError",
      "beforeRetry",
      "afterResponse"
    ];
    function validateSearchParameters(searchParameters) {
      for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
          throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
      }
    }
    function isClientRequest(clientRequest) {
      return is_1.default.object(clientRequest) && !("statusCode" in clientRequest);
    }
    var cacheableStore = new weakable_map_1.default();
    var waitForOpenFile = async (file) => new Promise((resolve, reject) => {
      const onError = (error) => {
        reject(error);
      };
      if (!file.pending) {
        resolve();
      }
      file.once("error", onError);
      file.once("ready", () => {
        file.off("error", onError);
        resolve();
      });
    });
    var redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
    var nonEnumerableProperties = [
      "context",
      "body",
      "json",
      "form"
    ];
    exports2.setNonEnumerableProperties = (sources, to) => {
      const properties = {};
      for (const source of sources) {
        if (!source) {
          continue;
        }
        for (const name of nonEnumerableProperties) {
          if (!(name in source)) {
            continue;
          }
          properties[name] = {
            writable: true,
            configurable: true,
            enumerable: false,
            value: source[name]
          };
        }
      }
      Object.defineProperties(to, properties);
    };
    var RequestError = class extends Error {
      constructor(message, error, self2) {
        var _a2;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = error.code;
        if (self2 instanceof Request) {
          Object.defineProperty(this, "request", {
            enumerable: false,
            value: self2
          });
          Object.defineProperty(this, "response", {
            enumerable: false,
            value: self2[kResponse]
          });
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2.options
          });
        } else {
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2
          });
        }
        this.timings = (_a2 = this.request) === null || _a2 === void 0 ? void 0 : _a2.timings;
        if (!is_1.default.undefined(error.stack)) {
          const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
          const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
          const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
          while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
            thisStackTrace.shift();
          }
          this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
      }
    };
    exports2.RequestError = RequestError;
    var MaxRedirectsError = class extends RequestError {
      constructor(request2) {
        super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
        this.name = "MaxRedirectsError";
      }
    };
    exports2.MaxRedirectsError = MaxRedirectsError;
    var HTTPError = class extends RequestError {
      constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = "HTTPError";
      }
    };
    exports2.HTTPError = HTTPError;
    var CacheError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "CacheError";
      }
    };
    exports2.CacheError = CacheError;
    var UploadError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "UploadError";
      }
    };
    exports2.UploadError = UploadError;
    var TimeoutError = class extends RequestError {
      constructor(error, timings, request2) {
        super(error.message, error, request2);
        this.name = "TimeoutError";
        this.event = error.event;
        this.timings = timings;
      }
    };
    exports2.TimeoutError = TimeoutError;
    var ReadError = class extends RequestError {
      constructor(error, request2) {
        super(error.message, error, request2);
        this.name = "ReadError";
      }
    };
    exports2.ReadError = ReadError;
    var UnsupportedProtocolError = class extends RequestError {
      constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = "UnsupportedProtocolError";
      }
    };
    exports2.UnsupportedProtocolError = UnsupportedProtocolError;
    var proxiedRequestEvents = [
      "socket",
      "connect",
      "continue",
      "information",
      "upgrade",
      "timeout"
    ];
    var Request = class extends stream_1.Duplex {
      constructor(url, options = {}, defaults) {
        super({
          autoDestroy: false,
          highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on("pipe", (source) => {
          source.prependListener("data", unlockWrite);
          source.on("data", lockWrite);
          source.prependListener("end", unlockWrite);
          source.on("end", lockWrite);
        });
        this.on("unpipe", (source) => {
          source.off("data", unlockWrite);
          source.off("data", lockWrite);
          source.off("end", unlockWrite);
          source.off("end", lockWrite);
        });
        this.on("pipe", (source) => {
          if (source instanceof http_1.IncomingMessage) {
            this.options.headers = {
              ...source.headers,
              ...this.options.headers
            };
          }
        });
        const {json: json2, body, form} = options;
        if (json2 || body || form) {
          this._lockWrite();
        }
        if (exports2.kIsNormalizedAlready in options) {
          this.options = options;
        } else {
          try {
            this.options = this.constructor.normalizeArguments(url, options, defaults);
          } catch (error) {
            if (is_1.default.nodeStream(options.body)) {
              options.body.destroy();
            }
            this.destroy(error);
            return;
          }
        }
        (async () => {
          var _a2;
          try {
            if (this.options.body instanceof fs_1.ReadStream) {
              await waitForOpenFile(this.options.body);
            }
            const {url: normalizedURL} = this.options;
            if (!normalizedURL) {
              throw new TypeError("Missing `url` property");
            }
            this.requestUrl = normalizedURL.toString();
            decodeURI(this.requestUrl);
            await this._finalizeBody();
            await this._makeRequest();
            if (this.destroyed) {
              (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.destroy();
              return;
            }
            for (const job of this[kJobs]) {
              job();
            }
            this[kJobs].length = 0;
            this.requestInitialized = true;
          } catch (error) {
            if (error instanceof RequestError) {
              this._beforeError(error);
              return;
            }
            if (!this.destroyed) {
              this.destroy(error);
            }
          }
        })();
      }
      static normalizeArguments(url, options, defaults) {
        var _a2, _b, _c, _d, _e;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
          options = {...defaults, ...url, ...options};
        } else {
          if (url && options && options.url !== void 0) {
            throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
          }
          options = {...defaults, ...options};
          if (url !== void 0) {
            options.url = url;
          }
          if (is_1.default.urlInstance(options.url)) {
            options.url = new url_1.URL(options.url.toString());
          }
        }
        if (options.cache === false) {
          options.cache = void 0;
        }
        if (options.dnsCache === false) {
          options.dnsCache = void 0;
        }
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
          is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
          is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
          is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
          is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        if (is_1.default.string(options.method)) {
          options.method = options.method.toUpperCase();
        } else {
          options.method = "GET";
        }
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
          options.headers = {...options.headers};
        } else {
          options.headers = lowercaseKeys({...defaults === null || defaults === void 0 ? void 0 : defaults.headers, ...options.headers});
        }
        if ("slashes" in options) {
          throw new TypeError("The legacy `url.Url` has been deprecated. Use `URL` instead.");
        }
        if ("auth" in options) {
          throw new TypeError("Parameter `auth` is deprecated. Use `username` / `password` instead.");
        }
        if ("searchParams" in options) {
          if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
            let searchParameters;
            if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {
              searchParameters = new url_1.URLSearchParams(options.searchParams);
            } else {
              validateSearchParameters(options.searchParams);
              searchParameters = new url_1.URLSearchParams();
              for (const key in options.searchParams) {
                const value = options.searchParams[key];
                if (value === null) {
                  searchParameters.append(key, "");
                } else if (value !== void 0) {
                  searchParameters.append(key, value);
                }
              }
            }
            (_a2 = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a2 === void 0 ? void 0 : _a2.forEach((value, key) => {
              if (!searchParameters.has(key)) {
                searchParameters.append(key, value);
              }
            });
            options.searchParams = searchParameters;
          }
        }
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : "";
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : "";
        if (is_1.default.undefined(options.prefixUrl)) {
          options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : "";
        } else {
          options.prefixUrl = options.prefixUrl.toString();
          if (options.prefixUrl !== "" && !options.prefixUrl.endsWith("/")) {
            options.prefixUrl += "/";
          }
        }
        if (is_1.default.string(options.url)) {
          if (options.url.startsWith("/")) {
            throw new Error("`input` must not start with a slash when using `prefixUrl`");
          }
          options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        } else if (is_1.default.undefined(options.url) && options.prefixUrl !== "" || options.protocol) {
          options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
          if ("port" in options) {
            delete options.port;
          }
          let {prefixUrl} = options;
          Object.defineProperty(options, "prefixUrl", {
            set: (value) => {
              const url2 = options.url;
              if (!url2.href.startsWith(value)) {
                throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url2.href}`);
              }
              options.url = new url_1.URL(value + url2.href.slice(prefixUrl.length));
              prefixUrl = value;
            },
            get: () => prefixUrl
          });
          let {protocol} = options.url;
          if (protocol === "unix:") {
            protocol = "http:";
            options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
          }
          if (options.searchParams) {
            options.url.search = options.searchParams.toString();
          }
          if (protocol !== "http:" && protocol !== "https:") {
            throw new UnsupportedProtocolError(options);
          }
          if (options.username === "") {
            options.username = options.url.username;
          } else {
            options.url.username = options.username;
          }
          if (options.password === "") {
            options.password = options.url.password;
          } else {
            options.url.password = options.password;
          }
        }
        const {cookieJar} = options;
        if (cookieJar) {
          let {setCookie, getCookieString} = cookieJar;
          is_1.assert.function_(setCookie);
          is_1.assert.function_(getCookieString);
          if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
            getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
            options.cookieJar = {
              setCookie,
              getCookieString
            };
          }
        }
        const {cache: cache2} = options;
        if (cache2) {
          if (!cacheableStore.has(cache2)) {
            cacheableStore.set(cache2, new CacheableRequest((requestOptions, handler) => {
              const result = requestOptions[kRequest](requestOptions, handler);
              if (is_1.default.promise(result)) {
                result.once = (event, handler2) => {
                  if (event === "error") {
                    result.catch(handler2);
                  } else if (event === "abort") {
                    (async () => {
                      try {
                        const request2 = await result;
                        request2.once("abort", handler2);
                      } catch (_a3) {
                      }
                    })();
                  } else {
                    throw new Error(`Unknown HTTP2 promise event: ${event}`);
                  }
                  return result;
                };
              }
              return result;
            }, cache2));
          }
        }
        options.cacheOptions = {...options.cacheOptions};
        if (options.dnsCache === true) {
          options.dnsCache = globalDnsCache;
        } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
          throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        if (is_1.default.number(options.timeout)) {
          options.timeout = {request: options.timeout};
        } else if (defaults && options.timeout !== defaults.timeout) {
          options.timeout = {
            ...defaults.timeout,
            ...options.timeout
          };
        } else {
          options.timeout = {...options.timeout};
        }
        if (!options.context) {
          options.context = {};
        }
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = {...options.hooks};
        for (const event of exports2.knownHookEvents) {
          if (event in options.hooks) {
            if (is_1.default.array(options.hooks[event])) {
              options.hooks[event] = [...options.hooks[event]];
            } else {
              throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
            }
          } else {
            options.hooks[event] = [];
          }
        }
        if (defaults && !areHooksDefault) {
          for (const event of exports2.knownHookEvents) {
            const defaultHooks = defaults.hooks[event];
            if (defaultHooks.length !== 0) {
              options.hooks[event] = [
                ...defaults.hooks[event],
                ...options.hooks[event]
              ];
            }
          }
        }
        if ("family" in options) {
          deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
          options.https = {...defaults.https, ...options.https};
        }
        if ("rejectUnauthorized" in options) {
          deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ("checkServerIdentity" in options) {
          deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ("ca" in options) {
          deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ("key" in options) {
          deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ("cert" in options) {
          deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ("passphrase" in options) {
          deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ("pfx" in options) {
          deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        if ("followRedirects" in options) {
          throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
        }
        if (options.agent) {
          for (const key in options.agent) {
            if (key !== "http" && key !== "https" && key !== "http2") {
              throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
            }
          }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        exports2.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalize_arguments_1.default(options, defaults);
      }
      _lockWrite() {
        const onLockedWrite = () => {
          throw new TypeError("The payload has been already provided");
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
      }
      _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
      }
      async _finalizeBody() {
        const {options} = this;
        const {headers} = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports2.withoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
          if (cannotHaveBody) {
            throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
          }
          if ([isBody, isForm, isJSON].filter((isTrue) => isTrue).length > 1) {
            throw new TypeError("The `body`, `json` and `form` options are mutually exclusive");
          }
          if (isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body)) {
            throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
          }
          if (isForm && !is_1.default.object(options.form)) {
            throw new TypeError("The `form` option must be an Object");
          }
          {
            const noContentType = !is_1.default.string(headers["content-type"]);
            if (isBody) {
              if (is_form_data_1.default(options.body) && noContentType) {
                headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
              }
              this[kBody] = options.body;
            } else if (isForm) {
              if (noContentType) {
                headers["content-type"] = "application/x-www-form-urlencoded";
              }
              this[kBody] = new url_1.URLSearchParams(options.form).toString();
            } else {
              if (noContentType) {
                headers["content-type"] = "application/json";
              }
              this[kBody] = options.stringifyJson(options.json);
            }
            const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
            if (is_1.default.undefined(headers["content-length"]) && is_1.default.undefined(headers["transfer-encoding"])) {
              if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                headers["content-length"] = String(uploadBodySize);
              }
            }
          }
        } else if (cannotHaveBody) {
          this._lockWrite();
        } else {
          this._unlockWrite();
        }
        this[kBodySize] = Number(headers["content-length"]) || void 0;
      }
      async _onResponseBase(response) {
        const {options} = this;
        const {url} = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
          response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers["content-length"]) || void 0;
        this[kResponse] = response;
        response.once("end", () => {
          this[kResponseSize] = this[kDownloadedSize];
          this.emit("downloadProgress", this.downloadProgress);
        });
        response.once("error", (error) => {
          response.destroy();
          this._beforeError(new ReadError(error, this));
        });
        response.once("aborted", () => {
          this._beforeError(new ReadError({
            name: "Error",
            message: "The server aborted pending request",
            code: "ECONNRESET"
          }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response.headers["set-cookie"];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
          let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
          if (options.ignoreInvalidCookies) {
            promises = promises.map(async (p) => p.catch(() => {
            }));
          }
          try {
            await Promise.all(promises);
          } catch (error) {
            this._beforeError(error);
            return;
          }
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
          response.resume();
          if (this[kRequest]) {
            this[kCancelTimeouts]();
            delete this[kRequest];
            this[kUnproxyEvents]();
          }
          const shouldBeGet = statusCode === 303 && options.method !== "GET" && options.method !== "HEAD";
          if (shouldBeGet || !options.methodRewriting) {
            options.method = "GET";
            if ("body" in options) {
              delete options.body;
            }
            if ("json" in options) {
              delete options.json;
            }
            if ("form" in options) {
              delete options.form;
            }
            this[kBody] = void 0;
            delete options.headers["content-length"];
          }
          if (this.redirects.length >= options.maxRedirects) {
            this._beforeError(new MaxRedirectsError(this));
            return;
          }
          try {
            const redirectBuffer = Buffer.from(response.headers.location, "binary").toString();
            const redirectUrl = new url_1.URL(redirectBuffer, url);
            const redirectString = redirectUrl.toString();
            decodeURI(redirectString);
            if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
              if ("host" in options.headers) {
                delete options.headers.host;
              }
              if ("cookie" in options.headers) {
                delete options.headers.cookie;
              }
              if ("authorization" in options.headers) {
                delete options.headers.authorization;
              }
              if (options.username || options.password) {
                options.username = "";
                options.password = "";
              }
            } else {
              redirectUrl.username = options.username;
              redirectUrl.password = options.password;
            }
            this.redirects.push(redirectString);
            options.url = redirectUrl;
            for (const hook of options.hooks.beforeRedirect) {
              await hook(options, typedResponse);
            }
            this.emit("redirect", typedResponse, options);
            await this._makeRequest();
          } catch (error) {
            this._beforeError(error);
            return;
          }
          return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
          this._beforeError(new HTTPError(typedResponse));
          return;
        }
        response.on("readable", () => {
          if (this[kTriggerRead]) {
            this._read();
          }
        });
        this.on("resume", () => {
          response.resume();
        });
        this.on("pause", () => {
          response.pause();
        });
        response.once("end", () => {
          this.push(null);
        });
        this.emit("response", response);
        for (const destination of this[kServerResponsesPiped]) {
          if (destination.headersSent) {
            continue;
          }
          for (const key in response.headers) {
            const isAllowed = options.decompress ? key !== "content-encoding" : true;
            const value = response.headers[key];
            if (isAllowed) {
              destination.setHeader(key, value);
            }
          }
          destination.statusCode = statusCode;
        }
      }
      async _onResponse(response) {
        try {
          await this._onResponseBase(response);
        } catch (error) {
          this._beforeError(error);
        }
      }
      _onRequest(request2) {
        const {options} = this;
        const {timeout, url} = options;
        http_timer_1.default(request2);
        this[kCancelTimeouts] = timed_out_1.default(request2, timeout, url);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request2.once(responseEventName, (response) => {
          void this._onResponse(response);
        });
        request2.once("error", (error) => {
          var _a2;
          request2.destroy();
          (_a2 = request2.res) === null || _a2 === void 0 ? void 0 : _a2.removeAllListeners("end");
          if (error instanceof timed_out_1.TimeoutError) {
            error = new TimeoutError(error, this.timings, this);
          } else {
            error = new RequestError(error.message, error, this);
          }
          this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request2, this, proxiedRequestEvents);
        this[kRequest] = request2;
        this.emit("uploadProgress", this.uploadProgress);
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request2;
        if (is_1.default.nodeStream(body)) {
          body.pipe(currentRequest);
          body.once("error", (error) => {
            this._beforeError(new UploadError(error, this));
          });
        } else {
          this._unlockWrite();
          if (!is_1.default.undefined(body)) {
            this._writeRequest(body, void 0, () => {
            });
            currentRequest.end();
            this._lockWrite();
          } else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();
            this._lockWrite();
          }
        }
        this.emit("request", request2);
      }
      async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
          Object.assign(options, url_to_options_1.default(url));
          delete options.url;
          let request2;
          const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
            response._readableState.autoDestroy = false;
            if (request2) {
              (await request2).emit("cacheableResponse", response);
            }
            resolve(response);
          });
          options.url = url;
          cacheRequest.once("error", reject);
          cacheRequest.once("request", async (requestOrPromise) => {
            request2 = requestOrPromise;
            resolve(request2);
          });
        });
      }
      async _makeRequest() {
        var _a2, _b, _c, _d, _e;
        const {options} = this;
        const {headers} = options;
        for (const key in headers) {
          if (is_1.default.undefined(headers[key])) {
            delete headers[key];
          } else if (is_1.default.null_(headers[key])) {
            throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
          }
        }
        if (options.decompress && is_1.default.undefined(headers["accept-encoding"])) {
          headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
        }
        if (options.cookieJar) {
          const cookieString = await options.cookieJar.getCookieString(options.url.toString());
          if (is_1.default.nonEmptyString(cookieString)) {
            options.headers.cookie = cookieString;
          }
        }
        for (const hook of options.hooks.beforeRequest) {
          const result = await hook(options);
          if (!is_1.default.undefined(result)) {
            options.request = () => result;
            break;
          }
        }
        if (options.body && this[kBody] !== options.body) {
          this[kBody] = options.body;
        }
        const {agent, request: request2, timeout, url} = options;
        if (options.dnsCache && !("lookup" in options)) {
          options.lookup = options.dnsCache.lookup;
        }
        if (url.hostname === "unix") {
          const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
          if (matches === null || matches === void 0 ? void 0 : matches.groups) {
            const {socketPath, path: path6} = matches.groups;
            Object.assign(options, {
              socketPath,
              path: path6,
              host: ""
            });
          }
        }
        const isHttps = url.protocol === "https:";
        let fallbackFn;
        if (options.http2) {
          fallbackFn = http2wrapper.auto;
        } else {
          fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a2 = options.request) !== null && _a2 !== void 0 ? _a2 : fallbackFn;
        const fn = options.cache ? this._createCacheableRequest : realFn;
        if (agent && !options.http2) {
          options.agent = agent[isHttps ? "https" : "http"];
        }
        options[kRequest] = realFn;
        delete options.request;
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        if (options.dnsLookupIpVersion !== void 0) {
          try {
            requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
          } catch (_f) {
            throw new Error("Invalid `dnsLookupIpVersion` option value");
          }
        }
        if (options.https) {
          if ("rejectUnauthorized" in options.https) {
            requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
          }
          if (options.https.checkServerIdentity) {
            requestOptions.checkServerIdentity = options.https.checkServerIdentity;
          }
          if (options.https.certificateAuthority) {
            requestOptions.ca = options.https.certificateAuthority;
          }
          if (options.https.certificate) {
            requestOptions.cert = options.https.certificate;
          }
          if (options.https.key) {
            requestOptions.key = options.https.key;
          }
          if (options.https.passphrase) {
            requestOptions.passphrase = options.https.passphrase;
          }
          if (options.https.pfx) {
            requestOptions.pfx = options.https.pfx;
          }
        }
        try {
          let requestOrResponse = await fn(url, requestOptions);
          if (is_1.default.undefined(requestOrResponse)) {
            requestOrResponse = fallbackFn(url, requestOptions);
          }
          options.request = request2;
          options.timeout = timeout;
          options.agent = agent;
          if (options.https) {
            if ("rejectUnauthorized" in options.https) {
              delete requestOptions.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
              delete requestOptions.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
              delete requestOptions.ca;
            }
            if (options.https.certificate) {
              delete requestOptions.cert;
            }
            if (options.https.key) {
              delete requestOptions.key;
            }
            if (options.https.passphrase) {
              delete requestOptions.passphrase;
            }
            if (options.https.pfx) {
              delete requestOptions.pfx;
            }
          }
          if (isClientRequest(requestOrResponse)) {
            this._onRequest(requestOrResponse);
          } else if (this.writable) {
            this.once("finish", () => {
              void this._onResponse(requestOrResponse);
            });
            this._unlockWrite();
            this.end();
            this._lockWrite();
          } else {
            void this._onResponse(requestOrResponse);
          }
        } catch (error) {
          if (error instanceof CacheableRequest.CacheError) {
            throw new CacheError(error, this);
          }
          throw new RequestError(error.message, error, this);
        }
      }
      async _error(error) {
        try {
          for (const hook of this.options.hooks.beforeError) {
            error = await hook(error);
          }
        } catch (error_) {
          error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
      }
      _beforeError(error) {
        if (this[kStopReading]) {
          return;
        }
        const {options} = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        const {response} = typedError;
        void (async () => {
          if (response && !response.body) {
            response.setEncoding(this._readableState.encoding);
            try {
              response.rawBody = await get_buffer_1.default(response);
              response.body = response.rawBody.toString();
            } catch (_a2) {
            }
          }
          if (this.listenerCount("retry") !== 0) {
            let backoff;
            try {
              let retryAfter;
              if (response && "retry-after" in response.headers) {
                retryAfter = Number(response.headers["retry-after"]);
                if (Number.isNaN(retryAfter)) {
                  retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                  if (retryAfter <= 0) {
                    retryAfter = 1;
                  }
                } else {
                  retryAfter *= 1e3;
                }
              }
              backoff = await options.retry.calculateDelay({
                attemptCount: retryCount,
                retryOptions: options.retry,
                error: typedError,
                retryAfter,
                computedValue: calculate_retry_delay_1.default({
                  attemptCount: retryCount,
                  retryOptions: options.retry,
                  error: typedError,
                  retryAfter,
                  computedValue: 0
                })
              });
            } catch (error_) {
              void this._error(new RequestError(error_.message, error_, this));
              return;
            }
            if (backoff) {
              const retry = async () => {
                try {
                  for (const hook of this.options.hooks.beforeRetry) {
                    await hook(this.options, typedError, retryCount);
                  }
                } catch (error_) {
                  void this._error(new RequestError(error_.message, error, this));
                  return;
                }
                if (this.destroyed) {
                  return;
                }
                this.destroy();
                this.emit("retry", retryCount, error);
              };
              this[kRetryTimeout] = setTimeout(retry, backoff);
              return;
            }
          }
          void this._error(typedError);
        })();
      }
      _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
          if (response.readableLength) {
            this[kTriggerRead] = false;
          }
          let data;
          while ((data = response.read()) !== null) {
            this[kDownloadedSize] += data.length;
            this[kStartedReading] = true;
            const progress = this.downloadProgress;
            if (progress.percent < 1) {
              this.emit("downloadProgress", progress);
            }
            this.push(data);
          }
        }
      }
      _write(chunk, encoding, callback) {
        const write = () => {
          this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
          write();
        } else {
          this[kJobs].push(write);
        }
      }
      _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
          return;
        }
        this._progressCallbacks.push(() => {
          this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
          const progress = this.uploadProgress;
          if (progress.percent < 1) {
            this.emit("uploadProgress", progress);
          }
        });
        this[kRequest].write(chunk, encoding, (error) => {
          if (!error && this._progressCallbacks.length !== 0) {
            this._progressCallbacks.shift()();
          }
          callback(error);
        });
      }
      _final(callback) {
        const endRequest = () => {
          while (this._progressCallbacks.length !== 0) {
            this._progressCallbacks.shift()();
          }
          if (!(kRequest in this)) {
            callback();
            return;
          }
          if (this[kRequest].destroyed) {
            callback();
            return;
          }
          this[kRequest].end((error) => {
            if (!error) {
              this[kBodySize] = this[kUploadedSize];
              this.emit("uploadProgress", this.uploadProgress);
              this[kRequest].emit("upload-complete");
            }
            callback(error);
          });
        };
        if (this.requestInitialized) {
          endRequest();
        } else {
          this[kJobs].push(endRequest);
        }
      }
      _destroy(error, callback) {
        var _a2;
        this[kStopReading] = true;
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
          this[kCancelTimeouts]();
          if (!((_a2 = this[kResponse]) === null || _a2 === void 0 ? void 0 : _a2.complete)) {
            this[kRequest].destroy();
          }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        callback(error);
      }
      get _isAboutToError() {
        return this[kStopReading];
      }
      get ip() {
        var _a2;
        return (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.socket.remoteAddress;
      }
      get aborted() {
        var _a2, _b, _c;
        return ((_b = (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
      }
      get socket() {
        var _a2;
        return (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.socket;
      }
      get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
          percent = this[kDownloadedSize] / this[kResponseSize];
        } else if (this[kResponseSize] === this[kDownloadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kDownloadedSize],
          total: this[kResponseSize]
        };
      }
      get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
          percent = this[kUploadedSize] / this[kBodySize];
        } else if (this[kBodySize] === this[kUploadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kUploadedSize],
          total: this[kBodySize]
        };
      }
      get timings() {
        var _a2;
        return (_a2 = this[kRequest]) === null || _a2 === void 0 ? void 0 : _a2.timings;
      }
      get isFromCache() {
        return this[kIsFromCache];
      }
      pipe(destination, options) {
        if (this[kStartedReading]) {
          throw new Error("Failed to pipe. The response has been emitted already.");
        }
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
      }
      unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
      }
    };
    exports2.default = Request;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\as-promise\types.js
  var require_types = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.CancelError = exports2.ParseError = void 0;
    var core_1 = require_core();
    var ParseError = class extends core_1.RequestError {
      constructor(error, response) {
        const {options} = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = "ParseError";
      }
    };
    exports2.ParseError = ParseError;
    var CancelError = class extends core_1.RequestError {
      constructor(request2) {
        super("Promise was canceled", {}, request2);
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    exports2.CancelError = CancelError;
    __exportStar2(require_core(), exports2);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\as-promise\parse-body.js
  var require_parse_body = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var types_1 = require_types();
    var parseBody = (response, responseType, parseJson, encoding) => {
      const {rawBody} = response;
      try {
        if (responseType === "text") {
          return rawBody.toString(encoding);
        }
        if (responseType === "json") {
          return rawBody.length === 0 ? "" : parseJson(rawBody.toString());
        }
        if (responseType === "buffer") {
          return rawBody;
        }
        throw new types_1.ParseError({
          message: `Unknown body type '${responseType}'`,
          name: "Error"
        }, response);
      } catch (error) {
        throw new types_1.ParseError(error, response);
      }
    };
    exports2.default = parseBody;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\as-promise\index.js
  var require_as_promise = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_1 = require("events");
    var is_1 = require_dist();
    var PCancelable = require_p_cancelable();
    var types_1 = require_types();
    var parse_body_1 = require_parse_body();
    var core_1 = require_core();
    var proxy_events_1 = require_proxy_events2();
    var get_buffer_1 = require_get_buffer();
    var is_response_ok_1 = require_is_response_ok();
    var proxiedRequestEvents = [
      "request",
      "response",
      "redirect",
      "uploadProgress",
      "downloadProgress"
    ];
    function asPromise(normalizedOptions) {
      let globalRequest;
      let globalResponse;
      const emitter = new events_1.EventEmitter();
      const promise = new PCancelable((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
          const request2 = new core_1.default(void 0, normalizedOptions);
          request2.retryCount = retryCount;
          request2._noPipe = true;
          onCancel(() => request2.destroy());
          onCancel.shouldReject = false;
          onCancel(() => reject(new types_1.CancelError(request2)));
          globalRequest = request2;
          request2.once("response", async (response) => {
            var _a2;
            response.retryCount = retryCount;
            if (response.request.aborted) {
              return;
            }
            let rawBody;
            try {
              rawBody = await get_buffer_1.default(request2);
              response.rawBody = rawBody;
            } catch (_b) {
              return;
            }
            if (request2._isAboutToError) {
              return;
            }
            const contentEncoding = ((_a2 = response.headers["content-encoding"]) !== null && _a2 !== void 0 ? _a2 : "").toLowerCase();
            const isCompressed = ["gzip", "deflate", "br"].includes(contentEncoding);
            const {options} = request2;
            if (isCompressed && !options.decompress) {
              response.body = rawBody;
            } else {
              try {
                response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
              } catch (error) {
                response.body = rawBody.toString();
                if (is_response_ok_1.isResponseOk(response)) {
                  request2._beforeError(error);
                  return;
                }
              }
            }
            try {
              for (const [index, hook] of options.hooks.afterResponse.entries()) {
                response = await hook(response, async (updatedOptions) => {
                  const typedOptions = core_1.default.normalizeArguments(void 0, {
                    ...updatedOptions,
                    retry: {
                      calculateDelay: () => 0
                    },
                    throwHttpErrors: false,
                    resolveBodyOnly: false
                  }, options);
                  typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                  for (const hook2 of typedOptions.hooks.beforeRetry) {
                    await hook2(typedOptions);
                  }
                  const promise2 = asPromise(typedOptions);
                  onCancel(() => {
                    promise2.catch(() => {
                    });
                    promise2.cancel();
                  });
                  return promise2;
                });
              }
            } catch (error) {
              request2._beforeError(new types_1.RequestError(error.message, error, request2));
              return;
            }
            if (!is_response_ok_1.isResponseOk(response)) {
              request2._beforeError(new types_1.HTTPError(response));
              return;
            }
            globalResponse = response;
            resolve(request2.options.resolveBodyOnly ? response.body : response);
          });
          const onError = (error) => {
            if (promise.isCanceled) {
              return;
            }
            const {options} = request2;
            if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
              const {response} = error;
              resolve(request2.options.resolveBodyOnly ? response.body : response);
              return;
            }
            reject(error);
          };
          request2.once("error", onError);
          request2.once("retry", (newRetryCount, error) => {
            var _a2;
            if (is_1.default.nodeStream((_a2 = error.request) === null || _a2 === void 0 ? void 0 : _a2.options.body)) {
              onError(error);
              return;
            }
            makeRequest(newRetryCount);
          });
          proxy_events_1.default(request2, emitter, proxiedRequestEvents);
        };
        makeRequest(0);
      });
      promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
      };
      const shortcut = (responseType) => {
        const newPromise = (async () => {
          await promise;
          const {options} = globalResponse.request;
          return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
      };
      promise.json = () => {
        const {headers} = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === void 0) {
          headers.accept = "application/json";
        }
        return shortcut("json");
      };
      promise.buffer = () => shortcut("buffer");
      promise.text = () => shortcut("text");
      return promise;
    }
    exports2.default = asPromise;
    __exportStar2(require_types(), exports2);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\as-promise\create-rejection.js
  var require_create_rejection = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var types_1 = require_types();
    function createRejection(error, ...beforeErrorGroups) {
      const promise = (async () => {
        if (error instanceof types_1.RequestError) {
          try {
            for (const hooks of beforeErrorGroups) {
              if (hooks) {
                for (const hook of hooks) {
                  error = await hook(error);
                }
              }
            }
          } catch (error_) {
            error = error_;
          }
        }
        throw error;
      })();
      const returnPromise = () => promise;
      promise.json = returnPromise;
      promise.text = returnPromise;
      promise.buffer = returnPromise;
      promise.on = returnPromise;
      return promise;
    }
    exports2.default = createRejection;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\utils\deep-freeze.js
  var require_deep_freeze = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var is_1 = require_dist();
    function deepFreeze(object) {
      for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
          deepFreeze(value);
        }
      }
      return Object.freeze(object);
    }
    exports2.default = deepFreeze;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\types.js
  var require_types2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\create.js
  var require_create = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.defaultHandler = void 0;
    var is_1 = require_dist();
    var as_promise_1 = require_as_promise();
    var create_rejection_1 = require_create_rejection();
    var core_1 = require_core();
    var deep_freeze_1 = require_deep_freeze();
    var errors4 = {
      RequestError: as_promise_1.RequestError,
      CacheError: as_promise_1.CacheError,
      ReadError: as_promise_1.ReadError,
      HTTPError: as_promise_1.HTTPError,
      MaxRedirectsError: as_promise_1.MaxRedirectsError,
      TimeoutError: as_promise_1.TimeoutError,
      ParseError: as_promise_1.ParseError,
      CancelError: as_promise_1.CancelError,
      UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
      UploadError: as_promise_1.UploadError
    };
    var delay = async (ms) => new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
    var {normalizeArguments} = core_1.default;
    var mergeOptions = (...sources) => {
      let mergedOptions;
      for (const source of sources) {
        mergedOptions = normalizeArguments(void 0, source, mergedOptions);
      }
      return mergedOptions;
    };
    var getPromiseOrStream = (options) => options.isStream ? new core_1.default(void 0, options) : as_promise_1.default(options);
    var isGotInstance = (value) => "defaults" in value && "options" in value.defaults;
    var aliases = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    exports2.defaultHandler = (options, next) => next(options);
    var callInitHooks = (hooks, options) => {
      if (hooks) {
        for (const hook of hooks) {
          hook(options);
        }
      }
    };
    var create = (defaults) => {
      defaults._rawHandlers = defaults.handlers;
      defaults.handlers = defaults.handlers.map((fn) => (options, next) => {
        let root;
        const result = fn(options, (newOptions) => {
          root = next(newOptions);
          return root;
        });
        if (result !== root && !options.isStream && root) {
          const typedResult = result;
          const {then: promiseThen, catch: promiseCatch, finally: promiseFianlly} = typedResult;
          Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
          Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
          typedResult.then = promiseThen;
          typedResult.catch = promiseCatch;
          typedResult.finally = promiseFianlly;
        }
        return result;
      });
      const got = (url, options, _defaults) => {
        var _a2, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
          return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        if (is_1.default.plainObject(url)) {
          const mergedOptions = {
            ...url,
            ...options
          };
          core_1.setNonEnumerableProperties([url, options], mergedOptions);
          options = mergedOptions;
          url = void 0;
        }
        try {
          let initHookError;
          try {
            callInitHooks(defaults.options.hooks.init, options);
            callInitHooks((_a2 = options === null || options === void 0 ? void 0 : options.hooks) === null || _a2 === void 0 ? void 0 : _a2.init, options);
          } catch (error) {
            initHookError = error;
          }
          const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
          normalizedOptions[core_1.kIsNormalizedAlready] = true;
          if (initHookError) {
            throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
          }
          return iterateHandlers(normalizedOptions);
        } catch (error) {
          if (options === null || options === void 0 ? void 0 : options.isStream) {
            throw error;
          } else {
            return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options === null || options === void 0 ? void 0 : options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
          }
        }
      };
      got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
          if (isGotInstance(value)) {
            optionsArray.push(value.defaults.options);
            handlers.push(...value.defaults._rawHandlers);
            isMutableDefaults = value.defaults.mutableDefaults;
          } else {
            optionsArray.push(value);
            if ("handlers" in value) {
              handlers.push(...value.handlers);
            }
            isMutableDefaults = value.mutableDefaults;
          }
        }
        handlers = handlers.filter((handler) => handler !== exports2.defaultHandler);
        if (handlers.length === 0) {
          handlers.push(exports2.defaultHandler);
        }
        return create({
          options: mergeOptions(...optionsArray),
          handlers,
          mutableDefaults: Boolean(isMutableDefaults)
        });
      };
      const paginateEach = async function* (url, options) {
        let normalizedOptions = normalizeArguments(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
          throw new TypeError("`options.pagination` must be implemented");
        }
        const all = [];
        let {countLimit} = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
          if (numberOfRequests !== 0) {
            await delay(pagination.backoff);
          }
          const result = await got(void 0, void 0, normalizedOptions);
          const parsed = await pagination.transform(result);
          const current = [];
          for (const item of parsed) {
            if (pagination.filter(item, all, current)) {
              if (!pagination.shouldContinue(item, all, current)) {
                return;
              }
              yield item;
              if (pagination.stackAllItems) {
                all.push(item);
              }
              current.push(item);
              if (--countLimit <= 0) {
                return;
              }
            }
          }
          const optionsToMerge = pagination.paginate(result, all, current);
          if (optionsToMerge === false) {
            return;
          }
          if (optionsToMerge === result.request.options) {
            normalizedOptions = result.request.options;
          } else if (optionsToMerge !== void 0) {
            normalizedOptions = normalizeArguments(void 0, optionsToMerge, normalizedOptions);
          }
          numberOfRequests++;
        }
      };
      got.paginate = paginateEach;
      got.paginate.all = async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
          results.push(item);
        }
        return results;
      };
      got.paginate.each = paginateEach;
      got.stream = (url, options) => got(url, {...options, isStream: true});
      for (const method of aliases) {
        got[method] = (url, options) => got(url, {...options, method});
        got.stream[method] = (url, options) => {
          return got(url, {...options, method, isStream: true});
        };
      }
      Object.assign(got, errors4);
      Object.defineProperty(got, "defaults", {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
      });
      got.mergeOptions = mergeOptions;
      return got;
    };
    exports2.default = create;
    __exportStar2(require_types2(), exports2);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\got-npm-11.7.0-cacb9b44fc-780b4b1d33.zip\node_modules\got\dist\source\index.js
  var require_source6 = __commonJS((exports2, module2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var url_1 = require("url");
    var create_1 = require_create();
    var defaults = {
      options: {
        method: "GET",
        retry: {
          limit: 2,
          methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
          ],
          statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
          ],
          errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
          ],
          maxRetryAfter: void 0,
          calculateDelay: ({computedValue}) => computedValue
        },
        timeout: {},
        headers: {
          "user-agent": "got (https://github.com/sindresorhus/got)"
        },
        hooks: {
          init: [],
          beforeRequest: [],
          beforeRedirect: [],
          beforeRetry: [],
          beforeError: [],
          afterResponse: []
        },
        cache: void 0,
        dnsCache: void 0,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: "text",
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: "",
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        http2: false,
        allowGetBody: false,
        https: void 0,
        pagination: {
          transform: (response) => {
            if (response.request.options.responseType === "json") {
              return response.body;
            }
            return JSON.parse(response.body);
          },
          paginate: (response) => {
            if (!Reflect.has(response.headers, "link")) {
              return false;
            }
            const items = response.headers.link.split(",");
            let next;
            for (const item of items) {
              const parsed = item.split(";");
              if (parsed[1].includes("next")) {
                next = parsed[0].trimStart().trim();
                next = next.slice(1, -1);
                break;
              }
            }
            if (next) {
              const options = {
                url: new url_1.URL(next)
              };
              return options;
            }
            return false;
          },
          filter: () => true,
          shouldContinue: () => true,
          countLimit: Infinity,
          backoff: 0,
          requestLimit: 1e4,
          stackAllItems: true
        },
        parseJson: (text) => JSON.parse(text),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
      },
      handlers: [create_1.defaultHandler],
      mutableDefaults: false
    };
    var got = create_1.default(defaults);
    exports2.default = got;
    module2.exports = got;
    module2.exports.default = got;
    module2.exports.__esModule = true;
    __exportStar2(require_create(), exports2);
    __exportStar2(require_as_promise(), exports2);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-libzip\sources\libzipSync.js
  var require_libzipSync = __commonJS((exports2, module2) => {
    var frozenFs = Object.assign({}, require("fs"));
    var Module3 = typeof Module3 !== "undefined" ? Module3 : {};
    var moduleOverrides = {};
    var key;
    for (key in Module3) {
      if (Module3.hasOwnProperty(key)) {
        moduleOverrides[key] = Module3[key];
      }
    }
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = function(status, toThrow) {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = true;
    var scriptDirectory = "";
    function locateFile(path6) {
      if (Module3["locateFile"]) {
        return Module3["locateFile"](path6, scriptDirectory);
      }
      return scriptDirectory + path6;
    }
    var read_;
    var readBinary;
    var nodeFS;
    var nodePath;
    if (ENVIRONMENT_IS_NODE) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = require("path").dirname(scriptDirectory) + "/";
      } else {
        scriptDirectory = __dirname + "/";
      }
      read_ = function shell_read(filename, binary) {
        var ret = tryParseAsDataURI(filename);
        if (ret) {
          return binary ? ret : ret.toString();
        }
        if (!nodeFS)
          nodeFS = frozenFs;
        if (!nodePath)
          nodePath = require("path");
        filename = nodePath["normalize"](filename);
        return nodeFS["readFileSync"](filename, binary ? null : "utf8");
      };
      readBinary = function readBinary2(filename) {
        var ret = read_(filename, true);
        if (!ret.buffer) {
          ret = new Uint8Array(ret);
        }
        assert(ret.buffer);
        return ret;
      };
      if (process["argv"].length > 1) {
        thisProgram = process["argv"][1].replace(/\\/g, "/");
      }
      arguments_ = process["argv"].slice(2);
      if (typeof module2 !== "undefined") {
        module2["exports"] = Module3;
      }
      quit_ = function(status) {
        process["exit"](status);
      };
      Module3["inspect"] = function() {
        return "[Emscripten Module object]";
      };
    } else {
    }
    var out = Module3["print"] || console.log.bind(console);
    var err = Module3["printErr"] || console.warn.bind(console);
    for (key in moduleOverrides) {
      if (moduleOverrides.hasOwnProperty(key)) {
        Module3[key] = moduleOverrides[key];
      }
    }
    moduleOverrides = null;
    if (Module3["arguments"])
      arguments_ = Module3["arguments"];
    if (Module3["thisProgram"])
      thisProgram = Module3["thisProgram"];
    if (Module3["quit"])
      quit_ = Module3["quit"];
    var STACK_ALIGN = 16;
    function alignMemory(size, factor) {
      if (!factor)
        factor = STACK_ALIGN;
      return Math.ceil(size / factor) * factor;
    }
    var tempRet0 = 0;
    var setTempRet0 = function(value) {
      tempRet0 = value;
    };
    var wasmBinary;
    if (Module3["wasmBinary"])
      wasmBinary = Module3["wasmBinary"];
    var noExitRuntime;
    if (Module3["noExitRuntime"])
      noExitRuntime = Module3["noExitRuntime"];
    if (typeof WebAssembly !== "object") {
      abort("no native wasm support detected");
    }
    function getValue(ptr, type, noSafe) {
      type = type || "i8";
      if (type.charAt(type.length - 1) === "*")
        type = "i32";
      switch (type) {
        case "i1":
          return HEAP8[ptr >> 0];
        case "i8":
          return HEAP8[ptr >> 0];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          return HEAP32[ptr >> 2];
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        default:
          abort("invalid type for getValue: " + type);
      }
      return null;
    }
    var wasmMemory;
    var wasmTable = new WebAssembly.Table({
      initial: 31,
      maximum: 31,
      element: "anyfunc"
    });
    var ABORT = false;
    var EXITSTATUS = 0;
    function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed: " + text);
      }
    }
    function getCFunc(ident) {
      var func = Module3["_" + ident];
      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
      return func;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = {
        string: function(str) {
          var ret2 = 0;
          if (str !== null && str !== void 0 && str !== 0) {
            var len = (str.length << 2) + 1;
            ret2 = stackAlloc(len);
            stringToUTF8(str, ret2, len);
          }
          return ret2;
        },
        array: function(arr) {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        }
      };
      function convertReturnValue(ret2) {
        if (returnType === "string")
          return UTF8ToString(ret2);
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      ret = convertReturnValue(ret);
      if (stack !== 0)
        stackRestore(stack);
      return ret;
    }
    function cwrap(ident, returnType, argTypes, opts) {
      argTypes = argTypes || [];
      var numericArgs = argTypes.every(function(type) {
        return type === "number";
      });
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heap, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heap[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(heap.subarray(idx, endPtr));
      } else {
        var str = "";
        while (idx < endPtr) {
          var u0 = heap[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heap[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heap[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343)
          u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
        if (u <= 127)
          ++len;
        else if (u <= 2047)
          len += 2;
        else if (u <= 65535)
          len += 3;
        else
          len += 4;
      }
      return len;
    }
    function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret)
        stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
    function writeArrayToMemory(array, buffer2) {
      HEAP8.set(array, buffer2);
    }
    var WASM_PAGE_SIZE = 65536;
    function alignUp(x, multiple) {
      if (x % multiple > 0) {
        x += multiple - x % multiple;
      }
      return x;
    }
    var buffer;
    var HEAP8;
    var HEAPU8;
    var HEAP16;
    var HEAPU16;
    var HEAP32;
    var HEAPU32;
    var HEAPF32;
    var HEAPF64;
    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module3["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module3["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module3["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module3["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module3["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module3["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module3["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module3["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }
    var INITIAL_INITIAL_MEMORY = Module3["INITIAL_MEMORY"] || 16777216;
    if (Module3["wasmMemory"]) {
      wasmMemory = Module3["wasmMemory"];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
        maximum: 2147483648 / WASM_PAGE_SIZE
      });
    }
    if (wasmMemory) {
      buffer = wasmMemory.buffer;
    }
    INITIAL_INITIAL_MEMORY = buffer.byteLength;
    updateGlobalBufferAndViews(buffer);
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module3["preRun"]) {
        if (typeof Module3["preRun"] == "function")
          Module3["preRun"] = [Module3["preRun"]];
        while (Module3["preRun"].length) {
          addOnPreRun(Module3["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module3["noFSInit"] && !FS.init.initialized)
        FS.init();
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      FS.ignorePermissions = false;
      callRuntimeCallbacks(__ATMAIN__);
    }
    function postRun() {
      if (Module3["postRun"]) {
        if (typeof Module3["postRun"] == "function")
          Module3["postRun"] = [Module3["postRun"]];
        while (Module3["postRun"].length) {
          addOnPostRun(Module3["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var Math_abs = Math.abs;
    var Math_ceil = Math.ceil;
    var Math_floor = Math.floor;
    var Math_min = Math.min;
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    Module3["preloadedImages"] = {};
    Module3["preloadedAudios"] = {};
    function abort(what) {
      if (Module3["onAbort"]) {
        Module3["onAbort"](what);
      }
      what += "";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
      var e = new WebAssembly.RuntimeError(what);
      throw e;
    }
    function hasPrefix(str, prefix) {
      return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return hasPrefix(filename, dataURIPrefix);
    }
    var wasmBinaryFile = "data:application/octet-stream;base64,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AkEgaiQAC4sDAQF/IwBBMGsiAyQAIAMgADYCJCADIAE2AiAgAyACNwMYAkAgAygCJC0AKEEBcQRAIANCfzcDKAwBCwJAAkAgAygCJCgCIEEATQ0AIAMpAxhC////////////AFYNACADKQMYQgBYDQEgAygCIA0BCyADKAIkQQxqQRJBABAVIANCfzcDKAwBCyADKAIkLQA1QQFxBEAgA0J/NwMoDAELAn8jAEEQayIAIAMoAiQ2AgwgACgCDC0ANEEBcQsEQCADQgA3AygMAQsgAykDGFAEQCADQgA3AygMAQsgA0IANwMQA0AgAykDECADKQMYVARAIAMgAygCJCADKAIgIAMpAxCnaiADKQMYIAMpAxB9QQEQIiICNwMIIAJCAFMEQCADKAIkQQE6ADUgAykDEFAEQCADQn83AygMBAsgAyADKQMQNwMoDAMLIAMpAwhQBEAgAygCJEEBOgA0BSADIAMpAwggAykDEHw3AxAMAgsLCyADIAMpAxA3AygLIAMpAyghAiADQTBqJAAgAgs2AQF/IwBBEGsiASAANgIMAn4gASgCDC0AAEEBcQRAIAEoAgwpAwggASgCDCkDEH0MAQtCAAsLsgECAX8BfiMAQRBrIgEkACABIAA2AgQgASABKAIEQggQHzYCAAJAIAEoAgBFBEAgAUIANwMIDAELIAEgASgCAC0AAK0gASgCAC0AB61COIYgASgCAC0ABq1CMIZ8IAEoAgAtAAWtQiiGfCABKAIALQAErUIghnwgASgCAC0AA61CGIZ8IAEoAgAtAAKtQhCGfCABKAIALQABrUIIhnx8NwMICyABKQMIIQIgAUEQaiQAIAILqAEBAX8jAEEQayIBJAAgASAANgIIAkAgASgCCCgCIEEATQRAIAEoAghBDGpBEkEAEBUgAUF/NgIMDAELIAEoAggiACAAKAIgQX9qNgIgIAEoAggoAiBFBEAgASgCCEEAQgBBAhAiGiABKAIIKAIABEAgASgCCCgCABAyQQBIBEAgASgCCEEMakEUQQAQFQsLCyABQQA2AgwLIAEoAgwhACABQRBqJAAgAAvxAgICfwF+AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiAB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ECwQMwsgASgCDCgCVBAWIAEoAgxBADYCVAsgAUEQaiQAC/EBAQF/IwBBEGsiASAANgIMIAEoAgxBADYCACABKAIMQQA6AAQgASgCDEEAOgAFIAEoAgxBAToABiABKAIMQb8GOwEIIAEoAgxBCjsBCiABKAIMQQA7AQwgASgCDEF/NgIQIAEoAgxBADYCFCABKAIMQQA2AhggASgCDEIANwMgIAEoAgxCADcDKCABKAIMQQA2AjAgASgCDEEANgI0IAEoAgxBADYCOCABKAIMQQA2AjwgASgCDEEAOwFAIAEoAgxBgIDYjXg2AkQgASgCDEIANwNIIAEoAgxBADsBUCABKAIMQQA7AVIgASgCDEEANgJUC9oTAQF/IwBBsAFrIgMkACADIAA2AqgBIAMgATYCpAEgAyACNgKgASADQQA2ApABIAMgAygCpAEoAjBBABA7NgKUASADIAMoAqQBKAI4QQAQOzYCmAECQAJAAkACQCADKAKUAUECRgRAIAMoApgBQQFGDQELIAMoApQBQQFGBEAgAygCmAFBAkYNAQsgAygClAFBAkcNASADKAKYAUECRw0BCyADKAKkASIAIAAvAQxBgBByOwEMDAELIAMoAqQBIgAgAC8BDEH/7wNxOwEMIAMoApQBQQJGBEAgA0H14AEgAygCpAEoAjAgAygCqAFBCGoQxAE2ApABIAMoApABRQRAIANBfzYCrAEMAwsLAkAgAygCoAFBgAJxDQAgAygCmAFBAkcNACADQfXGASADKAKkASgCOCADKAKoAUEIahDEATYCSCADKAJIRQRAIAMoApABECQgA0F/NgKsAQwDCyADKAJIIAMoApABNgIAIAMgAygCSDYCkAELCwJAIAMoAqQBLwFSRQRAIAMoAqQBIgAgAC8BDEH+/wNxOwEMDAELIAMoAqQBIgAgAC8BDEEBcjsBDAsgAyADKAKkASADKAKgARCAAUEBcToAhgEgAyADKAKgAUGACnFBgApHBH8gAy0AhgEFQQELQQFxOgCHASADAn9BASADKAKkAS8BUkGBAkYNABpBASADKAKkAS8BUkGCAkYNABogAygCpAEvAVJBgwJGC0EBcToAhQEgAy0AhwFBAXEEQCADIANBIGpCHBAqNgIcIAMoAhxFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAILAkAgAygCoAFBgAJxBEACQCADKAKgAUGACHENACADKAKkASkDIEL/////D1YNACADKAKkASkDKEL/////D1gNAgsgAygCHCADKAKkASkDKBAuIAMoAhwgAygCpAEpAyAQLgwBCwJAAkAgAygCoAFBgAhxDQAgAygCpAEpAyBC/////w9WDQAgAygCpAEpAyhC/////w9WDQAgAygCpAEpA0hC/////w9YDQELIAMoAqQBKQMoQv////8PWgRAIAMoAhwgAygCpAEpAygQLgsgAygCpAEpAyBC/////w9aBEAgAygCHCADKAKkASkDIBAuCyADKAKkASkDSEL/////D1oEQCADKAIcIAMoAqQBKQNIEC4LCwsCfyMAQRBrIgAgAygCHDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAIcEBcgAygCkAEQJCADQX82AqwBDAILIANBAQJ/IwBBEGsiACADKAIcNgIMAn4gACgCDC0AAEEBcQRAIAAoAgwpAxAMAQtCAAunQf//A3ELIANBIGpBgAYQUDYCjAEgAygCHBAXIAMoAowBIAMoApABNgIAIAMgAygCjAE2ApABCyADLQCFAUEBcQRAIAMgA0EVakIHECo2AhAgAygCEEUEQCADKAKoAUEIakEOQQAQFSADKAKQARAkIANBfzYCrAEMAgsgAygCEEECECAgAygCEEHP0wBBAhBAIAMoAhAgAygCpAEvAVJB/wFxEIoBIAMoAhAgAygCpAEoAhBB//8DcRAgAn8jAEEQayIAIAMoAhA2AgwgACgCDC0AAEEBcUULBEAgAygCqAFBCGpBFEEAEBUgAygCEBAXIAMoApABECQgA0F/NgKsAQwCCyADQYGyAkEHIANBFWpBgAYQUDYCDCADKAIQEBcgAygCDCADKAKQATYCACADIAMoAgw2ApABCyADIANB0ABqQi4QKiIANgJMIABFBEAgAygCqAFBCGpBDkEAEBUgAygCkAEQJCADQX82AqwBDAELIAMoAkxBxdMAQcrTACADKAKgAUGAAnEbQQQQQCADKAKgAUGAAnFFBEAgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQgLQf//A3EQIAsgAygCTAJ/QS0gAy0AhgFBAXENABogAygCpAEvAQoLQf//A3EQICADKAJMIAMoAqQBLwEMECACQCADLQCFAUEBcQRAIAMoAkxB4wAQIAwBCyADKAJMIAMoAqQBKAIQQf//A3EQIAsgAygCpAEoAhQgA0GeAWogA0GcAWoQwwEgAygCTCADLwGeARAgIAMoAkwgAy8BnAEQIAJAAkAgAy0AhQFBAXFFDQAgAygCpAEpAyhCFFoNACADKAJMQQAQIQwBCyADKAJMIAMoAqQBKAIYECELAkACQCADKAKgAUGAAnFBgAJHDQAgAygCpAEpAyBC/////w9UBEAgAygCpAEpAyhC/////w9UDQELIAMoAkxBfxAhIAMoAkxBfxAhDAELAkAgAygCpAEpAyBC/////w9UBEAgAygCTCADKAKkASkDIKcQIQwBCyADKAJMQX8QIQsCQCADKAKkASkDKEL/////D1QEQCADKAJMIAMoAqQBKQMopxAhDAELIAMoAkxBfxAhCwsgAygCTCADKAKkASgCMBBSQf//A3EQICADIAMoAqQBKAI0IAMoAqABEIIBQf//A3EgAygCkAFBgAYQggFB//8DcWo2AogBIAMoAkwgAygCiAFB//8DcRAgIAMoAqABQYACcUUEQCADKAJMIAMoAqQBKAI4EFJB//8DcRAgIAMoAkwgAygCpAEoAjxB//8DcRAgIAMoAkwgAygCpAEvAUAQICADKAJMIAMoAqQBKAJEECECQCADKAKkASkDSEL/////D1QEQCADKAJMIAMoAqQBKQNIpxAhDAELIAMoAkxBfxAhCwsCfyMAQRBrIgAgAygCTDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAJMEBcgAygCkAEQJCADQX82AqwBDAELIAMoAqgBIANB0ABqAn4jAEEQayIAIAMoAkw2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IACwsQNkEASARAIAMoAkwQFyADKAKQARAkIANBfzYCrAEMAQsgAygCTBAXIAMoAqQBKAIwBEAgAygCqAEgAygCpAEoAjAQhgFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABBEAgAygCqAEgAygCkAFBgAYQgQFBAEgEQCADKAKQARAkIANBfzYCrAEMAgsLIAMoApABECQgAygCpAEoAjQEQCADKAKoASADKAKkASgCNCADKAKgARCBAUEASARAIANBfzYCrAEMAgsLIAMoAqABQYACcUUEQCADKAKkASgCOARAIAMoAqgBIAMoAqQBKAI4EIYBQQBIBEAgA0F/NgKsAQwDCwsLIAMgAy0AhwFBAXE2AqwBCyADKAKsASEAIANBsAFqJAAgAAuCAgEBfyMAQSBrIgUkACAFIAA2AhggBSABNgIUIAUgAjsBEiAFQQA7ARAgBSADNgIMIAUgBDYCCCAFQQA2AgQCQANAIAUoAhgEQAJAIAUoAhgvAQggBS8BEkcNACAFKAIYKAIEIAUoAgxxQYAGcUUNACAFKAIEIAUvARBIBEAgBSAFKAIEQQFqNgIEDAELIAUoAhQEQCAFKAIUIAUoAhgvAQo7AQALIAUoAhgvAQpBAEoEQCAFIAUoAhgoAgw2AhwMBAsgBUGx0wA2AhwMAwsgBSAFKAIYKAIANgIYDAELCyAFKAIIQQlBABAVIAVBADYCHAsgBSgCHCEAIAVBIGokACAAC4EDAQF/IwBBMGsiBSQAIAUgADYCKCAFIAE2AiQgBSACNgIgIAUgAzoAHyAFIAQ2AhgCQAJAIAUoAiANACAFLQAfQQFxDQAgBUEANgIsDAELIAUgBSgCICAFLQAfQQFxRUVqEBk2AhQgBSgCFEUEQCAFKAIYQQ5BABAVIAVBADYCLAwBCwJAIAUoAigEQCAFIAUoAiggBSgCIK0QHzYCECAFKAIQRQRAIAUoAhhBDkEAEBUgBSgCFBAWIAVBADYCLAwDCyAFKAIUIAUoAhAgBSgCIBAaGgwBCyAFKAIkIAUoAhQgBSgCIK0gBSgCGBBhQQBIBEAgBSgCFBAWIAVBADYCLAwCCwsgBS0AH0EBcQRAIAUoAhQgBSgCIGpBADoAACAFIAUoAhQ2AgwDQCAFKAIMIAUoAhQgBSgCIGpJBEAgBSgCDC0AAEUEQCAFKAIMQSA6AAALIAUgBSgCDEEBajYCDAwBCwsLIAUgBSgCFDYCLAsgBSgCLCEAIAVBMGokACAAC8IBAQF/IwBBMGsiBCQAIAQgADYCKCAEIAE2AiQgBCACNwMYIAQgAzYCFAJAIAQpAxhC////////////AFYEQCAEKAIUQRRBABAVIARBfzYCLAwBCyAEIAQoAiggBCgCJCAEKQMYEC8iAjcDCCACQgBTBEAgBCgCFCAEKAIoEBggBEF/NgIsDAELIAQpAwggBCkDGFMEQCAEKAIUQRFBABAVIARBfzYCLAwBCyAEQQA2AiwLIAQoAiwhACAEQTBqJAAgAAs2AQF/IwBBEGsiASQAIAEgADYCDCABKAIMEGMgASgCDCgCABA6IAEoAgwoAgQQOiABQRBqJAALqwEBAX8jAEEQayIBJAAgASAANgIMIAEoAgwoAggEQCABKAIMKAIIEBwgASgCDEEANgIICwJAIAEoAgwoAgRFDQAgASgCDCgCBCgCAEEBcUUNACABKAIMKAIEKAIQQX5HDQAgASgCDCgCBCIAIAAoAgBBfnE2AgAgASgCDCgCBCgCAEUEQCABKAIMKAIEEDogASgCDEEANgIECwsgASgCDEEAOgAMIAFBEGokAAttAQF/IwBBIGsiBCQAIAQgADYCGCAEIAE2AhQgBCACNgIQIAQgAzYCDAJAIAQoAhhFBEAgBEEANgIcDAELIAQgBCgCFCAEKAIQIAQoAgwgBCgCGEEIahCOATYCHAsgBCgCHCEAIARBIGokACAAC4EGAgF/AX4jAEGQAWsiAyQAIAMgADYChAEgAyABNgKAASADIAI2AnwgAxBdAkAgAygCgAEpAwhCAFIEQCADIAMoAoABKAIAKAIAKQNINwNgIAMgAygCgAEoAgAoAgApA0g3A2gMAQsgA0IANwNgIANCADcDaAsgA0IANwNwAkADQCADKQNwIAMoAoABKQMIVARAIAMoAoABKAIAIAMpA3CnQQR0aigCACkDSCADKQNoVARAIAMgAygCgAEoAgAgAykDcKdBBHRqKAIAKQNINwNoCyADKQNoIAMoAoABKQMgVgRAIAMoAnxBE0EAEBUgA0J/NwOIAQwDCyADIAMoAoABKAIAIAMpA3CnQQR0aigCACkDSCADKAKAASgCACADKQNwp0EEdGooAgApAyB8IAMoAoABKAIAIAMpA3CnQQR0aigCACgCMBBSQf//A3GtfEIefDcDWCADKQNYIAMpA2BWBEAgAyADKQNYNwNgCyADKQNgIAMoAoABKQMgVgRAIAMoAnxBE0EAEBUgA0J/NwOIAQwDCyADKAKEASgCACADKAKAASgCACADKQNwp0EEdGooAgApA0hBABAoQQBIBEAgAygCfCADKAKEASgCABAYIANCfzcDiAEMAwsgAyADKAKEASgCAEEAQQEgAygCfBDCAUJ/UQRAIAMQXCADQn83A4gBDAMLIAMoAoABKAIAIAMpA3CnQQR0aigCACADEPEBBEAgAygCfEEVQQAQFSADEFwgA0J/NwOIAQwDBSADKAKAASgCACADKQNwp0EEdGooAgAoAjQgAygCNBCFASEAIAMoAoABKAIAIAMpA3CnQQR0aigCACAANgI0IAMoAoABKAIAIAMpA3CnQQR0aigCAEEBOgAEIANBADYCNCADEFwgAyADKQNwQgF8NwNwDAILAAsLIAMCfiADKQNgIAMpA2h9Qv///////////wBUBEAgAykDYCADKQNofQwBC0L///////////8ACzcDiAELIAMpA4gBIQQgA0GQAWokACAEC6YBAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgAygCEBD6ASIANgIMAkAgAEUEQCADQQA2AhwMAQsgAygCDCADKAIYNgIAIAMoAgwgAygCFDYCBCADKAIUQRBxBEAgAygCDCIAIAAoAhRBAnI2AhQgAygCDCIAIAAoAhhBAnI2AhgLIAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC9UBAQF/IwBBIGsiBCQAIAQgADYCGCAEIAE3AxAgBCACNgIMIAQgAzYCCAJAAkAgBCkDEEL///////////8AVwRAIAQpAxBCgICAgICAgICAf1kNAQsgBCgCCEEEQT0QFSAEQX82AhwMAQsCfyAEKQMQIQEgBCgCDCEAIAQoAhgiAigCTEF/TARAIAIgASAAEJYBDAELIAIgASAAEJYBC0EASARAIAQoAghBBEG0nAEoAgAQFSAEQX82AhwMAQsgBEEANgIcCyAEKAIcIQAgBEEgaiQAIAALJwACf0EAQQAgABAFIgAgAEEbRhsiAEUNABpBtJwBIAA2AgBBAAsaC14BAX8jAEEQayIDJAAgAyABQcCAgAJxBH8gAyACQQRqNgIMIAIoAgAFQQALNgIAIAAgAUGAgAJyIAMQESIAQYFgTwRAQbScAUEAIABrNgIAQX8hAAsgA0EQaiQAIAALVQEBfyMAQRBrIgEkACABIAA2AgwCQAJAIAEoAgwoAiRBAUYNACABKAIMKAIkQQJGDQAMAQsgASgCDEEAQgBBChAiGiABKAIMQQA2AiQLIAFBEGokAAszAQF/An8gABAGIgFBYUYEQCAAEBIhAQsgAUGBYE8LBH9BtJwBQQAgAWs2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IEUNACABKAIIKAIkDQELIAFBATYCDAwBCyABIAEoAggoAhw2AgQCQAJAIAEoAgRFDQAgASgCBCgCACABKAIIRw0AIAEoAgQoAgRBKkYNASABKAIEKAIEQTlGDQEgASgCBCgCBEHFAEYNASABKAIEKAIEQckARg0BIAEoAgQoAgRB2wBGDQEgASgCBCgCBEHnAEYNASABKAIEKAIEQfEARg0BIAEoAgQoAgRBmgVGDQELIAFBATYCDAwBCyABQQA2AgwLIAEoAgwL0gQBAX8jAEEgayIDIAA2AhwgAyABNgIYIAMgAjYCFCADIAMoAhxB3BZqIAMoAhRBAnRqKAIANgIQIAMgAygCFEEBdDYCDANAAkAgAygCDCADKAIcKALQKEoNAAJAIAMoAgwgAygCHCgC0ChODQAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBOBEAgAygCGCADKAIcIAMoAgxBAnRqQeAWaigCAEECdGovAQAgAygCGCADKAIcQdwWaiADKAIMQQJ0aigCAEECdGovAQBHDQEgAygCHCADKAIMQQJ0akHgFmooAgAgAygCHEHYKGpqLQAAIAMoAhxB3BZqIAMoAgxBAnRqKAIAIAMoAhxB2Chqai0AAEoNAQsgAyADKAIMQQFqNgIMCyADKAIYIAMoAhBBAnRqLwEAIAMoAhggAygCHEHcFmogAygCDEECdGooAgBBAnRqLwEASA0AAkAgAygCGCADKAIQQQJ0ai8BACADKAIYIAMoAhxB3BZqIAMoAgxBAnRqKAIAQQJ0ai8BAEcNACADKAIQIAMoAhxB2Chqai0AACADKAIcQdwWaiADKAIMQQJ0aigCACADKAIcQdgoamotAABKDQAMAQsgAygCHEHcFmogAygCFEECdGogAygCHEHcFmogAygCDEECdGooAgA2AgAgAyADKAIMNgIUIAMgAygCDEEBdDYCDAwBCwsgAygCHEHcFmogAygCFEECdGogAygCEDYCAAvnCAEDfyMAQTBrIgIkACACIAA2AiwgAiABNgIoIAIgAigCKCgCADYCJCACIAIoAigoAggoAgA2AiAgAiACKAIoKAIIKAIMNgIcIAJBfzYCECACKAIsQQA2AtAoIAIoAixBvQQ2AtQoIAJBADYCGANAIAIoAhggAigCHE5FBEACQCACKAIkIAIoAhhBAnRqLwEABEAgAiACKAIYIgE2AhAgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQAgBCAANgLQKCAAQQJ0IANqIAE2AgAgAigCGCACKAIsQdgoampBADoAAAwBCyACKAIkIAIoAhhBAnRqQQA7AQILIAIgAigCGEEBajYCGAwBCwsDQCACKAIsKALQKEECSARAAkAgAigCEEECSARAIAIgAigCEEEBaiIANgIQDAELQQAhAAsgAigCLEHcFmohAyACKAIsIgQoAtAoQQFqIQEgBCABNgLQKCABQQJ0IANqIAA2AgAgAiAANgIMIAIoAiQgAigCDEECdGpBATsBACACKAIMIAIoAixB2ChqakEAOgAAIAIoAiwiACAAKAKoLUF/ajYCqC0gAigCIARAIAIoAiwiACAAKAKsLSACKAIgIAIoAgxBAnRqLwECazYCrC0LDAELCyACKAIoIAIoAhA2AgQgAiACKAIsKALQKEECbTYCGANAIAIoAhhBAUhFBEAgAigCLCACKAIkIAIoAhgQdSACIAIoAhhBf2o2AhgMAQsLIAIgAigCHDYCDANAIAIgAigCLCgC4BY2AhggAigCLEHcFmohASACKAIsIgMoAtAoIQAgAyAAQX9qNgLQKCACKAIsIABBAnQgAWooAgA2AuAWIAIoAiwgAigCJEEBEHUgAiACKAIsKALgFjYCFCACKAIYIQEgAigCLEHcFmohAyACKAIsIgQoAtQoQX9qIQAgBCAANgLUKCAAQQJ0IANqIAE2AgAgAigCFCEBIAIoAixB3BZqIQMgAigCLCIEKALUKEF/aiEAIAQgADYC1CggAEECdCADaiABNgIAIAIoAiQgAigCDEECdGogAigCJCACKAIYQQJ0ai8BACACKAIkIAIoAhRBAnRqLwEAajsBACACKAIMIAIoAixB2ChqagJ/IAIoAhggAigCLEHYKGpqLQAAIAIoAhQgAigCLEHYKGpqLQAATgRAIAIoAhggAigCLEHYKGpqLQAADAELIAIoAhQgAigCLEHYKGpqLQAAC0EBajoAACACKAIkIAIoAhRBAnRqIAIoAgwiADsBAiACKAIkIAIoAhhBAnRqIAA7AQIgAiACKAIMIgBBAWo2AgwgAigCLCAANgLgFiACKAIs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AykDKCEBIANBMGokACABC3cBAX8jAEEQayICIAA2AgggAiABNgIEAkACQAJAIAIoAggpAyhC/////w9aDQAgAigCCCkDIEL/////D1oNACACKAIEQYAEcUUNASACKAIIKQNIQv////8PVA0BCyACQQE6AA8MAQsgAkEAOgAPCyACLQAPQQFxC9kCAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgA0EMakIEECo2AggCQCADKAIIRQRAIANBfzYCHAwBCwNAIAMoAhQEQCADKAIUKAIEIAMoAhBxQYAGcQRAIAMoAghCABAtGiADKAIIIAMoAhQvAQgQICADKAIIIAMoAhQvAQoQIAJ/IwBBEGsiACADKAIINgIMIAAoAgwtAABBAXFFCwRAIAMoAhhBCGpBFEEAEBUgAygCCBAXIANBfzYCHAwECyADKAIYIANBDGpCBBA2QQBIBEAgAygCCBAXIANBfzYCHAwECyADKAIULwEKQQBKBEAgAygCGCADKAIUKAIMIAMoAhQvAQqtEDZBAEgEQCADKAIIEBcgA0F/NgIcDAULCwsgAyADKAIUKAIANgIUDAELCyADKAIIEBcgA0EANgIcCyADKAIcIQAgA0EgaiQAIAALaAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEAOwEGA0AgAigCDARAIAIoAgwoAgQgAigCCHFBgAZxBEAgAiACKAIMLwEKIAIvAQZBBGpqOwEGCyACIAIoAgwoAgA2AgwMAQsLIAIvAQYL8AEBAX8jAEEQayIBJAAgASAANgIMIAEgASgCDDYCCCABQQA2AgQDQCABKAIMBEACQAJAIAEoAgwvAQhB9cYBRg0AIAEoAgwvAQhB9eABRg0AIAEoAgwvAQhBgbICRg0AIAEoAgwvAQhBAUcNAQsgASABKAIMKAIANgIAIAEoAgggASgCDEYEQCABIAEoAgA2AggLIAEoAgxBADYCACABKAIMECQgASgCBARAIAEoAgQgASgCADYCAAsgASABKAIANgIMDAILIAEgASgCDDYCBCABIAEoAgwoAgA2AgwMAQsLIAEoAgghACABQRBqJAAgAAuzBAEBfyMAQUBqIgUkACAFIAA2AjggBSABOwE2IAUgAjYCMCAFIAM2AiwgBSAENgIoIAUgBSgCOCAFLwE2rRAqIgA2AiQC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ACgCDCgCBDYCAAsLIAIoAgwEQCACKAIMIAIoAgQ2AgALIAJBEGokAAuVAQEBfyMAQRBrIgEkACABIAA2AggCQAJ/IwBBEGsiACABKAIINgIMIAAoAgwpAxhCgIAQg1ALBEAgASgCCCgCAARAIAEgASgCCCgCABCUAUEBcToADwwCCyABQQE6AA8MAQsgASABKAIIQQBCAEESECI+AgQgASABKAIEQQBHOgAPCyABLQAPQQFxIQAgAUEQaiQAIAALfwEBfyMAQSBrIgMkACADIAA2AhggAyABNwMQIANBADYCDCADIAI2AggCQCADKQMQQv///////////wBWBEAgAygCCEEEQT0QFSADQX82AhwMAQsgAyADKAIYIAMpAxAgAygCDCADKAIIEGc2AhwLIAMoAhwhACADQSBqJAAgAAt9ACACQQFGBEAgASAAKAIIIAAoAgRrrH0hAQsCQCAAKAIUIAAoAhxLBEAgAEEAQQAgACgCJBEBABogACgCFEUNAQsgAEEANgIcIABCADcDECAAIAEgAiAAKAIoERAAQgBTDQAgAEIANwIEIAAgACgCAEFvcTYCAEEADwtBfwviAgECfyMAQSBrIgMkAAJ/AkACQEH0lwEgASwAABCYAUUEQEG0nAFBHDYCAAwBC0GYCRAZIgINAQtBAAwBCyACQQBBkAEQMyABQSsQmAFFBEAgAkEIQQQgAS0AAEHyAEYbNgIACwJAIAEtAABB4QBHBEAgAigCACEBDAELIABBA0EAEAQiAUGACHFFBEAgAyABQYAIcjYCECAAQQQgA0EQahAEGgsgAiACKAIAQYABciIBNgIACyACQf8BOgBLIAJBgAg2AjAgAiAANgI8IAIgAkGYAWo2AiwCQCABQQhxDQAgAyADQRhqNgIAIABBk6gBIAMQDg0AIAJBCjoASwsgAkEaNgIoIAJBGzYCJCACQRw2AiAgAkEdNgIMQdygASgCAEUEQCACQX82AkwLIAJBsKEBKAIANgI4QbChASgCACIABEAgACACNgI0C0GwoQEgAjYCACACCyEAIANBIGokACAACxoAIAAgARCFAiIAQQAgAC0AACABQf8BcUYbCxgAIAAoAkxBf0wEQCAAEJoBDwsgABCaAQtgAgJ/AX4gACgCKCEBQQEhAiAAQgAgAC0AAEGAAXEEf0ECQQEgACgCFCAAKAIc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KAIYKQMwWgRAIAIoAhhBCGpBEkEAEBUgAkF/NgIcDAELIAIoAhgoAhhBAnEEQCACKAIYQQhqQRlBABAVIAJBfzYCHAwBCyACIAIoAhggAikDEEEAIAIoAhhBCGoQTyIANgIMIABFBEAgAkF/NgIcDAELIAIoAhgoAlAgAigCDCACKAIYQQhqEFlBAXFFBEAgAkF/NgIcDAELIAIoAhggAikDEBCgAgRAIAJBfzYCHAwBCyACKAIYKAJAIAIpAxCnQQR0akEBOgAMIAJBADYCHAsgAigCHCEAIAJBIGokACAAC5gCAAJAAkAgAUEUSw0AAkACQAJAAkACQAJAAkACQCABQXdqDgoAAQIJAwQFBgkHCAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQRYRBAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0oBA38gACgCACwAAEFQakEKSQRAA0AgACgCACIBLAAAIQMgACABQQFqNgIAIAMgAkEKbGpBUGohAiABLAABQVBqQQpJDQALCyACC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEKQBIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABELQCC+UBAQJ/IAJBAEchAwJAAkACQCACRQ0AIABBA3FFDQAgAUH/AXEhBANAIAAtAAAgBEYNAiAAQQFqIQAgAkF/aiICQQBHIQMgAkUNASAAQQNxDQALCyADRQ0BCwJAIAAtAAAgAUH/AXFGDQAgAkEESQ0AIAFB/wFxQYGChAhsIQMDQCAAKAIAIANzIgRBf3MgBEH//ft3anFBgIGChHhxDQEgAEEEaiEAIAJB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HAvkAQEBfyMAQSBrIgMkACADIAA6ABsgAyABNgIUIAMgAjYCECADQcgAEBkiADYCDAJAIABFBEAgAygCEEEBQbScASgCABAVIANBADYCHAwBCyADKAIMIAMoAhA2AgAgAygCDCADLQAbQQFxOgAEIAMoAgwgAygCFDYCCAJAIAMoAgwoAghBAU4EQCADKAIMKAIIQQlMDQELIAMoAgxBCTYCCAsgAygCDEEAOgAMIAMoAgxBADYCMCADKAIMQQA2AjQgAygCDEEANgI4IAMgAygCDDYCHAsgAygCHCEAIANBIGokACAAC+MIAQF/IwBBQGoiAiAANgI4IAIgATYCNCACIAIoAjgoAnw2AjAgAiACKAI4KAI4IAIoAjgoAmxqNgIsIAIgAigCOCgCeDYCICACIAIoAjgoApABNgIcIAICfyACKAI4KAJsIAIoAjgoAixBhgJrSwRAIAIoAjgoAmwgAigCOCgCLEGGAmtrDAELQQALNgIYIAIgAigCOCgCQDYCFCACIAIoAjgoAjQ2AhAgAiACKAI4KAI4IAIoAjgoAmxqQYICajYCDCACIAIoAiwgAigCIEEBa2otAAA6AAsgAiACKAIsIAIoAiBqLQAAOgAKIAIoAjgoAnggAigCOCgCjAFPBEAgAiACKAIwQQJ2NgIwCyACKAIcIAIoAjgoAnRLBEAgAiACKAI4KAJ0NgIcCwNAAkAgAiACKAI4KAI4IAIoAjRqNgIoAkAgAigCKCACKAIgai0AACACLQAKRw0AIAIoAiggAigCIEEBa2otAAAgAi0AC0cNACACKAIoLQAAIAIoAiwtAABHDQAgAiACKAIoIgBBAWo2AiggAC0AASACKAIsLQABRwRADAELIAIgAigCLEECajYCLCACIAIoAihBAWo2AigDQCACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AigCf0EAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACKAIsIAIoAgxJC0EBcQ0ACyACQYICIAIoAgwgAigCLGtrNgIkIAIgAigCDEH+fWo2AiwgAigCJCACKAIgSgRAIAIoAjggAigCNDYCcCACIAIoAiQ2AiAgAigCJCACKAIcTg0CIAIgAigCLCACKAIgQQFrai0AADoACyACIAIoAiwgAigCIGotAAA6AAoLCyACIAIoAhQgAigCNCACKAIQcUEBdGovAQAiATYCNEEAIQAgASACKAIYSwR/IAIgAigCMEF/aiIANgIwIABBAEcFQQALQQFxDQELCwJAIAIoAiAgAigCOCgCdE0EQCACIAIoAiA2AjwMAQsgAiACKAI4KAJ0NgI8CyACKAI8C5gQAQF/IwBBMGsiAiQAIAIgADYCKCACIAE2AiQgAgJ/IAIoAigoAgxBBWsgAigCKCgCLEsEQCACKAIoKAIsDAELIAIoAigoAgxBBWsLNgIgIAJBADYCECACIAIoAigoAgAoAgQ2AgwDQAJAIAJB//8DNgIcIAIgAigCKCgCvC1BKmpBA3U2AhQgAigCKCgCACgCECACKAIUSQ0AIAIgAigCKCgCACgCECACKAIUazYCFCACIAIoAigoAmwgAigCKCgCXGs2AhggAigCHCACKAIYIAIoAigoAgAoAgRqSwRAIAIgAigCGCACKAIoKAIAKAIEajYCHAsgAigCHCACKAIUSwRAIAIgAigCFDYCHAsCQCACKAIcIAIoAiBPDQACQCACKAIcRQRAIAIoAiRBBEcNAQsgAigCJEUNACACKAIcIAIoAhggAigCKCgCACgCBGpGDQELDAELQQAhACACIAIoAiRBBEYEfyACKAIcIAIoAhggAigCKCgCACgCBGpGBUEAC0EBcUVFNgIQIAIoAihBAEEAIAIoAhAQVyACKAIoKAIIIAIoAigoAhRBBGtqIAIoAhw6AAAgAigCKCgCCCACKAIoKAIUQQNraiACKAIcQQh2OgAAIAIoAigoAgggAigCKCgCFEECa2ogAigCHEF/czoAACACKAIoKAIIIAIoAigoAhRBAWtqIAIoAhxBf3NBCHY6AAAgAigCKCgCABAdIAIoAhgEQCACKAIYIAIoAhxLBEAgAiACKAIcNgIYCyACKAIoKAIAKAIMIAIoAigoAjggAigCKCgCXGogAigCGBAaGiACKAIoKAIAIgAgAigCGCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIYazYCECACKAIoKAIAIgAgAigCGCAAKAIUajYCFCACKAIoIgAgAigCGCAAKAJcajYCXCACIAIoAhwgAigCGGs2AhwLIAIoAhwEQCACKAIoKAIAIAIoAigoAgAoAgwgAigCHBBzGiACKAIoKAIAIgAgAigCHCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIcazYCECACKAIoKAIAIgAgAigCHCAAKAIUajYCFAsgAigCEEUNAQsLIAIgAigCDCACKAIoKAIAKAIEazYCDCACKAIMBEACQCACKAIMIAIoAigoAixPBEAgAigCKEECNgKwLSACKAIoKAI4IAIoAigoAgAoAgAgAigCKCgCLGsgAigCKCgCLBAaGiACKAIoIAIoAigoAiw2AmwMAQsgAigCKCgCPCACKAIoKAJsayACKAIMTQRAIAIoAigiACAAKAJsIAIoAigoAixrNgJsIAIoAigoAjggAigCKCgCOCACKAIoKAIsaiACKAIoKAJsEBoaIAIoAigoArAtQQJJBEAgAigCKCIAIAAoArAtQQFqNgKwLQsLIAIoAigoAjggAigCKCgCbGogAigCKCgCACgCACACKAIMayACKAIMEBoaIAIoAigiACACKAIMIAAoAmxqNgJsCyACKAIoIAIoAigoAmw2AlwgAigCKCIBAn8gAigCDCACKAIoKAIsIAIoAigoArQta0sEQCACKAIoKAIsIAIoAigoArQtawwBCyACKAIMCyABKAK0LWo2ArQtCyACKAIoKALALSACKAIoKAJsSQRAIAIoAiggAigCKCgCbDYCwC0LAkAgAigCEARAIAJBAzYCLAwBCwJAIAIoAiRFDQAgAigCJEEERg0AIAIoAigoAgAoAgQNACACKAIoKAJsIAIoAigoAlxHDQAgAkEBNgIsDAELIAIgAigCKCgCPCACKAIoKAJsa0EBazYCFAJAIAIoAigoAgAoAgQgAigCFE0NACACKAIoKAJcIAIoAigoAixIDQAgAigCKCIAIAAoAlwgAigCKCgCLGs2AlwgAigCKCIAIAAoAmwgAigCKCgCLGs2AmwgAigCKCgCOCACKAIoKAI4IAIoAigoAixqIAIoAigoAmwQGhogAigCKCgCsC1BAkkEQCACKAIoIgAgACgCsC1BAWo2ArAtCyACIAIoAigoAiwgAigCFGo2AhQLIAIoAhQgAigCKCgCACgCBEsEQCACIAIoAigoAgAoAgQ2AhQLIAIoAhQEQCACKAIoKAIAIAIoAigoAjggAigCKCgCbGogAigCFBBzGiACKAIoIgAgAigCFCAAKAJsajYCbAsgAigCKCgCwC0gAigCKCgCbEkEQCACKAIoIAIoAigoAmw2AsAtCyACIAIoAigoArwtQSpqQQN1NgIUIAICf0H//wMgAigCKCgCDCACKAIUa0H//wNLDQAaIAIoAigoAgwgAigCFGsLNgIUIAICfyACKAIUIAIoAigoAixLBEAgAigCKCgCLAwBCyACKAIUCzYCICACIAIoAigoAmwgAigCKCgCXGs2AhgCQCACKAIYIAIoAiBJBEAgAigCGEUEQCACKAIkQQRHDQILIAIoAiRFDQEgAigCKCgCACgCBA0BIAIoAhggAigCFEsNAQsgAgJ/IAIoAhggAigCFEsEQCACKAIUDAELIAIoAhgLNgIcIAICf0EAIAIoAiRBBEcNABpBACACKAIoKAIAKAIEDQAaIAIoAhwgAigCGEYLQQFxRUU2AhAgAigCKCACKAIoKAI4IAIoAigoAlxqIAIoAhwgAigCEBBXIAIoAigiACACKAIcIAAoAlxqNgJcIAIoAigoAgAQHQsgAkECQQAgAigCEBs2AiwLIAIoAiwhACACQTBqJAAgAAuyAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHQEQCABQX42AgwMAQsgASABKAIIKAIcKAIENgIEIAEoAggoAhwoAggEQCABKAIIKAIoIAEoAggoAhwoAgggASgCCCgCJBEEAAsgASgCCCgCHCgCRARAIAEoAggoAiggASgCCCgCHCgCRCABKAIIKAIkEQQACyABKAIIKAIcKAJABEAgASgCCCgCKCABKAIIKAIcKAJAIAEoAggoAiQRBAALIAEoAggoAhwoAjgEQCABKAIIKAIoIAEoAggoAhwoAjggASgCCCgCJBEEAAsgASgCCCgCKCABKAIIKAIcIAEoAggoAiQRBAAgASgCCEEANgIcIAFBfUEAIAEoAgRB8QBGGzYCDAsgASgCDCEAIAFBEGokACAAC+sXAQJ/IwBB8ABrIgMgADYCbCADIAE2AmggAyACNgJkIANBfzYCXCADIAMoAmgvAQI2AlQgA0EANgJQIANBBzYCTCADQQQ2AkggAygCVEUEQCADQYoBNgJMIANBAzYCSAsgA0EANgJgA0AgAygCYCADKAJkSkUEQCADIAMoAlQ2AlggAyADKAJoIAMoAmBBAWpBAnRqLwECNgJUIAMgAygCUEEBaiIANgJQAkACQCAAIAMoAkxODQAgAygCWCADKAJURw0ADAELAkAgAygCUCADKAJISARAA0AgAyADKAJsQfwUaiADKAJYQQJ0ai8BAjYCRAJAIAMoAmwoArwtQRAgAygCRGtKBEAgAyADKAJsQfwUaiADKAJYQQJ0ai8BADYCQCADKAJsIgAgAC8BuC0gAygCQEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAJAQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCREEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJsQfwUaiADKAJYQQJ0ai8BACADKAJsKAK8LXRyOwG4LSADKAJsIgAgAygCRCAAKAK8LWo2ArwtCyADIAMoAlBBf2oiADYCUCAADQALDAELAkAgAygCWARAIAMoAlggAygCXEcEQCADIAMoAmxB/BRqIAMoAlhBAnRqLwECNgI8AkAgAygCbCgCvC1BECADKAI8a0oEQCADIAMoAmxB/BRqIAMoAlhBAnRqLwEANgI4IAMoAmwiACAALwG4LSADKAI4Qf//A3EgAygCbCgCvC10cjsBuC0gAygCbC8BuC1B/wFxIQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbC8BuC1BCHUhASADKAJsKAIIIQIgAygCbCIEKAIUIQAgBCAAQQFqNgIUIAAgAmogAToAACADKAJsIAMoAjhB//8DcUEQIAMoAmwoArwta3U7AbgtIAMoAmwiACAAKAK8LSADKAI8QRBrajYCvC0MAQsgAygCbCIAIAAvAbgtIAMoAmxB/BRqIAMoAlhBAnRqLwEAIAMoAmwoArwtdHI7AbgtIAMoAmwiACADKAI8IAAoArwtajYCvC0LIAMgAygCUEF/ajYCUAsgAyADKAJsLwG+FTYCNAJAIAMoAmwoArwtQRAgAygCNGtKBEAgAyADKAJsLwG8FTYCMCADKAJsIgAgAC8BuC0gAygCMEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIwQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCNEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJsLwG8FSADKAJsKAK8LXRyOwG4LSADKAJsIgAgAygCNCAAKAK8LWo2ArwtCyADQQI2AiwCQCADKAJsKAK8LUEQIAMoAixrSgRAIAMgAygCUEEDazYCKCADKAJsIgAgAC8BuC0gAygCKEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIoQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCLEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJQQQNrQf//A3EgAygCbCgCvC10cjsBuC0gAygCbCIAIAMoAiwgACgCvC1qNgK8LQsMAQsCQCADKAJQQQpMBEAgAyADKAJsLwHCFTYCJAJAIAMoAmwoArwtQRAgAygCJGtKBEAgAyADKAJsLwHAFTYCICADKAJsIgAgAC8BuC0gAygCIEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIgQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCJEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJsLwHAFSADKAJsKAK8LXRyOwG4LSADKAJsIgAgAygCJCAAKAK8LWo2ArwtCyADQQM2AhwCQCADKAJsKAK8LUEQIAMoAhxrSgRAIAMgAygCUEEDazYCGCADKAJsIgAgAC8BuC0gAygCGEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIYQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCHEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJQQQNrQf//A3EgAygCbCgCvC10cjsBuC0gAygCbCIAIAMoAhwgACgCvC1qNgK8LQsMAQsgAyADKAJsLwHGFTYCFAJAIAMoAmwoArwtQRAgAygCFGtKBEAgAyADKAJsLwHEFTYCECADKAJsIgAgAC8BuC0gAygCEEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIQQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCFEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJsLwHEFSADKAJsKAK8LXRyOwG4LSADKAJsIgAgAygCFCAAKAK8LWo2ArwtCyADQQc2AgwCQCADKAJsKAK8LUEQIAMoAgxrSgRAIAMgAygCUEELazYCCCADKAJsIgAgAC8BuC0gAygCCEH//wNxIAMoAmwoArwtdHI7AbgtIAMoAmwvAbgtQf8BcSEBIAMoAmwoAgghAiADKAJsIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAmwvAbgtQQh1IQEgAygCbCgCCCECIAMoAmwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCbCADKAIIQf//A3FBECADKAJsKAK8LWt1OwG4LSADKAJsIgAgACgCvC0gAygCDEEQa2o2ArwtDAELIAMoAmwiACAALwG4LSADKAJQQQtrQf//A3EgAygCbCgCvC10cjsBuC0gAygCbCIAIAMoAgwgACgCvC1qNgK8LQsLCwsgA0EANgJQIAMgAygCWDYCXAJAIAMoAlRFBEAgA0GKATYCTCADQQM2AkgMAQsCQCADKAJYIAMoAlRGBEAgA0EGNgJMIANBAzYCSAwBCyADQQc2AkwgA0EENgJICwsLIAMgAygCYEEBajYCYAwBCwsLkQQBAX8jAEEwayIDIAA2AiwgAyABNgIoIAMgAjYCJCADQX82AhwgAyADKAIoLwECNgIUIANBADYCECADQQc2AgwgA0EENgIIIAMoAhRFBEAgA0GKATYCDCADQQM2AggLIAMoAiggAygCJEEBakECdGpB//8DOwECIANBADYCIANAIAMoAiAgAygCJEpFBEAgAyADKAIUNgIYIAMgAygCKCADKAIgQQFqQQJ0ai8BAjYCFCADIAMoAhBBAWoiADYCEAJAAkAgACADKAIMTg0AIAMoAhggAygCFEcNAAwBCwJAIAMoAhAgAygCCEgEQCADKAIsQfwUaiADKAIYQQJ0aiIAIAMoAhAgAC8BAGo7AQAMAQsCQCADKAIYBEAgAygCGCADKAIcRwRAIAMoAiwgAygCGEECdGpB/BRqIgAgAC8BAEEBajsBAAsgAygCLCIAIABBvBVqLwEAQQFqOwG8FQwBCwJAIAMoAhBBCkwEQCADKAIsIgAgAEHAFWovAQBBAWo7AcAVDAELIAMoAiwiACAAQcQVai8BAEEBajsBxBULCwsgA0EANgIQIAMgAygCGDYCHAJAIAMoAhRFBEAgA0GKATYCDCADQQM2AggMAQsCQCADKAIYIAMoAhRGBEAgA0EGNgIMIANBAzYCCAwBCyADQQc2AgwgA0EENgIICwsLIAMgAygCIEEBajYCIAwBCwsLpxIBAn8jAEHQAGsiAyAANgJMIAMgATYCSCADIAI2AkQgA0EANgI4IAMoAkwoAqAtBEADQCADIAMoAkwoAqQtIAMoAjhBAXRqLwEANgJAIAMoAkwoApgtIQAgAyADKAI4IgFBAWo2AjggAyAAIAFqLQAANgI8AkAgAygCQEUEQCADIAMoAkggAygCPEECdGovAQI2AiwCQCADKAJMKAK8LUEQIAMoAixrSgRAIAMgAygCSCADKAI8QQJ0ai8BADYCKCADKAJMIgAgAC8BuC0gAygCKEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwvAbgtQf8BcSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwvAbgtQQh1IQEgAygCTCgCCCECIAMoAkwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCTCADKAIoQf//A3FBECADKAJMKAK8LWt1OwG4LSADKAJMIgAgACgCvC0gAygCLEEQa2o2ArwtDAELIAMoAkwiACAALwG4LSADKAJIIAMoAjxBAnRqLwEAIAMoAkwoArwtdHI7AbgtIAMoAkwiACADKAIsIAAoArwtajYCvC0LDAELIAMgAygCPC0AgFk2AjQgAyADKAJIIAMoAjRBgQJqQQJ0ai8BAjYCJAJAIAMoAkwoArwtQRAgAygCJGtKBEAgAyADKAJIIAMoAjRBgQJqQQJ0ai8BADYCICADKAJMIgAgAC8BuC0gAygCIEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwvAbgtQf8BcSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwvAbgtQQh1IQEgAygCTCgCCCECIAMoAkwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCTCADKAIgQf//A3FBECADKAJMKAK8LWt1OwG4LSADKAJMIgAgACgCvC0gAygCJEEQa2o2ArwtDAELIAMoAkwiACAALwG4LSADKAJIIAMoAjRBgQJqQQJ0ai8BACADKAJMKAK8LXRyOwG4LSADKAJMIgAgAygCJCAAKAK8LWo2ArwtCyADIAMoAjRBAnRBwOUAaigCADYCMCADKAIwBEAgAyADKAI8IAMoAjRBAnRBsOgAaigCAGs2AjwgAyADKAIwNgIcAkAgAygCTCgCvC1BECADKAIca0oEQCADIAMoAjw2AhggAygCTCIAIAAvAbgtIAMoAhhB//8DcSADKAJMKAK8LXRyOwG4LSADKAJMLwG4LUH/AXEhASADKAJMKAIIIQIgAygCTCIEKAIUIQAgBCAAQQFqNgIUIAAgAmogAToAACADKAJMLwG4LUEIdSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwgAygCGEH//wNxQRAgAygCTCgCvC1rdTsBuC0gAygCTCIAIAAoArwtIAMoAhxBEGtqNgK8LQwBCyADKAJMIgAgAC8BuC0gAygCPEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwiACADKAIcIAAoArwtajYCvC0LCyADIAMoAkBBf2o2AkAgAwJ/IAMoAkBBgAJJBEAgAygCQC0AgFUMAQsgAygCQEEHdkGAAmotAIBVCzYCNCADIAMoAkQgAygCNEECdGovAQI2AhQCQCADKAJMKAK8LUEQIAMoAhRrSgRAIAMgAygCRCADKAI0QQJ0ai8BADYCECADKAJMIgAgAC8BuC0gAygCEEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwvAbgtQf8BcSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwvAbgtQQh1IQEgAygCTCgCCCECIAMoAkwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCTCADKAIQQf//A3FBECADKAJMKAK8LWt1OwG4LSADKAJMIgAgACgCvC0gAygCFEEQa2o2ArwtDAELIAMoAkwiACAALwG4LSADKAJEIAMoAjRBAnRqLwEAIAMoAkwoArwtdHI7AbgtIAMoAkwiACADKAIUIAAoArwtajYCvC0LIAMgAygCNEECdEHA5gBqKAIANgIwIAMoAjAEQCADIAMoAkAgAygCNEECdEGw6QBqKAIAazYCQCADIAMoAjA2AgwCQCADKAJMKAK8LUEQIAMoAgxrSgRAIAMgAygCQDYCCCADKAJMIgAgAC8BuC0gAygCCEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwvAbgtQf8BcSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwvAbgtQQh1IQEgAygCTCgCCCECIAMoAkwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCTCADKAIIQf//A3FBECADKAJMKAK8LWt1OwG4LSADKAJMIgAgACgCvC0gAygCDEEQa2o2ArwtDAELIAMoAkwiACAALwG4LSADKAJAQf//A3EgAygCTCgCvC10cjsBuC0gAygCTCIAIAMoAgwgACgCvC1qNgK8LQsLCyADKAI4IAMoAkwoAqAtSQ0ACwsgAyADKAJILwGCCDYCBAJAIAMoAkwoArwtQRAgAygCBGtKBEAgAyADKAJILwGACDYCACADKAJMIgAgAC8BuC0gAygCAEH//wNxIAMoAkwoArwtdHI7AbgtIAMoAkwvAbgtQf8BcSEBIAMoAkwoAgghAiADKAJMIgQoAhQhACAEIABBAWo2AhQgACACaiABOgAAIAMoAkwvAbgtQQh1IQEgAygCTCgCCCECIAMoAkwiBCgCFCEAIAQgAEEBajYCFCAAIAJqIAE6AAAgAygCTCADKAIAQf//A3FBECADKAJMKAK8LWt1OwG4LSADKAJMIgAgACgCvC0gAygCBEEQa2o2ArwtDAELIAMoAkwiACAALwG4LSADKAJILwGACCADKAJMKAK8LXRyOwG4LSADKAJMIgAgAygCBCAAKAK8LWo2ArwtCwuqDAEGfyAAIAFqIQUCQAJAIAAoAgQiAkEBcQ0AIAJBA3FFDQEgACgCACIDIAFqIQEgACADayIAQcycASgCAEcEQEHInAEoAgAhBCADQf8BTQRAIAAoAggiBCADQQN2IgNBA3RB4JwBakcaIAQgACgCDCICRgRAQbicAUG4nAEoAgBBfiADd3E2AgAMAwsgBCACNgIMIAIgBDYCCAwCCyAAKAIYIQYCQCAAIAAoAgwiAkcEQCAEIAAoAggiA00EQCADKAIMGgsgAyACNgIMIAIgAzYCCAwBCwJAIABBFGoiAygCACIEDQAgAEEQaiIDKAIAIgQNAEEAIQIMAQsDQCADIQcgBCICQRRqIgMoAgAiBA0AIAJBEGohAyACKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgACAAKAIcIgNBAnRB6J4BaiIEKAIARgRAIAQgAjYCACACDQFBvJwBQbycASgCAEF+IAN3cTYCAAwDCyAGQRBBFCAGKAIQIABGG2ogAjYCACACRQ0CCyACIAY2AhggACgCECIDBEAgAiADNgIQIAMgAjYCGAsgACgCFCIDRQ0BIAIgAzYCFCADIAI2AhgMAQsgBSgCBCICQQNxQQNHDQBBwJwBIAE2AgAgBSACQX5xNgIEIAAgAUEBcjYCBCAFIAE2AgAPCwJAIAUoAgQiAkECcUUEQCAFQdCcASgCAEYEQEHQnAEgADYCAEHEnAFBxJwBKAIAIAFqIgE2AgAgACABQQFyNgIEIABBzJwBKAIARw0DQcCcAUEANgIAQcycAUEANgIADwsgBUHMnAEoAgBGBEBBzJwBIAA2AgBBwJwBQcCcASgCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPC0HInAEoAgAhAyACQXhxIAFqIQECQCACQf8BTQRAIAUoAggiBCACQQN2IgJBA3RB4JwBakcaIAQgBSgCDCIDRgRAQbicAUG4nAEoAgBBfiACd3E2AgAMAgsgBCADNgIMIAMgBDYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAkcEQCADIAUoAggiA00EQCADKAIMGgsgAyACNgIMIAIgAzYCCAwBCwJAIAVBFGoiAygCACIEDQAgBUEQaiIDKAIAIgQNAEEAIQIMAQsDQCADIQcgBCICQRRqIgMoAgAiBA0AIAJBEGohAyACKAIQIgQNAAsgB0EANgIACyAGRQ0AAkAgBSAFKAIcIgNBAnRB6J4BaiIEKAIARgRAIAQgAjYCACACDQFBvJwBQbycASgCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogAjYCACACRQ0BCyACIAY2AhggBSgCECIDBEAgAiADNgIQIAMgAjYCGAsgBSgCFCIDRQ0AIAIgAzYCFCADIAI2AhgLIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEHMnAEoAgBHDQFBwJwBIAE2AgAPCyAFIAJBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUH/AU0EQCABQQN2IgJBA3RB4JwBaiEBAn9BuJwBKAIAIgNBASACdCICcUUEQEG4nAEgAiADcjYCACABDAELIAEoAggLIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIDwsgAEIANwIQIAACf0EAIAFBCHYiAkUNABpBHyABQf///wdLDQAaIAIgAkGA/j9qQRB2QQhxIgJ0IgMgA0GA4B9qQRB2QQRxIgN0IgQgBEGAgA9qQRB2QQJxIgR0QQ92IAIgA3IgBHJrIgJBAXQgASACQRVqdkEBcXJBHGoLIgM2AhwgA0ECdEHongFqIQICQAJAQbycASgCACIEQQEgA3QiB3FFBEBBvJwBIAQgB3I2AgAgAiAANgIAIAAgAjYCGAwBCyABQQBBGSADQQF2ayADQR9GG3QhAyACKAIAIQIDQCACIgQoAgRBeHEgAUYNAiADQR12IQIgA0EBdCEDIAQgAkEEcWoiB0EQaigCACICDQALIAcgADYCECAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC5cCAQR/IwBBEGsiASAANgIMAkAgASgCDCgCvC1BEEYEQCABKAIMLwG4LUH/AXEhAiABKAIMKAIIIQMgASgCDCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAjoAACABKAIMLwG4LUEIdSECIAEoAgwoAgghAyABKAIMIgQoAhQhACAEIABBAWo2AhQgACADaiACOgAAIAEoAgxBADsBuC0gASgCDEEANgK8LQwBCyABKAIMKAK8LUEITgRAIAEoAgwvAbgtIQIgASgCDCgCCCEDIAEoAgwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAI6AAAgASgCDCIAIAAvAbgtQQh1OwG4LSABKAIMIgAgACgCvC1BCGs2ArwtCwsL7wEBBH8jAEEQayIBIAA2AgwCQCABKAIMKAK8LUEISgRAIAEoAgwvAbgtQf8BcSECIAEoAgwoAgghAyABKAIMIgQoAhQhACAEIABBAWo2AhQgACADaiACOgAAIAEoAgwvAbgtQQh1IQIgASgCDCgCCCEDIAEoAgwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAI6AAAMAQsgASgCDCgCvC1BAEoEQCABKAIMLwG4LSECIAEoAgwoAgghAyABKAIMIgQoAhQhACAEIABBAWo2AhQgACADaiACOgAACwsgASgCDEEAOwG4LSABKAIMQQA2ArwtC/wBAQF/IwBBEGsiASAANgIMIAFBADYCCANAIAEoAghBngJORQRAIAEoAgxBlAFqIAEoAghBAnRqQQA7AQAgASABKAIIQQFqNgIIDAELCyABQQA2AggDQCABKAIIQR5ORQRAIAEoAgxBiBNqIAEoAghBAnRqQQA7AQAgASABKAIIQQFqNgIIDAELCyABQQA2AggDQCABKAIIQRNORQRAIAEoAgxB/BRqIAEoAghBAnRqQQA7AQAgASABKAIIQQFqNgIIDAELCyABKAIMQQE7AZQJIAEoAgxBADYCrC0gASgCDEEANgKoLSABKAIMQQA2ArAtIAEoAgxBADYCoC0LIgEBfyMAQRBrIgEkACABIAA2AgwgASgCDBAWIAFBEGokAAvpAQEBfyMAQTBrIgIgADYCJCACIAE3AxggAkIANwMQIAIgAigCJCkDCEIBfTcDCAJAA0AgAikDECACKQMIVARAIAIgAikDECACKQMIIAIpAxB9QgGIfDcDAAJAIAIoAiQoAgQgAikDAKdBA3RqKQMAIAIpAxhWBEAgAiACKQMAQgF9NwMIDAELAkAgAikDACACKAIkKQMIUgRAIAIoAiQoAgQgAikDAEIBfKdBA3RqKQMAIAIpAxhYDQELIAIgAikDADcDKAwECyACIAIpAwBCAXw3AxALDAELCyACIAIpAxA3AygLIAIpAygLpwEBAX8jAEEwayIEJAAgBCAANgIoIAQgATYCJCAEIAI3AxggBCADNgIUIAQgBCgCKCkDOCAEKAIoKQMwIAQoAiQgBCkDGCAEKAIUEI0BNwMIAkAgBCkDCEIAUwRAIARBfzYCLAwBCyAEKAIoIAQpAwg3AzggBCgCKCAEKAIoKQM4ELsBIQIgBCgCKCACNwNAIARBADYCLAsgBCgCLCEAIARBMGokACAAC+sBAQF/IwBBIGsiAyQAIAMgADYCGCADIAE3AxAgAyACNgIMAkAgAykDECADKAIYKQMQVARAIANBAToAHwwBCyADIAMoAhgoAgAgAykDEEIEhqcQTSIANgIIIABFBEAgAygCDEEOQQAQFSADQQA6AB8MAQsgAygCGCADKAIINgIAIAMgAygCGCgCBCADKQMQQgF8QgOGpxBNIgA2AgQgAEUEQCADKAIMQQ5BABAVIANBADoAHwwBCyADKAIYIAMoAgQ2AgQgAygCGCADKQMQNwMQIANBAToAHwsgAy0AH0EBcSEAIANBIGokACAAC9ACAQF/IwBBMGsiBCQAIAQgADYCKCAEIAE3AyAgBCACNgIcIAQgAzYCGAJAAkAgBCgCKA0AIAQpAyBCAFgNACAEKAIYQRJBABAVIARBADYCLAwBCyAEIAQoAiggBCkDICAEKAIcIAQoAhgQTiIANgIMIABFBEAgBEEANgIsDAELIARBGBAZIgA2AhQgAEUEQCAEKAIYQQ5BABAVIAQoAgwQNCAEQQA2AiwMAQsgBCgCFCAEKAIMNgIQIAQoAhRBADYCFEEAEAEhACAEKAIUIAA2AgwjAEEQayIAIAQoAhQ2AgwgACgCDEEANgIAIAAoAgxBADYCBCAAKAIMQQA2AgggBEECIAQoAhQgBCgCGBCQASIANgIQIABFBEAgBCgCFCgCEBA0IAQoAhQQFiAEQQA2AiwMAQsgBCAEKAIQNgIsCyAEKAIsIQAgBEEwaiQAIAALqQEBAX8jAEEwayIEJAAgBCAANgIoIAQgATcDICAEIAI2AhwgBCADNgIYAkAgBCgCKEUEQCAEKQMgQgBWBEAgBCgCGEESQQAQFSAEQQA2AiwMAgsgBEEAQgAgBCgCHCAEKAIYEL4BNgIsDAELIAQgBCgCKDYCCCAEIAQpAyA3AxAgBCAEQQhqQgEgBCgCHCAEKAIYEL4BNgIsCyAEKAIsIQAgBEEwaiQAIAALRgEBfyMAQSBrIgMkACADIAA2AhwgAyABNwMQIAMgAjYCDCADKAIcIAMpAxAgAygCDCADKAIcQQhqEE8hACADQSBqJAAgAAuNAgEBfyMAQTBrIgMkACADIAA2AiggAyABOwEmIAMgAjYCICADIAMoAigoAjQgA0EeaiADLwEmQYAGQQAQXzYCEAJAIAMoAhBFDQAgAy8BHkEFSA0AAkAgAygCEC0AAEEBRg0ADAELIAMgAygCECADLwEerRAqIgA2AhQgAEUEQAwBCyADKAIUEIsBGiADIAMoAhQQKzYCGCADKAIgEIgBIAMoAhhGBEAgAyADKAIUEDA9AQ4gAyADKAIUIAMvAQ6tEB8gAy8BDkGAEEEAEFE2AgggAygCCARAIAMoAiAQJiADIAMoAgg2AiALCyADKAIUEBcLIAMgAygCIDYCLCADKAIsIQAgA0EwaiQAIAALuRECAX8BfiMAQYABayIFJAAgBSAANgJ0IAUgATYCcCAFIAI2AmwgBSADOgBrIAUgBDYCZCAFIAUoAmxBAEc6AB0gBUEeQS4gBS0Aa0EBcRs2AigCQAJAIAUoAmwEQCAFKAJsEDAgBSgCKK1UBEAgBSgCZEETQQAQFSAFQn83A3gMAwsMAQsgBSAFKAJwIAUoAiitIAVBMGogBSgCZBBBIgA2AmwgAEUEQCAFQn83A3gMAgsLIAUoAmxCBBAfIQBBxdMAQcrTACAFLQBrQQFxGygAACAAKAAARwRAIAUoAmRBE0EAEBUgBS0AHUEBcUUEQCAFKAJsEBcLIAVCfzcDeAwBCyAFKAJ0EF0CQCAFLQBrQQFxRQRAIAUoAmwQHiEAIAUoAnQgADsBCAwBCyAFKAJ0QQA7AQgLIAUoAmwQHiEAIAUoAnQgADsBCiAFKAJsEB4hACAFKAJ0IAA7AQwgBSgCbBAeQf//A3EhACAFKAJ0IAA2AhAgBSAFKAJsEB47AS4gBSAFKAJsEB47ASwgBS8BLiAFLwEsEI0DIQAgBSgCdCAANgIUIAUoAmwQKyEAIAUoAnQgADYCGCAFKAJsECutIQYgBSgCdCAGNwMgIAUoAmwQK60hBiAFKAJ0IAY3AyggBSAFKAJsEB47ASIgBSAFKAJsEB47AR4CQCAFLQBrQQFxBEAgBUEAOwEgIAUoAnRBADYCPCAFKAJ0QQA7AUAgBSgCdEEANgJEIAUoAnRCADcDSAwBCyAFIAUoAmwQHjsBICAFKAJsEB5B//8DcSEAIAUoAnQgADYCPCAFKAJsEB4hACAFKAJ0IAA7AUAgBSgCbBArIQAgBSgCdCAANgJEIAUoAmwQK60hBiAFKAJ0IAY3A0gLAn8jAEEQayIAIAUoAmw2AgwgACgCDC0AAEEBcUULBEAgBSgCZEEUQQAQFSAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAELAkAgBSgCdC8BDEEBcQRAIAUoAnQvAQxBwABxBEAgBSgCdEH//wM7AVIMAgsgBSgCdEEBOwFSDAELIAUoAnRBADsBUgsgBSgCdEEANgIwIAUoAnRBADYCNCAFKAJ0QQA2AjggBSAFLwEgIAUvASIgBS8BHmpqNgIkAkAgBS0AHUEBcQRAIAUoAmwQMCAFKAIkrVQEQCAFKAJkQRVBABAVIAVCfzcDeAwDCwwBCyAFKAJsEBcgBSAFKAJwIAUoAiStQQAgBSgCZBBBIgA2AmwgAEUEQCAFQn83A3gMAgsLIAUvASIEQCAFKAJsIAUoAnAgBS8BIkEBIAUoAmQQiQEhACAFKAJ0IAA2AjAgBSgCdCgCMEUEQAJ/IwBBEGsiACAFKAJkNgIMIAAoAgwoAgBBEUYLBEAgBSgCZEEVQQAQFQsgBS0AHUEBcUUEQCAFKAJsEBcLIAVCfzcDeAwCCyAFKAJ0LwEMQYAQcQRAIAUoAnQoAjBBAhA7QQVGBEAgBSgCZEEVQQAQFSAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAMLCwsgBS8BHgRAIAUgBSgCbCAFKAJwIAUvAR5BACAFKAJkEGA2AhggBSgCGEUEQCAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAILIAUoAhggBS8BHkGAAkGABCAFLQBrQQFxGyAFKAJ0QTRqIAUoAmQQhAFBAXFFBEAgBSgCGBAWIAUtAB1BAXFFBEAgBSgCbBAXCyAFQn83A3gMAgsgBSgCGBAWIAUtAGtBAXEEQCAFKAJ0QQE6AAQLCyAFLwEgBEAgBSgCbCAFKAJwIAUvASBBACAFKAJkEIkBIQAgBSgCdCAANgI4IAUoAnQoAjhFBEAgBS0AHUEBcUUEQCAFKAJsEBcLIAVCfzcDeAwCCyAFKAJ0LwEMQYAQcQRAIAUoAnQoAjhBAhA7QQVGBEAgBSgCZEEVQQAQFSAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAMLCwsgBSgCdEH14AEgBSgCdCgCMBDBASEAIAUoAnQgADYCMCAFKAJ0QfXGASAFKAJ0KAI4EMEBIQAgBSgCdCAANgI4AkACQCAFKAJ0KQMoQv////8PUQ0AIAUoAnQpAyBC/////w9RDQAgBSgCdCkDSEL/////D1INAQsgBSAFKAJ0KAI0IAVBFmpBAUGAAkGABCAFLQBrQQFxGyAFKAJkEF82AgwgBSgCDEUEQCAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAILIAUgBSgCDCAFLwEWrRAqIgA2AhAgAEUEQCAFKAJkQQ5BABAVIAUtAB1BAXFFBEAgBSgCbBAXCyAFQn83A3gMAgsCQCAFKAJ0KQMoQv////8PUQRAIAUoAhAQMSEGIAUoAnQgBjcDKAwBCyAFLQBrQQFxBEAgBSgCEBDMAQsLIAUoAnQpAyBC/////w9RBEAgBSgCEBAxIQYgBSgCdCAGNwMgCyAFLQBrQQFxRQRAIAUoAnQpA0hC/////w9RBEAgBSgCEBAxIQYgBSgCdCAGNwNICyAFKAJ0KAI8Qf//A0YEQCAFKAIQECshACAFKAJ0IAA2AjwLCyAFKAIQEEhBAXFFBEAgBSgCZEEVQQAQFSAFKAIQEBcgBS0AHUEBcUUEQCAFKAJsEBcLIAVCfzcDeAwCCyAFKAIQEBcLAn8jAEEQayIAIAUoAmw2AgwgACgCDC0AAEEBcUULBEAgBSgCZEEUQQAQFSAFLQAdQQFxRQRAIAUoAmwQFwsgBUJ/NwN4DAELIAUtAB1BAXFFBEAgBSgCbBAXCyAFKAJ0KQNIQv///////////wBWBEAgBSgCZEEEQRYQFSAFQn83A3gMAQsgBSgCdCAFKAJkEIwDQQFxRQRAIAVCfzcDeAwBCyAFKAJ0KAI0EIMBIQAgBSgCdCAANgI0IAUgBSgCKCAFKAIkaq03A3gLIAUpA3ghBiAFQYABaiQAIAYLzQEBAX8jAEEQayIDJAAgAyAANgIMIAMgATYCCCADIAI2AgQgAyADQQxqQaygARAKNgIAAkAgAygCAEUEQCADKAIEQSE7AQAgAygCCEEAOwEADAELIAMoAgAoAhRB0ABIBEAgAygCAEHQADYCFAsgAygCBCADKAIAKAIMIAMoAgAoAhRBCXQgAygCACgCEEEFdGpBoMB9amo7AQAgAygCCCADKAIAKAIIQQt0IAMoAgAoAgRBBXRqIAMoAgAoAgBBAXVqOwEACyADQRBqJAALgwMBAX8jAEEgayIDJAAgAyAAOwEaIAMgATYCFCADIAI2AhAgAyADKAIUIANBCGpBwABBABBHIgA2AgwCQCAARQRAIANBADYCHAwBCyADKAIIQQVqQf//A0sEQCADKAIQQRJBABAVIANBADYCHAwBCyADQQAgAygCCEEFaq0QKiIANgIEIABFBEAgAygCEEEOQQAQFSADQQA2AhwMAQsgAygCBEEBEIoBIAMoAgQgAygCFBCIARAhIAMoAgQgAygCDCADKAIIEEACfyMAQRBrIgAgAygCBDYCDCAAKAIMLQAAQQFxRQsEQCADKAIQQRRBABAVIAMoAgQQFyADQQA2AhwMAQsgAyADLwEaAn8jAEEQayIAIAMoAgQ2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IAC6dB//8DcQsCfyMAQRBrIgAgAygCBDYCDCAAKAIMKAIEC0GABhBQNgIAIAMoAgQQFyADIAMoAgA2AhwLIAMoAhwhACADQSBqJAAgAAu0AgEBfyMAQTBrIgMkACADIAA2AiggAyABNwMgIAMgAjYCHAJAIAMpAyBQBEAgA0EBOgAvDAELIAMgAygCKCkDECADKQMgfDcDCAJAIAMpAwggAykDIFoEQCADKQMIQv////8AWA0BCyADKAIcQQ5BABAVIANBADoALwwBCyADIAMoAigoAgAgAykDCKdBBHQQTSIANgIEIABFBEAgAygCHEEOQQAQFSADQQA6AC8MAQsgAygCKCADKAIENgIAIAMgAygCKCkDCDcDEANAIAMpAxAgAykDCFpFBEAgAygCKCgCACADKQMQp0EEdGoQjAEgAyADKQMQQgF8NwMQDAELCyADKAIoIAMpAwgiATcDECADKAIoIAE3AwggA0EBOgAvCyADLQAvQQFxIQAgA0EwaiQAIAALzAEBAX8jAEEgayICJAAgAiAANwMQIAIgATYCDCACQTAQGSIBNgIIAkAgAUUEQCACKAIMQQ5BABAVIAJBADYCHAwBCyACKAIIQQA2AgAgAigCCEIANwMQIAIoAghCADcDCCACKAIIQgA3AyAgAigCCEIANwMYIAIoAghBADYCKCACKAIIQQA6ACwgAigCCCACKQMQIAIoAgwQxQFBAXFFBEAgAigCCBAlIAJBADYCHAwBCyACIAIoAgg2AhwLIAIoAhwhASACQSBqJAAgAQu2BQEBfyMAQTBrIgIkACACIAA2AiggAiABNwMgAkAgAikDICACKAIoKQMwWgRAIAIoAihBCGpBEkEAEBUgAkF/NgIsDAELIAIgAigCKCgCQCACKQMgp0EEdGo2AhwCQCACKAIcKAIABEAgAigCHCgCAC0ABEEBcUUNAQsgAkEANgIsDAELIAIoAhwoAgApA0hCGnxC////////////AFYEQCACKAIoQQhqQQRBFhAVIAJBfzYCLAwBCyACKAIoKAIAIAIoAhwoAgApA0hCGnxBABAoQQBIBEAgAigCKEEIaiACKAIoKAIAEBggAkF/NgIsDAELIAIgAigCKCgCAEIEIAJBGGogAigCKEEIahBBIgA2AhQgAEUEQCACQX82AiwMAQsgAiACKAIUEB47ARIgAiACKAIUEB47ARAgAigCFBBIQQFxRQRAIAIoAhQQFyACKAIoQQhqQRRBABAVIAJBfzYCLAwBCyACKAIUEBcgAi8BEEEASgRAIAIoAigoAgAgAi8BEq1BARAoQQBIBEAgAigCKEEIakEEQbScASgCABAVIAJBfzYCLAwCCyACQQAgAigCKCgCACACLwEQQQAgAigCKEEIahBgNgIIIAIoAghFBEAgAkF/NgIsDAILIAIoAgggAi8BEEGAAiACQQxqIAIoAihBCGoQhAFBAXFFBEAgAigCCBAWIAJBfzYCLAwCCyACKAIIEBYgAigCDARAIAIgAigCDBCDATYCDCACKAIcKAIAKAI0IAIoAgwQhQEhACACKAIcKAIAIAA2AjQLCyACKAIcKAIAQQE6AAQCQCACKAIcKAIERQ0AIAIoAhwoAgQtAARBAXENACACKAIcKAIEIAIoAhwoAgAoAjQ2AjQgAigCHCgCBEEBOgAECyACQQA2AiwLIAIoAiwhACACQTBqJAAgAAsHACAAKAIAC4wBAQF/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQgAkEANgIQAkAgAigCFEUEQCACQQA2AhwMAQsgAiACKAIUEBk2AgwgAigCDEUEQCACKAIQQQ5BABAVIAJBADYCHAwBCyACKAIMIAIoAhggAigCFBAaGiACIAIoAgw2AhwLIAIoAhwhACACQSBqJAAgAAsYAEGonAFCADcCAEGwnAFBADYCAEGonAELiAEBAX8jAEEgayIDJAAgAyAANgIUIAMgATYCECADIAI3AwgCQAJAIAMoAhQoAiRBAUYEQCADKQMIQv///////////wBYDQELIAMoAhRBDGpBEkEAEBUgA0J/NwMYDAELIAMgAygCFCADKAIQIAMpAwhBCxAiNwMYCyADKQMYIQIgA0EgaiQAIAILcwEBfyMAQSBrIgEkACABIAA2AhggAUIINwMQIAEgASgCGCkDECABKQMQfDcDCAJAIAEpAwggASgCGCkDEFQEQCABKAIYQQA6AAAgAUF/NgIcDAELIAEgASgCGCABKQMIEC02AhwLIAEoAhwaIAFBIGokAAsIAEEBQQwQewuWAQEBfyMAQSBrIgIgADYCGCACIAE3AxACQAJAAkAgAigCGC0AAEEBcUUNACACKAIYKQMQIAIpAxB8IAIpAxBUDQAgAigCGCkDECACKQMQfCACKAIYKQMIWA0BCyACKAIYQQA6AAAgAkEANgIcDAELIAIgAigCGCgCBCACKAIYKQMQp2o2AgwgAiACKAIMNgIcCyACKAIcCwcAIAAoAigLuQIBAX8jAEEQayICIAA2AgggAiABNgIEAkAgAigCCEGAAUkEQCACKAIEIAIoAgg6AAAgAkEBNgIMDAELIAIoAghBgBBJBEAgAigCBCACKAIIQQZ2QR9xQcABcjoAACACKAIEIAIoAghBP3FBgAFyOgABIAJBAjYCDAwBCyACKAIIQYCABEkEQCACKAIEIAIoAghBDHZBD3FB4AFyOgAAIAIoAgQgAigCCEEGdkE/cUGAAXI6AAEgAigCBCACKAIIQT9xQYABcjoAAiACQQM2AgwMAQsgAigCBCACKAIIQRJ2QQdxQfABcjoAACACKAIEIAIoAghBDHZBP3FBgAFyOgABIAIoAgQgAigCCEEGdkE/cUGAAXI6AAIgAigCBCACKAIIQT9xQYABcjoAAyACQQQ2AgwLIAIoAgwLXwEBfyMAQRBrIgEgADYCCAJAIAEoAghBgAFJBEAgAUEBNgIMDAELIAEoAghBgBBJBEAgAUECNgIMDAELIAEoAghBgIAESQRAIAFBAzYCDAwBCyABQQQ2AgwLIAEoAgwL/gIBAX8jAEEwayIEJAAgBCAANgIoIAQgATYCJCAEIAI2AiAgBCADNgIcIAQgBCgCKDYCGAJAIAQoAiRFBEAgBCgCIARAIAQoAiBBADYCAAsgBEEANgIsDAELIARBATYCECAEQQA2AgwDQCAEKAIMIAQoAiRPRQRAIAQgBCgCGCAEKAIMai0AAEEBdEGwzwBqLwEAENEBIAQoAhBqNgIQIAQgBCgCDEEBajYCDAwBCwsgBCAEKAIQEBkiADYCFCAARQRAIAQoAhxBDkEAEBUgBEEANgIsDAELIARBADYCCCAEQQA2AgwDQCAEKAIMIAQoAiRPRQRAIAQgBCgCGCAEKAIMai0AAEEBdEGwzwBqLwEAIAQoAhQgBCgCCGoQ0AEgBCgCCGo2AgggBCAEKAIMQQFqNgIMDAELCyAEKAIUIAQoAhBBAWtqQQA6AAAgBCgCIARAIAQoAiAgBCgCEEEBazYCAAsgBCAEKAIUNgIsCyAEKAIsIQAgBEEwaiQAIAALBwAgACgCGAvyCwEBfyMAQSBrIgMgADYCHCADIAE2AhggAyACNgIUIAMgAygCHEEIdkGA/gNxIAMoAhxBGHZqIAMoAhxBgP4DcUEIdGogAygCHEH/AXFBGHRqNgIQIAMgAygCEEF/czYCEANAQQAhACADKAIUBH8gAygCGEEDcUEARwVBAAtBAXEEQCADKAIQQRh2IQAgAyADKAIYIgFBAWo2AhggAyABLQAAIABzQQJ0QbAvaigCACADKAIQQQh0czYCECADIAMoAhRBf2o2AhQMAQsLIAMgAygCGDYCDANAIAMoAhRBIElFBEAgAyADKAIMIgBBBGo2AgwgAyAAKAIAIAMoAhBzNgIQIAMgAygCEEEYdkECdEGwxwBqKAIAIAMoAhBBEHZB/wFxQQJ0QbA/aigCACADKAIQQf8BcUECdEGwL2ooAgAgAygCEEEIdkH/AXFBAnRBsDdqKAIAc3NzNgIQIAMgAygCDCIAQQRqNgIMIAMgACgCACADKAIQczYCECADIAMoAhBBGHZBAnRBsMcAaigCACADKAIQQRB2Qf8BcUECdEGwP2ooAgAgAygCEEH/AXFBAnRBsC9qKAIAIAMoAhBBCHZB/wFxQQJ0QbA3aigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbDHAGooAgAgAygCEEEQdkH/AXFBAnRBsD9qKAIAIAMoAhBB/wFxQQJ0QbAvaigCACADKAIQQQh2Qf8BcUECdEGwN2ooAgBzc3M2AhAgAyADKAIMIgBBBGo2AgwgAyAAKAIAIAMoAhBzNgIQIAMgAygCEEEYdkECdEGwxwBqKAIAIAMoAhBBEHZB/wFxQQJ0QbA/aigCACADKAIQQf8BcUECdEGwL2ooAgAgAygCEEEIdkH/AXFBAnRBsDdqKAIAc3NzNgIQIAMgAygCDCIAQQRqNgIMIAMgACgCACADKAIQczYCECADIAMoAhBBGHZBAnRBsMcAaigCACADKAIQQRB2Qf8BcUECdEGwP2ooAgAgAygCEEH/AXFBAnRBsC9qKAIAIAMoAhBBCHZB/wFxQQJ0QbA3aigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbDHAGooAgAgAygCEEEQdkH/AXFBAnRBsD9qKAIAIAMoAhBB/wFxQQJ0QbAvaigCACADKAIQQQh2Qf8BcUECdEGwN2ooAgBzc3M2AhAgAyADKAIMIgBBBGo2AgwgAyAAKAIAIAMoAhBzNgIQIAMgAygCEEEYdkECdEGwxwBqKAIAIAMoAhBBEHZB/wFxQQJ0QbA/aigCACADKAIQQf8BcUECdEGwL2ooAgAgAygCEEEIdkH/AXFBAnRBsDdqKAIAc3NzNgIQIAMgAygCDCIAQQRqNgIMIAMgACgCACADKAIQczYCECADIAMoAhBBGHZBAnRBsMcAaigCACADKAIQQRB2Qf8BcUECdEGwP2ooAgAgAygCEEH/AXFBAnRBsC9qKAIAIAMoAhBBCHZB/wFxQQJ0QbA3aigCAHNzczYCECADIAMoAhRBIGs2AhQMAQsLA0AgAygCFEEESUUEQCADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbDHAGooAgAgAygCEEEQdkH/AXFBAnRBsD9qKAIAIAMoAhBB/wFxQQJ0QbAvaigCACADKAIQQQh2Qf8BcUECdEGwN2ooAgBzc3M2AhAgAyADKAIUQQRrNgIUDAELCyADIAMoAgw2AhggAygCFARAA0AgAygCEEEYdiEAIAMgAygCGCIBQQFqNgIYIAMgAS0AACAAc0ECdEGwL2ooAgAgAygCEEEIdHM2AhAgAyADKAIUQX9qIgA2AhQgAA0ACwsgAyADKAIQQX9zNgIQIAMoAhBBCHZBgP4DcSADKAIQQRh2aiADKAIQQYD+A3FBCHRqIAMoAhBB/wFxQRh0aguTCwEBfyMAQSBrIgMgADYCHCADIAE2AhggAyACNgIUIAMgAygCHDYCECADIAMoAhBBf3M2AhADQEEAIQAgAygCFAR/IAMoAhhBA3FBAEcFQQALQQFxBEAgAygCECEAIAMgAygCGCIBQQFqNgIYIAMgAS0AACAAc0H/AXFBAnRBsA9qKAIAIAMoAhBBCHZzNgIQIAMgAygCFEF/ajYCFAwBCwsgAyADKAIYNgIMA0AgAygCFEEgSUUEQCADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAhRBIGs2AhQMAQsLA0AgAygCFEEESUUEQCADIAMoAgwiAEEEajYCDCADIAAoAgAgAygCEHM2AhAgAyADKAIQQRh2QQJ0QbAPaigCACADKAIQQRB2Qf8BcUECdEGwF2ooAgAgAygCEEH/AXFBAnRBsCdqKAIAIAMoAhBBCHZB/wFxQQJ0QbAfaigCAHNzczYCECADIAMoAhRBBGs2AhQMAQsLIAMgAygCDDYCGCADKAIUBEADQCADKAIQIQAgAyADKAIYIgFBAWo2AhggAyABLQAAIABzQf8BcUECdEGwD2ooAgAgAygCEEEIdnM2AhAgAyADKAIUQX9qIgA2AhQgAA0ACwsgAyADKAIQQX9zNgIQIAMoAhALhgEBAX8jAEEgayIDJAAgAyAANgIYIAMgATYCFCADIAI2AhACQCADKAIURQRAIANBADYCHAwBCyADQQE2AgwgAy0ADARAIAMgAygCGCADKAIUIAMoAhAQ1QE2AhwMAQsgAyADKAIYIAMoAhQgAygCEBDUATYCHAsgAygCHCEAIANBIGokACAACwcAIAAoAhALIgEBfyMAQRBrIgEgADYCDCABKAIMIgAgACgCMEEBajYCMAsUACAAIAGtIAKtQiCGhCADIAQQegsTAQF+IAAQSiIBQiCIpxAAIAGnCxIAIAAgAa0gAq1CIIaEIAMQKAsfAQF+IAAgASACrSADrUIghoQQLyIEQiCIpxAAIASnCxUAIAAgAa0gAq1CIIaEIAMgBBC/AQsUACAAIAEgAq0gA61CIIaEIAQQeQsVACAAIAGtIAKtQiCGhCADIAQQ8AELFwEBfiAAIAEgAhBuIgNCIIinEAAgA6cLFgEBfiAAIAEQkQIiAkIgiKcQACACpwsTACAAIAGtIAKtQiCGhCADEMABCyABAX4gACABIAKtIAOtQiCGhBCSAiIEQiCIpxAAIASnCxMAIAAgAa0gAq1CIIaEIAMQkwILFQAgACABrSACrUIghoQgAyAEEJYCCxcAIAAgAa0gAq1CIIaEIAMgBCAFEJ8BCxcAIAAgAa0gAq1CIIaEIAMgBCAFEJ4BCxoBAX4gACABIAIgAxCaAiIEQiCIpxAAIASnCxgBAX4gACABIAIQnAIiA0IgiKcQACADpwsRACAAIAGtIAKtQiCGhBChAQsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC8QBAQF/IwBBMGsiASQAIAEgADYCKCABQQA2AiQgAUIANwMYAkADQCABKQMYIAEoAigpAzBUBEAgASABKAIoIAEpAxhBACABQRdqIAFBEGoQngE2AgwgASgCDEF/RgRAIAFBfzYCLAwDBQJAIAEtABdBA0cNACABKAIQQRB2QYDgA3FBgMACRw0AIAEgASgCJEEBajYCJAsgASABKQMYQgF8NwMYDAILAAsLIAEgASgCJDYCLAsgASgCLCEAIAFBMGokACAAC4IBAgF/AX4jAEEgayIEJAAgBCAANgIYIAQgATYCFCAEIAI2AhAgBCADNgIMIAQgBCgCGCAEKAIUIAQoAhAQbiIFNwMAAkAgBUIAUwRAIARBfzYCHAwBCyAEIAQoAhggBCkDACAEKAIQIAQoAgwQejYCHAsgBCgCHCEAIARBIGokACAAC9IDAQF/IwBBIGsiBCQAIAQgADYCGCAEIAE3AxAgBCACNgIMIAQgAzYCCAJAAkAgBCkDECAEKAIYKQMwVARAIAQoAghBCU0NAQsgBCgCGEEIakESQQAQFSAEQX82AhwMAQsgBCgCGCgCGEECcQRAIAQoAhhBCGpBGUEAEBUgBEF/NgIcDAELIAQoAgwQwwJBAXFFBEAgBCgCGEEIakEQQQAQFSAEQX82AhwMAQsgBCAEKAIYKAJAIAQpAxCnQQR0ajYCBCAEAn9BfyAEKAIEKAIARQ0AGiAEKAIEKAIAKAIQCzYCAAJAIAQoAgwgBCgCAEYEQCAEKAIEKAIEBEAgBCgCBCgCBCIAIAAoAgBBfnE2AgAgBCgCBCgCBEEAOwFQIAQoAgQoAgQoAgBFBEAgBCgCBCgCBBA6IAQoAgRBADYCBAsLDAELIAQoAgQoAgRFBEAgBCgCBCgCABBGIQAgBCgCBCAANgIEIABFBEAgBCgCGEEIakEOQQAQFSAEQX82AhwMAwsLIAQoAgQoAgQgBCgCDDYCECAEKAIEKAIEIAQoAgg7AVAgBCgCBCgCBCIAIAAoAgBBAXI2AgALIARBADYCHAsgBCgCHCEAIARBIGokACAAC5ACAQF/IwBBEGsiAiQAIAIgADYCCCACIAE2AgQCQAJAAkAgAigCCC8BCiACKAIELwEKSA0AIAIoAggoAhAgAigCBCgCEEcNACACKAIIKAIUIAIoAgQoAhRHDQAgAigCCCgCMCACKAIEKAIwEIcBDQELIAJBfzYCDAwBCwJAAkAgAigCCCgCGCACKAIEKAIYRw0AIAIoAggpAyAgAigCBCkDIFINACACKAIIKQMoIAIoAgQpAyhRDQELAkACQCACKAIELwEMQQhxRQ0AIAIoAgQoAhgNACACKAIEKQMgQgBSDQAgAigCBCkDKFANAQsgAkF/NgIMDAILCyACQQA2AgwLIAIoAgwhACACQRBqJAAgAAv6AwEBfyMAQdAAayIEJAAgBCAANgJIIAQgATcDQCAEIAI2AjwgBCADNgI4AkAgBCgCSBAwQhZUBEAgBCgCOEEVQQAQFSAEQQA2AkwMAQsjAEEQayIAIAQoAkg2AgwgBAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALNwMIIAQoAkhCBBAfGiAEKAJIECsEQCAEKAI4QQFBABAVIARBADYCTAwBCyAEIAQoAkgQHkH//wNxrTcDKCAEIAQoAkgQHkH//wNxrTcDICAEKQMgIAQpAyhSBEAgBCgCOEETQQAQFSAEQQA2AkwMAQsgBCAEKAJIECutNwMYIAQgBCgCSBArrTcDECAEKQMQIAQpAxh8IAQpAxBUBEAgBCgCOEEEQRYQFSAEQQA2AkwMAQsgBCkDECAEKQMYfCAEKQNAIAQpAwh8VgRAIAQoAjhBFUEAEBUgBEEANgJMDAELAkAgBCgCPEEEcUUNACAEKQMQIAQpAxh8IAQpA0AgBCkDCHxRDQAgBCgCOEEVQQAQFSAEQQA2AkwMAQsgBCAEKQMgIAQoAjgQxgEiADYCNCAARQRAIARBADYCTAwBCyAEKAI0QQA6ACwgBCgCNCAEKQMYNwMYIAQoAjQgBCkDEDcDICAEIAQoAjQ2AkwLIAQoAkwhACAEQdAAaiQAIAAL1QoBAX8jAEGwAWsiBSQAIAUgADYCqAEgBSABNgKkASAFIAI3A5gBIAUgAzYClAEgBSAENgKQASMAQRBrIgAgBSgCpAE2AgwgBQJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALNwMYIAUoAqQBQgQQHxogBSAFKAKkARAeQf//A3E2AhAgBSAFKAKkARAeQf//A3E2AgggBSAFKAKkARAxNwM4AkAgBSkDOEL///////////8AVgRAIAUoApABQQRBFhAVIAVBADYCrAEMAQsgBSkDOEI4fCAFKQMYIAUpA5gBfFYEQCAFKAKQAUEVQQAQFSAFQQA2AqwBDAELAkACQCAFKQM4IAUpA5gBVA0AIAUpAzhCOHwgBSkDmAECfiMAQRBrIgAgBSgCpAE2AgwgACgCDCkDCAt8Vg0AIAUoAqQBIAUpAzggBSkDmAF9EC0aIAVBADoAFwwBCyAFKAKoASAFKQM4QQAQKEEASARAIAUoApABIAUoAqgBEBggBUEANgKsAQwCCyAFIAUoAqgBQjggBUFAayAFKAKQARBBIgA2AqQBIABFBEAgBUEANgKsAQwCCyAFQQE6ABcLIAUoAqQBQgQQHygAAEHQlpkwRwRAIAUoApABQRVBABAVIAUtABdBAXEEQCAFKAKkARAXCyAFQQA2AqwBDAELIAUgBSgCpAEQMTcDMAJAIAUoApQBQQRxRQ0AIAUpAzAgBSkDOHxCDHwgBSkDmAEgBSkDGHxRDQAgBSgCkAFBFUEAEBUgBS0AF0EBcQRAIAUoAqQBEBcLIAVBADYCrAEMAQsgBSgCpAFCBBAfGiAFIAUoAqQBECs2AgwgBSAFKAKkARArNgIEIAUoAhBB//8DRgRAIAUgBSgCDDYCEAsgBSgCCEH//wNGBEAgBSAFKAIENgIICwJAIAUoApQBQQRxRQ0AIAUoAgggBSgCBEYEQCAFKAIQIAUoAgxGDQELIAUoApABQRVBABAVIAUtABdBAXEEQCAFKAKkARAXCyAFQQA2AqwBDAELAkAgBSgCEEUEQCAFKAIIRQ0BCyAFKAKQAUEBQQAQFSAFLQAXQQFxBEAgBSgCpAEQFwsgBUEANgKsAQwBCyAFIAUoAqQBEDE3AyggBSAFKAKkARAxNwMgIAUpAyggBSkDIFIEQCAFKAKQAUEBQQAQFSAFLQAXQQFxBEAgBSgCpAEQFwsgBUEANgKsAQwBCyAFIAUoAqQBEDE3AzAgBSAFKAKkARAxNwOAAQJ/IwBBEGsiACAFKAKkATYCDCAAKAIMLQAAQQFxRQsEQCAFKAKQAUEUQQAQFSAFLQAXQQFxBEAgBSgCpAEQFwsgBUEANgKsAQwBCyAFLQAXQQFxBEAgBSgCpAEQFwsCQCAFKQOAAUL///////////8AWARAIAUpA4ABIAUpAzB8IAUpA4ABWg0BCyAFKAKQAUEEQRYQFSAFQQA2AqwBDAELIAUpA4ABIAUpAzB8IAUpA5gBIAUpAzh8VgRAIAUoApABQRVBABAVIAVBADYCrAEMAQsCQCAFKAKUAUEEcUUNACAFKQOAASAFKQMwfCAFKQOYASAFKQM4fFENACAFKAKQAUEVQQAQFSAFQQA2AqwBDAELIAUpAyggBSkDMEIugFYEQCAFKAKQAUEVQQAQFSAFQQA2AqwBDAELIAUgBSkDKCAFKAKQARDGASIANgKMASAARQRAIAVBADYCrAEMAQsgBSgCjAFBAToALCAFKAKMASAFKQMwNwMYIAUoAowBIAUpA4ABNwMgIAUgBSgCjAE2AqwBCyAFKAKsASEAIAVBsAFqJAAgAAviCwEBfyMAQfAAayIEJAAgBCAANgJoIAQgATYCZCAEIAI3A1ggBCADNgJUIwBBEGsiACAEKAJkNgIMIAQCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IACzcDMAJAIAQoAmQQMEIWVARAIAQoAlRBE0EAEBUgBEEANgJsDAELIAQoAmRCBBAfKAAAQdCWlTBHBEAgBCgCVEETQQAQFSAEQQA2AmwMAQsCQAJAIAQpAzBCFFQNACMAQRBrIgAgBCgCZDYCDCAAKAIMKAIEIAQpAzCnakFsaigAAEHQlpk4Rw0AIAQoAmQgBCkDMEIUfRAtGiAEIAQoAmgoAgAgBCgCZCAEKQNYIAQoAmgoAhQgBCgCVBDzATYCUAwBCyAEKAJkIAQpAzAQLRogBCAEKAJkIAQpA1ggBCgCaCgCFCAEKAJUEPIBNgJQCyAEKAJQRQRAIARBADYCbAwBCyAEKAJkIAQpAzBCFHwQLRogBCAEKAJkEB47AU4gBCgCUCkDICAEKAJQKQMYfCAEKQNYIAQpAzB8VgRAIAQoAlRBFUEAEBUgBCgCUBAlIARBADYCbAwBCwJAIAQvAU5FBEAgBCgCaCgCBEEEcUUNAQsgBCgCZCAEKQMwQhZ8EC0aIAQgBCgCZBAwNwMgAkAgBCkDICAELwFOrVoEQCAEKAJoKAIEQQRxRQ0BIAQpAyAgBC8BTq1RDQELIAQoAlRBFUEAEBUgBCgCUBAlIARBADYCbAwCCyAELwFOBEAgBCgCZCAELwFOrRAfIAQvAU5BACAEKAJUEFEhACAEKAJQIAA2AiggAEUEQCAEKAJQECUgBEEANgJsDAMLCwsCQCAEKAJQKQMgIAQpA1haBEAgBCgCZCAEKAJQKQMgIAQpA1h9EC0aIAQgBCgCZCAEKAJQKQMYEB8iADYCHCAARQRAIAQoAlRBFUEAEBUgBCgCUBAlIARBADYCbAwDCyAEIAQoAhwgBCgCUCkDGBAqIgA2AiwgAEUEQCAEKAJUQQ5BABAVIAQoAlAQJSAEQQA2AmwMAwsMAQsgBEEANgIsIAQoAmgoAgAgBCgCUCkDIEEAEChBAEgEQCAEKAJUIAQoAmgoAgAQGCAEKAJQECUgBEEANgJsDAILIAQoAmgoAgAQSiAEKAJQKQMgUgRAIAQoAlRBE0EAEBUgBCgCUBAlIARBADYCbAwCCwsgBCAEKAJQKQMYNwM4IARCADcDQANAAkAgBCkDOEIAWA0AIARBADoAGyAEKQNAIAQoAlApAwhRBEAgBCgCUC0ALEEBcQ0BIAQpAzhCLlQNASAEKAJQQoCABCAEKAJUEMUBQQFxRQRAIAQoAlAQJSAEKAIsEBcgBEEANgJsDAQLIARBAToAGwsQjgMhACAEKAJQKAIAIAQpA0CnQQR0aiAANgIAAkAgAARAIAQgBCgCUCgCACAEKQNAp0EEdGooAgAgBCgCaCgCACAEKAIsQQAgBCgCVBDCASICNwMQIAJCAFkNAQsCQCAELQAbQQFxRQ0AIwBBEGsiACAEKAJUNgIMIAAoAgwoAgBBE0cNACAEKAJUQRVBABAVCyAEKAJQECUgBCgCLBAXIARBADYCbAwDCyAEIAQpA0BCAXw3A0AgBCAEKQM4IAQpAxB9NwM4DAELCwJAIAQpA0AgBCgCUCkDCFEEQCAEKQM4QgBYDQELIAQoAlRBFUEAEBUgBCgCLBAXIAQoAlAQJSAEQQA2AmwMAQsgBCgCaCgCBEEEcQRAAkAgBCgCLARAIAQgBCgCLBBIQQFxOgAPDAELIAQgBCgCaCgCABBKNwMAIAQpAwBCAFMEQCAEKAJUIAQoAmgoAgAQGCAEKAJQECUgBEEANgJsDAMLIAQgBCkDACAEKAJQKQMgIAQoAlApAxh8UToADwsgBC0AD0EBcUUEQCAEKAJUQRVBABAVIAQoAiwQFyAEKAJQECUgBEEANgJsDAILCyAEKAIsEBcgBCAEKAJQNgJsCyAEKAJsIQAgBEHwAGokACAAC9cBAQF/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQgAkGJmAE2AhAgAkEENgIMAkACQCACKAIUIAIoAgxPBEAgAigCDA0BCyACQQA2AhwMAQsgAiACKAIYQX9qNgIIA0ACQCACIAIoAghBAWogAigCEC0AACACKAIYIAIoAghrIAIoAhQgAigCDGtqEKYBIgA2AgggAEUNACACKAIIQQFqIAIoAhBBAWogAigCDEEBaxBTDQEgAiACKAIINgIcDAILCyACQQA2AhwLIAIoAhwhACACQSBqJAAgAAvBBgEBfyMAQeAAayICJAAgAiAANgJYIAIgATcDUAJAIAIpA1BCFlQEQCACKAJYQQhqQRNBABAVIAJBADYCXAwBCyACAn4gAikDUEKqgARUBEAgAikDUAwBC0KqgAQLNwMwIAIoAlgoAgBCACACKQMwfUECEChBAEgEQCMAQRBrIgAgAigCWCgCADYCDCACIAAoAgxBDGo2AggCQAJ/IwBBEGsiACACKAIINgIMIAAoAgwoAgBBBEYLBEAjAEEQayIAIAIoAgg2AgwgACgCDCgCBEEWRg0BCyACKAJYQQhqIAIoAggQRCACQQA2AlwMAgsLIAIgAigCWCgCABBKIgE3AzggAUIAUwRAIAIoAlhBCGogAigCWCgCABAYIAJBADYCXAwBCyACIAIoAlgoAgAgAikDMEEAIAIoAlhBCGoQQSIANgIMIABFBEAgAkEANgJcDAELIAJCfzcDICACQQA2AkwgAikDMEKqgARaBEAgAigCDEIUEC0aCyACQRBqQRNBABAVIAIgAigCDEIAEB82AkQDQAJAIAIgAigCRCACKAIMEDBCEn2nEPUBIgA2AkQgAEUNACACKAIMIAIoAkQCfyMAQRBrIgAgAigCDDYCDCAAKAIMKAIEC2usEC0aIAIgAigCWCACKAIMIAIpAzggAkEQahD0ASIANgJIIAAEQAJAIAIoAkwEQCACKQMgQgBXBEAgAiACKAJYIAIoAkwgAkEQahBlNwMgCyACIAIoAlggAigCSCACQRBqEGU3AygCQCACKQMgIAIpAyhTBEAgAigCTBAlIAIgAigCSDYCTCACIAIpAyg3AyAMAQsgAigCSBAlCwwBCyACIAIoAkg2AkwCQCACKAJYKAIEQQRxBEAgAiACKAJYIAIoAkwgAkEQahBlNwMgDAELIAJCADcDIAsLIAJBADYCSAsgAiACKAJEQQFqNgJEIAIoAgwgAigCRAJ/IwBBEGsiACACKAIMNgIMIAAoAgwoAgQLa6wQLRoMAQsLIAIoAgwQFyACKQMgQgBTBEAgAigCWEEIaiACQRBqEEQgAigCTBAlIAJBADYCXAwBCyACIAIoAkw2AlwLIAIoAlwhACACQeAAaiQAIAALvwUBAX8jAEHwAGsiAyQAIAMgADYCaCADIAE2AmQgAyACNgJgIANBIGoiABA8AkAgAygCaCAAEDlBAEgEQCADKAJgIAMoAmgQGCADQQA2AmwMAQsgAykDIEIEg1AEQCADKAJgQQRBigEQFSADQQA2AmwMAQsgAyADKQM4NwMYIAMgAygCaCADKAJkIAMoAmAQZiIANgJcIABFBEAgA0EANgJsDAELAkAgAykDGFBFDQAgAygCaBCUAUEBcUUNACADIAMoAlw2AmwMAQsgAyADKAJcIAMpAxgQ9gEiADYCWCAARQRAIAMoAmAgAygCXEEIahBEIwBBEGsiACADKAJoNgIMIAAoAgwiACAAKAIwQQFqNgIwIAMoAlwQPyADQQA2AmwMAQsgAygCXCADKAJYKAIANgJAIAMoAlwgAygCWCkDCDcDMCADKAJcIAMoAlgpAxA3AzggAygCXCADKAJYKAIoNgIgIAMoAlgQFiADKAJcKAJQIAMoAlwpAzAgAygCXEEIahD9AiADQgA3AxADQCADKQMQIAMoAlwpAzBUBEAgAyADKAJcKAJAIAMpAxCnQQR0aigCACgCMEEAQQAgAygCYBBHNgIMIAMoAgxFBEAjAEEQayIAIAMoAmg2AgwgACgCDCIAIAAoAjBBAWo2AjAgAygCXBA/IANBADYCbAwDCyADKAJcKAJQIAMoAgwgAykDEEEIIAMoAlxBCGoQfUEBcUUEQAJAIAMoAlwoAghBCkYEQCADKAJkQQRxRQ0BCyADKAJgIAMoAlxBCGoQRCMAQRBrIgAgAygCaDYCDCAAKAIMIgAgACgCMEEBajYCMCADKAJcED8gA0EANgJsDAQLCyADIAMpAxBCAXw3AxAMAQsLIAMoAlwgAygCXCgCFDYCGCADIAMoAlw2AmwLIAMoAmwhACADQfAAaiQAIAALwQEBAX8jAEHQAGsiAiQAIAIgADYCSCACIAE2AkQgAkEIaiIAEDwCQCACKAJIIAAQOQRAIwBBEGsiACACKAJINgIMIAIgACgCDEEMajYCBCMAQRBrIgAgAigCBDYCDAJAIAAoAgwoAgBBBUcNACMAQRBrIgAgAigCBDYCDCAAKAIMKAIEQSxHDQAgAkEANgJMDAILIAIoAkQgAigCBBBEIAJBfzYCTAwBCyACQQE2AkwLIAIoAkwhACACQdAAaiQAIAAL6gEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI2AiAjAEEQayIAIANBCGoiATYCDCAAKAIMQQA2AgAgACgCDEEANgIEIAAoAgxBADYCCCADIAMoAiggARD7ASIANgIYAkAgAEUEQCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIAMgAygCGCADKAIkIANBCGoQkgEiADYCHCAARQRAIAMoAhgQHCADKAIgIANBCGoiABCTASAAEDggA0EANgIsDAELIANBCGoQOCADIAMoAhw2AiwLIAMoAiwhACADQTBqJAAgAAvIAgEBfyMAQRBrIgEkACABIAA2AgggAUHYABAZNgIEAkAgASgCBEUEQCABKAIIQQ5BABAVIAFBADYCDAwBCyABKAIIEIEDIQAgASgCBCAANgJQIABFBEAgASgCBBAWIAFBADYCDAwBCyABKAIEQQA2AgAgASgCBEEANgIEIwBBEGsiACABKAIEQQhqNgIMIAAoAgxBADYCACAAKAIMQQA2AgQgACgCDEEANgIIIAEoAgRBADYCGCABKAIEQQA2AhQgASgCBEEANgIcIAEoAgRBADYCJCABKAIEQQA2AiAgASgCBEEAOgAoIAEoAgRCADcDOCABKAIEQgA3AzAgASgCBEEANgJAIAEoAgRBADYCSCABKAIEQQA2AkQgASgCBEEANgJMIAEoAgRBADYCVCABIAEoAgQ2AgwLIAEoAgwhACABQRBqJAAgAAuBAQEBfyMAQSBrIgIkACACIAA2AhggAkIANwMQIAJCfzcDCCACIAE2AgQCQAJAIAIoAhgEQCACKQMIQn9ZDQELIAIoAgRBEkEAEBUgAkEANgIcDAELIAIgAigCGCACKQMQIAIpAwggAigCBBD/ATYCHAsgAigCHCEAIAJBIGokACAAC80BAQJ/IwBBIGsiASQAIAEgADYCGCAB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CyAAIAFBf2oiAWoiAi0AAEEvRw0ACyACC6kBAQN/AkAgAC0AACICRQ0AA0AgAS0AACIERQRAIAIhAwwCCwJAIAIgBEYNACACQSByIAIgAkG/f2pBGkkbIAEtAAAiAkEgciACIAJBv39qQRpJG0YNACAALQAAIQMMAgsgAUEBaiEBIAAtAAEhAiAAQQFqIQAgAg0ACwsgA0H/AXEiAEEgciAAIABBv39qQRpJGyABLQAAIgBBIHIgACAAQb9/akEaSRtrC+gDAQN/IwBBsAFrIgEkACABIAA2AqgBIAEoAqgBEDgCQAJAIAEoAqgBKAIAQQBOBEAgASgCqAEoAgBBoA4oAgBIDQELIAEgASgCqAEoAgA2AhAgAUEgakG8lwEgAUEQahBvIAFBADYCpAEgASABQSBqNgKgAQwBCyABIAEoAqgBKAIAQQJ0QaANaigCADYCpAECQAJAAkACQCABKAKoASgCAEECdEGwDmooAgBBf2oOAgABAgsgASABKAKoASgCBEGQmgEoAgAQpAI2AqABDAILIwBBEGsiACABKAKoASgCBDYCDCABQQAgACgCDGtBAnRB2NQAaigCADYCoAEMAQsgAUEANgKgAQsLAkAgASgCoAFFBEAgASABKAKkATYCrAEMAQsgASABKAKgARAsAn8gASgCpAEEQCABKAKkARAsQQJqDAELQQALakEBahAZIgA2AhwgAEUEQCABQdgNKAIANgKsAQwBCyABKAIcIQACfyABKAKkAQRAIAEoAqQBDAELQdSXAQshAkHVlwFB1JcBIAEoAqQBGyEDIAEgASgCoAE2AgggASADNgIEIAEgAjYCACAAQc2XASABEG8gASgCqAEgASgCHDYCCCABIAEoAhw2AqwBCyABKAKsASEAIAFBsAFqJAAgAAtxAQN/AkACQANAIAAgAkHQiAFqLQAARwRAQdcAIQMgAkEBaiICQdcARw0BDAILCyACIgMNAEGwiQEhAAwBC0GwiQEhAgNAIAItAAAhBCACQQFqIgAhAiAEDQAgACECIANBf2oiAw0ACwsgASgCFBogAAszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQGhogACAAKAIUIAFqNgIUIAILigEBAn8jAEGgAWsiAyQAIANBCGpBuIcBQZABEBoaIAMgADYCNCADIAA2AhwgA0F+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QQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACwYAQaShAQsGAEGgoQELBgBBmKEBC9kDAgJ/An4jAEEgayICJAACQCABQv///////////wCDIgVCgICAgICAwP9DfCAFQoCAgICAgMCAvH98VARAIAFCBIYgAEI8iIQhBCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCEEDAILIARCgICAgICAgIBAfSEEIABCgICAgICAgIAIhUIAUg0BIARCAYMgBHwhBAwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQQMAQtCgICAgICAgPj/ACEEIAVC////////v//DAFYNAEIAIQQgBUIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qELMCIAIgACAEQYH4ACADaxCyAiACKQMIQgSGIAIpAwAiAEI8iIQhBCACKQMQIAIpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIARCAXwhBAwBCyAAQoCAgICAgICACIVCAFINACAEQgGDIAR8IQQLIAJBIGokACAEIAFCgICAgICAgICAf4OEvwtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAuLAgACQCAABH8gAUH/AE0NAQJAQZCaASgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAg8LIAFBgLADT0EAIAFBgEBxQYDAA0cbRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCAfGpB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0G0nAFBGTYCAEF/BUEBCw8LIAAgAToAAEEBC74CAQF/IwBBwMAAayIDJAAgAyAANgK4QCADIAE2ArRAIAMgAjcDqEACQCADKAK0QBBJQQBIBEAgAygCuEBBCGogAygCtEAQGCADQX82ArxADAELIANBADYCDCADQgA3AxADQAJAIAMgAygCtEAgA0EgakKAwAAQLyICNwMYIAJCAFcNACADKAK4QCADQSBqIAMpAxgQNkEASARAIANBfzYCDAUgAykDGEKAwABSDQIgAygCuEAoAlRFDQIgAykDqEBCAFcNAiADIAMpAxggAykDEHw3AxAgAygCuEAoAlQgAykDELkgAykDqEC5oxBYDAILCwsgAykDGEIAUwRAIAMoArhAQQhqIAMoArRAEBggA0F/NgIMCyADKAK0QBAyGiADIAMoAgw2ArxACyADKAK8QCEAIANBwMAAaiQAIAALqgEBAX8jAEEwayIDJAAgAyAANgIoIAMgATYCJCADIAI3AxggAyADKAIoKAIAEDUiAjcDEAJAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoIAMoAiQgAykDGBCQAyICNwMAIAJCAFMEQCADQX82AiwMAQsgAyADKAIoKAIAEDUiAjcDCCACQgBTBEAgA0F/NgIsDAELIANBADYCLAsgAygCLCEAIANBMGokACAAC/4BAQF/IwBBoMAAayICJAAgAiAANgKYQCACIAE3A5BAIAIgAikDkEC6OQMAAkADQCACKQOQQEIAVgRAIAICfkKAwAAgAikDkEBCgMAAVg0AGiACKQOQQAs+AgwgAigCmEAoAgAgAkEQaiACKAIMrSACKAKYQEEIahBhQQBIBEAgAkF/NgKcQAwDCyACKAKYQCACQRBqIAIoAgytEDZBAEgEQCACQX82ApxADAMFIAIgAikDkEAgAjUCDH03A5BAIAIoAphAKAJUIAIrAwAgAikDkEC6oSACKwMAoxBYDAILAAsLIAJBADYCnEALIAIoApxAIQAgAkGgwABqJAAgAAvnEQIBfwF+IwBBoAFrIgMkACADIAA2ApgBIAMgATYClAEgAyACNgKQAQJAIAMoApQBIANBOGoQOUEASARAIAMoApgBQQhqIAMoApQBEBggA0F/NgKcAQwBCyADKQM4QsAAg1AEQCADIAMpAzhCwACENwM4IANBADsBaAsCQAJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQsgAy8BaEUNACADKAKQASADLwFoNgIQDAELAkACQCADKAKQASgCEA0AIAMpAzhCBINQDQAgAyADKQM4QgiENwM4IAMgAykDUDcDWAwBCyADIAMpAzhC9////w+DNwM4CwsgAykDOEKAAYNQBEAgAyADKQM4QoABhDcDOCADQQA7AWoLIANBgAI2AiQCQCADKQM4QgSDUARAIAMgAygCJEGACHI2AiQgA0J/NwNwDAELIAMoApABIAMpA1A3AyggAyADKQNQNwNwAkAgAykDOEIIg1AEQAJAAkACQAJAAkACfwJAIAMoApABKAIQQX9HBEAgAygCkAEoAhBBfkcNAQtBCAwBCyADKAKQASgCEAtB//8DcQ4NAgMDAwMDAwMBAwMDAAMLIANClMLk8w83AxAMAwsgA0KDg7D/DzcDEAwCCyADQv////8PNwMQDAELIANCADcDEAsgAykDUCADKQMQVgRAIAMgAygCJEGACHI2AiQLDAELIAMoApABIAMpA1g3AyALCyADIAMoApgBKAIAEDUiBDcDiAEgBEIAUwRAIAMoApgBQQhqIAMoApgBKAIAEBggA0F/NgKcAQwBCyADKAKQASIAIAAvAQxB9/8DcTsBDCADIAMoApgBIAMoApABIAMoAiQQXiIANgIoIABBAEgEQCADQX82ApwBDAELIAMgAy8BaAJ/AkAgAygCkAEoAhBBf0cEQCADKAKQASgCEEF+Rw0BC0EIDAELIAMoApABKAIQC0H//wNxRzoAIiADIAMtACJBAXEEfyADLwFoQQBHBUEAC0EBcToAISADIAMvAWgEfyADLQAhBUEBC0EBcToAICADIAMtACJBAXEEfyADKAKQASgCEEEARwVBAAtBAXE6AB8gAwJ/QQEgAy0AIkEBcQ0AGkEBIAMoApABKAIAQYABcQ0AGiADKAKQAS8BUiADLwFqRwtBAXE6AB4gAyADLQAeQQFxBH8gAy8BakEARwVBAAtBAXE6AB0gAyADLQAeQQFxBH8gAygCkAEvAVJBAEcFQQALQQFxOgAcIAMgAygClAE2AjQjAEEQayIAIAMoAjQ2AgwgACgCDCIAIAAoAjBBAWo2AjAgAy0AHUEBcQRAIAMgAy8BakEAEHciADYCDCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADLwFqQQAgAygCmAEoAhwgAygCDBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAy0AIUEBcQRAIAMgAygCmAEgAygCNCADLwFoEKsBIgA2AjAgAEUEQCADKAI0EBwgA0F/NgKcAQwCCyADKAI0EBwgAyADKAIwNgI0CyADLQAgQQFxBEAgAyADKAKYASADKAI0QQAQqgEiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtAB9BAXEEQCADIAMoApgBIAMoAjQgAygCkAEoAhAgAygCkAEvAVAQwgIiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtABxBAXEEQCADQQA2AgQCQCADKAKQASgCVARAIAMgAygCkAEoAlQ2AgQMAQsgAygCmAEoAhwEQCADIAMoApgBKAIcNgIECwsgAyADKAKQAS8BUkEBEHciADYCCCAARQRAIAMoApgBQQhqQRhBABAVIAMoAjQQHCADQX82ApwBDAILIAMgAygCmAEgAygCNCADKAKQAS8BUkEBIAMoAgQgAygCCBEGACIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAyADKAKYASgCABA1IgQ3A4ABIARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAyADKAKYASADKAI0IAMpA3AQtQI2AiwgAygCNCADQThqEDlBAEgEQCADKAKYAUEIaiADKAI0EBggA0F/NgIsCyADIAMoAjQQuwIiADoAIyAAQRh0QRh1QQBIBEAgAygCmAFBCGogAygCNBAYIANBfzYCLAsgAygCNBAcIAMoAixBAEgEQCADQX82ApwBDAELIAMgAygCmAEoAgAQNSIENwN4IARCAFMEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAygCmAEoAgAgAykDiAEQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgAykDOELkAINC5ABSBEAgAygCmAFBCGpBFEEAEBUgA0F/NgKcAQwBCyADKAKQASgCAEEgcUUEQAJAIAMpAzhCEINCAFIEQCADKAKQASADKAJgNgIUDAELIAMoApABQRRqEAEaCwsgAygCkAEgAy8BaDYCECADKAKQASADKAJkNgIYIAMoApABIAMpA1A3AyggAygCkAEgAykDeCADKQOAAX03AyAgAygCkAEgAygCkAEvAQxB+f8DcSADLQAjQQF0cjsBDCADKAKQASADKAIkQYAIcUEARxCKAyADIAMoApgBIAMoApABIAMoAiQQXiIANgIsIABBAEgEQCADQX82ApwBDAELIAMoAiggAygCLEcEQCADKAKYAUEIakEUQQAQFSADQX82ApwBDAELIAMoApgBKAIAIAMpA3gQqAFBAEgEQCADKAKYAUEIaiADKAKYASgCABAYIANBfzYCnAEMAQsgA0EANgKcAQsgAygCnAEhACADQaABaiQAIAALrwIBAX8jAEEgayICIAA2AhwgAiABNgIYIAJBADYCFCACQgA3AwACQCACKAIcLQAoQQFxRQRAIAIoAhwoAhggAigCHCgCFEYNAQsgAkEBNgIUCyACQgA3AwgDQCACKQMIIAIoAhwpAzBUBEACQAJAIAIoAhwoAkAgAikDCKdBBHRqKAIIDQAgAigCHCgCQCACKQMIp0EEdGotAAxBAXENACACKAIcKAJAIAIpAwinQQR0aigCBEUNASACKAIcKAJAIAIpAwinQQR0aigCBCgCAEUNAQsgAkEBNgIUCyACKAIcKAJAIAIpAwinQQR0ai0ADEEBcUUEQCACIAIpAwBCAXw3AwALIAIgAikDCEIBfDcDCAwBCwsgAigCGARAIAIoAhggAikDADcDAAsgAigCFAuMEAMCfwF+AXwjAEHgAGsiASQAIAEgADYCWAJAIAEoAlhFBEAgAUF/NgJcDAELIAEgASgCWCABQUBrELkCNgIkIAEpA0BQBEACQCABKAJYKAIEQQhxRQRAIAEoAiRFDQELIAEoAlgoAgAQhAJBAEgEQAJAAn8jAEEQayICIAEoAlgoAgA2AgwjAEEQayIAIAIoAgxBDGo2AgwgACgCDCgCAEEWRgsEQCMAQRBrIgIgASgC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NgI8IAEoAlAgASgCODYCQCABKAJYIAEoAjAQ1gIgASABKAJYKAIMNgJIIAEgASgCWCgCEDYCQCABIAEoAlgoAgA2AkwgASABKAJYKAIENgJEIAEgASgCUCgCPDYCPCABIAEoAlAoAkA2AjggASgCUCgCBEG//gBGBEAgASgCUEF/NgLINwsMDQsgASgCUEEANgLINwNAAkAgASABKAJQKAJQIAEoAjxBASABKAJQKAJYdEEBa3FBAnRqKAEANgEgIAEtACEgASgCOE0NACABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCwJAIAEtACBFDQAgAS0AIEHwAXENACABIAEoASA2ARgDQAJAIAEgASgCUCgCUCABLwEaIAEoAjxBASABLQAZIAEtABhqdEEBa3EgAS0AGXZqQQJ0aigBADYBICABLQAZIAEtACFqIAEoAjhNDQAgASgCREUNDiABIAEoAkRBf2o2AkQgASABKAJMIgBBAWo2AkwgASABKAI8IAAtAAAgASgCOHRqNgI8IAEgASgCOEEIajYCOAwBCwsgASABKAI8IAEtABl2NgI8IAEgASgCOCABLQAZazYCOCABKAJQIgAgAS0AGSAAKALIN2o2Asg3CyABIAEoAjwgAS0AIXY2AjwgASABKAI4IAEtACFrNgI4IAEoAlAiACABLQAhIAAoAsg3ajYCyDcgASgCUCABLwEiNgJEIAEtACBFBEAgASgCUEHN/gA2AgQMDQsgAS0AIEEgcQRAIAEoAlBBfzYCyDcgASgCUEG//gA2AgQMDQsgAS0AIEHAAHEEQCABKAJYQYfxADYCGCABKAJQQdH+ADYCBAwNCyABKAJQIAEtACBBD3E2AkwgASgCUEHJ/gA2AgQLIAEoAlAoAkwEQANAIAEoAjggASgCUCgCTEkEQCABKAJERQ0NIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCyABKAJQIgAgACgCRCABKAI8QQEgASgCUCgCTHRBAWtxajYCRCABIAEoAjwgASgCUCgCTHY2AjwgASABKAI4IAEoAlAoAkxrNgI4IAEoAlAiACAB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KAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AiggAigCKCACKAIMSQRAIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AigLCyACIAIoAgQgAigCLEEBIAIoAgx0QQFrcWo2AgQgAiACKAIsIAIoAgx2NgIsIAIgAigCKCACKAIMazYCKCACIAIoAkggAigCRGs2AgwCQCACKAIEIAIoAgxLBEAgAiACKAIEIAIoAgxrNgIMIAIoAgwgAigCOEsEQCACKAJUKALENwRAIAIoAlxBsO0ANgIYIAIoAlRB0f4ANgIEDAoLCyACIAIoAjA2AgACQCACKAI0RQRAIAIgAigCACACKAI8IAIoAgxrajYCACACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCSCACKAIEazYCAAsMAQsCQCACKAI0IAIoAgxJBEAgAiACKAIAIAIoAjwgAigCNGogAigCDGtqNgIAIAIgAigCDCACKAI0azYCDCACKAIMIAIoAghJBEAgAiACKAIIIAIoAgxrNgIIA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgxBf2oiADYCDCAADQALIAIgAigCMDYCACACKAI0IAIoAghJBEAgAiACKAI0NgIMIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwwBCyACIAIoAgAgAigCNCACKAIMa2o2AgAgAigCDCACKAIISQRAIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALCwsDQCACKAIIQQJNRQRAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCCEEDazYCCAwBCwsMAQsgAiACKAJIIAIoAgRrNgIAA0AgAiACKAIAIgBBAWo2AgAgAC0AACEAIAIgAigCSCIBQQFqNgJIIAEgADoAACACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIIQQNrNgIIIAIoAghBAksNAAsLIAIoAggEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIoAghBAUsEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAACwsMAgsgAigCDEHAAHFFBEAgAkEQaiACKAIgIAIvARIgAigCLEEBIAIoAgx0QQFrcWpBAnRqKAEANgEADAELCyACKAJcQc7tADYCGCACKAJUQdH+ADYCBAwECwwCCyACKAIMQcAAcUUEQCACQRBqIAIoAiQgAi8BEiACKAIsQQEgAigCDHRBAWtxakECdGooAQA2AQAMAQsLIAIoAgxBIHEEQCACKAJUQb/+ADYCBAwCCyACKAJcQeTtADYCGCACKAJUQdH+ADYCBAwBC0EAIQAgAigCUCACKAJMSQR/IAIoAkggAigCQEkFQQALQQFxDQELCyACIAIoAihBA3Y2AgggAiACKAJQIAIoAghrNgJQIAIgAigCKCACKAIIQQN0azYCKCACIAIoAixBASACKAIodEEBa3E2AiwgAigCXCACKAJQNgIAIAIoAlwgAigCSDYCDCACKAJcAn8gAigCUCACKAJMSQRAIAIoAkwgAigCUGtBBWoMAQtBBSACKAJQIAIoAkxraws2AgQgAigCXAJ/IAIoAkggAigCQEkEQCACKAJAIAIoAkhrQYECagwBC0GBAiACKAJIIAIoAkBraws2AhAgAigCVCACKAIsNgI8IAIoAlQgAigCKDYCQAvBEAECfyMAQSBrIgIk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LSAAKAKgLUEBdGogAi8BEDsBACACLQATIQEgAigCKCIAKAKYLSEDIAAgACgCoC0iAEEBajYCoC0gACADaiABOgAAIAIgAi8BEEF/ajsBECACKAIoIAItABNBgNkAai0AAEECdGpBmAlqIgAgAC8BAEEBajsBACACKAIoQYgTagJ/IAIvARBBgAJIBEAgAi8BEC0AgFUMAQsgAi8BEEEHdUGAAmotAIBVC0ECdGoiACAALwEAQQFqOwEAIAIgAigCKCgCoC0gAigCKCgCnC1BAWtGNgIgIAIoAigiACAAKAJ0IAIoAigoAmBrNgJ0IAIoAigiACACKAIoKAJgIAAoAmxqNgJsIAIoAihBADYCYAwBCyACIAIoAigiACgCOCAAKAJsai0AADoADyACKAIoIgAoAqQtIAAoAqAtQQF0akEAOwEAIAItAA8hASACKAIoIgAoApgtIQMgACAAKAKgLSIAQQFqNgKgLSAAIANqIAE6AAAgAigCKCACLQAPQQJ0aiIAIAAvAZQBQQFqOwGUASACIAIoAigoAqAtIAIoAigoApwtQQFrRjYCICACKAIoIgAgACgCdEF/ajYCdCACKAIoIgAgACgCbEEBajYCbAsgAigCIARAIAIoAigCfyACKAIoKAJcQQBOBEAgAigCKCgCOCACKAIoKAJcagwBC0EACyACKAIoKAJsIAIoAigoAlxrQQAQKSACKAIoIAIoAigoAmw2AlwgAigCKCgCABAdIAIoAigoAgAoAhBFBEAgAkEANgIsDAQLCwwBCwsgAigCKEEANgK0LSACKAIkQQRGBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBARApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQI2AiwMAgsgAkEDNgIsDAELIAIoAigoAqAtBEAgAigCKAJ/IAIoAigoAlxBAE4EQCACKAIoKAI4IAIoAigoAlxqDAELQQALIAIoAigoAmwgAigCKCgCXGtBABApIAIoAiggAigCKCgCbDYCXCACKAIoKAIAEB0gAigCKCgCACgCEEUEQCACQQA2AiwMAgsLIAJBATYCLAsgAigCLCEAIAJBMGokACAAC8AFAQJ/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQCQANAAkAgAigCGCgCdEUEQCACKAIYEFYgAigCGCgCdEUEQCACKAIURQRAIAJBADYCHAwFCwwCCwsgAigCGEEANgJgIAIgAigCGCIAKAI4IAAoAmxqLQAAOgAPIAIoAhgiACgCpC0gACgCoC1BAXRqQQA7AQAgAi0ADyEBIAIoAhgiACgCmC0hAyAAIAAoAqAtIgBBAWo2AqAtIAAgA2ogAToAACACKAIYIAItAA9BAnRqIgAgAC8BlAFBAWo7AZQBIAIgAigCGCgCoC0gAigCGCgCnC1BAWtGNgIQIAIoAhgiACAAKAJ0QX9qNgJ0IAIoAhgiACAAKAJsQQFqNgJsIAIoAhAEQCACKAIYAn8gAigCGCgCXEEATgRAIAIoAhgoAjggAigCGCgCXGoMAQtBAAsgAigCGCgCbCACKAIYKAJca0EAECkgAigCGCACKAIYKAJsNgJcIAIoAhgoAgAQHSACKAIYKAIAKAIQRQRAIAJBADYCHAwECwsMAQsLIAIoAhhBADYCtC0gAigCFEEERgRAIAIoAhgCfyACKAIYKAJcQQBOBEAgAigCGCgCOCACKAIYKAJcagwBC0EACyACKAIYKAJsIAIoAhgoAlxrQQEQKSACKAIYIAIoAhgoAmw2AlwgAigCGCgCABAdIAIoAhgoAgAoAhBFBEAgAkECNgIcDAILIAJBAzYCHAwBCyACKAIYKAKgLQRAIAIoAhgCfyACKAIYKAJcQQBOBEAgAigCGCgCOCACKAIYKAJcagwBC0EACyACKAIYKAJsIAIoAhgoAlxrQQAQKSACKAIYIAIoAhgoAmw2AlwgAigCGCgCABAdIAIoAhgoAgAoAhBFBEAgAkEANgIcDAILCyACQQE2AhwLIAIoAhwhACACQSBqJAAgAAuuJQEDfyMAQUBqIgIkACACIAA2AjggAiABNgI0AkACQAJAIAIoAjgQdA0AIAIoAjRBBUoNACACKAI0QQBODQELIAJBfjYCPAwBCyACIAIoAjgoAhw2AiwCQAJAIAIoAjgoAgxFDQAgAigCOCgCBARAIAIoAjgoAgBFDQELIAIoAiwoAgRBmgVHDQEgAigCNEEERg0BCyACKAI4QeDUACgCADYCGCACQX42AjwMAQsgAigCOCgCEEUEQCACKAI4QezUACgCADYCGCACQXs2AjwMAQsgAiACKAIsKAIoNgIwIAIoAiwgAigCNDYCKAJAIAIoAiwoAhQEQCACKAI4EB0gAigCOCgCEEUEQCACKAIsQX82AiggAkEANgI8DAMLDAELAkAgAigCOCgCBA0AIAIoAjRBAXRBCUEAIAIoAjRBBEobayACKAIwQQF0QQlBACACKAIwQQRKG2tKDQAgAigCNEEERg0AIAIoAjhB7NQAKAIANgIYIAJBezYCPAwCCwsCQCACKAIsKAIEQZoFRw0AIAIoAjgoAgRFDQAgAigCOEHs1AAoAgA2AhggAkF7NgI8DAELIAIoAiwoAgRBKkYEQCACIAIoAiwoAjBBBHRBiH9qQQh0NgIoAkACQCACKAIsKAKIAUECSARAIAIoAiwoAoQBQQJODQELIAJBADYCJAwBCwJAIAIoAiwoAoQBQQZIBEAgAkEBNgIkDAELAkAgAigCLCgChAFBBkYEQCACQQI2AiQMAQsgAkEDNgIkCwsLIAIgAigCKCACKAIkQQZ0cjYCKCACKAIsKAJsBEAgAiACKAIoQSByNgIoCyACIAIoAihBHyACKAIoQR9wa2o2AiggAigCLCACKAIoEEwgAigCLCgCbARAIAIoAiwgAigCOCgCMEEQdhBMIAIoAiwgAigCOCgCMEH//wNxEEwLQQBBAEEAED4hACACKAI4IAA2AjAgAigCLEHxADYCBCACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMAgsLIAIoAiwoAgRBOUYEQEEAQQBBABAbIQAgAigCOCAANgIwIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakEfOgAAIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakGLAToAACACKAIsKAIIIQEgAigCLCIDKAIUIQAgAyAAQQFqNgIUIAAgAWpBCDoAAAJAIAIoAiwoAhxFBEAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAAgAigCLCgCCCEBIAIoAiwiAygCFCEAIAMgAEEBajYCFCAAIAFqQQA6AAACf0ECIAIoAiwoAoQBQQlGDQAaQQEhAEEEQQAgAigCLCgCiAFBAkgEfyACKAIsKAKEAUECSAVBAQtBAXEbCyEAIAIoAiwoAgghAyACKAIsIgQoAhQhASAEIAFBAWo2AhQgASADaiAAOgAAIAIoAiwoAgghASACKAIsIgMoAhQhACADIABBAWo2AhQgACABakEDOgAAIAIoAixB8QA2AgQgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAQLDAELIAIoAiwoAhwoAgBFRUECQQAgAigCLCgCHCgCLBtqQQRBACACKAIsKAIcKAIQG2pBCEEAIAIoAiwoAhwoAhwbakEQQQAgAigCLCgCHCgCJBtqIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCLCgCHCgCBEH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAIsKAIcKAIEQQh2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAgRBEHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCLCgCHCgCBEEYdiEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAAn9BAiACKAIsKAKEAUEJRg0AGkEBIQBBBEEAIAIoAiwoAogBQQJIBH8gAigCLCgChAFBAkgFQQELQQFxGwshACACKAIsKAIIIQMgAigCLCIEKAIUIQEgBCABQQFqNgIUIAEgA2ogADoAACACKAIsKAIcKAIMQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAhAEQCACKAIsKAIcKAIUQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAiwoAhwoAhRBCHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAALIAIoAiwoAhwoAiwEQCACKAI4KAIwIAIoAiwoAgggAigCLCgCFBAbIQAgAigCOCAANgIwCyACKAIsQQA2AiAgAigCLEHFADYCBAsLIAIoAiwoAgRBxQBGBEAgAigCLCgCHCgCEARAIAIgAigCLCgCFDYCICACIAIoAiwoAhwoAhRB//8DcSACKAIsKAIgazYCHANAIAIoAiwoAhQgAigCHGogAigCLCgCDEsEQCACIAIoAiwoAgwgAigCLCgCFGs2AhggAigCLCgCCCACKAIsKAIUaiACKAIsKAIcKAIQIAIoAiwoAiBqIAIoAhgQGhogAigCLCACKAIsKAIMNgIUAkAgAigCLCgCHCgCLEUNACACKAIsKAIUIAIoAiBNDQAgAigCOCgCMCACKAIsKAIIIAIoAiBqIAIoAiwoAhQgAigCIGsQGyEAIAIoAjggADYCMAsgAigCLCIAIAIoAhggACgCIGo2AiAgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAUFIAJBADYCICACIAIoAhwgAigCGGs2AhwMAgsACwsgAigCLCgCCCACKAIsKAIUaiACKAIsKAIcKAIQIAIoAiwoAiBqIAIoAhwQGhogAigCLCIAIAIoAhwgACgCFGo2AhQCQCACKAIsKAIcKAIsRQ0AIAIoAiwoAhQgAigCIE0NACACKAI4KAIwIAIoAiwoAgggAigCIGogAigCLCgCFCACKAIgaxAbIQAgAigCOCAANgIwCyACKAIsQQA2AiALIAIoAixByQA2AgQLIAIoAiwoAgRByQBGBEAgAigCLCgCHCgCHARAIAIgAigCLCgCFDYCFANAIAIoAiwoAhQgAigCLCgCDEYEQAJAIAIoAiwoAhwoAixFDQAgAigCLCgCFCACKAIUTQ0AIAIoAjgoAjAgAigCLCgCCCACKAIUaiACKAIsKAIUIAIoAhRrEBshACACKAI4IAA2AjALIAIoAjgQHSACKAIsKAIUBEAgAigCLEF/NgIoIAJBADYCPAwFCyACQQA2AhQLIAIoAiwoAhwoAhwhASACKAIsIgMoAiAhACADIABBAWo2AiAgAiAAIAFqLQAANgIQIAIoAhAhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAIQDQALAkAgAigCLCgCHCgCLEUNACACKAIsKAIUIAIoAhRNDQAgAigCOCgCMCACKAIsKAIIIAIoAhRqIAIoAiwoAhQgAigCFGsQGyEAIAIoAjggADYCMAsgAigCLEEANgIgCyACKAIsQdsANgIECyACKAIsKAIEQdsARgRAIAIoAiwoAhwoAiQEQCACIAIoAiwoAhQ2AgwDQCACKAIsKAIUIAIoAiwoAgxGBEACQCACKAIsKAIcKAIsRQ0AIAIoAiwoAhQgAigCDE0NACACKAI4KAIwIAIoAiwoAgggAigCDGogAigCLCgCFCACKAIMaxAbIQAgAigCOCAANgIwCyACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMBQsgAkEANgIMCyACKAIsKAIcKAIkIQEgAigCLCIDKAIgIQAgAyAAQQFqNgIgIAIgACABai0AADYCCCACKAIIIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCCA0ACwJAIAIoAiwoAhwoAixFDQAgAigCLCgCFCACKAIMTQ0AIAIoAjgoAjAgAigCLCgCCCACKAIMaiACKAIsKAIUIAIoAgxrEBshACACKAI4IAA2AjALCyACKAIsQecANgIECyACKAIsKAIEQecARgRAIAIoAiwoAhwoAiwEQCACKAIsKAIUQQJqIAIoAiwoAgxLBEAgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAQLCyACKAI4KAIwQf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAjBBCHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AABBAEEAQQAQGyEAIAIoAjggADYCMAsgAigCLEHxADYCBCACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMAgsLAkACQCACKAI4KAIEDQAgAigCLCgCdA0AIAIoAjRFDQEgAigCLCgCBEGaBUYNAQsgAgJ/IAIoAiwoAoQBRQRAIAIoAiwgAigCNBCxAQwBCwJ/IAIoAiwoAogBQQJGBEAgAigCLCACKAI0ENoCDAELAn8gAigCLCgCiAFBA0YEQCACKAIsIAIoAjQQ2QIMAQsgAigCLCACKAI0IAIoAiwoAoQBQQxsQbDqAGooAggRAgALCws2AgQCQCACKAIEQQJHBEAgAigCBEEDRw0BCyACKAIsQZoFNgIECwJAIAIoAgQEQCACKAIEQQJHDQELIAIoAjgoAhBFBEAgAigCLEF/NgIoCyACQQA2AjwMAgsgAigCBEEBRgRAAkAgAigCNEEBRgRAIAIoAiwQ6AIMAQsgAigCNEEFRwRAIAIoAixBAEEAQQAQVyACKAI0QQNGBEAgAigCLCgCRCACKAIsKAJMQQFrQQF0akEAOwEAIAIoAiwoAkRBACACKAIsKAJMQQFrQQF0EDMgAigCLCgCdEUEQCACKAIsQQA2AmwgAigCLEEANgJcIAIoAixBADYCtC0LCwsLIAIoAjgQHSACKAI4KAIQRQRAIAIoAixBfzYCKCACQQA2AjwMAwsLCyACKAI0QQRHBEAgAkEANgI8DAELIAIoAiwoAhhBAEwEQCACQQE2AjwMAQsCQCACKAIsKAIYQQJGBEAgAigCOCgCMEH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAI4KAIwQQh2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAjBBEHZB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCOCgCMEEYdiEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAghB/wFxIQEgAigCLCgCCCEDIAIoAiwiBCgCFCEAIAQgAEEBajYCFCAAIANqIAE6AAAgAigCOCgCCEEIdkH/AXEhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAACACKAI4KAIIQRB2Qf8BcSEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAjgoAghBGHYhASACKAIsKAIIIQMgAigCLCIEKAIUIQAgBCAAQQFqNgIUIAAgA2ogAToAAAwBCyACKAIsIAIoAjgoAjBBEHYQTCACKAIsIAIoAjgoAjBB//8DcRBMCyACKAI4EB0gAigCLCgCGEEASgRAIAIoAixBACACKAIsKAIYazYCGAsgAiACKAIsKAIURTYCPAsgAigCPCEAIAJBQGskACAAC44CAQF/IwBBIGsiASAANgIcIAEgASgCHCgCLDYCDCABIAEoAhwoAkw2AhggASABKAIcKAJEIAEoAhhBAXRqNgIQA0AgASABKAIQQX5qIgA2AhAgASAALwEANgIUIAEoAhACfyABKAIUIAEoAgxPBEAgASgCFCABKAIMawwBC0EACzsBACABIAEoAhhBf2oiADYCGCAADQALIAEgASgCDDYCGCABIAEoAhwoAkAgASgCGEEBdGo2AhADQCABIAEoAhBBfmoiADYCECABIAAvAQA2AhQgASgCEAJ/IAEoAhQgASgCDE8EQCABKAIUIAEoAgxrDAELQQALOwEAIAEgASgCGEF/aiIANgIYIAANAAsLRQBBoJwBQgA3AwBBmJwBQgA3AwBBkJwBQgA3AwBBiJwBQgA3AwBBgJwBQgA3AwBB+JsBQgA3AwBB8JsBQgA3AwBB8JsBC6gCAQF/IwBBEGsiASQAIAEgADYCDCABKAIMIAEoAgwoAixBAXQ2AjwgASgCDCgCRCABKAIMKAJMQQFrQQF0akEAOwEAIAEoAgwoAkRBACABKAIMKAJMQQFrQQF0EDMgASgCDCABKAIMKAKEAUEMbEGw6gBqLwECNgKAASABKAIMIAEoAgwoAoQBQQxsQbDqAGovAQA2AowBIAEoAgwgASgCDCgChAFBDGxBsOoAai8BBDYCkAEgASgCDCABKAIMKAKEAUEMbEGw6gBqLwEGNgJ8IAEoAgxBADYCbCABKAIMQQA2AlwgASgCDEEANgJ0IAEoAgxBADYCtC0gASgCDEECNgJ4IAEoAgxBAjYCYCABKAIMQQA2AmggASgCDEEANgJIIAFBEGokAAubAgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEHQEQCABQX42AgwMAQsgASgCCEEANgIUIAEoAghBADYCCCABKAIIQQA2AhggASgCCEECNgIsIAEgASgCCCgCHDYCBCABKAIEQQA2AhQgASgCBCABKAIEKAIINgIQIAEoAgQoAhhBAEgEQCABKAIEQQAgASgCBCgCGGs2AhgLIAEoAgQCf0E5IAEoAgQoAhhBAkYNABpBKkHxACABKAIEKAIYGws2AgQCfyABKAIEKAIYQQJGBEBBAEEAQQAQGwwBC0EAQQBBABA+CyEAIAEoAgggADYCMCABKAIEQQA2AiggASgCBBDqAiABQQA2AgwLIAEoAgwhACABQRBqJAAgAAtFAQF/IwBBEGsiASQAIAEgADYCDCABIAEoAgwQ3wI2AgggASgCCEUEQCABKAIMKAIcEN4CCyABKAIIIQAgAUEQaiQAIAAL4AgBAX8jAEEwayICJAAgAiAANgIoIAIgATYCJCACQQg2AiAgAkFxNgIcIAJBCTYCGCACQQA2AhQgAkGQgwE2AhAgAkE4NgIMIAJBATYCBAJAAkACQCACKAIQRQ0AIAIoAhAsAABBqOoALAAARw0AIAIoAgxBOEYNAQsgAkF6NgIsDAELIAIoAihFBEAgAkF+NgIsDAELIAIoAihBADYCGCACKAIoKAIgRQRAIAIoAihBBTYCICACKAIoQQA2AigLIAIoAigoAiRFBEAgAigCKEEGNgIkCyACKAIkQX9GBEAgAkEGNgIkCwJAIAIoAhxBAEgEQCACQQA2AgQgAkEAIAIoAhxrNgIcDAELIAIoAhxBD0oEQCACQQI2AgQgAiACKAIcQRBrNgIcCwsCQAJAIAIoAhhBAUgNACACKAIYQQlKDQAgAigCIEEIRw0AIAIoAhxBCEgNACACKAIcQQ9KDQAgAigCJEEASA0AIAIoAiRBCUoNACACKAIUQQBIDQAgAigCFEEESg0AIAIoAhxBCEcNASACKAIEQQFGDQELIAJBfjYCLAwBCyACKAIcQQhGBEAgAkEJNgIcCyACIAIoAigoAihBAUHELSACKAIoKAIgEQEANgIIIAIoAghFBEAgAkF8NgIsDAELIAIoAiggAigCCDYCHCACKAIIIAIoAig2AgAgAigCCEEqNgIEIAIoAgggAigCBDYCGCACKAIIQQA2AhwgAigCCCACKAIcNgIwIAIoAghBASACKAIIKAIwdDYCLCACKAIIIAIoAggoAixBAWs2AjQgAigCCCACKAIYQQdqNgJQIAIoAghBASACKAIIKAJQdDYCTCACKAIIIAIoAggoAkxBAWs2AlQgAigCCCACKAIIKAJQQQJqQQNuNgJYIAIoAigoAiggAigCCCgCLEECIAIoAigoAiARAQAhACACKAIIIAA2AjggAigCKCgCKCACKAIIKAIsQQIgAigCKCgCIBEBACEAIAIoAgggADYCQCACKAIoKAIoIAIoAggoAkxBAiACKAIoKAIgEQEAIQAgAigCCCAANgJEIAIoAghBADYCwC0gAigCCEEBIAIoAhhBBmp0NgKcLSACIAIoAigoAiggAigCCCgCnC1BBCACKAIoKAIgEQEANgIAIAIoAgggAigCADYCCCACKAIIIAIoAggoApwtQQJ0NgIMAkACQCACKAIIKAI4RQ0AIAIoAggoAkBFDQAgAigCCCgCREUNACACKAIIKAIIDQELIAIoAghBmgU2AgQgAigCKEHo1AAoAgA2AhggAigCKBCyARogAkF8NgIsDAELIAIoAgggAigCACACKAIIKAKcLUEBdkEBdGo2AqQtIAIoAgggAigCCCgCCCACKAIIKAKcLUEDbGo2ApgtIAIoAgggAigCJDYChAEgAigCCCACKAIUNgKIASACKAIIIAIoAiA6ACQgAiACKAIoEOACNgIsCyACKAIsIQAgAkEwaiQAIAALbAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEANgIEA0AgAiACKAIEIAIoAgxBAXFyNgIEIAIgAigCDEEBdjYCDCACIAIoAgRBAXQ2AgQgAiACKAIIQX9qIgA2AgggAEEASg0ACyACKAIEQQF2C5UCAQF/IwBBQGoiAyQAIAMgADYCPCADIAE2AjggAyACNgI0IANBADYCDCADQQE2AggDQCADKAIIQQ9KRQRAIAMgAygCDCADKAI0IAMoAghBAWtBAXRqLwEAakEBdDYCDCADQRBqIAMoAghBAXRqIAMoAgw7AQAgAyADKAIIQQFqNgIIDAELCyADQQA2AgQDQCADKAIEIAMoAjhMBEAgAyADKAI8IAMoAgRBAnRqLwECNgIAIAMoAgAEQCADQRBqIAMoAgBBAXRqIgEvAQAhACABIABBAWo7AQAgAEH//wNxIAMoAgAQ4gIhACADKAI8IAMoAgRBAnRqIAA7AQALIAMgAygCBEEBajYCBAwBCwsgA0FAayQAC4gIAQF/IwBBQGoiAiAANgI8IAIgATYCOCACIAIoAjgoAgA2AjQgAiACKAI4KAIENgIwIAIgAigCOCgCCCgCADYCLCACIAIoAjgoAggoAgQ2AiggAiACKAI4KAIIKAIINgIkIAIgAigCOCgCCCgCEDYCICACQQA2AgQgAkEANgIQA0AgAigCEEEPSkUEQCACKAI8QbwWaiACKAIQQQF0akEAOwEAIAIgAigCEEEBajYCEAwBCwsgAigCNCACKAI8QdwWaiACKAI8KALUKEECdGooAgBBAnRqQQA7AQIgAiACKAI8KALUKEEBajYCHANAIAIoAhxBvQRIBEAgAiACKAI8QdwWaiACKAIcQQJ0aigCADYCGCACIAIoAjQgAigCNCACKAIYQQJ0ai8BAkECdGovAQJBAWo2AhAgAigCECACKAIgSgRAIAIgAigCIDYCECACIAIoAgRBAWo2AgQLIAIoAjQgAigCGEECdGogAigCEDsBAiACKAIYIAIoAjBMBEAgAigCPCACKAIQQQF0akG8FmoiACAALwEAQQFqOwEAIAJBADYCDCACKAIYIAIoAiROBEAgAiACKAIoIAIoAhggAigCJGtBAnRqKAIANgIMCyACIAIoAjQgAigCGEECdGovAQA7AQogAigCPCIAIAAoAqgtIAIvAQogAigCECACKAIMamxqNgKoLSACKAIsBEAgAigCPCIAIAAoAqwtIAIvAQogAigCLCACKAIYQQJ0ai8BAiACKAIMamxqNgKsLQsLIAIgAigCHEEBajYCHAwBCwsCQCACKAIERQ0AA0AgAiACKAIgQQFrNgIQA0AgAigCPEG8FmogAigCEEEBdGovAQBFBEAgAiACKAIQQX9qNgIQDAELCyACKAI8IAIoAhBBAXRqQbwWaiIAIAAvAQBBf2o7AQAgAigCPCACKAIQQQF0akG+FmoiACAALwEAQQJqOwEAIAIoAjwgAigCIEEBdGpBvBZqIgAgAC8BAEF/ajsBACACIAIoAgRBAms2AgQgAigCBEEASg0ACyACIAIoAiA2AhADQCACKAIQRQ0BIAIgAigCPEG8FmogAigCEEEBdGovAQA2AhgDQCACKAIYBEAgAigCPEHcFmohACACIAIoAhxBf2oiATYCHCACIAFBAnQgAGooAgA2AhQgAigCFCACKAIwSg0BIAIoAjQgAigCFEECdGovAQIgAigCEEcEQCACKAI8IgAgACgCqC0gAigCNCACKAIUQQJ0ai8BACACKAIQIAIoAjQgAigCFEECdGovAQJrbGo2AqgtIAIoAjQgAigCFEECdGogAigCEDsBAgsgAiACKAIYQX9qNgIYDAELCyACIAIo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KAIMIAEoAgxB/BRqNgKwFiABKAIMQajbADYCuBYgASgCDEEAOwG4LSABKAIMQQA2ArwtIAEoAgwQuQEgAUEQaiQAC9cNAQF/IwBBIGsiAyAANgIYIAMgATYCFCADIAI2AhAgAyADKAIYQRB2NgIMIAMgAygCGEH//wNxNgIYAkAgAygCEEEBRgRAIAMgAygCFC0AACADKAIYajYCGCADKAIYQfH/A08EQCADIAMoAhhB8f8DazYCGAsgAyADKAIYIAMoAgxqNgIMIAMoAgxB8f8DTwRAIAMgAygCDEHx/wNrNgIMCyADIAMoAhggAygCDEEQdHI2AhwMAQsgAygCFEUEQCADQQE2AhwMAQsgAygCEEEQSQRAA0AgAyADKAIQIgBBf2o2AhAgAARAIAMgAygCFCIAQQFqNgIUIAMgAC0AACADKAIYajYCGCADIAMoAhggAygCDGo2AgwMAQsLIAMoAhhB8f8DTwRAIAMgAygCGEHx/wNrNgIYCyADIAMoAgxB8f8DcDYCDCADIAMoAhggAygCDEEQdHI2AhwMAQsDQCADKAIQQbArSUUEQCADIAMoAhBBsCtrNgIQIANB2wI2AggDQCADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFCADIAMoAghBf2oiADYCCCAADQALIAMgAygCGEHx/wNwNgIYIAMgAygCDEHx/wNwNgIMDAELCyADKAIQBEADQCADKAIQQRBJRQRAIAMgAygCEEEQazYCECADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFAwBCwsDQCADIAMoAhAiAEF/ajYCECAABEAgAyADKAIUIgBBAWo2AhQgAyAALQAAIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDAwBCwsgAyADKAIYQfH/A3A2AhggAyADKAIMQfH/A3A2AgwLIAMgAygC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KAIEDAELIAMoAgwoAgALQYAEEF4iADYCECAAQQBIBEAgA0J/NwO4AQwDCyADKAIQBEAgA0EBOgAXCyADIAMpAxhCAXw3AxgMAQsLIAMgAygCtAEoAgAQNSICNwMgIAJCAFMEQCADKAK0AUEIaiADKAK0ASgCABAYIANCfzcDuAEMAQsgAyADKQMgIAMpA6ABfTcDmAECQCADKQOgAUL/////D1gEQCADKQOoAUL//wNYDQELIANBAToAFwsgAyADQTBqQuIAECoiADYCLCAARQRAIAMoArQBQQhqQQ5BABAVIANCfzcDuAEMAQsgAy0AF0EBcQRAIAMoAixBttMAQQQQQCADKAIsQiwQLiADKAIsQS0QICADKAIsQS0QICADKAIsQQAQISADKAIsQQAQISADKAIsIAMpA6gBEC4gAygCLCADKQOoARAuIAMoAiwgAykDmAEQLiADKAIsIAMpA6ABEC4gAygCLEG70wBBBBBAIAMoAixBABAhIAMoAiwgAykDoAEgAykDmAF8EC4gAygCLEEBECELIAMoAixBwNMAQQQQQCADKAIsQQAQISADKAIsAn5C//8DIAMpA6gBQv//A1oNABogAykDqAELp0H//wNxECAgAygCLAJ+Qv//AyADKQOoAUL//wNaDQAaIAMpA6gBC6dB//8DcRAgIAMoAiwCf0F/IAMpA5gBQv////8PWg0AGiADKQOYAacLECEgAygCLAJ/QX8gAykDoAFC/////w9aDQAaIAMpA6ABpwsQISADAn8gAygCtAEtAChBAXEEQCADKAK0ASgCJAwBCyADKAK0ASgCIAs2ApQBIAMoAiwCfyADKAKUAQRAIAMoApQBLwEEDAELQQALQf//A3EQIAJ/IwBBEGsiACADKAIsNgIMIAAoAgwtAABBAXFFCwRAIAMoArQBQQhqQRRBABAVIAMoAiwQFyADQn83A7gBDAELIAMoArQBAn8jAEEQayIAIAMoAiw2AgwgACgCDCgCBAsCfiMAQRBrIgAgAygCLDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALCxA2QQBIBEAgAygCLBAXIANCfzcDuAEMAQsgAygCLBAXIAMoApQBBEAgAygCtAEgAygClAEoAgAgAygClAEvAQStEDZBAEgEQCADQn83A7gBDAILCyADIAMpA5gBNwO4AQsgAykDuAEhAiADQcABaiQAIAILBwAgACgCIAsIAEEBQTgQewsDAAELC/KNAScAQYAIC5QFTm8gZXJyb3IATXVsdGktZGlzayB6aXAgYXJjaGl2ZXMgbm90IHN1cHBvcnRlZABSZW5hbWluZyB0ZW1wb3JhcnkgZmlsZSBmYWlsZWQAQ2xvc2luZyB6aXAgYXJjaGl2ZSBmYWlsZWQAU2VlayBlcnJvcgBSZWFkIGVycm9yAFdyaXRlIGVycm9yAENSQyBlcnJvcgBDb250YWluaW5nIHppcCBhcmNoaXZlIHdhcyBjbG9zZWQATm8gc3VjaCBmaWxlAEZpbGUgYWxyZWFkeSBleGlzdHMAQ2FuJ3Qgb3BlbiBmaWxlAEZhaWx1cmUgdG8gY3JlYXRlIHRlbXBvcmFyeSBmaWxlAFpsaWIgZXJyb3IATWFsbG9jIGZhaWx1cmUARW50cnkgaGFzIGJlZW4gY2hhbmdlZABDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABQcmVtYXR1cmUgZW5kIG9mIGZpbGUASW52YWxpZCBhcmd1bWVudABOb3QgYSB6aXAgYXJjaGl2ZQBJbnRlcm5hbCBlcnJvcgBaaXAgYXJjaGl2ZSBpbmNvbnNpc3RlbnQAQ2FuJ3QgcmVtb3ZlIGZpbGUARW50cnkgaGFzIGJlZW4gZGVsZXRlZABFbmNyeXB0aW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkAFJlYWQtb25seSBhcmNoaXZlAE5vIHBhc3N3b3JkIHByb3ZpZGVkAFdyb25nIHBhc3N3b3JkIHByb3ZpZGVkAE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkAFJlc291cmNlIHN0aWxsIGluIHVzZQBUZWxsIGVycm9yAENvbXByZXNzZWQgZGF0YSBpbnZhbGlkAEGhDQuAAQQAAAkEAAAvBAAATgQAAGkEAAB0BAAAfwQAAIsEAACVBAAAtwQAAMQEAADYBAAA6AQAAAkFAAAUBQAAIwUAADoFAABbBQAAcQUAAIIFAACUBQAAowUAALwFAADOBQAA5QUAAAUGAAAXBgAALAYAAEQGAABcBgAAcgYAAH0GAAAgAEG4DgsRAQAAAAEAAAABAAAAAQAAAAEAQdwOCwkBAAAAAQAAAAIAQYgPCwEBAEGoDwsB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CAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYACAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgA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cnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAFVua25vd24gZXJyb3IgJWQAJXMlcyVzAAA6IAAvcHJvYy9zZWxmL2ZkLwAvZGV2L3VyYW5kb20AcndhACVzLlhYWFhYWAByK2IAcmIAUEsFBgBBkJgBC04KAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAARAAAAAQAAAAgAAAAQTAAAMEwAQZCaAQsCgFAAQciaAQsJHwAAAGRNAAADAEHkmgELjAEt9FFYz4yxwEb2tcspMQPHBFtwMLRd/SB4f4ua2FkpUGhIiaunVgNs/7fNiD/Ud7QrpaNw8brkqPxBg/3Zb+GKei8tdJYHHw0JXgN2LHD3QKUsp29XQaiqdN+gWGQDSsfEPFOur18YBBWx420ohqsMpL9D8OlQgTlXFlI3/////////////////////w==";
    if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
    }
    function getBinary() {
      try {
        if (wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        var binary = tryParseAsDataURI(wasmBinaryFile);
        if (binary) {
          return binary;
        }
        if (readBinary) {
          return readBinary(wasmBinaryFile);
        } else {
          throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
        }
      } catch (err2) {
        abort(err2);
      }
    }
    function createWasm() {
      var info = {a: asmLibraryArg};
      function receiveInstance(instance, module3) {
        var exports4 = instance.exports;
        Module3["asm"] = exports4;
        removeRunDependency("wasm-instantiate");
      }
      addRunDependency("wasm-instantiate");
      function instantiateSync() {
        var instance;
        var module3;
        var binary;
        try {
          binary = getBinary();
          module3 = new WebAssembly.Module(binary);
          instance = new WebAssembly.Instance(module3, info);
        } catch (e) {
          var str = e.toString();
          err("failed to compile wasm module: " + str);
          if (str.indexOf("imported Memory") >= 0 || str.indexOf("memory import") >= 0) {
            err("Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time).");
          }
          throw e;
        }
        receiveInstance(instance, module3);
      }
      if (Module3["instantiateWasm"]) {
        try {
          var exports3 = Module3["instantiateWasm"](info, receiveInstance);
          return exports3;
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          return false;
        }
      }
      instantiateSync();
      return Module3["asm"];
    }
    var tempDouble;
    var tempI64;
    __ATINIT__.push({
      func: function() {
        ___wasm_call_ctors();
      }
    });
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == "function") {
          callback(Module3);
          continue;
        }
        var func = callback.func;
        if (typeof func === "number") {
          if (callback.arg === void 0) {
            wasmTable.get(func)();
          } else {
            wasmTable.get(func)(callback.arg);
          }
        } else {
          func(callback.arg === void 0 ? null : callback.arg);
        }
      }
    }
    function demangle(func) {
      return func;
    }
    function demangleAll(text) {
      var regex = /\b_Z[\w\d_]+/g;
      return text.replace(regex, function(x) {
        var y = demangle(x);
        return x === y ? x : y + " [" + x + "]";
      });
    }
    function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        try {
          throw new Error();
        } catch (e) {
          error = e;
        }
        if (!error.stack) {
          return "(no stack trace available)";
        }
      }
      return error.stack.toString();
    }
    function stackTrace() {
      var js = jsStackTrace();
      if (Module3["extraStackTrace"])
        js += "\n" + Module3["extraStackTrace"]();
      return demangleAll(js);
    }
    function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[time >> 2] * 1e3);
      HEAP32[tmPtr >> 2] = date.getUTCSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      HEAP32[tmPtr + 36 >> 2] = 0;
      HEAP32[tmPtr + 32 >> 2] = 0;
      var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      if (!_gmtime_r.GMTString)
        _gmtime_r.GMTString = allocateUTF8("GMT");
      HEAP32[tmPtr + 40 >> 2] = _gmtime_r.GMTString;
      return tmPtr;
    }
    function ___gmtime_r(a0, a1) {
      return _gmtime_r(a0, a1);
    }
    var PATH = {
      splitPath: function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: function(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: function(path6) {
        var isAbsolute = path6.charAt(0) === "/", trailingSlash = path6.substr(-1) === "/";
        path6 = PATH.normalizeArray(path6.split("/").filter(function(p) {
          return !!p;
        }), !isAbsolute).join("/");
        if (!path6 && !isAbsolute) {
          path6 = ".";
        }
        if (path6 && trailingSlash) {
          path6 += "/";
        }
        return (isAbsolute ? "/" : "") + path6;
      },
      dirname: function(path6) {
        var result = PATH.splitPath(path6), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: function(path6) {
        if (path6 === "/")
          return "/";
        path6 = PATH.normalize(path6);
        path6 = path6.replace(/\/$/, "");
        var lastSlash = path6.lastIndexOf("/");
        if (lastSlash === -1)
          return path6;
        return path6.substr(lastSlash + 1);
      },
      extname: function(path6) {
        return PATH.splitPath(path6)[3];
      },
      join: function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      },
      join2: function(l, r) {
        return PATH.normalize(l + "/" + r);
      }
    };
    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }
    var PATH_FS = {
      resolve: function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path6 = i >= 0 ? arguments[i] : FS.cwd();
          if (typeof path6 !== "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path6) {
            return "";
          }
          resolvedPath = path6 + "/" + resolvedPath;
          resolvedAbsolute = path6.charAt(0) === "/";
        }
        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start2 = 0;
          for (; start2 < arr.length; start2++) {
            if (arr[start2] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start2 > end)
            return [];
          return arr.slice(start2, end - start2 + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    var TTY = {
      ttys: [],
      init: function() {
      },
      shutdown: function() {
      },
      register: function(dev, ops) {
        TTY.ttys[dev] = {input: [], output: [], ops};
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        },
        flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        },
        read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      },
      default_tty_ops: {
        get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().indexOf("EOF") != -1)
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      },
      default_tty1_ops: {
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      }
    };
    var MEMFS = {
      ops_table: null,
      mount: function(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode: function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {llseek: MEMFS.stream_ops.llseek}
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },
      getFileDataAsRegularArray: function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i)
            arr.push(node.contents[i]);
          return arr;
        }
        return node.contents;
      },
      getFileDataAsTypedArray: function(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        return;
      },
      resizeFileStorage: function(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }
          node.usedBytes = newSize;
          return;
        }
        if (!node.contents)
          node.contents = [];
        if (node.contents.length > newSize)
          node.contents.length = newSize;
        else
          while (node.contents.length < newSize)
            node.contents.push(0);
        node.usedBytes = newSize;
      },
      node_ops: {
        getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function(parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },
        unlink: function(parent, name) {
          delete parent.contents[name];
        },
        rmdir: function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
        },
        readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        },
        symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        },
        write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
        mmap: function(stream, address, length, position, prot, flags) {
          assert(address === 0);
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = FS.mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return {ptr, allocated};
        },
        msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        }
      }
    };
    var ERRNO_CODES = {
      EPERM: 63,
      ENOENT: 44,
      ESRCH: 71,
      EINTR: 27,
      EIO: 29,
      ENXIO: 60,
      E2BIG: 1,
      ENOEXEC: 45,
      EBADF: 8,
      ECHILD: 12,
      EAGAIN: 6,
      EWOULDBLOCK: 6,
      ENOMEM: 48,
      EACCES: 2,
      EFAULT: 21,
      ENOTBLK: 105,
      EBUSY: 10,
      EEXIST: 20,
      EXDEV: 75,
      ENODEV: 43,
      ENOTDIR: 54,
      EISDIR: 31,
      EINVAL: 28,
      ENFILE: 41,
      EMFILE: 33,
      ENOTTY: 59,
      ETXTBSY: 74,
      EFBIG: 22,
      ENOSPC: 51,
      ESPIPE: 70,
      EROFS: 69,
      EMLINK: 34,
      EPIPE: 64,
      EDOM: 18,
      ERANGE: 68,
      ENOMSG: 49,
      EIDRM: 24,
      ECHRNG: 106,
      EL2NSYNC: 156,
      EL3HLT: 107,
      EL3RST: 108,
      ELNRNG: 109,
      EUNATCH: 110,
      ENOCSI: 111,
      EL2HLT: 112,
      EDEADLK: 16,
      ENOLCK: 46,
      EBADE: 113,
      EBADR: 114,
      EXFULL: 115,
      ENOANO: 104,
      EBADRQC: 103,
      EBADSLT: 102,
      EDEADLOCK: 16,
      EBFONT: 101,
      ENOSTR: 100,
      ENODATA: 116,
      ETIME: 117,
      ENOSR: 118,
      ENONET: 119,
      ENOPKG: 120,
      EREMOTE: 121,
      ENOLINK: 47,
      EADV: 122,
      ESRMNT: 123,
      ECOMM: 124,
      EPROTO: 65,
      EMULTIHOP: 36,
      EDOTDOT: 125,
      EBADMSG: 9,
      ENOTUNIQ: 126,
      EBADFD: 127,
      EREMCHG: 128,
      ELIBACC: 129,
      ELIBBAD: 130,
      ELIBSCN: 131,
      ELIBMAX: 132,
      ELIBEXEC: 133,
      ENOSYS: 52,
      ENOTEMPTY: 55,
      ENAMETOOLONG: 37,
      ELOOP: 32,
      EOPNOTSUPP: 138,
      EPFNOSUPPORT: 139,
      ECONNRESET: 15,
      ENOBUFS: 42,
      EAFNOSUPPORT: 5,
      EPROTOTYPE: 67,
      ENOTSOCK: 57,
      ENOPROTOOPT: 50,
      ESHUTDOWN: 140,
      ECONNREFUSED: 14,
      EADDRINUSE: 3,
      ECONNABORTED: 13,
      ENETUNREACH: 40,
      ENETDOWN: 38,
      ETIMEDOUT: 73,
      EHOSTDOWN: 142,
      EHOSTUNREACH: 23,
      EINPROGRESS: 26,
      EALREADY: 7,
      EDESTADDRREQ: 17,
      EMSGSIZE: 35,
      EPROTONOSUPPORT: 66,
      ESOCKTNOSUPPORT: 137,
      EADDRNOTAVAIL: 4,
      ENETRESET: 39,
      EISCONN: 30,
      ENOTCONN: 53,
      ETOOMANYREFS: 141,
      EUSERS: 136,
      EDQUOT: 19,
      ESTALE: 72,
      ENOTSUP: 138,
      ENOMEDIUM: 148,
      EILSEQ: 25,
      EOVERFLOW: 61,
      ECANCELED: 11,
      ENOTRECOVERABLE: 56,
      EOWNERDEAD: 62,
      ESTRPIPE: 135
    };
    var NODEFS = {
      isWindows: false,
      staticInit: function() {
        NODEFS.isWindows = !!process.platform.match(/^win/);
        var flags = {fs: fs9.constants};
        if (flags["fs"]) {
          flags = flags["fs"];
        }
        NODEFS.flagsForNodeMap = {
          1024: flags["O_APPEND"],
          64: flags["O_CREAT"],
          128: flags["O_EXCL"],
          0: flags["O_RDONLY"],
          2: flags["O_RDWR"],
          4096: flags["O_SYNC"],
          512: flags["O_TRUNC"],
          1: flags["O_WRONLY"]
        };
      },
      bufferFrom: function(arrayBuffer) {
        return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
      },
      convertNodeCode: function(e) {
        var code = e.code;
        return ERRNO_CODES[code];
      },
      mount: function(mount) {
        return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
      },
      createNode: function(parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },
      getMode: function(path6) {
        var stat;
        try {
          stat = fs9.lstatSync(path6);
          if (NODEFS.isWindows) {
            stat.mode = stat.mode | (stat.mode & 292) >> 2;
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return stat.mode;
      },
      realPath: function(node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },
      flagsForNode: function(flags) {
        flags &= ~2097152;
        flags &= ~2048;
        flags &= ~32768;
        flags &= ~524288;
        var newFlags = 0;
        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }
        if (!flags) {
          return newFlags;
        } else {
          throw new FS.ErrnoError(28);
        }
      },
      node_ops: {
        getattr: function(node) {
          var path6 = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs9.lstatSync(path6);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },
        setattr: function(node, attr) {
          var path6 = NODEFS.realPath(node);
          try {
            if (attr.mode !== void 0) {
              fs9.chmodSync(path6, attr.mode);
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              var date = new Date(attr.timestamp);
              fs9.utimesSync(path6, date, date);
            }
            if (attr.size !== void 0) {
              fs9.truncateSync(path6, attr.size);
            }
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        lookup: function(parent, name) {
          var path6 = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path6);
          return NODEFS.createNode(parent, name, mode);
        },
        mknod: function(parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          var path6 = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs9.mkdirSync(path6, node.mode);
            } else {
              fs9.writeFileSync(path6, "", {mode: node.mode});
            }
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          return node;
        },
        rename: function(oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs9.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          oldNode.name = newName;
        },
        unlink: function(parent, name) {
          var path6 = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs9.unlinkSync(path6);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        rmdir: function(parent, name) {
          var path6 = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs9.rmdirSync(path6);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        readdir: function(node) {
          var path6 = NODEFS.realPath(node);
          try {
            return fs9.readdirSync(path6);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        symlink: function(parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs9.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        readlink: function(node) {
          var path6 = NODEFS.realPath(node);
          try {
            path6 = fs9.readlinkSync(path6);
            path6 = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path6);
            return path6;
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }
      },
      stream_ops: {
        open: function(stream) {
          var path6 = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs9.openSync(path6, NODEFS.flagsForNode(stream.flags));
            }
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        close: function(stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs9.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        read: function(stream, buffer2, offset, length, position) {
          if (length === 0)
            return 0;
          try {
            return fs9.readSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        write: function(stream, buffer2, offset, length, position) {
          try {
            return fs9.writeSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },
        llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs9.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        mmap: function(stream, address, length, position, prot, flags) {
          assert(address === 0);
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr = FS.mmapAlloc(length);
          NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
          return {ptr, allocated: true};
        },
        msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          var bytesWritten = NODEFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        }
      }
    };
    var NODERAWFS = {
      lookupPath: function(path6) {
        return {path: path6, node: {mode: NODEFS.getMode(path6)}};
      },
      createStandardStreams: function() {
        FS.streams[0] = {
          fd: 0,
          nfd: 0,
          position: 0,
          path: "",
          flags: 0,
          tty: true,
          seekable: false
        };
        for (var i = 1; i < 3; i++) {
          FS.streams[i] = {
            fd: i,
            nfd: i,
            position: 0,
            path: "",
            flags: 577,
            tty: true,
            seekable: false
          };
        }
      },
      cwd: function() {
        return process.cwd();
      },
      chdir: function() {
        process.chdir.apply(void 0, arguments);
      },
      mknod: function(path6, mode) {
        if (FS.isDir(path6)) {
          fs9.mkdirSync(path6, mode);
        } else {
          fs9.writeFileSync(path6, "", {mode});
        }
      },
      mkdir: function() {
        fs9.mkdirSync.apply(void 0, arguments);
      },
      symlink: function() {
        fs9.symlinkSync.apply(void 0, arguments);
      },
      rename: function() {
        fs9.renameSync.apply(void 0, arguments);
      },
      rmdir: function() {
        fs9.rmdirSync.apply(void 0, arguments);
      },
      readdir: function() {
        fs9.readdirSync.apply(void 0, arguments);
      },
      unlink: function() {
        fs9.unlinkSync.apply(void 0, arguments);
      },
      readlink: function() {
        return fs9.readlinkSync.apply(void 0, arguments);
      },
      stat: function() {
        return fs9.statSync.apply(void 0, arguments);
      },
      lstat: function() {
        return fs9.lstatSync.apply(void 0, arguments);
      },
      chmod: function() {
        fs9.chmodSync.apply(void 0, arguments);
      },
      fchmod: function() {
        fs9.fchmodSync.apply(void 0, arguments);
      },
      chown: function() {
        fs9.chownSync.apply(void 0, arguments);
      },
      fchown: function() {
        fs9.fchownSync.apply(void 0, arguments);
      },
      truncate: function() {
        fs9.truncateSync.apply(void 0, arguments);
      },
      ftruncate: function() {
        fs9.ftruncateSync.apply(void 0, arguments);
      },
      utime: function() {
        fs9.utimesSync.apply(void 0, arguments);
      },
      open: function(path6, flags, mode, suggestFD) {
        if (typeof flags === "string") {
          flags = VFS.modeStringToFlags(flags);
        }
        var nfd = fs9.openSync(path6, NODEFS.flagsForNode(flags), mode);
        var fd = suggestFD != null ? suggestFD : FS.nextfd(nfd);
        var stream = {
          fd,
          nfd,
          position: 0,
          path: path6,
          flags,
          seekable: true
        };
        FS.streams[fd] = stream;
        return stream;
      },
      close: function(stream) {
        if (!stream.stream_ops) {
          fs9.closeSync(stream.nfd);
        }
        FS.closeStream(stream.fd);
      },
      llseek: function(stream, offset, whence) {
        if (stream.stream_ops) {
          return VFS.llseek(stream, offset, whence);
        }
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          position += fs9.fstatSync(stream.nfd).size;
        } else if (whence !== 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        stream.position = position;
        return position;
      },
      read: function(stream, buffer2, offset, length, position) {
        if (stream.stream_ops) {
          return VFS.read(stream, buffer2, offset, length, position);
        }
        var seeking = typeof position !== "undefined";
        if (!seeking && stream.seekable)
          position = stream.position;
        var bytesRead = fs9.readSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      },
      write: function(stream, buffer2, offset, length, position) {
        if (stream.stream_ops) {
          return VFS.write(stream, buffer2, offset, length, position);
        }
        if (stream.flags & +"1024") {
          FS.llseek(stream, 0, +"2");
        }
        var seeking = typeof position !== "undefined";
        if (!seeking && stream.seekable)
          position = stream.position;
        var bytesWritten = fs9.writeSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
        if (!seeking)
          stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: function() {
        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
      },
      mmap: function() {
        throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
      },
      msync: function() {
        return 0;
      },
      munmap: function() {
        return 0;
      },
      ioctl: function() {
        throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
      }
    };
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      trackingDelegate: {},
      tracking: {openFlags: {READ: 1, WRITE: 2}},
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      handleFSError: function(e) {
        if (!(e instanceof FS.ErrnoError))
          throw e + " : " + stackTrace();
        return setErrNo(e.errno);
      },
      lookupPath: function(path6, opts) {
        path6 = PATH_FS.resolve(FS.cwd(), path6);
        opts = opts || {};
        if (!path6)
          return {path: "", node: null};
        var defaults = {follow_mount: true, recurse_count: 0};
        for (var key2 in defaults) {
          if (opts[key2] === void 0) {
            opts[key2] = defaults[key2];
          }
        }
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = PATH.normalizeArray(path6.split("/").filter(function(p) {
          return !!p;
        }), false);
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return {path: current_path, node: current};
      },
      getPath: function(node) {
        var path6;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path6)
              return mount;
            return mount[mount.length - 1] !== "/" ? mount + "/" + path6 : mount + path6;
          }
          path6 = path6 ? node.name + "/" + path6 : node.name;
          node = node.parent;
        }
      },
      hashName: function(parentid, name) {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode: function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode: function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode: function(node) {
        FS.hashRemoveNode(node);
      },
      isRoot: function(node) {
        return node === node.parent;
      },
      isMountpoint: function(node) {
        return !!node.mounted;
      },
      isFile: function(mode) {
        return (mode & 61440) === 32768;
      },
      isDir: function(mode) {
        return (mode & 61440) === 16384;
      },
      isLink: function(mode) {
        return (mode & 61440) === 40960;
      },
      isChrdev: function(mode) {
        return (mode & 61440) === 8192;
      },
      isBlkdev: function(mode) {
        return (mode & 61440) === 24576;
      },
      isFIFO: function(mode) {
        return (mode & 61440) === 4096;
      },
      isSocket: function(mode) {
        return (mode & 49152) === 49152;
      },
      flagModes: {
        r: 0,
        rs: 1052672,
        "r+": 2,
        w: 577,
        wx: 705,
        xw: 705,
        "w+": 578,
        "wx+": 706,
        "xw+": 706,
        a: 1089,
        ax: 1217,
        xa: 1217,
        "a+": 1090,
        "ax+": 1218,
        "xa+": 1218
      },
      modeStringToFlags: function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }
        return flags;
      },
      flagsToPermissionString: function(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions: function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: function(dir) {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      },
      mayCreate: function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete: function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: function(fd) {
        return FS.streams[fd];
      },
      createStream: function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function() {
          };
          FS.FSStream.prototype = {
            object: {
              get: function() {
                return this.node;
              },
              set: function(val) {
                this.node = val;
              }
            },
            isRead: {
              get: function() {
                return (this.flags & 2097155) !== 1;
              }
            },
            isWrite: {
              get: function() {
                return (this.flags & 2097155) !== 0;
              }
            },
            isAppend: {
              get: function() {
                return this.flags & 1024;
              }
            }
          };
        }
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: function(fd) {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: function() {
          throw new FS.ErrnoError(70);
        }
      },
      major: function(dev) {
        return dev >> 8;
      },
      minor: function(dev) {
        return dev & 255;
      },
      makedev: function(ma, mi) {
        return ma << 8 | mi;
      },
      registerDevice: function(dev, ops) {
        FS.devices[dev] = {stream_ops: ops};
      },
      getDevice: function(dev) {
        return FS.devices[dev];
      },
      getMounts: function(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push.apply(check, m.mounts);
        }
        return mounts;
      },
      syncfs: function(populate, callback) {
        if (typeof populate === "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach(function(mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: function(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, {follow_mount: false});
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {type, opts, mountpoint, mounts: []};
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount: function(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, {follow_mount: false});
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach(function(hash) {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: function(path6, mode, dev) {
        var lookup = FS.lookupPath(path6, {parent: true});
        var parent = lookup.node;
        var name = PATH.basename(path6);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: function(path6, mode) {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path6, mode, 0);
      },
      mkdir: function(path6, mode) {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path6, mode, 0);
      },
      mkdirTree: function(path6, mode) {
        var dirs = path6.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i])
            continue;
          d += "/" + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20)
              throw e;
          }
        }
      },
      mkdev: function(path6, mode, dev) {
        if (typeof dev === "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path6, mode, dev);
      },
      symlink: function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, {parent: true});
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, {parent: true});
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, {parent: true});
        new_dir = lookup.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate["willMovePath"]) {
            FS.trackingDelegate["willMovePath"](old_path, new_path);
          }
        } catch (e) {
          err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate["onMovePath"])
            FS.trackingDelegate["onMovePath"](old_path, new_path);
        } catch (e) {
          err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
        }
      },
      rmdir: function(path6) {
        var lookup = FS.lookupPath(path6, {parent: true});
        var parent = lookup.node;
        var name = PATH.basename(path6);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path6);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path6 + "') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate["onDeletePath"])
            FS.trackingDelegate["onDeletePath"](path6);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path6 + "') threw an exception: " + e.message);
        }
      },
      readdir: function(path6) {
        var lookup = FS.lookupPath(path6, {follow: true});
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: function(path6) {
        var lookup = FS.lookupPath(path6, {parent: true});
        var parent = lookup.node;
        var name = PATH.basename(path6);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate["willDeletePath"]) {
            FS.trackingDelegate["willDeletePath"](path6);
          }
        } catch (e) {
          err("FS.trackingDelegate['willDeletePath']('" + path6 + "') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate["onDeletePath"])
            FS.trackingDelegate["onDeletePath"](path6);
        } catch (e) {
          err("FS.trackingDelegate['onDeletePath']('" + path6 + "') threw an exception: " + e.message);
        }
      },
      readlink: function(path6) {
        var lookup = FS.lookupPath(path6);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },
      stat: function(path6, dontFollow) {
        var lookup = FS.lookupPath(path6, {follow: !dontFollow});
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: function(path6) {
        return FS.stat(path6, true);
      },
      chmod: function(path6, mode, dontFollow) {
        var node;
        if (typeof path6 === "string") {
          var lookup = FS.lookupPath(path6, {follow: !dontFollow});
          node = lookup.node;
        } else {
          node = path6;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod: function(path6, mode) {
        FS.chmod(path6, mode, true);
      },
      fchmod: function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: function(path6, uid, gid, dontFollow) {
        var node;
        if (typeof path6 === "string") {
          var lookup = FS.lookupPath(path6, {follow: !dontFollow});
          node = lookup.node;
        } else {
          node = path6;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {timestamp: Date.now()});
      },
      lchown: function(path6, uid, gid) {
        FS.chown(path6, uid, gid, true);
      },
      fchown: function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: function(path6, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path6 === "string") {
          var lookup = FS.lookupPath(path6, {follow: true});
          node = lookup.node;
        } else {
          node = path6;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {size: len, timestamp: Date.now()});
      },
      ftruncate: function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: function(path6, atime, mtime) {
        var lookup = FS.lookupPath(path6, {follow: true});
        var node = lookup.node;
        node.node_ops.setattr(node, {timestamp: Math.max(atime, mtime)});
      },
      open: function(path6, flags, mode, fd_start, fd_end) {
        if (path6 === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === "undefined" ? 438 : mode;
        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path6 === "object") {
          node = path6;
        } else {
          path6 = PATH.normalize(path6);
          try {
            var lookup = FS.lookupPath(path6, {follow: !(flags & 131072)});
            node = lookup.node;
          } catch (e) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path6, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module3["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles)
            FS.readFiles = {};
          if (!(path6 in FS.readFiles)) {
            FS.readFiles[path6] = 1;
            err("FS.trackingDelegate error on read file: " + path6);
          }
        }
        try {
          if (FS.trackingDelegate["onOpenFile"]) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate["onOpenFile"](path6, trackingFlags);
          }
        } catch (e) {
          err("FS.trackingDelegate['onOpenFile']('" + path6 + "', flags) threw an exception: " + e.message);
        }
        return stream;
      },
      close: function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents)
          stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: function(stream) {
        return stream.fd === null;
      },
      llseek: function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: function(stream, buffer2, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      },
      write: function(stream, buffer2, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
        if (!seeking)
          stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate["onWriteToFile"])
            FS.trackingDelegate["onWriteToFile"](stream.path);
        } catch (e) {
          err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
        }
        return bytesWritten;
      },
      allocate: function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: function(stream, address, length, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },
      msync: function(stream, buffer2, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
      },
      munmap: function(stream) {
        return 0;
      },
      ioctl: function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: function(path6, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "r";
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path6, opts.flags);
        var stat = FS.stat(path6);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: function(path6, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "w";
        var stream = FS.open(path6, opts.flags, opts.mode);
        if (typeof data === "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: function() {
        return FS.currentPath;
      },
      chdir: function(path6) {
        var lookup = FS.lookupPath(path6, {follow: true});
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: function() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices: function() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() {
            return 0;
          },
          write: function(stream, buffer2, offset, length, pos) {
            return length;
          }
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device;
        if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
          var randomBuffer = new Uint8Array(1);
          random_device = function() {
            crypto.getRandomValues(randomBuffer);
            return randomBuffer[0];
          };
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require("crypto");
            random_device = function() {
              return crypto_module["randomBytes"](1)[0];
            };
          } catch (e) {
          }
        } else {
        }
        if (!random_device) {
          random_device = function() {
            abort("random_device");
          };
        }
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories: function() {
        FS.mkdir("/proc");
        FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({
          mount: function() {
            var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream)
                  throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: {mountpoint: "fake"},
                  node_ops: {
                    readlink: function() {
                      return stream.path;
                    }
                  }
                };
                ret.parent = ret;
                return ret;
              }
            };
            return node;
          }
        }, {}, "/proc/self/fd");
      },
      createStandardStreams: function() {
        if (Module3["stdin"]) {
          FS.createDevice("/dev", "stdin", Module3["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (Module3["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module3["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (Module3["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module3["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", "r");
        var stdout = FS.open("/dev/stdout", "w");
        var stderr = FS.open("/dev/stderr", "w");
      },
      ensureErrnoError: function() {
        if (FS.ErrnoError)
          return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno2) {
            this.errno = errno2;
          };
          this.setErrno(errno);
          this.message = "FS error";
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      },
      staticInit: function() {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {MEMFS, NODEFS};
      },
      init: function(input, output, error) {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module3["stdin"] = input || Module3["stdin"];
        Module3["stdout"] = output || Module3["stdout"];
        Module3["stderr"] = error || Module3["stderr"];
        FS.createStandardStreams();
      },
      quit: function() {
        FS.init.initialized = false;
        var fflush = Module3["_fflush"];
        if (fflush)
          fflush(0);
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: function(canRead, canWrite) {
        var mode = 0;
        if (canRead)
          mode |= 292 | 73;
        if (canWrite)
          mode |= 146;
        return mode;
      },
      joinPath: function(parts, forceRelative) {
        var path6 = PATH.join.apply(null, parts);
        if (forceRelative && path6[0] == "/")
          path6 = path6.substr(1);
        return path6;
      },
      absolutePath: function(relative, base) {
        return PATH_FS.resolve(base, relative);
      },
      standardizePath: function(path6) {
        return PATH.normalize(path6);
      },
      findObject: function(path6, dontResolveLastLink) {
        var ret = FS.analyzePath(path6, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },
      analyzePath: function(path6, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path6, {follow: !dontResolveLastLink});
          path6 = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path6, {parent: true});
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path6);
          lookup = FS.lookupPath(path6, {follow: !dontResolveLastLink});
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      },
      createFolder: function(parent, name, canRead, canWrite) {
        var path6 = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path6, mode);
      },
      createPath: function(parent, path6, canRead, canWrite) {
        parent = typeof parent === "string" ? parent : FS.getPath(parent);
        var parts = path6.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
          }
          parent = current;
        }
        return current;
      },
      createFile: function(parent, name, properties, canRead, canWrite) {
        var path6 = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path6, mode);
      },
      createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
        var path6 = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path6, mode);
        if (data) {
          if (typeof data === "string") {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, "w");
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: function(parent, name, input, output) {
        var path6 = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major)
          FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path6, mode, dev);
      },
      createLink: function(parent, name, target, canRead, canWrite) {
        var path6 = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path6);
      },
      forceLoadFile: function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        var success = true;
        if (typeof XMLHttpRequest !== "undefined") {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }
        if (!success)
          setErrNo(29);
        return success;
      },
      createLazyFile: function(parent, name, url, canRead, canWrite) {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = function(from, to) {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            if (typeof Uint8Array != "undefined")
              xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(xhr2.response || []);
            } else {
              return intArrayFromString(xhr2.responseText || "", true);
            }
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter(function(chunkNum) {
            var start2 = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start2, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] === "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
          var properties = {isDevice: false, contents: lazyArray};
        } else {
          var properties = {isDevice: false, url};
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key2) {
          var fn = node.stream_ops[key2];
          stream_ops[key2] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }
            return fn.apply(null, arguments);
          };
        });
        stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer2[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer2[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init();
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);
        function processData(byteArray) {
          function finish(byteArray2) {
            if (preFinish)
              preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
            }
            if (onload)
              onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module3["preloadPlugins"].forEach(function(plugin23) {
            if (handled)
              return;
            if (plugin23["canHandle"](fullname)) {
              plugin23["handle"](byteArray, fullname, finish, function() {
                if (onerror)
                  onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled)
            finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == "string") {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },
      DB_NAME: function() {
        return "EM_FS_" + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: "FILE_DATA",
      saveFilesToDB: function(paths, onload, onerror) {
        onload = onload || function() {
        };
        onerror = onerror || function() {
        };
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach(function(path6) {
            var putRequest = files.put(FS.analyzePath(path6).object.contents, path6);
            putRequest.onsuccess = function putRequest_onsuccess() {
              ok++;
              if (ok + fail == total)
                finish();
            };
            putRequest.onerror = function putRequest_onerror() {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: function(paths, onload, onerror) {
        onload = onload || function() {
        };
        onerror = onerror || function() {
        };
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach(function(path6) {
            var getRequest = files.get(path6);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path6).exists) {
                FS.unlink(path6);
              }
              FS.createDataFile(PATH.dirname(path6), PATH.basename(path6), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total)
                finish();
            };
            getRequest.onerror = function getRequest_onerror() {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      mmapAlloc: function(size) {
        var alignedSize = alignMemory(size, 16384);
        var ptr = _malloc(alignedSize);
        while (size < alignedSize)
          HEAP8[ptr + size++] = 0;
        return ptr;
      }
    };
    var SYSCALLS = {
      mappings: {},
      DEFAULT_POLLMASK: 5,
      umask: 511,
      calculateAt: function(dirfd, path6) {
        if (path6[0] !== "/") {
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path6 = PATH.join2(dir, path6);
        }
        return path6;
      },
      doStat: function(func, path6, buf) {
        try {
          var stat = func(path6);
        } catch (e) {
          if (e && e.node && PATH.normalize(path6) !== PATH.normalize(FS.getPath(e.node))) {
            return -54;
          }
          throw e;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = 0;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAP32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        HEAP32[buf + 32 >> 2] = 0;
        tempI64 = [
          stat.size >>> 0,
          (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAP32[buf + 48 >> 2] = 4096;
        HEAP32[buf + 52 >> 2] = stat.blocks;
        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
        HEAP32[buf + 60 >> 2] = 0;
        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
        HEAP32[buf + 68 >> 2] = 0;
        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
        HEAP32[buf + 76 >> 2] = 0;
        tempI64 = [
          stat.ino >>> 0,
          (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
        ], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
        return 0;
      },
      doMsync: function(addr, stream, len, flags, offset) {
        var buffer2 = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer2, offset, len, flags);
      },
      doMkdir: function(path6, mode) {
        path6 = PATH.normalize(path6);
        if (path6[path6.length - 1] === "/")
          path6 = path6.substr(0, path6.length - 1);
        FS.mkdir(path6, mode, 0);
        return 0;
      },
      doMknod: function(path6, mode, dev) {
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default:
            return -28;
        }
        FS.mknod(path6, mode, dev);
        return 0;
      },
      doReadlink: function(path6, buf, bufsize) {
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path6);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      },
      doAccess: function(path6, amode) {
        if (amode & ~7) {
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path6, {follow: true});
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },
      doDup: function(path6, flags, suggestFD) {
        var suggest2 = FS.getStream(suggestFD);
        if (suggest2)
          FS.close(suggest2);
        return FS.open(path6, flags, 0, suggestFD, suggestFD).fd;
      },
      doReadv: function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.read(stream, HEAP8, ptr, len, offset);
          if (curr < 0)
            return -1;
          ret += curr;
          if (curr < len)
            break;
        }
        return ret;
      },
      doWritev: function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          var curr = FS.write(stream, HEAP8, ptr, len, offset);
          if (curr < 0)
            return -1;
          ret += curr;
        }
        return ret;
      },
      varargs: void 0,
      get: function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      },
      getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function(fd) {
        var stream = FS.getStream(fd);
        if (!stream)
          throw new FS.ErrnoError(8);
        return stream;
      },
      get64: function(low, high) {
        return low;
      }
    };
    function ___sys_chmod(path6, mode) {
      try {
        path6 = SYSCALLS.getStr(path6);
        FS.chmod(path6, mode);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.open(stream.path, stream.flags, 0, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 12: {
            var arg = SYSCALLS.get();
            var offset = 0;
            HEAP16[arg + offset >> 1] = 2;
            return 0;
          }
          case 13:
          case 14:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty)
              return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty)
              return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          default:
            abort("bad ioctl syscall " + op);
        }
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_open(path6, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var pathname = SYSCALLS.getStr(path6);
        var mode = SYSCALLS.get();
        var stream = FS.open(pathname, flags, mode);
        return stream.fd;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_read(fd, buf, count) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return FS.read(stream, HEAP8, buf, count);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_rename(old_path, new_path) {
      try {
        old_path = SYSCALLS.getStr(old_path);
        new_path = SYSCALLS.getStr(new_path);
        FS.rename(old_path, new_path);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_rmdir(path6) {
      try {
        path6 = SYSCALLS.getStr(path6);
        FS.rmdir(path6);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_stat64(path6, buf) {
      try {
        path6 = SYSCALLS.getStr(path6);
        return SYSCALLS.doStat(FS.stat, path6, buf);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function ___sys_unlink(path6) {
      try {
        path6 = SYSCALLS.getStr(path6);
        FS.unlink(path6);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return -e.errno;
      }
    }
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
    function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
    function emscripten_realloc_buffer(size) {
      try {
        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1;
      } catch (e) {
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      requestedSize = requestedSize >>> 0;
      var oldSize = _emscripten_get_heap_size();
      var maxHeapSize = 2147483648;
      if (requestedSize > maxHeapSize) {
        return false;
      }
      var minHeapSize = 16777216;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return e.errno;
      }
    }
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        HEAP8[pbuf >> 0] = type;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return e.errno;
      }
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = SYSCALLS.doReadv(stream, iov, iovcnt);
        HEAP32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return e.errno;
      }
    }
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var HIGH_OFFSET = 4294967296;
        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
        var DOUBLE_LIMIT = 9007199254740992;
        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
          return -61;
        }
        FS.llseek(stream, offset, whence);
        tempI64 = [
          stream.position >>> 0,
          (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return e.errno;
      }
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = SYSCALLS.doWritev(stream, iov, iovcnt);
        HEAP32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
          abort(e);
        return e.errno;
      }
    }
    function _setTempRet0($i) {
      setTempRet0($i | 0);
    }
    function _time(ptr) {
      var ret = Date.now() / 1e3 | 0;
      if (ptr) {
        HEAP32[ptr >> 2] = ret;
      }
      return ret;
    }
    function _tzset() {
      if (_tzset.called)
        return;
      _tzset.called = true;
      HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      HEAP32[__get_daylight() >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
      function extractZone(date) {
        var match2 = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match2 ? match2[1] : "GMT";
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        HEAP32[__get_tzname() >> 2] = winterNamePtr;
        HEAP32[__get_tzname() + 4 >> 2] = summerNamePtr;
      } else {
        HEAP32[__get_tzname() >> 2] = summerNamePtr;
        HEAP32[__get_tzname() + 4 >> 2] = winterNamePtr;
      }
    }
    function _timegm(tmPtr) {
      _tzset();
      var time = Date.UTC(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var date = new Date(time);
      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
      var start2 = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = (date.getTime() - start2) / (1e3 * 60 * 60 * 24) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      return date.getTime() / 1e3 | 0;
    }
    var FSNode = function(parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function() {
          return (this.mode & readMode) === readMode;
        },
        set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        }
      },
      write: {
        get: function() {
          return (this.mode & writeMode) === writeMode;
        },
        set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        }
      },
      isFolder: {
        get: function() {
          return FS.isDir(this.mode);
        }
      },
      isDevice: {
        get: function() {
          return FS.isChrdev(this.mode);
        }
      }
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    if (ENVIRONMENT_IS_NODE) {
      fs9 = frozenFs;
      NODEJS_PATH = require("path");
      NODEFS.staticInit();
    }
    var fs9;
    var NODEJS_PATH;
    if (ENVIRONMENT_IS_NODE) {
      _wrapNodeError = function(func) {
        return function() {
          try {
            return func.apply(this, arguments);
          } catch (e) {
            if (!e.code)
              throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        };
      };
      VFS = Object.assign({}, FS);
      for (var _key in NODERAWFS)
        FS[_key] = _wrapNodeError(NODERAWFS[_key]);
    } else {
      throw new Error("NODERAWFS is currently only supported on Node.js environment.");
    }
    var _wrapNodeError;
    var VFS;
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var decodeBase64 = typeof atob === "function" ? atob : function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      do {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output = output + String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output = output + String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output = output + String.fromCharCode(chr3);
        }
      } while (i < input.length);
      return output;
    };
    function intArrayFromBase64(s) {
      if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
        var buf;
        try {
          buf = Buffer.from(s, "base64");
        } catch (_) {
          buf = new Buffer(s, "base64");
        }
        return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
      }
      try {
        var decoded = decodeBase64(s);
        var bytes = new Uint8Array(decoded.length);
        for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }
        return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    var asmLibraryArg = {
      m: ___gmtime_r,
      b: wasmTable,
      r: ___sys_chmod,
      g: ___sys_fcntl64,
      l: ___sys_fstat64,
      q: ___sys_ioctl,
      t: ___sys_open,
      s: ___sys_read,
      j: ___sys_rename,
      u: ___sys_rmdir,
      e: ___sys_stat64,
      i: ___sys_unlink,
      v: _emscripten_memcpy_big,
      w: _emscripten_resize_heap,
      h: _fd_close,
      k: _fd_fdstat_get,
      p: _fd_read,
      n: _fd_seek,
      f: _fd_write,
      a: wasmMemory,
      c: _setTempRet0,
      d: _time,
      o: _timegm
    };
    var asm = createWasm();
    var ___wasm_call_ctors = Module3["___wasm_call_ctors"] = asm["x"];
    var _zipstruct_stat = Module3["_zipstruct_stat"] = asm["y"];
    var _zipstruct_statS = Module3["_zipstruct_statS"] = asm["z"];
    var _zipstruct_stat_name = Module3["_zipstruct_stat_name"] = asm["A"];
    var _zipstruct_stat_index = Module3["_zipstruct_stat_index"] = asm["B"];
    var _zipstruct_stat_size = Module3["_zipstruct_stat_size"] = asm["C"];
    var _zipstruct_stat_mtime = Module3["_zipstruct_stat_mtime"] = asm["D"];
    var _zipstruct_error = Module3["_zipstruct_error"] = asm["E"];
    var _zipstruct_errorS = Module3["_zipstruct_errorS"] = asm["F"];
    var _zipstruct_error_code_zip = Module3["_zipstruct_error_code_zip"] = asm["G"];
    var _zipstruct_stat_comp_size = Module3["_zipstruct_stat_comp_size"] = asm["H"];
    var _zipstruct_stat_comp_method = Module3["_zipstruct_stat_comp_method"] = asm["I"];
    var _zip_close = Module3["_zip_close"] = asm["J"];
    var _zip_delete = Module3["_zip_delete"] = asm["K"];
    var _zip_dir_add = Module3["_zip_dir_add"] = asm["L"];
    var _zip_discard = Module3["_zip_discard"] = asm["M"];
    var _zip_error_init_with_code = Module3["_zip_error_init_with_code"] = asm["N"];
    var _zip_get_error = Module3["_zip_get_error"] = asm["O"];
    var _zip_file_get_error = Module3["_zip_file_get_error"] = asm["P"];
    var _zip_error_strerror = Module3["_zip_error_strerror"] = asm["Q"];
    var _zip_fclose = Module3["_zip_fclose"] = asm["R"];
    var _zip_file_add = Module3["_zip_file_add"] = asm["S"];
    var _zip_file_get_external_attributes = Module3["_zip_file_get_external_attributes"] = asm["T"];
    var _zip_file_set_external_attributes = Module3["_zip_file_set_external_attributes"] = asm["U"];
    var _zip_file_set_mtime = Module3["_zip_file_set_mtime"] = asm["V"];
    var _zip_fopen = Module3["_zip_fopen"] = asm["W"];
    var _zip_fopen_index = Module3["_zip_fopen_index"] = asm["X"];
    var _zip_fread = Module3["_zip_fread"] = asm["Y"];
    var _zip_get_name = Module3["_zip_get_name"] = asm["Z"];
    var _zip_get_num_entries = Module3["_zip_get_num_entries"] = asm["_"];
    var _zip_name_locate = Module3["_zip_name_locate"] = asm["$"];
    var _zip_open = Module3["_zip_open"] = asm["aa"];
    var _zip_open_from_source = Module3["_zip_open_from_source"] = asm["ba"];
    var _zip_set_file_compression = Module3["_zip_set_file_compression"] = asm["ca"];
    var _zip_source_buffer = Module3["_zip_source_buffer"] = asm["da"];
    var _zip_source_buffer_create = Module3["_zip_source_buffer_create"] = asm["ea"];
    var _zip_source_close = Module3["_zip_source_close"] = asm["fa"];
    var _zip_source_error = Module3["_zip_source_error"] = asm["ga"];
    var _zip_source_free = Module3["_zip_source_free"] = asm["ha"];
    var _zip_source_keep = Module3["_zip_source_keep"] = asm["ia"];
    var _zip_source_open = Module3["_zip_source_open"] = asm["ja"];
    var _zip_source_read = Module3["_zip_source_read"] = asm["ka"];
    var _zip_source_seek = Module3["_zip_source_seek"] = asm["la"];
    var _zip_source_set_mtime = Module3["_zip_source_set_mtime"] = asm["ma"];
    var _zip_source_tell = Module3["_zip_source_tell"] = asm["na"];
    var _zip_stat = Module3["_zip_stat"] = asm["oa"];
    var _zip_stat_index = Module3["_zip_stat_index"] = asm["pa"];
    var _zip_ext_count_symlinks = Module3["_zip_ext_count_symlinks"] = asm["qa"];
    var ___errno_location = Module3["___errno_location"] = asm["ra"];
    var __get_tzname = Module3["__get_tzname"] = asm["sa"];
    var __get_daylight = Module3["__get_daylight"] = asm["ta"];
    var __get_timezone = Module3["__get_timezone"] = asm["ua"];
    var stackSave = Module3["stackSave"] = asm["va"];
    var stackRestore = Module3["stackRestore"] = asm["wa"];
    var stackAlloc = Module3["stackAlloc"] = asm["xa"];
    var _malloc = Module3["_malloc"] = asm["ya"];
    var _free = Module3["_free"] = asm["za"];
    Module3["cwrap"] = cwrap;
    Module3["getValue"] = getValue;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0)
        return;
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module3["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        preMain();
        if (Module3["onRuntimeInitialized"])
          Module3["onRuntimeInitialized"]();
        postRun();
      }
      if (Module3["setStatus"]) {
        Module3["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module3["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    Module3["run"] = run;
    if (Module3["preInit"]) {
      if (typeof Module3["preInit"] == "function")
        Module3["preInit"] = [Module3["preInit"]];
      while (Module3["preInit"].length > 0) {
        Module3["preInit"].pop()();
      }
    }
    noExitRuntime = true;
    run();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\grammars\shell.js
  var require_shell = __commonJS((exports2, module2) => {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++) {
          descriptions[i] = describeExpectation(expected2[i]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = {Start: peg$parseStart}, peg$startRuleFunction = peg$parseStart, peg$c0 = function(line) {
        return line ? line : [];
      }, peg$c1 = function(command, type, then) {
        return [command].concat(then || []);
      }, peg$c2 = function(command, type) {
        return [command];
      }, peg$c3 = function(then) {
        return then;
      }, peg$c4 = ";", peg$c5 = peg$literalExpectation(";", false), peg$c6 = function(chain, then) {
        return then ? {chain, then} : {chain};
      }, peg$c7 = function(type, then) {
        return {type, line: then};
      }, peg$c8 = "&&", peg$c9 = peg$literalExpectation("&&", false), peg$c10 = "||", peg$c11 = peg$literalExpectation("||", false), peg$c12 = function(main3, then) {
        return then ? {...main3, then} : main3;
      }, peg$c13 = function(type, then) {
        return {type, chain: then};
      }, peg$c14 = "|&", peg$c15 = peg$literalExpectation("|&", false), peg$c16 = "|", peg$c17 = peg$literalExpectation("|", false), peg$c18 = "=", peg$c19 = peg$literalExpectation("=", false), peg$c20 = function(name, arg) {
        return {name, args: [arg]};
      }, peg$c21 = function(name) {
        return {name, args: []};
      }, peg$c22 = "(", peg$c23 = peg$literalExpectation("(", false), peg$c24 = ")", peg$c25 = peg$literalExpectation(")", false), peg$c26 = function(subshell, args) {
        return {type: `subshell`, subshell, args};
      }, peg$c27 = "{", peg$c28 = peg$literalExpectation("{", false), peg$c29 = "}", peg$c30 = peg$literalExpectation("}", false), peg$c31 = function(group, args) {
        return {type: `group`, group, args};
      }, peg$c32 = function(envs, args) {
        return {type: `command`, args, envs};
      }, peg$c33 = function(envs) {
        return {type: `envs`, envs};
      }, peg$c34 = function(args) {
        return args;
      }, peg$c35 = function(arg) {
        return arg;
      }, peg$c36 = function(redirect, arg) {
        return {type: `redirection`, subtype: redirect, args: [arg]};
      }, peg$c37 = ">>", peg$c38 = peg$literalExpectation(">>", false), peg$c39 = ">&", peg$c40 = peg$literalExpectation(">&", false), peg$c41 = ">", peg$c42 = peg$literalExpectation(">", false), peg$c43 = "<<<", peg$c44 = peg$literalExpectation("<<<", false), peg$c45 = "<&", peg$c46 = peg$literalExpectation("<&", false), peg$c47 = "<", peg$c48 = peg$literalExpectation("<", false), peg$c49 = function(segments) {
        return {type: `argument`, segments: [].concat(...segments)};
      }, peg$c50 = function(string) {
        return string;
      }, peg$c51 = "'", peg$c52 = peg$literalExpectation("'", false), peg$c53 = function(text2) {
        return [{type: `text`, text: text2}];
      }, peg$c54 = '"', peg$c55 = peg$literalExpectation('"', false), peg$c56 = function(segments) {
        return segments;
      }, peg$c57 = function(arithmetic) {
        return {type: `arithmetic`, arithmetic, quoted: true};
      }, peg$c58 = function(shell) {
        return {type: `shell`, shell, quoted: true};
      }, peg$c59 = function(variable) {
        return {type: `variable`, ...variable, quoted: true};
      }, peg$c60 = function(text2) {
        return {type: `text`, text: text2};
      }, peg$c61 = function(arithmetic) {
        return {type: `arithmetic`, arithmetic, quoted: false};
      }, peg$c62 = function(shell) {
        return {type: `shell`, shell, quoted: false};
      }, peg$c63 = function(variable) {
        return {type: `variable`, ...variable, quoted: false};
      }, peg$c64 = function(pattern) {
        return {type: `glob`, pattern};
      }, peg$c65 = "\\", peg$c66 = peg$literalExpectation("\\", false), peg$c67 = peg$anyExpectation(), peg$c68 = function(c) {
        return c;
      }, peg$c69 = /^[^']/, peg$c70 = peg$classExpectation(["'"], true, false), peg$c71 = function(chars) {
        return chars.join(``);
      }, peg$c72 = /^[^$"]/, peg$c73 = peg$classExpectation(["$", '"'], true, false), peg$c74 = "-", peg$c75 = peg$literalExpectation("-", false), peg$c76 = "+", peg$c77 = peg$literalExpectation("+", false), peg$c78 = /^[0-9]/, peg$c79 = peg$classExpectation([["0", "9"]], false, false), peg$c80 = ".", peg$c81 = peg$literalExpectation(".", false), peg$c82 = function(sign, left, right) {
        return {type: `number`, value: (sign === "-" ? -1 : 1) * parseFloat(left.join(``) + `.` + right.join(``))};
      }, peg$c83 = function(sign, value) {
        return {type: `number`, value: (sign === "-" ? -1 : 1) * parseInt(value.join(``))};
      }, peg$c84 = function(variable) {
        return {type: `variable`, ...variable};
      }, peg$c85 = function(name) {
        return {type: `variable`, name};
      }, peg$c86 = function(value) {
        return value;
      }, peg$c87 = "*", peg$c88 = peg$literalExpectation("*", false), peg$c89 = function(left, right) {
        return {type: `multiplication`, left, right};
      }, peg$c90 = "/", peg$c91 = peg$literalExpectation("/", false), peg$c92 = function(left, right) {
        return {type: `division`, left, right};
      }, peg$c93 = function(left, right) {
        return {type: `addition`, left, right};
      }, peg$c94 = function(left, right) {
        return {type: `subtraction`, left, right};
      }, peg$c95 = "$((", peg$c96 = peg$literalExpectation("$((", false), peg$c97 = "))", peg$c98 = peg$literalExpectation("))", false), peg$c99 = function(arithmetic) {
        return arithmetic;
      }, peg$c100 = "$(", peg$c101 = peg$literalExpectation("$(", false), peg$c102 = function(command) {
        return command;
      }, peg$c103 = "${", peg$c104 = peg$literalExpectation("${", false), peg$c105 = ":-", peg$c106 = peg$literalExpectation(":-", false), peg$c107 = function(name, arg) {
        return {name, defaultValue: arg};
      }, peg$c108 = ":-}", peg$c109 = peg$literalExpectation(":-}", false), peg$c110 = function(name) {
        return {name, defaultValue: []};
      }, peg$c111 = function(name) {
        return {name};
      }, peg$c112 = "$", peg$c113 = peg$literalExpectation("$", false), peg$c114 = function(pattern) {
        return options.isGlobPattern(pattern);
      }, peg$c115 = function(pattern) {
        return pattern;
      }, peg$c116 = /^[a-zA-Z0-9_]/, peg$c117 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false), peg$c118 = function() {
        return text();
      }, peg$c119 = /^[$@*?#a-zA-Z0-9_\-]/, peg$c120 = peg$classExpectation(["$", "@", "*", "?", "#", ["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false), peg$c121 = /^[(){}<>$|&; \t"']/, peg$c122 = peg$classExpectation(["(", ")", "{", "}", "<", ">", "$", "|", "&", ";", " ", "	", '"', "'"], false, false), peg$c123 = /^[<>&; \t"']/, peg$c124 = peg$classExpectation(["<", ">", "&", ";", " ", "	", '"', "'"], false, false), peg$c125 = /^[ \t]/, peg$c126 = peg$classExpectation([" ", "	"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{line: 1, column: 1}], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return {type: "literal", text: text2, ignoreCase};
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {type: "class", parts, inverted, ignoreCase};
      }
      function peg$anyExpectation() {
        return {type: "any"};
      }
      function peg$endExpectation() {
        return {type: "end"};
      }
      function peg$otherExpectation(description) {
        return {type: "other", description};
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
      }
      function peg$parseStart() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseShellLine();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseShellLine() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseCommandLine();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseShellLineType();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseShellLineThen();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseCommandLine();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseShellLineType();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c2(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseShellLineThen() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseShellLine();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c3(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseShellLineType() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 59) {
          s0 = peg$c4;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }
        return s0;
      }
      function peg$parseCommandLine() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseCommandChain();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseCommandLineThen();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommandLineThen() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseCommandLineType();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseCommandLine();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommandLineType() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c8) {
          s0 = peg$c8;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c10) {
            s0 = peg$c10;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c11);
            }
          }
        }
        return s0;
      }
      function peg$parseCommandChain() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseCommand();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseCommandChainThen();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c12(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommandChainThen() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseCommandChainType();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseCommandChain();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c13(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseCommandChainType() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c14) {
          s0 = peg$c14;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 124) {
            s0 = peg$c16;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
        }
        return s0;
      }
      function peg$parseVariableAssignment() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseEnvVariable();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c18;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c19);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseStrictValueArgument();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c20(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEnvVariable();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c18;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c21(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseCommand() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c22;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c23);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseShellLine();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s6 = peg$c24;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c25);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseS();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseS();
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = [];
                      s9 = peg$parseRedirectArgument();
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$parseRedirectArgument();
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = [];
                        s10 = peg$parseS();
                        while (s10 !== peg$FAILED) {
                          s9.push(s10);
                          s10 = peg$parseS();
                        }
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c26(s4, s8);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s2 = peg$c27;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseShellLine();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s6 = peg$c29;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c30);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = [];
                        s9 = peg$parseRedirectArgument();
                        while (s9 !== peg$FAILED) {
                          s8.push(s9);
                          s9 = peg$parseRedirectArgument();
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c31(s4, s8);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseVariableAssignment();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseVariableAssignment();
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseArgument();
                  if (s5 !== peg$FAILED) {
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parseArgument();
                    }
                  } else {
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c32(s2, s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseVariableAssignment();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseVariableAssignment();
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c33(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseCommandString() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseValueArgument();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseValueArgument();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseArgument() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseRedirectArgument();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseValueArgument();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseRedirectArgument() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseRedirectType();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseValueArgument();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c36(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseRedirectType() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c37) {
          s0 = peg$c37;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c39) {
            s0 = peg$c39;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s0 = peg$c41;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c43) {
                s0 = peg$c43;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c44);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c45) {
                  s0 = peg$c45;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 60) {
                    s0 = peg$c47;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueArgument() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseStrictValueArgument();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseStrictValueArgument() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseArgumentSegment();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseArgumentSegment();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseArgumentSegment() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseSglQuoteString();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDblQuoteString();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePlainString();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseSglQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c51;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSglQuoteStringText();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c51;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c53(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseDblQuoteString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c54;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDblQuoteStringSegment();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDblQuoteStringSegment();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c54;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c56(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsePlainString() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsePlainStringSegment();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsePlainStringSegment();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c56(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseDblQuoteStringSegment() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseArithmetic();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSubshell();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c58(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseVariable();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseDblQuoteStringText();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s1);
              }
              s0 = s1;
            }
          }
        }
        return s0;
      }
      function peg$parsePlainStringSegment() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseArithmetic();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c61(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSubshell();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c62(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseVariable();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c63(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseGlob();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c64(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsePlainStringText();
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c60(s1);
                }
                s0 = s1;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseSglQuoteStringText() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (peg$c69.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c70);
            }
          }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s3 = peg$c65;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c67);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c68(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (peg$c69.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c70);
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseDblQuoteStringText() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (peg$c72.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s3 = peg$c65;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }
            if (s3 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c67);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c68(s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              if (peg$c72.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsePlainStringText() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSpecialShellChars();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c67);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c68(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s3 = peg$c65;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }
            if (s3 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c67);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c68(s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$currPos;
              peg$silentFails++;
              s4 = peg$parseSpecialShellChars();
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c68(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseArithmeticPrimary() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c74;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c76;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c78.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c79);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c78.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c79);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c80;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c81);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c78.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c79);
                }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c78.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c79);
                    }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c82(s1, s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c74;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c75);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c76;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c77);
              }
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c78.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c79);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c78.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c79);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseVariable();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c84(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseIdentifier();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c85(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                  s1 = peg$c22;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c23);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parseS();
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseS();
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseArithmeticExpression();
                    if (s3 !== peg$FAILED) {
                      s4 = [];
                      s5 = peg$parseS();
                      while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$parseS();
                      }
                      if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                          s5 = peg$c24;
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c25);
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c86(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseArithmeticTimesExpression() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseArithmeticPrimary();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
              s3 = peg$c87;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c88);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseArithmeticTimesExpression();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c89(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseArithmeticPrimary();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s3 = peg$c90;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c91);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseArithmeticTimesExpression();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c92(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseArithmeticPrimary();
          }
        }
        return s0;
      }
      function peg$parseArithmeticExpression() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseArithmeticTimesExpression();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s3 = peg$c76;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c77);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseArithmeticExpression();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c93(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseArithmeticTimesExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s3 = peg$c74;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseArithmeticExpression();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c94(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseArithmeticTimesExpression();
          }
        }
        return s0;
      }
      function peg$parseArithmetic() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c95) {
          s1 = peg$c95;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c96);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseArithmeticExpression();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c97) {
                  s5 = peg$c97;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c98);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c99(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseSubshell() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c100) {
          s1 = peg$c100;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c101);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseShellLine();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c24;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c25);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c102(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c103) {
          s1 = peg$c103;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c104);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c105) {
              s3 = peg$c105;
              peg$currPos += 2;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c106);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseCommandString();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c29;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c107(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c108) {
                s3 = peg$c108;
                peg$currPos += 3;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c109);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c110(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseIdentifier();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s3 = peg$c29;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c111(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 36) {
                s1 = peg$c112;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c113);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c111(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseGlob() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseGlobText();
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c114(s1);
          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c115(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseGlobText() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseGlobSpecialShellChars();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c67);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c68(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseGlobSpecialShellChars();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c67);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c68(s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseEnvVariable() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c116.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c116.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c117);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c118();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c119.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c120);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c119.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c120);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c118();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseSpecialShellChars() {
        var s0;
        if (peg$c121.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }
        return s0;
      }
      function peg$parseGlobSpecialShellChars() {
        var s0;
        if (peg$c123.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }
        return s0;
      }
      function peg$parseS() {
        var s0, s1;
        s0 = [];
        if (peg$c125.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$c125.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c126);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\grammars\resolution.js
  var require_resolution = __commonJS((exports2, module2) => {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return `"${literalEscape(expectation.text)}"`;
        },
        class: function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++)
            escapedParts += expectation.parts[i] instanceof Array ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}` : classEscape(expectation.parts[i]);
          return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return `\\x0${hex(ch)}`;
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return `\\x${hex(ch)}`;
        });
      }
      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return `\\x0${hex(ch)}`;
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return `\\x${hex(ch)}`;
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++)
          descriptions[i] = describeExpectation(expected2[i]);
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return `${descriptions[0]} or ${descriptions[1]}`;
          default:
            return `${descriptions.slice(0, -1).join(", ")}, or ${descriptions[descriptions.length - 1]}`;
        }
      }
      function describeFound(found2) {
        return found2 ? `"${literalEscape(found2)}"` : "end of input";
      }
      return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = {resolution: peg$parseresolution}, peg$startRuleFunction = peg$parseresolution, peg$c0 = "/", peg$c1 = peg$literalExpectation("/", false), peg$c2 = function(from, descriptor) {
        return {from, descriptor};
      }, peg$c3 = function(descriptor) {
        return {descriptor};
      }, peg$c4 = "@", peg$c5 = peg$literalExpectation("@", false), peg$c6 = function(fullName, description) {
        return {fullName, description};
      }, peg$c7 = function(fullName) {
        return {fullName};
      }, peg$c8 = function() {
        return text();
      }, peg$c9 = /^[^\/@]/, peg$c10 = peg$classExpectation(["/", "@"], true, false), peg$c11 = /^[^\/]/, peg$c12 = peg$classExpectation(["/"], true, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{line: 1, column: 1}], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions))
          throw new Error(`Can't start parsing from rule "${options.startRule}".`);
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return {type: "literal", text: text2, ignoreCase};
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {type: "class", parts, inverted, ignoreCase};
      }
      function peg$anyExpectation() {
        return {type: "any"};
      }
      function peg$endExpectation() {
        return {type: "end"};
      }
      function peg$otherExpectation(description) {
        return {type: "other", description};
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p])
            p--;
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos)
          return;
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
      }
      function peg$parseresolution() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsespecifier();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s2 = peg$c0;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c1);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsespecifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c2(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsespecifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsespecifier() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsefullName();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 64) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsedescription();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsefullName();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c7(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsefullName() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s1 = peg$c4;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseident();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c0;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c1);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseident();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseident();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseident() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c10);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c9.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
        }
        s0 = s1;
        return s0;
      }
      function peg$parsedescription() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c11.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c12);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
        }
        s0 = s1;
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length)
          peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\common.js
  var require_common2 = __commonJS((exports2, module2) => {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\exception.js
  var require_exception = __commonJS((exports2, module2) => {
    "use strict";
    function YAMLException(reason, mark2) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark2;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\mark.js
  var require_mark = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start2, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start2 = this.position;
      while (start2 > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start2 - 1)) === -1) {
        start2 -= 1;
        if (this.position - start2 > maxLength / 2 - 1) {
          head = " ... ";
          start2 += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start2, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start2 + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type.js
  var require_type = __commonJS((exports2, module2) => {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type2(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema.js
  var require_schema = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    var YAMLException = require_exception();
    var Type2 = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types2 = common.toArray(types2);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types2.every(function(type) {
        return type instanceof Type2;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module2.exports = Schema;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\str.js
  var require_str = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\seq.js
  var require_seq = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\map.js
  var require_map = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    module2.exports = new Type2("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema\failsafe.js
  var require_failsafe = __commonJS((exports2, module2) => {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\null.js
  var require_null = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type2("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\bool.js
  var require_bool = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type2("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\int.js
  var require_int = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    var Type2 = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type2("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\float.js
  var require_float = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    var Type2 = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type2("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema\json.js
  var require_json = __commonJS((exports2, module2) => {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema\core.js
  var require_core2 = __commonJS((exports2, module2) => {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json()
      ]
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\timestamp.js
  var require_timestamp = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match2 = YAML_DATE_REGEXP.exec(data);
      if (match2 === null)
        match2 = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match2 === null)
        throw new Error("Date resolve error");
      year = +match2[1];
      month = +match2[2] - 1;
      day = +match2[3];
      if (!match2[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match2[4];
      minute = +match2[5];
      second = +match2[6];
      if (match2[7]) {
        fraction = match2[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match2[9]) {
        tz_hour = +match2[10];
        tz_minute = +(match2[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match2[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type2("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\merge.js
  var require_merge = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type2("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\binary.js
  var require_binary = __commonJS((exports2, module2) => {
    "use strict";
    var NodeBuffer;
    try {
      _require = require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type2 = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type2("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\omap.js
  var require_omap = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type2("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\pairs.js
  var require_pairs = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type2("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\set.js
  var require_set = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type2("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema\default_safe.js
  var require_default_safe = __commonJS((exports2, module2) => {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core2()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\js\undefined.js
  var require_undefined = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type2("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\js\regexp.js
  var require_regexp = __commonJS((exports2, module2) => {
    "use strict";
    var Type2 = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type2("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\type\js\function.js
  var require_function = __commonJS((exports2, module2) => {
    "use strict";
    var esprima;
    try {
      _require = require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type2 = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, {range: true});
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, {range: true}), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type2("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\schema\default_full.js
  var require_default_full = __commonJS((exports2, module2) => {
    "use strict";
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\loader.js
  var require_loader = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (var i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match2, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match2 === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match2[1], 10);
        minor = parseInt(match2[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start2, end, checkJson) {
      var _position, _length, _character, _result;
      if (start2 < end) {
        _result = state.input.slice(start2, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!state.anchorMap.hasOwnProperty(alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      var documents = loadDocuments(input, options), index, length;
      if (typeof iterator !== "function") {
        return documents;
      }
      for (index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, output, options) {
      if (typeof output === "function") {
        loadAll(input, output, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
      } else {
        return loadAll(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
      }
    }
    function safeLoad2(input, options) {
      return load(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml\dumper.js
  var require_dumper = __commonJS((exports2, module2) => {
    "use strict";
    var common = require_common2();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isPlainSafe(c) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match2;
      while (match2 = lineRe.exec(string)) {
        var prefix = match2[1], line = match2[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match2;
      var start2 = 0, end, curr = 0, next = 0;
      var result = "";
      while (match2 = breakRe.exec(line)) {
        next = match2.index;
        if (next - start2 > width) {
          end = curr > start2 ? curr : next;
          result += "\n" + line.slice(start2, end);
          start2 = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start2 > width && curr > start2) {
        result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start2);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = state.condenseFlow ? '"' : "";
        if (index !== 0)
          pairBuffer += ", ";
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\lib\js-yaml.js
  var require_js_yaml = __commonJS((exports2, module2) => {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core2();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\js-yaml-npm-3.12.2-0477061df7-3edb01855e.zip\node_modules\js-yaml\index.js
  var require_js_yaml2 = __commonJS((exports2, module2) => {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\grammars\syml.js
  var require_syml = __commonJS((exports2, module2) => {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return `"${literalEscape(expectation.text)}"`;
        },
        class: function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++)
            escapedParts += expectation.parts[i] instanceof Array ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}` : classEscape(expectation.parts[i]);
          return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return `\\x0${hex(ch)}`;
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return `\\x${hex(ch)}`;
        });
      }
      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return `\\x0${hex(ch)}`;
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return `\\x${hex(ch)}`;
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++)
          descriptions[i] = describeExpectation(expected2[i]);
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return `${descriptions[0]} or ${descriptions[1]}`;
          default:
            return `${descriptions.slice(0, -1).join(", ")}, or ${descriptions[descriptions.length - 1]}`;
        }
      }
      function describeFound(found2) {
        return found2 ? `"${literalEscape(found2)}"` : "end of input";
      }
      return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = {Start: peg$parseStart}, peg$startRuleFunction = peg$parseStart, peg$c0 = function(statements) {
        return [].concat(...statements);
      }, peg$c1 = "-", peg$c2 = peg$literalExpectation("-", false), peg$c3 = function(value) {
        return value;
      }, peg$c4 = function(statements) {
        return Object.assign({}, ...statements);
      }, peg$c5 = "#", peg$c6 = peg$literalExpectation("#", false), peg$c7 = peg$anyExpectation(), peg$c8 = function() {
        return {};
      }, peg$c9 = ":", peg$c10 = peg$literalExpectation(":", false), peg$c11 = function(property, value) {
        return {[property]: value};
      }, peg$c12 = ",", peg$c13 = peg$literalExpectation(",", false), peg$c14 = function(property, other) {
        return other;
      }, peg$c15 = function(property, others, value) {
        return Object.assign({}, ...[property].concat(others).map((property2) => ({[property2]: value})));
      }, peg$c16 = function(statements) {
        return statements;
      }, peg$c17 = function(expression) {
        return expression;
      }, peg$c18 = peg$otherExpectation("correct indentation"), peg$c19 = " ", peg$c20 = peg$literalExpectation(" ", false), peg$c21 = function(spaces) {
        return spaces.length === indentLevel * INDENT_STEP;
      }, peg$c22 = function(spaces) {
        return spaces.length === (indentLevel + 1) * INDENT_STEP;
      }, peg$c23 = function() {
        indentLevel++;
        return true;
      }, peg$c24 = function() {
        indentLevel--;
        return true;
      }, peg$c25 = function() {
        return text();
      }, peg$c26 = peg$otherExpectation("pseudostring"), peg$c27 = /^[^\r\n\t ?:,\][{}#&*!|>'"%@`\-]/, peg$c28 = peg$classExpectation(["\r", "\n", "	", " ", "?", ":", ",", "]", "[", "{", "}", "#", "&", "*", "!", "|", ">", "'", '"', "%", "@", "`", "-"], true, false), peg$c29 = /^[^\r\n\t ,\][{}:#"']/, peg$c30 = peg$classExpectation(["\r", "\n", "	", " ", ",", "]", "[", "{", "}", ":", "#", '"', "'"], true, false), peg$c31 = function() {
        return text().replace(/^ *| *$/g, "");
      }, peg$c32 = "--", peg$c33 = peg$literalExpectation("--", false), peg$c34 = /^[a-zA-Z\/0-9]/, peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "/", ["0", "9"]], false, false), peg$c36 = /^[^\r\n\t :,]/, peg$c37 = peg$classExpectation(["\r", "\n", "	", " ", ":", ","], true, false), peg$c38 = "null", peg$c39 = peg$literalExpectation("null", false), peg$c40 = function() {
        return null;
      }, peg$c41 = "true", peg$c42 = peg$literalExpectation("true", false), peg$c43 = function() {
        return true;
      }, peg$c44 = "false", peg$c45 = peg$literalExpectation("false", false), peg$c46 = function() {
        return false;
      }, peg$c47 = peg$otherExpectation("string"), peg$c48 = '"', peg$c49 = peg$literalExpectation('"', false), peg$c50 = function() {
        return "";
      }, peg$c51 = function(chars) {
        return chars;
      }, peg$c52 = function(chars) {
        return chars.join(``);
      }, peg$c53 = /^[^"\\\0-\x1F\x7F]/, peg$c54 = peg$classExpectation(['"', "\\", ["\0", ""], "\x7F"], true, false), peg$c55 = '\\"', peg$c56 = peg$literalExpectation('\\"', false), peg$c57 = function() {
        return `"`;
      }, peg$c58 = "\\\\", peg$c59 = peg$literalExpectation("\\\\", false), peg$c60 = function() {
        return `\\`;
      }, peg$c61 = "\\/", peg$c62 = peg$literalExpectation("\\/", false), peg$c63 = function() {
        return `/`;
      }, peg$c64 = "\\b", peg$c65 = peg$literalExpectation("\\b", false), peg$c66 = function() {
        return `\b`;
      }, peg$c67 = "\\f", peg$c68 = peg$literalExpectation("\\f", false), peg$c69 = function() {
        return `\f`;
      }, peg$c70 = "\\n", peg$c71 = peg$literalExpectation("\\n", false), peg$c72 = function() {
        return `
`;
      }, peg$c73 = "\\r", peg$c74 = peg$literalExpectation("\\r", false), peg$c75 = function() {
        return `\r`;
      }, peg$c76 = "\\t", peg$c77 = peg$literalExpectation("\\t", false), peg$c78 = function() {
        return `	`;
      }, peg$c79 = "\\u", peg$c80 = peg$literalExpectation("\\u", false), peg$c81 = function(h1, h2, h3, h4) {
        return String.fromCharCode(parseInt(`0x${h1}${h2}${h3}${h4}`));
      }, peg$c82 = /^[0-9a-fA-F]/, peg$c83 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false), peg$c84 = peg$otherExpectation("blank space"), peg$c85 = /^[ \t]/, peg$c86 = peg$classExpectation([" ", "	"], false, false), peg$c87 = peg$otherExpectation("white space"), peg$c88 = /^[ \t\n\r]/, peg$c89 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$c90 = "\r\n", peg$c91 = peg$literalExpectation("\r\n", false), peg$c92 = "\n", peg$c93 = peg$literalExpectation("\n", false), peg$c94 = "\r", peg$c95 = peg$literalExpectation("\r", false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{line: 1, column: 1}], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions))
          throw new Error(`Can't start parsing from rule "${options.startRule}".`);
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return {type: "literal", text: text2, ignoreCase};
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {type: "class", parts, inverted, ignoreCase};
      }
      function peg$anyExpectation() {
        return {type: "any"};
      }
      function peg$endExpectation() {
        return {type: "end"};
      }
      function peg$otherExpectation(description) {
        return {type: "other", description};
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p])
            p--;
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos)
          return;
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found), expected2, found, location2);
      }
      function peg$parseStart() {
        var s0;
        s0 = peg$parsePropertyStatements();
        return s0;
      }
      function peg$parseItemStatements() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseItemStatement();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseItemStatement();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseItemStatement() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseSamedent();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseB();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseExpression();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c3(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsePropertyStatements() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsePropertyStatement();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsePropertyStatement();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c4(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsePropertyStatement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseB();
        if (s1 === peg$FAILED)
          s1 = null;
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s3 = peg$c5;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseEOL();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c7);
                }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$currPos;
                peg$silentFails++;
                s7 = peg$parseEOL();
                peg$silentFails--;
                if (s7 === peg$FAILED) {
                  s6 = void 0;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c7);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED)
            s2 = null;
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseEOL_ANY();
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseEOL_ANY();
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c8();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSamedent();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseName();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseB();
              if (s3 === peg$FAILED)
                s3 = null;
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c9;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseB();
                  if (s5 === peg$FAILED)
                    s5 = null;
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseExpression();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c11(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSamedent();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLegacyName();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseB();
                if (s3 === peg$FAILED)
                  s3 = null;
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s4 = peg$c9;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseB();
                    if (s5 === peg$FAILED)
                      s5 = null;
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseExpression();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c11(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseSamedent();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLegacyName();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseB();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseLegacyLiteral();
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseEOL_ANY();
                      if (s6 !== peg$FAILED) {
                        while (s6 !== peg$FAILED) {
                          s5.push(s6);
                          s6 = peg$parseEOL_ANY();
                        }
                      } else {
                        s5 = peg$FAILED;
                      }
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c11(s2, s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseSamedent();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseLegacyName();
                  if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$currPos;
                    s5 = peg$parseB();
                    if (s5 === peg$FAILED)
                      s5 = null;
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s6 = peg$c12;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c13);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseB();
                        if (s7 === peg$FAILED)
                          s7 = null;
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseLegacyName();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s5 = peg$c14(s2, s8);
                            s4 = s5;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$currPos;
                        s5 = peg$parseB();
                        if (s5 === peg$FAILED)
                          s5 = null;
                        if (s5 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s6 = peg$c12;
                            peg$currPos++;
                          } else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c13);
                            }
                          }
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseB();
                            if (s7 === peg$FAILED)
                              s7 = null;
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parseLegacyName();
                              if (s8 !== peg$FAILED) {
                                peg$savedPos = s4;
                                s5 = peg$c14(s2, s8);
                                s4 = s5;
                              } else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s4;
                              s4 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      }
                    } else {
                      s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseB();
                      if (s4 === peg$FAILED)
                        s4 = null;
                      if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                          s5 = peg$c9;
                          peg$currPos++;
                        } else {
                          s5 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseB();
                          if (s6 === peg$FAILED)
                            s6 = null;
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseExpression();
                            if (s7 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c15(s2, s3, s7);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseExpression() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = peg$parseEOL();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExtradent();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c1;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c2);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseB();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEOL_ANY();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseIndent();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseItemStatements();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDedent();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c16(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseEOL();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIndent();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsePropertyStatements();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseDedent();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c16(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLiteral();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseEOL_ANY();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseEOL_ANY();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c17(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseSamedent() {
        var s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c19;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c21(s1);
          if (s2)
            s2 = void 0;
          else
            s2 = peg$FAILED;
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        return s0;
      }
      function peg$parseExtradent() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (input.charCodeAt(peg$currPos) === 32) {
            s2 = peg$c19;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c22(s1);
          if (s2)
            s2 = void 0;
          else
            s2 = peg$FAILED;
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIndent() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$c23();
        if (s0)
          s0 = void 0;
        else
          s0 = peg$FAILED;
        return s0;
      }
      function peg$parseDedent() {
        var s0;
        peg$savedPos = peg$currPos;
        s0 = peg$c24();
        if (s0)
          s0 = void 0;
        else
          s0 = peg$FAILED;
        return s0;
      }
      function peg$parseName() {
        var s0;
        s0 = peg$parsestring();
        if (s0 === peg$FAILED)
          s0 = peg$parsepseudostring();
        return s0;
      }
      function peg$parseLegacyName() {
        var s0, s1, s2;
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsepseudostringLegacy();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsepseudostringLegacy();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseLiteral() {
        var s0;
        s0 = peg$parsenull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseboolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepseudostring();
            }
          }
        }
        return s0;
      }
      function peg$parseLegacyLiteral() {
        var s0;
        s0 = peg$parsenull();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepseudostringLegacy();
          }
        }
        return s0;
      }
      function peg$parsepseudostring() {
        var s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c27.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseB();
          if (s4 === peg$FAILED)
            s4 = null;
          if (s4 !== peg$FAILED) {
            if (peg$c29.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseB();
            if (s4 === peg$FAILED)
              s4 = null;
            if (s4 !== peg$FAILED) {
              if (peg$c29.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }
        return s0;
      }
      function peg$parsepseudostringLegacy() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c32) {
          s1 = peg$c32;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }
        if (s1 === peg$FAILED)
          s1 = null;
        if (s1 !== peg$FAILED) {
          if (peg$c34.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c36.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c36.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c37);
                }
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c31();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenull() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c38) {
          s1 = peg$c38;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseboolean() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c41) {
          s1 = peg$c41;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c43();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c44) {
            s1 = peg$c44;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestring() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c48;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c48;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c49);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c48;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c49);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsechars();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c48;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c49);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c51(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }
        return s0;
      }
      function peg$parsechars() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsechar();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsechar();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c52(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsechar() {
        var s0, s1, s2, s3, s4, s5;
        if (peg$c53.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c55) {
            s1 = peg$c55;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c57();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c58) {
              s1 = peg$c58;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c59);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c61) {
                s1 = peg$c61;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c62);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c63();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c64) {
                  s1 = peg$c64;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c65);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c66();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c67) {
                    s1 = peg$c67;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c68);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c69();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c70) {
                      s1 = peg$c70;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c71);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c72();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c73) {
                        s1 = peg$c73;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c74);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c75();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c76) {
                          s1 = peg$c76;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c77);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c78();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.substr(peg$currPos, 2) === peg$c79) {
                            s1 = peg$c79;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c80);
                            }
                          }
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parsehexDigit();
                            if (s2 !== peg$FAILED) {
                              s3 = peg$parsehexDigit();
                              if (s3 !== peg$FAILED) {
                                s4 = peg$parsehexDigit();
                                if (s4 !== peg$FAILED) {
                                  s5 = peg$parsehexDigit();
                                  if (s5 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c81(s2, s3, s4, s5);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsehexDigit() {
        var s0;
        if (peg$c82.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c83);
          }
        }
        return s0;
      }
      function peg$parseB() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$c85.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        return s0;
      }
      function peg$parseS() {
        var s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c88.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c89);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$c88.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c89);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c87);
          }
        }
        return s0;
      }
      function peg$parseEOL_ANY() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseEOL();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseB();
          if (s4 === peg$FAILED)
            s4 = null;
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEOL();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseB();
            if (s4 === peg$FAILED)
              s4 = null;
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEOL();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEOL() {
        var s0;
        if (input.substr(peg$currPos, 2) === peg$c90) {
          s0 = peg$c90;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c91);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c92;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c93);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c94;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c95);
              }
            }
          }
        }
        return s0;
      }
      const INDENT_STEP = 2;
      let indentLevel = 0;
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length)
          peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_freeGlobal.js
  var require_freeGlobal = __commonJS((exports2, module2) => {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_root.js
  var require_root = __commonJS((exports2, module2) => {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Symbol.js
  var require_Symbol = __commonJS((exports2, module2) => {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_arrayMap.js
  var require_arrayMap = __commonJS((exports2, module2) => {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isArray.js
  var require_isArray = __commonJS((exports2, module2) => {
    var isArray = Array.isArray;
    module2.exports = isArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getRawTag.js
  var require_getRawTag = __commonJS((exports2, module2) => {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_objectToString.js
  var require_objectToString = __commonJS((exports2, module2) => {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseGetTag.js
  var require_baseGetTag = __commonJS((exports2, module2) => {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isObjectLike.js
  var require_isObjectLike = __commonJS((exports2, module2) => {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isSymbol.js
  var require_isSymbol = __commonJS((exports2, module2) => {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseToString.js
  var require_baseToString = __commonJS((exports2, module2) => {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\toString.js
  var require_toString = __commonJS((exports2, module2) => {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseSlice.js
  var require_baseSlice = __commonJS((exports2, module2) => {
    function baseSlice(array, start2, end) {
      var index = -1, length = array.length;
      if (start2 < 0) {
        start2 = -start2 > length ? 0 : length + start2;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start2 > end ? 0 : end - start2 >>> 0;
      start2 >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start2];
      }
      return result;
    }
    module2.exports = baseSlice;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_castSlice.js
  var require_castSlice = __commonJS((exports2, module2) => {
    var baseSlice = require_baseSlice();
    function castSlice(array, start2, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start2 && end >= length ? array : baseSlice(array, start2, end);
    }
    module2.exports = castSlice;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hasUnicode.js
  var require_hasUnicode = __commonJS((exports2, module2) => {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_asciiToArray.js
  var require_asciiToArray = __commonJS((exports2, module2) => {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_unicodeToArray.js
  var require_unicodeToArray = __commonJS((exports2, module2) => {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stringToArray.js
  var require_stringToArray = __commonJS((exports2, module2) => {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_createCaseFirst.js
  var require_createCaseFirst = __commonJS((exports2, module2) => {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\upperFirst.js
  var require_upperFirst = __commonJS((exports2, module2) => {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\capitalize.js
  var require_capitalize = __commonJS((exports2, module2) => {
    var toString = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize2(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    module2.exports = capitalize2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\p-try-npm-2.0.0-1f8d030b63-c3d8ed858d.zip\node_modules\p-try\index.js
  var require_p_try = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (callback, ...args) => new Promise((resolve) => {
      resolve(callback(...args));
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\p-limit-npm-2.2.0-d458ce1c4b-867b236a32.zip\node_modules\p-limit\index.js
  var require_p_limit = __commonJS((exports2, module2) => {
    "use strict";
    var pTry = require_p_try();
    var pLimit4 = (concurrency) => {
      if (concurrency < 1) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        }
      });
      return generator;
    };
    module2.exports = pLimit4;
    module2.exports.default = pLimit4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\grapheme-splitter-npm-1.0.4-648f2bf509-6875e94add.zip\node_modules\grapheme-splitter\index.js
  var require_grapheme_splitter = __commonJS((exports2, module2) => {
    function GraphemeSplitter() {
      var CR = 0, LF = 1, Control = 2, Extend = 3, Regional_Indicator = 4, SpacingMark = 5, L = 6, V = 7, T = 8, LV = 9, LVT = 10, Other = 11, Prepend = 12, E_Base = 13, E_Modifier = 14, ZWJ = 15, Glue_After_Zwj = 16, E_Base_GAZ = 17;
      var NotBreak = 0, BreakStart = 1, Break = 2, BreakLastRegional = 3, BreakPenultimateRegional = 4;
      function isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      function codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        var code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          var hi = code;
          var low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          var hi = str.charCodeAt(idx - 1);
          var low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      function shouldBreak(start2, mid, end) {
        var all = [start2].concat(mid).concat([end]);
        var previous = all[all.length - 2];
        var next = end;
        var eModifierIndex = all.lastIndexOf(E_Modifier);
        if (eModifierIndex > 1 && all.slice(1, eModifierIndex).every(function(c) {
          return c == Extend;
        }) && [Extend, E_Base, E_Base_GAZ].indexOf(start2) == -1) {
          return Break;
        }
        var rIIndex = all.lastIndexOf(Regional_Indicator);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c == Regional_Indicator;
        }) && [Prepend, Regional_Indicator].indexOf(previous) == -1) {
          if (all.filter(function(c) {
            return c == Regional_Indicator;
          }).length % 2 == 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous == CR && next == LF) {
          return NotBreak;
        } else if (previous == Control || previous == CR || previous == LF) {
          if (next == E_Modifier && mid.every(function(c) {
            return c == Extend;
          })) {
            return Break;
          } else {
            return BreakStart;
          }
        } else if (next == Control || next == CR || next == LF) {
          return BreakStart;
        } else if (previous == L && (next == L || next == V || next == LV || next == LVT)) {
          return NotBreak;
        } else if ((previous == LV || previous == V) && (next == V || next == T)) {
          return NotBreak;
        } else if ((previous == LVT || previous == T) && next == T) {
          return NotBreak;
        } else if (next == Extend || next == ZWJ) {
          return NotBreak;
        } else if (next == SpacingMark) {
          return NotBreak;
        } else if (previous == Prepend) {
          return NotBreak;
        }
        var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
        if ([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 && all.slice(previousNonExtendIndex + 1, -1).every(function(c) {
          return c == Extend;
        }) && next == E_Modifier) {
          return NotBreak;
        }
        if (previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
          return NotBreak;
        }
        if (mid.indexOf(Regional_Indicator) != -1) {
          return Break;
        }
        if (previous == Regional_Indicator && next == Regional_Indicator) {
          return NotBreak;
        }
        return BreakStart;
      }
      this.nextBreak = function(string, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string.length - 1) {
          return string.length;
        }
        var prev = getGraphemeBreakProperty(codePointAt(string, index));
        var mid = [];
        for (var i = index + 1; i < string.length; i++) {
          if (isSurrogate(string, i - 1)) {
            continue;
          }
          var next = getGraphemeBreakProperty(codePointAt(string, i));
          if (shouldBreak(prev, mid, next)) {
            return i;
          }
          mid.push(next);
        }
        return string.length;
      };
      this.splitGraphemes = function(str) {
        var res = [];
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      };
      this.iterateGraphemes = function(str) {
        var index = 0;
        var res = {
          next: function() {
            var value;
            var brk;
            if ((brk = this.nextBreak(str, index)) < str.length) {
              value = str.slice(index, brk);
              index = brk;
              return {value, done: false};
            }
            if (index < str.length) {
              value = str.slice(index);
              index = str.length;
              return {value, done: false};
            }
            return {value: void 0, done: true};
          }.bind(this)
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          res[Symbol.iterator] = function() {
            return res;
          };
        }
        return res;
      };
      this.countGraphemes = function(str) {
        var count = 0;
        var index = 0;
        var brk;
        while ((brk = this.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      };
      function getGraphemeBreakProperty(code) {
        if (1536 <= code && code <= 1541 || code == 1757 || code == 1807 || code == 2274 || code == 3406 || code == 69821 || 70082 <= code && code <= 70083 || code == 72250 || 72326 <= code && code <= 72329 || code == 73030) {
          return Prepend;
        }
        if (code == 13) {
          return CR;
        }
        if (code == 10) {
          return LF;
        }
        if (0 <= code && code <= 9 || 11 <= code && code <= 12 || 14 <= code && code <= 31 || 127 <= code && code <= 159 || code == 173 || code == 1564 || code == 6158 || code == 8203 || 8206 <= code && code <= 8207 || code == 8232 || code == 8233 || 8234 <= code && code <= 8238 || 8288 <= code && code <= 8292 || code == 8293 || 8294 <= code && code <= 8303 || 55296 <= code && code <= 57343 || code == 65279 || 65520 <= code && code <= 65528 || 65529 <= code && code <= 65531 || 113824 <= code && code <= 113827 || 119155 <= code && code <= 119162 || code == 917504 || code == 917505 || 917506 <= code && code <= 917535 || 917632 <= code && code <= 917759 || 918e3 <= code && code <= 921599) {
          return Control;
        }
        if (768 <= code && code <= 879 || 1155 <= code && code <= 1159 || 1160 <= code && code <= 1161 || 1425 <= code && code <= 1469 || code == 1471 || 1473 <= code && code <= 1474 || 1476 <= code && code <= 1477 || code == 1479 || 1552 <= code && code <= 1562 || 1611 <= code && code <= 1631 || code == 1648 || 1750 <= code && code <= 1756 || 1759 <= code && code <= 1764 || 1767 <= code && code <= 1768 || 1770 <= code && code <= 1773 || code == 1809 || 1840 <= code && code <= 1866 || 1958 <= code && code <= 1968 || 2027 <= code && code <= 2035 || 2070 <= code && code <= 2073 || 2075 <= code && code <= 2083 || 2085 <= code && code <= 2087 || 2089 <= code && code <= 2093 || 2137 <= code && code <= 2139 || 2260 <= code && code <= 2273 || 2275 <= code && code <= 2306 || code == 2362 || code == 2364 || 2369 <= code && code <= 2376 || code == 2381 || 2385 <= code && code <= 2391 || 2402 <= code && code <= 2403 || code == 2433 || code == 2492 || code == 2494 || 2497 <= code && code <= 2500 || code == 2509 || code == 2519 || 2530 <= code && code <= 2531 || 2561 <= code && code <= 2562 || code == 2620 || 2625 <= code && code <= 2626 || 2631 <= code && code <= 2632 || 2635 <= code && code <= 2637 || code == 2641 || 2672 <= code && code <= 2673 || code == 2677 || 2689 <= code && code <= 2690 || code == 2748 || 2753 <= code && code <= 2757 || 2759 <= code && code <= 2760 || code == 2765 || 2786 <= code && code <= 2787 || 2810 <= code && code <= 2815 || code == 2817 || code == 2876 || code == 2878 || code == 2879 || 2881 <= code && code <= 2884 || code == 2893 || code == 2902 || code == 2903 || 2914 <= code && code <= 2915 || code == 2946 || code == 3006 || code == 3008 || code == 3021 || code == 3031 || code == 3072 || 3134 <= code && code <= 3136 || 3142 <= code && code <= 3144 || 3146 <= code && code <= 3149 || 3157 <= code && code <= 3158 || 3170 <= code && code <= 3171 || code == 3201 || code == 3260 || code == 3263 || code == 3266 || code == 3270 || 3276 <= code && code <= 3277 || 3285 <= code && code <= 3286 || 3298 <= code && code <= 3299 || 3328 <= code && code <= 3329 || 3387 <= code && code <= 3388 || code == 3390 || 3393 <= code && code <= 3396 || code == 3405 || code == 3415 || 3426 <= code && code <= 3427 || code == 3530 || code == 3535 || 3538 <= code && code <= 3540 || code == 3542 || code == 3551 || code == 3633 || 3636 <= code && code <= 3642 || 3655 <= code && code <= 3662 || code == 3761 || 3764 <= code && code <= 3769 || 3771 <= code && code <= 3772 || 3784 <= code && code <= 3789 || 3864 <= code && code <= 3865 || code == 3893 || code == 3895 || code == 3897 || 3953 <= code && code <= 3966 || 3968 <= code && code <= 3972 || 3974 <= code && code <= 3975 || 3981 <= code && code <= 3991 || 3993 <= code && code <= 4028 || code == 4038 || 4141 <= code && code <= 4144 || 4146 <= code && code <= 4151 || 4153 <= code && code <= 4154 || 4157 <= code && code <= 4158 || 4184 <= code && code <= 4185 || 4190 <= code && code <= 4192 || 4209 <= code && code <= 4212 || code == 4226 || 4229 <= code && code <= 4230 || code == 4237 || code == 4253 || 4957 <= code && code <= 4959 || 5906 <= code && code <= 5908 || 5938 <= code && code <= 5940 || 5970 <= code && code <= 5971 || 6002 <= code && code <= 6003 || 6068 <= code && code <= 6069 || 6071 <= code && code <= 6077 || code == 6086 || 6089 <= code && code <= 6099 || code == 6109 || 6155 <= code && code <= 6157 || 6277 <= code && code <= 6278 || code == 6313 || 6432 <= code && code <= 6434 || 6439 <= code && code <= 6440 || code == 6450 || 6457 <= code && code <= 6459 || 6679 <= code && code <= 6680 || code == 6683 || code == 6742 || 6744 <= code && code <= 6750 || code == 6752 || code == 6754 || 6757 <= code && code <= 6764 || 6771 <= code && code <= 6780 || code == 6783 || 6832 <= code && code <= 6845 || code == 6846 || 6912 <= code && code <= 6915 || code == 6964 || 6966 <= code && code <= 6970 || code == 6972 || code == 6978 || 7019 <= code && code <= 7027 || 7040 <= code && code <= 7041 || 7074 <= code && code <= 7077 || 7080 <= code && code <= 7081 || 7083 <= code && code <= 7085 || code == 7142 || 7144 <= code && code <= 7145 || code == 7149 || 7151 <= code && code <= 7153 || 7212 <= code && code <= 7219 || 7222 <= code && code <= 7223 || 7376 <= code && code <= 7378 || 7380 <= code && code <= 7392 || 7394 <= code && code <= 7400 || code == 7405 || code == 7412 || 7416 <= code && code <= 7417 || 7616 <= code && code <= 7673 || 7675 <= code && code <= 7679 || code == 8204 || 8400 <= code && code <= 8412 || 8413 <= code && code <= 8416 || code == 8417 || 8418 <= code && code <= 8420 || 8421 <= code && code <= 8432 || 11503 <= code && code <= 11505 || code == 11647 || 11744 <= code && code <= 11775 || 12330 <= code && code <= 12333 || 12334 <= code && code <= 12335 || 12441 <= code && code <= 12442 || code == 42607 || 42608 <= code && code <= 42610 || 42612 <= code && code <= 42621 || 42654 <= code && code <= 42655 || 42736 <= code && code <= 42737 || code == 43010 || code == 43014 || code == 43019 || 43045 <= code && code <= 43046 || 43204 <= code && code <= 43205 || 43232 <= code && code <= 43249 || 43302 <= code && code <= 43309 || 43335 <= code && code <= 43345 || 43392 <= code && code <= 43394 || code == 43443 || 43446 <= code && code <= 43449 || code == 43452 || code == 43493 || 43561 <= code && code <= 43566 || 43569 <= code && code <= 43570 || 43573 <= code && code <= 43574 || code == 43587 || code == 43596 || code == 43644 || code == 43696 || 43698 <= code && code <= 43700 || 43703 <= code && code <= 43704 || 43710 <= code && code <= 43711 || code == 43713 || 43756 <= code && code <= 43757 || code == 43766 || code == 44005 || code == 44008 || code == 44013 || code == 64286 || 65024 <= code && code <= 65039 || 65056 <= code && code <= 65071 || 65438 <= code && code <= 65439 || code == 66045 || code == 66272 || 66422 <= code && code <= 66426 || 68097 <= code && code <= 68099 || 68101 <= code && code <= 68102 || 68108 <= code && code <= 68111 || 68152 <= code && code <= 68154 || code == 68159 || 68325 <= code && code <= 68326 || code == 69633 || 69688 <= code && code <= 69702 || 69759 <= code && code <= 69761 || 69811 <= code && code <= 69814 || 69817 <= code && code <= 69818 || 69888 <= code && code <= 69890 || 69927 <= code && code <= 69931 || 69933 <= code && code <= 69940 || code == 70003 || 70016 <= code && code <= 70017 || 70070 <= code && code <= 70078 || 70090 <= code && code <= 70092 || 70191 <= code && code <= 70193 || code == 70196 || 70198 <= code && code <= 70199 || code == 70206 || code == 70367 || 70371 <= code && code <= 70378 || 70400 <= code && code <= 70401 || code == 70460 || code == 70462 || code == 70464 || code == 70487 || 70502 <= code && code <= 70508 || 70512 <= code && code <= 70516 || 70712 <= code && code <= 70719 || 70722 <= code && code <= 70724 || code == 70726 || code == 70832 || 70835 <= code && code <= 70840 || code == 70842 || code == 70845 || 70847 <= code && code <= 70848 || 70850 <= code && code <= 70851 || code == 71087 || 71090 <= code && code <= 71093 || 71100 <= code && code <= 71101 || 71103 <= code && code <= 71104 || 71132 <= code && code <= 71133 || 71219 <= code && code <= 71226 || code == 71229 || 71231 <= code && code <= 71232 || code == 71339 || code == 71341 || 71344 <= code && code <= 71349 || code == 71351 || 71453 <= code && code <= 71455 || 71458 <= code && code <= 71461 || 71463 <= code && code <= 71467 || 72193 <= code && code <= 72198 || 72201 <= code && code <= 72202 || 72243 <= code && code <= 72248 || 72251 <= code && code <= 72254 || code == 72263 || 72273 <= code && code <= 72278 || 72281 <= code && code <= 72283 || 72330 <= code && code <= 72342 || 72344 <= code && code <= 72345 || 72752 <= code && code <= 72758 || 72760 <= code && code <= 72765 || code == 72767 || 72850 <= code && code <= 72871 || 72874 <= code && code <= 72880 || 72882 <= code && code <= 72883 || 72885 <= code && code <= 72886 || 73009 <= code && code <= 73014 || code == 73018 || 73020 <= code && code <= 73021 || 73023 <= code && code <= 73029 || code == 73031 || 92912 <= code && code <= 92916 || 92976 <= code && code <= 92982 || 94095 <= code && code <= 94098 || 113821 <= code && code <= 113822 || code == 119141 || 119143 <= code && code <= 119145 || 119150 <= code && code <= 119154 || 119163 <= code && code <= 119170 || 119173 <= code && code <= 119179 || 119210 <= code && code <= 119213 || 119362 <= code && code <= 119364 || 121344 <= code && code <= 121398 || 121403 <= code && code <= 121452 || code == 121461 || code == 121476 || 121499 <= code && code <= 121503 || 121505 <= code && code <= 121519 || 122880 <= code && code <= 122886 || 122888 <= code && code <= 122904 || 122907 <= code && code <= 122913 || 122915 <= code && code <= 122916 || 122918 <= code && code <= 122922 || 125136 <= code && code <= 125142 || 125252 <= code && code <= 125258 || 917536 <= code && code <= 917631 || 917760 <= code && code <= 917999) {
          return Extend;
        }
        if (127462 <= code && code <= 127487) {
          return Regional_Indicator;
        }
        if (code == 2307 || code == 2363 || 2366 <= code && code <= 2368 || 2377 <= code && code <= 2380 || 2382 <= code && code <= 2383 || 2434 <= code && code <= 2435 || 2495 <= code && code <= 2496 || 2503 <= code && code <= 2504 || 2507 <= code && code <= 2508 || code == 2563 || 2622 <= code && code <= 2624 || code == 2691 || 2750 <= code && code <= 2752 || code == 2761 || 2763 <= code && code <= 2764 || 2818 <= code && code <= 2819 || code == 2880 || 2887 <= code && code <= 2888 || 2891 <= code && code <= 2892 || code == 3007 || 3009 <= code && code <= 3010 || 3014 <= code && code <= 3016 || 3018 <= code && code <= 3020 || 3073 <= code && code <= 3075 || 3137 <= code && code <= 3140 || 3202 <= code && code <= 3203 || code == 3262 || 3264 <= code && code <= 3265 || 3267 <= code && code <= 3268 || 3271 <= code && code <= 3272 || 3274 <= code && code <= 3275 || 3330 <= code && code <= 3331 || 3391 <= code && code <= 3392 || 3398 <= code && code <= 3400 || 3402 <= code && code <= 3404 || 3458 <= code && code <= 3459 || 3536 <= code && code <= 3537 || 3544 <= code && code <= 3550 || 3570 <= code && code <= 3571 || code == 3635 || code == 3763 || 3902 <= code && code <= 3903 || code == 3967 || code == 4145 || 4155 <= code && code <= 4156 || 4182 <= code && code <= 4183 || code == 4228 || code == 6070 || 6078 <= code && code <= 6085 || 6087 <= code && code <= 6088 || 6435 <= code && code <= 6438 || 6441 <= code && code <= 6443 || 6448 <= code && code <= 6449 || 6451 <= code && code <= 6456 || 6681 <= code && code <= 6682 || code == 6741 || code == 6743 || 6765 <= code && code <= 6770 || code == 6916 || code == 6965 || code == 6971 || 6973 <= code && code <= 6977 || 6979 <= code && code <= 6980 || code == 7042 || code == 7073 || 7078 <= code && code <= 7079 || code == 7082 || code == 7143 || 7146 <= code && code <= 7148 || code == 7150 || 7154 <= code && code <= 7155 || 7204 <= code && code <= 7211 || 7220 <= code && code <= 7221 || code == 7393 || 7410 <= code && code <= 7411 || code == 7415 || 43043 <= code && code <= 43044 || code == 43047 || 43136 <= code && code <= 43137 || 43188 <= code && code <= 43203 || 43346 <= code && code <= 43347 || code == 43395 || 43444 <= code && code <= 43445 || 43450 <= code && code <= 43451 || 43453 <= code && code <= 43456 || 43567 <= code && code <= 43568 || 43571 <= code && code <= 43572 || code == 43597 || code == 43755 || 43758 <= code && code <= 43759 || code == 43765 || 44003 <= code && code <= 44004 || 44006 <= code && code <= 44007 || 44009 <= code && code <= 44010 || code == 44012 || code == 69632 || code == 69634 || code == 69762 || 69808 <= code && code <= 69810 || 69815 <= code && code <= 69816 || code == 69932 || code == 70018 || 70067 <= code && code <= 70069 || 70079 <= code && code <= 70080 || 70188 <= code && code <= 70190 || 70194 <= code && code <= 70195 || code == 70197 || 70368 <= code && code <= 70370 || 70402 <= code && code <= 70403 || code == 70463 || 70465 <= code && code <= 70468 || 70471 <= code && code <= 70472 || 70475 <= code && code <= 70477 || 70498 <= code && code <= 70499 || 70709 <= code && code <= 70711 || 70720 <= code && code <= 70721 || code == 70725 || 70833 <= code && code <= 70834 || code == 70841 || 70843 <= code && code <= 70844 || code == 70846 || code == 70849 || 71088 <= code && code <= 71089 || 71096 <= code && code <= 71099 || code == 71102 || 71216 <= code && code <= 71218 || 71227 <= code && code <= 71228 || code == 71230 || code == 71340 || 71342 <= code && code <= 71343 || code == 71350 || 71456 <= code && code <= 71457 || code == 71462 || 72199 <= code && code <= 72200 || code == 72249 || 72279 <= code && code <= 72280 || code == 72343 || code == 72751 || code == 72766 || code == 72873 || code == 72881 || code == 72884 || 94033 <= code && code <= 94078 || code == 119142 || code == 119149) {
          return SpacingMark;
        }
        if (4352 <= code && code <= 4447 || 43360 <= code && code <= 43388) {
          return L;
        }
        if (4448 <= code && code <= 4519 || 55216 <= code && code <= 55238) {
          return V;
        }
        if (4520 <= code && code <= 4607 || 55243 <= code && code <= 55291) {
          return T;
        }
        if (code == 44032 || code == 44060 || code == 44088 || code == 44116 || code == 44144 || code == 44172 || code == 44200 || code == 44228 || code == 44256 || code == 44284 || code == 44312 || code == 44340 || code == 44368 || code == 44396 || code == 44424 || code == 44452 || code == 44480 || code == 44508 || code == 44536 || code == 44564 || code == 44592 || code == 44620 || code == 44648 || code == 44676 || code == 44704 || code == 44732 || code == 44760 || code == 44788 || code == 44816 || code == 44844 || code == 44872 || code == 44900 || code == 44928 || code == 44956 || code == 44984 || code == 45012 || code == 45040 || code == 45068 || code == 45096 || code == 45124 || code == 45152 || code == 45180 || code == 45208 || code == 45236 || code == 45264 || code == 45292 || code == 45320 || code == 45348 || code == 45376 || code == 45404 || code == 45432 || code == 45460 || code == 45488 || code == 45516 || code == 45544 || code == 45572 || code == 45600 || code == 45628 || code == 45656 || code == 45684 || code == 45712 || code == 45740 || code == 45768 || code == 45796 || code == 45824 || code == 45852 || code == 45880 || code == 45908 || code == 45936 || code == 45964 || code == 45992 || code == 46020 || code == 46048 || code == 46076 || code == 46104 || code == 46132 || code == 46160 || code == 46188 || code == 46216 || code == 46244 || code == 46272 || code == 46300 || code == 46328 || code == 46356 || code == 46384 || code == 46412 || code == 46440 || code == 46468 || code == 46496 || code == 46524 || code == 46552 || code == 46580 || code == 46608 || code == 46636 || code == 46664 || code == 46692 || code == 46720 || code == 46748 || code == 46776 || code == 46804 || code == 46832 || code == 46860 || code == 46888 || code == 46916 || code == 46944 || code == 46972 || code == 47e3 || code == 47028 || code == 47056 || code == 47084 || code == 47112 || code == 47140 || code == 47168 || code == 47196 || code == 47224 || code == 47252 || code == 47280 || code == 47308 || code == 47336 || code == 47364 || code == 47392 || code == 47420 || code == 47448 || code == 47476 || code == 47504 || code == 47532 || code == 47560 || code == 47588 || code == 47616 || code == 47644 || code == 47672 || code == 47700 || code == 47728 || code == 47756 || code == 47784 || code == 47812 || code == 47840 || code == 47868 || code == 47896 || code == 47924 || code == 47952 || code == 47980 || code == 48008 || code == 48036 || code == 48064 || code == 48092 || code == 48120 || code == 48148 || code == 48176 || code == 48204 || code == 48232 || code == 48260 || code == 48288 || code == 48316 || code == 48344 || code == 48372 || code == 48400 || code == 48428 || code == 48456 || code == 48484 || code == 48512 || code == 48540 || code == 48568 || code == 48596 || code == 48624 || code == 48652 || code == 48680 || code == 48708 || code == 48736 || code == 48764 || code == 48792 || code == 48820 || code == 48848 || code == 48876 || code == 48904 || code == 48932 || code == 48960 || code == 48988 || code == 49016 || code == 49044 || code == 49072 || code == 49100 || code == 49128 || code == 49156 || code == 49184 || code == 49212 || code == 49240 || code == 49268 || code == 49296 || code == 49324 || code == 49352 || code == 49380 || code == 49408 || code == 49436 || code == 49464 || code == 49492 || code == 49520 || code == 49548 || code == 49576 || code == 49604 || code == 49632 || code == 49660 || code == 49688 || code == 49716 || code == 49744 || code == 49772 || code == 49800 || code == 49828 || code == 49856 || code == 49884 || code == 49912 || code == 49940 || code == 49968 || code == 49996 || code == 50024 || code == 50052 || code == 50080 || code == 50108 || code == 50136 || code == 50164 || code == 50192 || code == 50220 || code == 50248 || code == 50276 || code == 50304 || code == 50332 || code == 50360 || code == 50388 || code == 50416 || code == 50444 || code == 50472 || code == 50500 || code == 50528 || code == 50556 || code == 50584 || code == 50612 || code == 50640 || code == 50668 || code == 50696 || code == 50724 || code == 50752 || code == 50780 || code == 50808 || code == 50836 || code == 50864 || code == 50892 || code == 50920 || code == 50948 || code == 50976 || code == 51004 || code == 51032 || code == 51060 || code == 51088 || code == 51116 || code == 51144 || code == 51172 || code == 51200 || code == 51228 || code == 51256 || code == 51284 || code == 51312 || code == 51340 || code == 51368 || code == 51396 || code == 51424 || code == 51452 || code == 51480 || code == 51508 || code == 51536 || code == 51564 || code == 51592 || code == 51620 || code == 51648 || code == 51676 || code == 51704 || code == 51732 || code == 51760 || code == 51788 || code == 51816 || code == 51844 || code == 51872 || code == 51900 || code == 51928 || code == 51956 || code == 51984 || code == 52012 || code == 52040 || code == 52068 || code == 52096 || code == 52124 || code == 52152 || code == 52180 || code == 52208 || code == 52236 || code == 52264 || code == 52292 || code == 52320 || code == 52348 || code == 52376 || code == 52404 || code == 52432 || code == 52460 || code == 52488 || code == 52516 || code == 52544 || code == 52572 || code == 52600 || code == 52628 || code == 52656 || code == 52684 || code == 52712 || code == 52740 || code == 52768 || code == 52796 || code == 52824 || code == 52852 || code == 52880 || code == 52908 || code == 52936 || code == 52964 || code == 52992 || code == 53020 || code == 53048 || code == 53076 || code == 53104 || code == 53132 || code == 53160 || code == 53188 || code == 53216 || code == 53244 || code == 53272 || code == 53300 || code == 53328 || code == 53356 || code == 53384 || code == 53412 || code == 53440 || code == 53468 || code == 53496 || code == 53524 || code == 53552 || code == 53580 || code == 53608 || code == 53636 || code == 53664 || code == 53692 || code == 53720 || code == 53748 || code == 53776 || code == 53804 || code == 53832 || code == 53860 || code == 53888 || code == 53916 || code == 53944 || code == 53972 || code == 54e3 || code == 54028 || code == 54056 || code == 54084 || code == 54112 || code == 54140 || code == 54168 || code == 54196 || code == 54224 || code == 54252 || code == 54280 || code == 54308 || code == 54336 || code == 54364 || code == 54392 || code == 54420 || code == 54448 || code == 54476 || code == 54504 || code == 54532 || code == 54560 || code == 54588 || code == 54616 || code == 54644 || code == 54672 || code == 54700 || code == 54728 || code == 54756 || code == 54784 || code == 54812 || code == 54840 || code == 54868 || code == 54896 || code == 54924 || code == 54952 || code == 54980 || code == 55008 || code == 55036 || code == 55064 || code == 55092 || code == 55120 || code == 55148 || code == 55176) {
          return LV;
        }
        if (44033 <= code && code <= 44059 || 44061 <= code && code <= 44087 || 44089 <= code && code <= 44115 || 44117 <= code && code <= 44143 || 44145 <= code && code <= 44171 || 44173 <= code && code <= 44199 || 44201 <= code && code <= 44227 || 44229 <= code && code <= 44255 || 44257 <= code && code <= 44283 || 44285 <= code && code <= 44311 || 44313 <= code && code <= 44339 || 44341 <= code && code <= 44367 || 44369 <= code && code <= 44395 || 44397 <= code && code <= 44423 || 44425 <= code && code <= 44451 || 44453 <= code && code <= 44479 || 44481 <= code && code <= 44507 || 44509 <= code && code <= 44535 || 44537 <= code && code <= 44563 || 44565 <= code && code <= 44591 || 44593 <= code && code <= 44619 || 44621 <= code && code <= 44647 || 44649 <= code && code <= 44675 || 44677 <= code && code <= 44703 || 44705 <= code && code <= 44731 || 44733 <= code && code <= 44759 || 44761 <= code && code <= 44787 || 44789 <= code && code <= 44815 || 44817 <= code && code <= 44843 || 44845 <= code && code <= 44871 || 44873 <= code && code <= 44899 || 44901 <= code && code <= 44927 || 44929 <= code && code <= 44955 || 44957 <= code && code <= 44983 || 44985 <= code && code <= 45011 || 45013 <= code && code <= 45039 || 45041 <= code && code <= 45067 || 45069 <= code && code <= 45095 || 45097 <= code && code <= 45123 || 45125 <= code && code <= 45151 || 45153 <= code && code <= 45179 || 45181 <= code && code <= 45207 || 45209 <= code && code <= 45235 || 45237 <= code && code <= 45263 || 45265 <= code && code <= 45291 || 45293 <= code && code <= 45319 || 45321 <= code && code <= 45347 || 45349 <= code && code <= 45375 || 45377 <= code && code <= 45403 || 45405 <= code && code <= 45431 || 45433 <= code && code <= 45459 || 45461 <= code && code <= 45487 || 45489 <= code && code <= 45515 || 45517 <= code && code <= 45543 || 45545 <= code && code <= 45571 || 45573 <= code && code <= 45599 || 45601 <= code && code <= 45627 || 45629 <= code && code <= 45655 || 45657 <= code && code <= 45683 || 45685 <= code && code <= 45711 || 45713 <= code && code <= 45739 || 45741 <= code && code <= 45767 || 45769 <= code && code <= 45795 || 45797 <= code && code <= 45823 || 45825 <= code && code <= 45851 || 45853 <= code && code <= 45879 || 45881 <= code && code <= 45907 || 45909 <= code && code <= 45935 || 45937 <= code && code <= 45963 || 45965 <= code && code <= 45991 || 45993 <= code && code <= 46019 || 46021 <= code && code <= 46047 || 46049 <= code && code <= 46075 || 46077 <= code && code <= 46103 || 46105 <= code && code <= 46131 || 46133 <= code && code <= 46159 || 46161 <= code && code <= 46187 || 46189 <= code && code <= 46215 || 46217 <= code && code <= 46243 || 46245 <= code && code <= 46271 || 46273 <= code && code <= 46299 || 46301 <= code && code <= 46327 || 46329 <= code && code <= 46355 || 46357 <= code && code <= 46383 || 46385 <= code && code <= 46411 || 46413 <= code && code <= 46439 || 46441 <= code && code <= 46467 || 46469 <= code && code <= 46495 || 46497 <= code && code <= 46523 || 46525 <= code && code <= 46551 || 46553 <= code && code <= 46579 || 46581 <= code && code <= 46607 || 46609 <= code && code <= 46635 || 46637 <= code && code <= 46663 || 46665 <= code && code <= 46691 || 46693 <= code && code <= 46719 || 46721 <= code && code <= 46747 || 46749 <= code && code <= 46775 || 46777 <= code && code <= 46803 || 46805 <= code && code <= 46831 || 46833 <= code && code <= 46859 || 46861 <= code && code <= 46887 || 46889 <= code && code <= 46915 || 46917 <= code && code <= 46943 || 46945 <= code && code <= 46971 || 46973 <= code && code <= 46999 || 47001 <= code && code <= 47027 || 47029 <= code && code <= 47055 || 47057 <= code && code <= 47083 || 47085 <= code && code <= 47111 || 47113 <= code && code <= 47139 || 47141 <= code && code <= 47167 || 47169 <= code && code <= 47195 || 47197 <= code && code <= 47223 || 47225 <= code && code <= 47251 || 47253 <= code && code <= 47279 || 47281 <= code && code <= 47307 || 47309 <= code && code <= 47335 || 47337 <= code && code <= 47363 || 47365 <= code && code <= 47391 || 47393 <= code && code <= 47419 || 47421 <= code && code <= 47447 || 47449 <= code && code <= 47475 || 47477 <= code && code <= 47503 || 47505 <= code && code <= 47531 || 47533 <= code && code <= 47559 || 47561 <= code && code <= 47587 || 47589 <= code && code <= 47615 || 47617 <= code && code <= 47643 || 47645 <= code && code <= 47671 || 47673 <= code && code <= 47699 || 47701 <= code && code <= 47727 || 47729 <= code && code <= 47755 || 47757 <= code && code <= 47783 || 47785 <= code && code <= 47811 || 47813 <= code && code <= 47839 || 47841 <= code && code <= 47867 || 47869 <= code && code <= 47895 || 47897 <= code && code <= 47923 || 47925 <= code && code <= 47951 || 47953 <= code && code <= 47979 || 47981 <= code && code <= 48007 || 48009 <= code && code <= 48035 || 48037 <= code && code <= 48063 || 48065 <= code && code <= 48091 || 48093 <= code && code <= 48119 || 48121 <= code && code <= 48147 || 48149 <= code && code <= 48175 || 48177 <= code && code <= 48203 || 48205 <= code && code <= 48231 || 48233 <= code && code <= 48259 || 48261 <= code && code <= 48287 || 48289 <= code && code <= 48315 || 48317 <= code && code <= 48343 || 48345 <= code && code <= 48371 || 48373 <= code && code <= 48399 || 48401 <= code && code <= 48427 || 48429 <= code && code <= 48455 || 48457 <= code && code <= 48483 || 48485 <= code && code <= 48511 || 48513 <= code && code <= 48539 || 48541 <= code && code <= 48567 || 48569 <= code && code <= 48595 || 48597 <= code && code <= 48623 || 48625 <= code && code <= 48651 || 48653 <= code && code <= 48679 || 48681 <= code && code <= 48707 || 48709 <= code && code <= 48735 || 48737 <= code && code <= 48763 || 48765 <= code && code <= 48791 || 48793 <= code && code <= 48819 || 48821 <= code && code <= 48847 || 48849 <= code && code <= 48875 || 48877 <= code && code <= 48903 || 48905 <= code && code <= 48931 || 48933 <= code && code <= 48959 || 48961 <= code && code <= 48987 || 48989 <= code && code <= 49015 || 49017 <= code && code <= 49043 || 49045 <= code && code <= 49071 || 49073 <= code && code <= 49099 || 49101 <= code && code <= 49127 || 49129 <= code && code <= 49155 || 49157 <= code && code <= 49183 || 49185 <= code && code <= 49211 || 49213 <= code && code <= 49239 || 49241 <= code && code <= 49267 || 49269 <= code && code <= 49295 || 49297 <= code && code <= 49323 || 49325 <= code && code <= 49351 || 49353 <= code && code <= 49379 || 49381 <= code && code <= 49407 || 49409 <= code && code <= 49435 || 49437 <= code && code <= 49463 || 49465 <= code && code <= 49491 || 49493 <= code && code <= 49519 || 49521 <= code && code <= 49547 || 49549 <= code && code <= 49575 || 49577 <= code && code <= 49603 || 49605 <= code && code <= 49631 || 49633 <= code && code <= 49659 || 49661 <= code && code <= 49687 || 49689 <= code && code <= 49715 || 49717 <= code && code <= 49743 || 49745 <= code && code <= 49771 || 49773 <= code && code <= 49799 || 49801 <= code && code <= 49827 || 49829 <= code && code <= 49855 || 49857 <= code && code <= 49883 || 49885 <= code && code <= 49911 || 49913 <= code && code <= 49939 || 49941 <= code && code <= 49967 || 49969 <= code && code <= 49995 || 49997 <= code && code <= 50023 || 50025 <= code && code <= 50051 || 50053 <= code && code <= 50079 || 50081 <= code && code <= 50107 || 50109 <= code && code <= 50135 || 50137 <= code && code <= 50163 || 50165 <= code && code <= 50191 || 50193 <= code && code <= 50219 || 50221 <= code && code <= 50247 || 50249 <= code && code <= 50275 || 50277 <= code && code <= 50303 || 50305 <= code && code <= 50331 || 50333 <= code && code <= 50359 || 50361 <= code && code <= 50387 || 50389 <= code && code <= 50415 || 50417 <= code && code <= 50443 || 50445 <= code && code <= 50471 || 50473 <= code && code <= 50499 || 50501 <= code && code <= 50527 || 50529 <= code && code <= 50555 || 50557 <= code && code <= 50583 || 50585 <= code && code <= 50611 || 50613 <= code && code <= 50639 || 50641 <= code && code <= 50667 || 50669 <= code && code <= 50695 || 50697 <= code && code <= 50723 || 50725 <= code && code <= 50751 || 50753 <= code && code <= 50779 || 50781 <= code && code <= 50807 || 50809 <= code && code <= 50835 || 50837 <= code && code <= 50863 || 50865 <= code && code <= 50891 || 50893 <= code && code <= 50919 || 50921 <= code && code <= 50947 || 50949 <= code && code <= 50975 || 50977 <= code && code <= 51003 || 51005 <= code && code <= 51031 || 51033 <= code && code <= 51059 || 51061 <= code && code <= 51087 || 51089 <= code && code <= 51115 || 51117 <= code && code <= 51143 || 51145 <= code && code <= 51171 || 51173 <= code && code <= 51199 || 51201 <= code && code <= 51227 || 51229 <= code && code <= 51255 || 51257 <= code && code <= 51283 || 51285 <= code && code <= 51311 || 51313 <= code && code <= 51339 || 51341 <= code && code <= 51367 || 51369 <= code && code <= 51395 || 51397 <= code && code <= 51423 || 51425 <= code && code <= 51451 || 51453 <= code && code <= 51479 || 51481 <= code && code <= 51507 || 51509 <= code && code <= 51535 || 51537 <= code && code <= 51563 || 51565 <= code && code <= 51591 || 51593 <= code && code <= 51619 || 51621 <= code && code <= 51647 || 51649 <= code && code <= 51675 || 51677 <= code && code <= 51703 || 51705 <= code && code <= 51731 || 51733 <= code && code <= 51759 || 51761 <= code && code <= 51787 || 51789 <= code && code <= 51815 || 51817 <= code && code <= 51843 || 51845 <= code && code <= 51871 || 51873 <= code && code <= 51899 || 51901 <= code && code <= 51927 || 51929 <= code && code <= 51955 || 51957 <= code && code <= 51983 || 51985 <= code && code <= 52011 || 52013 <= code && code <= 52039 || 52041 <= code && code <= 52067 || 52069 <= code && code <= 52095 || 52097 <= code && code <= 52123 || 52125 <= code && code <= 52151 || 52153 <= code && code <= 52179 || 52181 <= code && code <= 52207 || 52209 <= code && code <= 52235 || 52237 <= code && code <= 52263 || 52265 <= code && code <= 52291 || 52293 <= code && code <= 52319 || 52321 <= code && code <= 52347 || 52349 <= code && code <= 52375 || 52377 <= code && code <= 52403 || 52405 <= code && code <= 52431 || 52433 <= code && code <= 52459 || 52461 <= code && code <= 52487 || 52489 <= code && code <= 52515 || 52517 <= code && code <= 52543 || 52545 <= code && code <= 52571 || 52573 <= code && code <= 52599 || 52601 <= code && code <= 52627 || 52629 <= code && code <= 52655 || 52657 <= code && code <= 52683 || 52685 <= code && code <= 52711 || 52713 <= code && code <= 52739 || 52741 <= code && code <= 52767 || 52769 <= code && code <= 52795 || 52797 <= code && code <= 52823 || 52825 <= code && code <= 52851 || 52853 <= code && code <= 52879 || 52881 <= code && code <= 52907 || 52909 <= code && code <= 52935 || 52937 <= code && code <= 52963 || 52965 <= code && code <= 52991 || 52993 <= code && code <= 53019 || 53021 <= code && code <= 53047 || 53049 <= code && code <= 53075 || 53077 <= code && code <= 53103 || 53105 <= code && code <= 53131 || 53133 <= code && code <= 53159 || 53161 <= code && code <= 53187 || 53189 <= code && code <= 53215 || 53217 <= code && code <= 53243 || 53245 <= code && code <= 53271 || 53273 <= code && code <= 53299 || 53301 <= code && code <= 53327 || 53329 <= code && code <= 53355 || 53357 <= code && code <= 53383 || 53385 <= code && code <= 53411 || 53413 <= code && code <= 53439 || 53441 <= code && code <= 53467 || 53469 <= code && code <= 53495 || 53497 <= code && code <= 53523 || 53525 <= code && code <= 53551 || 53553 <= code && code <= 53579 || 53581 <= code && code <= 53607 || 53609 <= code && code <= 53635 || 53637 <= code && code <= 53663 || 53665 <= code && code <= 53691 || 53693 <= code && code <= 53719 || 53721 <= code && code <= 53747 || 53749 <= code && code <= 53775 || 53777 <= code && code <= 53803 || 53805 <= code && code <= 53831 || 53833 <= code && code <= 53859 || 53861 <= code && code <= 53887 || 53889 <= code && code <= 53915 || 53917 <= code && code <= 53943 || 53945 <= code && code <= 53971 || 53973 <= code && code <= 53999 || 54001 <= code && code <= 54027 || 54029 <= code && code <= 54055 || 54057 <= code && code <= 54083 || 54085 <= code && code <= 54111 || 54113 <= code && code <= 54139 || 54141 <= code && code <= 54167 || 54169 <= code && code <= 54195 || 54197 <= code && code <= 54223 || 54225 <= code && code <= 54251 || 54253 <= code && code <= 54279 || 54281 <= code && code <= 54307 || 54309 <= code && code <= 54335 || 54337 <= code && code <= 54363 || 54365 <= code && code <= 54391 || 54393 <= code && code <= 54419 || 54421 <= code && code <= 54447 || 54449 <= code && code <= 54475 || 54477 <= code && code <= 54503 || 54505 <= code && code <= 54531 || 54533 <= code && code <= 54559 || 54561 <= code && code <= 54587 || 54589 <= code && code <= 54615 || 54617 <= code && code <= 54643 || 54645 <= code && code <= 54671 || 54673 <= code && code <= 54699 || 54701 <= code && code <= 54727 || 54729 <= code && code <= 54755 || 54757 <= code && code <= 54783 || 54785 <= code && code <= 54811 || 54813 <= code && code <= 54839 || 54841 <= code && code <= 54867 || 54869 <= code && code <= 54895 || 54897 <= code && code <= 54923 || 54925 <= code && code <= 54951 || 54953 <= code && code <= 54979 || 54981 <= code && code <= 55007 || 55009 <= code && code <= 55035 || 55037 <= code && code <= 55063 || 55065 <= code && code <= 55091 || 55093 <= code && code <= 55119 || 55121 <= code && code <= 55147 || 55149 <= code && code <= 55175 || 55177 <= code && code <= 55203) {
          return LVT;
        }
        if (code == 9757 || code == 9977 || 9994 <= code && code <= 9997 || code == 127877 || 127938 <= code && code <= 127940 || code == 127943 || 127946 <= code && code <= 127948 || 128066 <= code && code <= 128067 || 128070 <= code && code <= 128080 || code == 128110 || 128112 <= code && code <= 128120 || code == 128124 || 128129 <= code && code <= 128131 || 128133 <= code && code <= 128135 || code == 128170 || 128372 <= code && code <= 128373 || code == 128378 || code == 128400 || 128405 <= code && code <= 128406 || 128581 <= code && code <= 128583 || 128587 <= code && code <= 128591 || code == 128675 || 128692 <= code && code <= 128694 || code == 128704 || code == 128716 || 129304 <= code && code <= 129308 || 129310 <= code && code <= 129311 || code == 129318 || 129328 <= code && code <= 129337 || 129341 <= code && code <= 129342 || 129489 <= code && code <= 129501) {
          return E_Base;
        }
        if (127995 <= code && code <= 127999) {
          return E_Modifier;
        }
        if (code == 8205) {
          return ZWJ;
        }
        if (code == 9792 || code == 9794 || 9877 <= code && code <= 9878 || code == 9992 || code == 10084 || code == 127752 || code == 127806 || code == 127859 || code == 127891 || code == 127908 || code == 127912 || code == 127979 || code == 127981 || code == 128139 || 128187 <= code && code <= 128188 || code == 128295 || code == 128300 || code == 128488 || code == 128640 || code == 128658) {
          return Glue_After_Zwj;
        }
        if (128102 <= code && code <= 128105) {
          return E_Base_GAZ;
        }
        return Other;
      }
      return this;
    }
    if (typeof module2 != "undefined" && module2.exports) {
      module2.exports = GraphemeSplitter;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@arcanis-slice-ansi-npm-1.0.2-f258a50730-1b45393630.zip\node_modules\@arcanis\slice-ansi\index.js
  var require_slice_ansi = __commonJS((exports2, module2) => {
    var GraphemeSplitter = require_grapheme_splitter();
    var ANSI_SEQUENCE = /^(.*?)(\x1b\[[^m]+m|\x1b\]8;;.*?(\x1b\\|\u0007))/;
    var splitter = new GraphemeSplitter();
    module2.exports = (orig, at = 0, until = orig.length) => {
      if (at < 0 || until < 0)
        throw new RangeError(`Negative indices aren't supported by this implementation`);
      const length = until - at;
      let output = ``;
      let skipped = 0;
      let visible = 0;
      while (orig.length > 0) {
        const lookup = orig.match(ANSI_SEQUENCE) || [orig, orig, void 0];
        let graphemes = splitter.splitGraphemes(lookup[1]);
        const skipping = Math.min(at - skipped, graphemes.length);
        graphemes = graphemes.slice(skipping);
        const displaying = Math.min(length - visible, graphemes.length);
        output += graphemes.slice(0, displaying).join(``);
        skipped += skipping;
        visible += displaying;
        if (typeof lookup[2] !== `undefined`)
          output += lookup[2];
        orig = orig.slice(lookup[0].length);
      }
      return output;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\high-level-opt.js
  var require_high_level_opt = __commonJS((exports2, module2) => {
    "use strict";
    var argmap = new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    var parse4 = module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\yallist-npm-4.0.0-b493d9e907-a2960ef879.zip\node_modules\yallist\iterator.js
  var require_iterator = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\yallist-npm-4.0.0-b493d9e907-a2960ef879.zip\node_modules\yallist\yallist.js
  var require_yallist = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start2, deleteCount, ...nodes) {
      if (start2 > this.length) {
        start2 = this.length - 1;
      }
      if (start2 < 0) {
        start2 = this.length + start2;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start2; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\minipass-npm-3.1.3-af723e33f3-d12b95a845.zip\node_modules\minipass\index.js
  var require_minipass = __commonJS((exports2, module2) => {
    "use strict";
    var EE = require("events");
    var Stream = require("stream");
    var Yallist = require_yallist();
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = new Yallist();
        this.buffer = new Yallist();
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {code: "ERR_STREAM_DESTROYED"}));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (!this.objectMode && !chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            cb();
          return this.flowing;
        }
        if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing) {
          if (this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          this.emit("data", chunk);
        } else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        try {
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
            return null;
          if (this[OBJECTMODE])
            n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding)
              this.buffer = new Yallist([
                Array.from(this.buffer).join("")
              ]);
            else
              this.buffer = new Yallist([
                Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
              ]);
          }
          return this[READ](n || null, this.buffer.head.value);
        } finally {
          this[MAYBE_EMIT_END]();
        }
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer.head.value = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        return this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer.head.value.length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === process.stdout || dest === process.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        const p = {dest, opts, ondrain: (_) => this[RESUME]()};
        this.pipes.push(p);
        dest.on("drain", p.ondrain);
        this[RESUME]();
        if (ended && p.opts.end)
          p.dest.end();
        return dest;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        try {
          return super.on(ev, fn);
        } finally {
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          }
        }
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          if (!data)
            return;
          if (this.pipes.length)
            this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
        } else if (ev === "end") {
          if (this[EMITTED_END] === true)
            return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[DECODER]) {
            data = this[DECODER].end();
            if (data) {
              this.pipes.forEach((p) => p.dest.write(data));
              super.emit("data", data);
            }
          }
          this.pipes.forEach((p) => {
            p.dest.removeListener("drain", p.ondrain);
            if (p.opts.end)
              p.dest.end();
          });
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
        }
        const args = new Array(arguments.length);
        args[0] = ev;
        args[1] = data;
        if (arguments.length > 2) {
          for (let i = 2; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        try {
          return super.emit.apply(this, args);
        } finally {
          if (!isEndish(ev))
            this[MAYBE_EMIT_END]();
          else
            this.removeAllListeners(ev);
        }
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("end", () => resolve());
          this.on("error", (er) => reject(er));
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({done: false, value: res});
          if (this[EOF])
            return Promise.resolve({done: true});
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({value, done: !!this[EOF]});
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({done: true});
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {next};
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return {value, done};
        };
        return {next};
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer = new Yallist();
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\minizlib-npm-2.1.2-ea89cd0cfb-5a45b57b34.zip\node_modules\minizlib\constants.js
  var require_constants5 = __commonJS((exports2, module2) => {
    var realZlibConstants = require("zlib").constants || {ZLIB_VERNUM: 4736};
    module2.exports = Object.freeze(Object.assign(Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\minizlib-npm-2.1.2-ea89cd0cfb-5a45b57b34.zip\node_modules\minizlib\index.js
  var require_minizlib = __commonJS((exports2) => {
    "use strict";
    var assert = require("assert");
    var Buffer2 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants3 = exports2.constants = require_constants5();
    var Minipass = require_minipass();
    var OriginalBufferConcat = Buffer2.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer2.alloc(0), {[_flushFlag]: flushFlag}));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer2.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer2.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer2.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer2.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer2.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer2.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants3.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants3.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants3.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants3.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants3.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants3.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants3.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\types.js
  var require_types3 = __commonJS((exports2) => {
    "use strict";
    exports2.name = new Map([
      ["0", "File"],
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      ["7", "ContiguousFile"],
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      ["A", "SolarisACL"],
      ["D", "GNUDumpDir"],
      ["I", "Inode"],
      ["K", "NextFileHasLongLinkpath"],
      ["L", "NextFileHasLongPath"],
      ["M", "ContinuationFile"],
      ["N", "OldGnuLongPath"],
      ["S", "SparseFile"],
      ["V", "TapeVolumeHeader"],
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\read-entry.js
  var require_read_entry = __commonJS((exports2, module2) => {
    "use strict";
    var types2 = require_types3();
    var MiniPass = require_minipass();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = header.path;
        this.mode = header.mode;
        if (this.mode)
          this.mode = this.mode & 4095;
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = header.linkpath;
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex)
          this[SLURP](ex);
        if (gex)
          this[SLURP](gex, true);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore)
          return true;
        if (r >= writeLen)
          return super.write(data);
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (let k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\large-numbers.js
  var require_large_numbers = __commonJS((exports2) => {
    "use strict";
    var encode = exports2.encode = (num, buf) => {
      if (!Number.isSafeInteger(num))
        throw Error("cannot encode number outside of javascript safe integer range");
      else if (num < 0)
        encodeNegative(num, buf);
      else
        encodePositive(num, buf);
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped)
          buf[i - 1] = onesComp(byte);
        else if (byte === 0)
          buf[i - 1] = 0;
        else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse4 = exports2.parse = (buf) => {
      var post4 = buf[buf.length - 1];
      var pre = buf[0];
      var value;
      if (pre === 128)
        value = pos(buf.slice(1, buf.length));
      else if (pre === 255)
        value = twos(buf);
      else
        throw Error("invalid base256 encoding");
      if (!Number.isSafeInteger(value))
        throw Error("parsed number outside of javascript safe integer range");
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped)
          f = onesComp(byte);
        else if (byte === 0)
          f = byte;
        else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0)
          sum -= f * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0)
          sum += byte * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\header.js
  var require_header = __commonJS((exports2, module2) => {
    "use strict";
    var types2 = require_types3();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data))
          this.decode(data, off || 0, ex, gex);
        else if (data)
          this.set(data);
      }
      decode(buf, off, ex, gex) {
        if (!off)
          off = 0;
        if (!buf || !(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "")
          this[TYPE] = "0";
        if (this[TYPE] === "0" && this.path.substr(-1) === "/")
          this[TYPE] = "5";
        if (this[TYPE] === "5")
          this.size = 0;
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix)
              this.path = prefix + "/" + this.path;
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32)
          this.nullBlock = true;
      }
      [SLURP](ex, global2) {
        for (let k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off)
          off = 0;
        if (!(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split2 = splitPrefix(this.path || "", prefixSize);
        const path6 = split2[0];
        const prefix = split2[1];
        this.needPax = split2[2];
        this.needPax = encString(buf, off, 100, path6) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0)
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (let i in data) {
          if (data[i] !== null && data[i] !== void 0)
            this[i] = data[i];
        }
      }
      get type() {
        return types2.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types2.code.has(type))
          this[TYPE] = types2.code.get(type);
        else
          this[TYPE] = type;
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize)
        ret = [pp, prefix, false];
      else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp, prefix, false];
          else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp.substr(0, pathSize - 1), prefix, true];
          else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret)
          ret = [p.substr(0, pathSize - 1), "", true];
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
    var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
    var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
    var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
    module2.exports = Header;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\pax.js
  var require_pax = __commonJS((exports2, module2) => {
    "use strict";
    var Header = require_header();
    var path6 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "")
          return null;
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          path: ("PaxHeader/" + path6.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0)
          return "";
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits))
          digits += 1;
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string, ex, g) => new Pax(merge3(parseKV(string), ex), g);
    var merge3 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1)
        return set;
      line = line.substr((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k)
        return set;
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\warn-mixin.js
  var require_warn_mixin = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file)
          data.file = this.file;
        if (this.cwd)
          data.cwd = this.cwd;
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\winchars.js
  var require_winchars = __commonJS((exports2, module2) => {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\mode-fix.js
  var require_mode_fix = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256)
          mode |= 64;
        if (mode & 32)
          mode |= 8;
        if (mode & 4)
          mode |= 1;
      }
      return mode;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\write-entry.js
  var require_write_entry = __commonJS((exports2, module2) => {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var ReadEntry = require_read_entry();
    var fs9 = require("fs");
    var path6 = require("path");
    var types2 = require_types3();
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string")
          throw new TypeError("path is required");
        this.path = p;
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid();
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = opt.cwd || process.cwd();
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths && path6.win32.isAbsolute(p)) {
          const parsed = path6.win32.parse(p);
          this.path = p.substr(parsed.root.length);
          pathWarn = parsed.root;
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = opt.absolute || path6.resolve(this.cwd, p);
        if (this.path === "")
          this.path = "./";
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute))
          this[ONLSTAT](this.statCache.get(this.absolute));
        else
          this[LSTAT]();
      }
      [LSTAT]() {
        fs9.lstat(this.absolute, (er, stat) => {
          if (er)
            return this.emit("error", er);
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile())
          stat.size = 0;
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.header = new Header({
          path: this.path,
          linkpath: this.linkpath,
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax)
          this.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this.path,
            linkpath: this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        this.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.substr(-1) !== "/")
          this.path += "/";
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs9.readlink(this.absolute, (er, linkpath) => {
          if (er)
            return this.emit("error", er);
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = linkpath.replace(/\\/g, "/");
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = path6.relative(this.cwd, linkpath).replace(/\\/g, "/");
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0)
              return this[HARDLINK](linkpath);
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0)
          return this.end();
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs9.open(this.absolute, "r", (er, fd) => {
          if (er)
            return this.emit("error", er);
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        const blockLen = 512 * Math.ceil(this.stat.size / 512);
        const bufLen = Math.min(blockLen, this.maxReadSize);
        const buf = Buffer.allocUnsafe(bufLen);
        this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
      }
      [READ](fd, buf, offset, length, pos, remain, blockRemain) {
        fs9.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](fd, () => this.emit("error", er));
          }
          this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
        });
      }
      [CLOSE](fd, cb) {
        fs9.close(fd, cb);
      }
      [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
        if (bytesRead <= 0 && remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](fd, () => this.emit("error", er));
        }
        if (bytesRead > remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](fd, () => this.emit("error", er));
        }
        if (bytesRead === remain) {
          for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
            buf[i + offset] = 0;
            bytesRead++;
            remain++;
          }
        }
        const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
        remain -= bytesRead;
        blockRemain -= bytesRead;
        pos += bytesRead;
        offset += bytesRead;
        this.write(writeBuf);
        if (!remain) {
          if (blockRemain)
            this.write(Buffer.alloc(blockRemain));
          return this[CLOSE](fd, (er) => er ? this.emit("error", er) : this.end());
        }
        if (offset >= length) {
          buf = Buffer.allocUnsafe(length);
          offset = 0;
        }
        length = buf.length - offset;
        this[READ](fd, buf, offset, length, pos, remain, blockRemain);
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      constructor(path7, opt) {
        super(path7, opt);
      }
      [LSTAT]() {
        this[ONLSTAT](fs9.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs9.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs9.openSync(this.absolute, "r"));
      }
      [READ](fd, buf, offset, length, pos, remain, blockRemain) {
        let threw = true;
        try {
          const bytesRead = fs9.readSync(fd, buf, offset, length, pos);
          this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
          threw = false;
        } finally {
          if (threw)
            try {
              this[CLOSE](fd, () => {
              });
            } catch (er) {
            }
        }
      }
      [CLOSE](fd, cb) {
        fs9.closeSync(fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.path = readEntry.path;
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = readEntry.linkpath;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (path6.isAbsolute(this.path) && !this.preservePaths) {
          const parsed = path6.parse(this.path);
          pathWarn = parsed.root;
          this.path = this.path.substr(parsed.root.length);
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this.path,
          linkpath: this.linkpath,
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax)
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this.path,
            linkpath: this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain)
          this.write(Buffer.alloc(this.blockRemain));
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\pack.js
  var require_pack = __commonJS((exports2, module2) => {
    "use strict";
    var PackJob = class {
      constructor(path7, absolute) {
        this.path = path7 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib3 = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs9 = require("fs");
    var path6 = require("path");
    var warner = require_warn_mixin();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = (opt.prefix || "").replace(/(\\|\/)+$/, "");
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.readdirCache = opt.readdirCache || new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object")
            opt.gzip = {};
          if (this.portable)
            opt.gzip.portable = true;
          this.zip = new zlib3.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else
          this.on("drain", this[ONDRAIN]);
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path7) {
        this.write(path7);
        return this;
      }
      end(path7) {
        if (path7)
          this.write(path7);
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path7) {
        if (this[ENDED])
          throw new Error("write after end");
        if (path7 instanceof ReadEntry)
          this[ADDTARENTRY](path7);
        else
          this[ADDFSENTRY](path7);
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = path6.resolve(this.cwd, p.path);
        if (this.prefix)
          p.path = this.prefix + "/" + p.path.replace(/^\.(\/+|$)/, "");
        if (!this.filter(p.path, p))
          p.resume();
        else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = path6.resolve(this.cwd, p);
        if (this.prefix)
          p = this.prefix + "/" + p.replace(/^\.(\/+|$)/, "");
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs9[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            this.emit("error", er);
          else
            this[ONSTAT](job, stat2);
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat))
          job.ignore = true;
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs9.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            return this.emit("error", er);
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING])
          return;
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip)
            this.zip.end(EOF);
          else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending)
          return;
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped)
            this[PIPE](job);
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute))
            this[ONSTAT](job, this.statCache.get(job.absolute));
          else
            this[STAT](job);
        }
        if (!job.stat)
          return;
        if (job.ignore)
          return;
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute))
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          else
            this[READDIR](job);
          if (!job.readdir)
            return;
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry)
          this[CURRENT].entry.resume();
      }
      [PIPE](job) {
        job.piped = true;
        if (job.readdir)
          job.readdir.forEach((entry) => {
            const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        const source = job.entry;
        const zip = this.zip;
        if (zip)
          source.on("data", (chunk) => {
            if (!zip.write(chunk))
              source.pause();
          });
        else
          source.on("data", (chunk) => {
            if (!super.write(chunk))
              source.pause();
          });
      }
      pause() {
        if (this.zip)
          this.zip.pause();
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs9[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs9.readdirSync(job.absolute));
      }
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir)
          job.readdir.forEach((entry) => {
            const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        if (zip)
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        else
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fs-minipass-npm-2.0.0-e6ab6b5c13-aca525363d.zip\node_modules\fs-minipass\index.js
  var require_fs_minipass = __commonJS((exports2) => {
    "use strict";
    var MiniPass = require_minipass();
    var EE = require("events").EventEmitter;
    var fs9 = require("fs");
    var binding = process.binding("fs");
    var writeBuffers = binding.writeBuffers;
    var FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var ReadStream2 = class extends MiniPass {
      constructor(path6, opt) {
        opt = opt || {};
        super(opt);
        this.writable = false;
        if (typeof path6 !== "string")
          throw new TypeError("path must be a string");
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path6;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs9.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs9.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          fs9.close(this[_fd], (_) => this.emit("close"));
          this[_fd] = null;
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream2 {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs9.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs9.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          try {
            fs9.closeSync(this[_fd]);
          } catch (er) {
          }
          this[_fd] = null;
          this.emit("close");
        }
      }
    };
    var WriteStream2 = class extends EE {
      constructor(path6, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path6;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs9.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = new Buffer(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs9.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          fs9.close(this[_fd], (_) => this.emit("close"));
          this[_fd] = null;
        }
      }
    };
    var WriteStreamSync = class extends WriteStream2 {
      [_open]() {
        let fd;
        try {
          fd = fs9.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else
            throw er;
        }
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          try {
            fs9.closeSync(this[_fd]);
          } catch (er) {
          }
          this[_fd] = null;
          this.emit("close");
        }
      }
      [_write](buf) {
        try {
          this[_onwrite](null, fs9.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        } catch (er) {
          this[_onwrite](er, 0);
        }
      }
    };
    var writev = (fd, iovec, pos, cb) => {
      const done = (er, bw) => cb(er, bw, iovec);
      const req = new FSReqWrap();
      req.oncomplete = done;
      binding.writeBuffers(fd, iovec, pos, req);
    };
    exports2.ReadStream = ReadStream2;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream2;
    exports2.WriteStreamSync = WriteStreamSync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\parse.js
  var require_parse5 = __commonJS((exports2, module2) => {
    "use strict";
    var warner = require_warn_mixin();
    var path6 = require("path");
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib3 = require_minizlib();
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone)
          this.on(DONE, opt.ondone);
        else
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
            this.emit("close");
          });
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        if (typeof opt.onentry === "function")
          this.on("entry", opt.onentry);
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null)
          this[SAW_VALID_ENTRY] = false;
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin")
              this[STATE] = "header";
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid)
            this.warn("TAR_ENTRY_INVALID", "checksum failure", {header});
          else if (!header.path)
            this.warn("TAR_ENTRY_INVALID", "path is required", {header});
          else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath required", {header});
            else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {header});
            else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid)
                      this[SAW_VALID_ENTRY] = true;
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain)
                    this[STATE] = "body";
                  else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else
                    this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry))
          this.emit.apply(this, entry);
        else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING])
              this.emit("drain");
          } else
            re.once("drain", (_) => this.emit("drain"));
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY])
          this[EMITMETA](entry);
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY])
          this.emit(ev, data, extra);
        else
          this[QUEUE].push([ev, data, extra]);
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, {recoverable: false});
      }
      write(chunk) {
        if (this[ABORTED])
          return;
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i])
              this[UNZIP] = false;
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib3.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP])
          this[UNZIP].write(chunk);
        else
          this[CONSUMECHUNK](chunk);
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length)
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED])
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {entry});
            if (this[BUFFER])
              entry.write(this[BUFFER]);
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING])
          this[BUFFERCONCAT](chunk);
        else if (!chunk && !this[BUFFER])
          this[MAYBEEND]();
        else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED])
          this[MAYBEEND]();
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        let length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER])
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          else
            this[BUFFER] = chunk.slice(position);
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP])
            this[UNZIP].end(chunk);
          else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\list.js
  var require_list = __commonJS((exports2, module2) => {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse5();
    var fs9 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var t7 = module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      if (!opt.noResume)
        onentryFunction(opt);
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path6.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path6.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
    };
    var listFileSync = (opt) => {
      const p = list(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs9.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs9.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs9.openSync(file, "r");
          while (pos < stat.size) {
            let bytesRead = fs9.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd)
          try {
            fs9.closeSync(fd);
          } catch (er) {
          }
      }
    };
    var listFile = (opt, cb) => {
      const parse4 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        parse4.on("error", reject);
        parse4.on("end", resolve);
        fs9.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse4);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list = (opt) => new Parser(opt);
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\create.js
  var require_create2 = __commonJS((exports2, module2) => {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs9 = require("fs");
    var fsm = require_fs_minipass();
    var t7 = require_list();
    var path6 = require("path");
    var c = module2.exports = (opt_, files, cb) => {
      if (typeof files === "function")
        cb = files;
      if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@")
          t7({
            file: path6.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@")
          return t7({
            file: path6.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        else
          p.add(file);
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\replace.js
  var require_replace = __commonJS((exports2, module2) => {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var Parse = require_parse5();
    var fs9 = require("fs");
    var fsm = require_fs_minipass();
    var t7 = require_list();
    var path6 = require("path");
    var Header = require_header();
    var r = module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs9.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT")
            fd = fs9.openSync(opt.file, "w+");
          else
            throw er;
        }
        const st = fs9.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
              bytes = fs9.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
                throw new Error("cannot append to compressed archives");
              if (!bytes)
                break POSITION;
            }
            let h = new Header(headBuf);
            if (!h.cksumValid)
              break;
            let entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size)
              break;
            position += entryBlockSize;
            if (opt.mtimeCache)
              opt.mtimeCache.set(h.path, h.mtime);
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw)
          try {
            fs9.closeSync(fd);
          } catch (er) {
          }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er)
            fs9.close(fd, (_) => cb_(er));
          else
            cb_(null, pos);
        };
        let position = 0;
        if (size === 0)
          return cb2(null, 0);
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
          if (er)
            return cb2(er);
          bufPos += bytes;
          if (bufPos < 512 && bytes)
            return fs9.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            return cb2(new Error("cannot append to compressed archives"));
          if (bufPos < 512)
            return cb2(null, position);
          const h = new Header(headBuf);
          if (!h.cksumValid)
            return cb2(null, position);
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size)
            return cb2(null, position);
          position += entryBlockSize + 512;
          if (position >= size)
            return cb2(null, position);
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
          bufPos = 0;
          fs9.read(fd, headBuf, 0, 512, position, onread);
        };
        fs9.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs9.open(opt.file, flag, onopen);
          }
          if (er)
            return reject(er);
          fs9.fstat(fd, (er2, st) => {
            if (er2)
              return reject(er2);
            getPos(fd, st.size, (er3, position) => {
              if (er3)
                return reject(er3);
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve);
              addFilesAsync(p, files);
            });
          });
        };
        fs9.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@")
          t7({
            file: path6.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@")
          return t7({
            file: path6.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        else
          p.add(file);
      }
      p.end();
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\update.js
  var require_update = __commonJS((exports2, module2) => {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    var u = module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache)
        opt.mtimeCache = new Map();
      opt.filter = filter ? (path6, stat) => filter(path6, stat) && !(opt.mtimeCache.get(path6) > stat.mtime) : (path6, stat) => !(opt.mtimeCache.get(path6) > stat.mtime);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\opts-arg.js
  var require_opts_arg = __commonJS((exports2, module2) => {
    var {promisify: promisify4} = require("util");
    var fs9 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = {mode: 511, fs: fs9};
      else if (typeof opts === "object")
        opts = {mode: 511, fs: fs9, ...opts};
      else if (typeof opts === "number")
        opts = {mode: opts, fs: fs9};
      else if (typeof opts === "string")
        opts = {mode: parseInt(opts, 8), fs: fs9};
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs9.mkdir;
      opts.mkdirAsync = promisify4(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs9.stat;
      opts.statAsync = promisify4(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs9.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs9.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\path-arg.js
  var require_path_arg = __commonJS((exports2, module2) => {
    var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var {resolve, parse: parse4} = require("path");
    var pathArg = (path6) => {
      if (/\0/.test(path6)) {
        throw Object.assign(new TypeError("path must be a string without null bytes"), {
          path: path6,
          code: "ERR_INVALID_ARG_VALUE"
        });
      }
      path6 = resolve(path6);
      if (platform === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const {root} = parse4(path6);
        if (badWinChars.test(path6.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path6,
            code: "EINVAL"
          });
        }
      }
      return path6;
    };
    module2.exports = pathArg;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\find-made.js
  var require_find_made = __commonJS((exports2, module2) => {
    var {dirname: dirname2} = require("path");
    var findMade = (opts, parent, path6 = void 0) => {
      if (path6 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then((st) => st.isDirectory() ? path6 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0);
    };
    var findMadeSync = (opts, parent, path6 = void 0) => {
      if (path6 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path6 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
      }
    };
    module2.exports = {findMade, findMadeSync};
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\mkdirp-manual.js
  var require_mkdirp_manual = __commonJS((exports2, module2) => {
    var {dirname: dirname2} = require("path");
    var mkdirpManual = (path6, opts, made) => {
      opts.recursive = false;
      const parent = dirname2(path6);
      if (parent === path6) {
        return opts.mkdirAsync(path6, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path6, opts).then(() => made || path6, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path6, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path6).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path6, opts, made) => {
      const parent = dirname2(path6);
      opts.recursive = false;
      if (parent === path6) {
        try {
          return opts.mkdirSync(path6, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path6, opts);
        return made || path6;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path6, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path6).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = {mkdirpManual, mkdirpManualSync};
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\mkdirp-native.js
  var require_mkdirp_native = __commonJS((exports2, module2) => {
    var {dirname: dirname2} = require("path");
    var {findMade, findMadeSync} = require_find_made();
    var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
    var mkdirpNative = (path6, opts) => {
      opts.recursive = true;
      const parent = dirname2(path6);
      if (parent === path6)
        return opts.mkdirAsync(path6, opts);
      return findMade(opts, path6).then((made) => opts.mkdirAsync(path6, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path6, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path6, opts) => {
      opts.recursive = true;
      const parent = dirname2(path6);
      if (parent === path6)
        return opts.mkdirSync(path6, opts);
      const made = findMadeSync(opts, path6);
      try {
        opts.mkdirSync(path6, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path6, opts);
        else
          throw er;
      }
    };
    module2.exports = {mkdirpNative, mkdirpNativeSync};
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\lib\use-native.js
  var require_use_native = __commonJS((exports2, module2) => {
    var fs9 = require("fs");
    var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs9.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs9.mkdirSync;
    module2.exports = {useNative, useNativeSync};
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\mkdirp-npm-1.0.4-37f6ef56b9-1aa3a6a2d7.zip\node_modules\mkdirp\index.js
  var require_mkdirp = __commonJS((exports2, module2) => {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
    var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
    var {useNative, useNativeSync} = require_use_native();
    var mkdirp = (path6, opts) => {
      path6 = pathArg(path6);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path6, opts) : mkdirpManual(path6, opts);
    };
    var mkdirpSync = (path6, opts) => {
      path6 = pathArg(path6);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path6, opts) : mkdirpManualSync(path6, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path6, opts) => mkdirpNative(pathArg(path6), optsArg(opts));
    mkdirp.manual = (path6, opts) => mkdirpManual(pathArg(path6), optsArg(opts));
    mkdirp.nativeSync = (path6, opts) => mkdirpNativeSync(pathArg(path6), optsArg(opts));
    mkdirp.manualSync = (path6, opts) => mkdirpManualSync(pathArg(path6), optsArg(opts));
    module2.exports = mkdirp;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\chownr-npm-2.0.0-638f1c9c61-b06ba0bf42.zip\node_modules\chownr\chownr.js
  var require_chownr = __commonJS((exports2, module2) => {
    "use strict";
    var fs9 = require("fs");
    var path6 = require("path");
    var LCHOWN = fs9.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs9.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs9.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path7, uid, gid) => {
      try {
        return fs9[LCHOWNSYNC](path7, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path7, uid, gid) => {
      try {
        return fs9.chownSync(path7, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path7, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs9.chown(path7, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path7, uid, gid) => {
      try {
        return lchownSync(path7, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path7, uid, gid);
      }
    } : (path7, uid, gid) => lchownSync(path7, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path7, options, cb) => fs9.readdir(path7, options, cb);
    var readdirSync = (path7, options) => fs9.readdirSync(path7, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path7, options, cb) => fs9.readdir(path7, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs9[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs9.lstat(path6.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path6.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path6.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path6.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, {withFileTypes: true}, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs9.lstatSync(path6.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path6.resolve(p, child.name), uid, gid);
      handleEISDirSync(path6.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, {withFileTypes: true});
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\mkdir.js
  var require_mkdir = __commonJS((exports2, module2) => {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs9 = require("fs");
    var path6 = require("path");
    var chownr = require_chownr();
    var SymlinkError = class extends Error {
      constructor(symlink, path7) {
        super("Cannot extract through symbolic link");
        this.path = path7;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path7, code) {
        super(code + ": Cannot cd into '" + path7 + "'");
        this.path = path7;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var mkdir = module2.exports = (dir, opt, cb) => {
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache2 = opt.cache;
      const cwd = opt.cwd;
      const done = (er, created) => {
        if (er)
          cb(er);
        else {
          cache2.set(dir, true);
          if (created && doChown)
            chownr(created, uid, gid, (er2) => done(er2));
          else if (needChmod)
            fs9.chmod(dir, mode, cb);
          else
            cb();
        }
      };
      if (cache2 && cache2.get(dir) === true)
        return done();
      if (dir === cwd)
        return fs9.stat(dir, (er, st) => {
          if (er || !st.isDirectory())
            er = new CwdError(dir, er && er.code || "ENOTDIR");
          done(er);
        });
      if (preserve)
        return mkdirp(dir, {mode}).then((made) => done(null, made), done);
      const sub = path6.relative(cwd, dir);
      const parts = sub.split(/\/|\\/);
      mkdir_(cwd, parts, mode, cache2, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache2, unlink, cwd, created, cb) => {
      if (!parts.length)
        return cb(null, created);
      const p = parts.shift();
      const part = base + "/" + p;
      if (cache2.get(part))
        return mkdir_(part, parts, mode, cache2, unlink, cwd, created, cb);
      fs9.mkdir(part, mode, onmkdir(part, parts, mode, cache2, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache2, unlink, cwd, created, cb) => (er) => {
      if (er) {
        if (er.path && path6.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
          return cb(new CwdError(cwd, er.code));
        fs9.lstat(part, (statEr, st) => {
          if (statEr)
            cb(statEr);
          else if (st.isDirectory())
            mkdir_(part, parts, mode, cache2, unlink, cwd, created, cb);
          else if (unlink)
            fs9.unlink(part, (er2) => {
              if (er2)
                return cb(er2);
              fs9.mkdir(part, mode, onmkdir(part, parts, mode, cache2, unlink, cwd, created, cb));
            });
          else if (st.isSymbolicLink())
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          else
            cb(er);
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache2, unlink, cwd, created, cb);
      }
    };
    var mkdirSync = module2.exports.sync = (dir, opt) => {
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache2 = opt.cache;
      const cwd = opt.cwd;
      const done = (created2) => {
        cache2.set(dir, true);
        if (created2 && doChown)
          chownr.sync(created2, uid, gid);
        if (needChmod)
          fs9.chmodSync(dir, mode);
      };
      if (cache2 && cache2.get(dir) === true)
        return done();
      if (dir === cwd) {
        let ok = false;
        let code = "ENOTDIR";
        try {
          ok = fs9.statSync(dir).isDirectory();
        } catch (er) {
          code = er.code;
        } finally {
          if (!ok)
            throw new CwdError(dir, code);
        }
        done();
        return;
      }
      if (preserve)
        return done(mkdirp.sync(dir, mode));
      const sub = path6.relative(cwd, dir);
      const parts = sub.split(/\/|\\/);
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        if (cache2.get(part))
          continue;
        try {
          fs9.mkdirSync(part, mode);
          created = created || part;
          cache2.set(part, true);
        } catch (er) {
          if (er.path && path6.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
            return new CwdError(cwd, er.code);
          const st = fs9.lstatSync(part);
          if (st.isDirectory()) {
            cache2.set(part, true);
            continue;
          } else if (unlink) {
            fs9.unlinkSync(part);
            fs9.mkdirSync(part, mode);
            created = created || part;
            cache2.set(part, true);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
      return done(created);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\path-reservations.js
  var require_path_reservations = __commonJS((exports2, module2) => {
    var assert = require("assert");
    module2.exports = () => {
      const queues = new Map();
      const reservations = new Map();
      const {join} = require("path");
      const getDirs = (path6) => join(path6).split(/[\\\/]/).slice(0, -1).reduce((set, path7) => set.length ? set.concat(join(set[set.length - 1], path7)) : [path7], []);
      const running = new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res)
          throw new Error("function does not have any path reservations");
        return {
          paths: res.paths.map((path6) => queues.get(path6)),
          dirs: [...res.dirs].map((path6) => queues.get(path6))
        };
      };
      const check = (fn) => {
        const {paths, dirs} = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn))
          return false;
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn))
          return false;
        const {paths, dirs} = reservations.get(fn);
        const next = new Set();
        paths.forEach((path6) => {
          const q = queues.get(path6);
          assert.equal(q[0], fn);
          if (q.length === 1)
            queues.delete(path6);
          else {
            q.shift();
            if (typeof q[0] === "function")
              next.add(q[0]);
            else
              q[0].forEach((fn2) => next.add(fn2));
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else
            q[0].delete(fn);
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        const dirs = new Set(paths.map((path6) => getDirs(path6)).reduce((a, b) => a.concat(b)));
        reservations.set(fn, {dirs, paths});
        paths.forEach((path6) => {
          const q = queues.get(path6);
          if (!q)
            queues.set(path6, [fn]);
          else
            q.push(fn);
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q)
            queues.set(dir, [new Set([fn])]);
          else if (q[q.length - 1] instanceof Set)
            q[q.length - 1].add(fn);
          else
            q.push(new Set([fn]));
        });
        return run(fn);
      };
      return {check, reserve};
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\get-write-flag.js
  var require_get_write_flag = __commonJS((exports2, module2) => {
    var platform = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows = platform === "win32";
    var fs9 = global.__FAKE_TESTING_FS__ || require("fs");
    var {O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0} = fs9.constants;
    var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\unpack.js
  var require_unpack = __commonJS((exports2, module2) => {
    "use strict";
    var assert = require("assert");
    var EE = require("events").EventEmitter;
    var Parser = require_parse5();
    var fs9 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var mkdir = require_mkdir();
    var mkdirSync = mkdir.sync;
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var UNKNOWN = Symbol("unknown");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var crypto2 = require("crypto");
    var getFlag = require_get_write_flag();
    var neverCalled = () => {
      throw new Error("sync function called cb somehow?!?");
    };
    var unlinkFile = (path7, cb) => {
      if (process.platform !== "win32")
        return fs9.unlink(path7, cb);
      const name = path7 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs9.rename(path7, name, (er) => {
        if (er)
          return cb(er);
        fs9.unlink(name, cb);
      });
    };
    var unlinkFileSync = (path7) => {
      if (process.platform !== "win32")
        return fs9.unlinkSync(path7);
      const name = path7 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs9.renameSync(path7, name);
      fs9.unlinkSync(name);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt)
          opt = {};
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
            throw new TypeError("cannot set owner without number uid and gid");
          if (opt.preserveOwner)
            throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
          this.preserveOwner = process.getuid && process.getuid() === 0;
        else
          this.preserveOwner = !!opt.preserveOwner;
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || process.platform === "win32";
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = path6.resolve(opt.cwd || process.cwd());
        this.strip = +opt.strip || 0;
        this.processUmask = process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
          data.recoverable = false;
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = entry.path.split(/\/|\\/);
          if (parts.length < this.strip)
            return false;
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = entry.linkpath.split(/\/|\\/);
            if (linkparts.length >= this.strip)
              entry.linkpath = linkparts.slice(this.strip).join("/");
          }
        }
        if (!this.preservePaths) {
          const p = entry.path;
          if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          if (path6.win32.isAbsolute(p)) {
            const parsed = path6.win32.parse(p);
            entry.path = p.substr(parsed.root.length);
            const r = parsed.root;
            this.warn("TAR_ENTRY_INFO", `stripping ${r} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (this.win32) {
          const parsed = path6.win32.parse(entry.path);
          entry.path = parsed.root === "" ? wc.encode(entry.path) : parsed.root + wc.encode(entry.path.substr(parsed.root.length));
        }
        if (path6.isAbsolute(entry.path))
          entry.absolute = entry.path;
        else
          entry.absolute = path6.resolve(this.cwd, entry.path);
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry))
          return entry.resume();
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode)
              entry.mode = entry.mode | 448;
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError")
          this.emit("error", er);
        else {
          this.warn("TAR_ENTRY_ERROR", er, {entry});
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(dir, {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => this[ONERROR](er, entry));
        let actions = 1;
        const done = (er) => {
          if (er)
            return this[ONERROR](er, entry);
          if (--actions === 0) {
            fs9.close(stream.fd, (er2) => {
              fullyDone();
              er2 ? this[ONERROR](er2, entry) : this[UNPEND]();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs9.futimes(fd, atime, mtime, (er) => er ? fs9.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs9.fchown(fd, uid, gid, (er) => er ? fs9.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            fullyDone();
            return this[ONERROR](er, entry);
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs9.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs9.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, {entry});
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        this[LINK](entry, path6.resolve(this.cwd, entry.linkpath), "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
      }
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath)
          paths.push(entry.linkpath);
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [CHECKFS2](entry, done) {
        this[MKDIR](path6.dirname(entry.absolute), this.dmode, (er) => {
          if (er) {
            done();
            return this[ONERROR](er, entry);
          }
          fs9.lstat(entry.absolute, (er2, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
            } else if (er2 || this[ISREUSABLE](entry, st)) {
              this[MAKEFS](null, entry, done);
            } else if (st.isDirectory()) {
              if (entry.type === "Directory") {
                if (!entry.mode || (st.mode & 4095) === entry.mode)
                  this[MAKEFS](null, entry, done);
                else
                  fs9.chmod(entry.absolute, entry.mode, (er3) => this[MAKEFS](er3, entry, done));
              } else
                fs9.rmdir(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
            } else
              unlinkFile(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
          });
        });
      }
      [MAKEFS](er, entry, done) {
        if (er)
          return this[ONERROR](er, entry);
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs9[link](linkpath, entry.absolute, (er) => {
          if (er)
            return this[ONERROR](er, entry);
          done();
          this[UNPEND]();
          entry.resume();
        });
      }
    };
    var UnpackSync = class extends Unpack {
      constructor(opt) {
        super(opt);
      }
      [CHECKFS](entry) {
        const er = this[MKDIR](path6.dirname(entry.absolute), this.dmode, neverCalled);
        if (er)
          return this[ONERROR](er, entry);
        try {
          const st = fs9.lstatSync(entry.absolute);
          if (this.keep || this.newer && st.mtime > entry.mtime)
            return this[SKIP](entry);
          else if (this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, neverCalled);
          else {
            try {
              if (st.isDirectory()) {
                if (entry.type === "Directory") {
                  if (entry.mode && (st.mode & 4095) !== entry.mode)
                    fs9.chmodSync(entry.absolute, entry.mode);
                } else
                  fs9.rmdirSync(entry.absolute);
              } else
                unlinkFileSync(entry.absolute);
              return this[MAKEFS](null, entry, neverCalled);
            } catch (er2) {
              return this[ONERROR](er2, entry);
            }
          }
        } catch (er2) {
          return this[MAKEFS](null, entry, neverCalled);
        }
      }
      [FILE](entry, _) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs9.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError)
            this[ONERROR](er || closeError, entry);
        };
        let stream;
        let fd;
        try {
          fd = fs9.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs9.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_2) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs9.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs9.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs9.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs9.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, _) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er)
          return this[ONERROR](er, entry);
        if (entry.mtime && !this.noMtime) {
          try {
            fs9.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs9.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(dir, {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, _) {
        try {
          fs9[link + "Sync"](linkpath, entry.absolute);
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\lib\extract.js
  var require_extract = __commonJS((exports2, module2) => {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs9 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var x = module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path6.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path6.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      const stat = fs9.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        u.on("error", reject);
        u.on("close", resolve);
        fs9.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => {
      return new Unpack.Sync(opt);
    };
    var extract = (opt) => {
      return new Unpack(opt);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-npm-6.0.5-a5360f3389-7ae2621092.zip\node_modules\tar\index.js
  var require_tar = __commonJS((exports2) => {
    "use strict";
    exports2.c = exports2.create = require_create2();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse5();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types3();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\treeify-npm-1.1.0-abf9292333-78db62f564.zip\node_modules\treeify\treeify.js
  var require_treeify = __commonJS((exports2, module2) => {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.treeify = factory();
      }
    })(exports2, function() {
      function makePrefix(key, last) {
        var str = last ? "\u2514" : "\u251C";
        if (key) {
          str += "\u2500 ";
        } else {
          str += "\u2500\u2500\u2510";
        }
        return str;
      }
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "\u2502") + "  ";
            }
            if (!circular && lastState[0] === root) {
              circular = true;
            }
          });
          line += makePrefix(key, last) + key;
          showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root === "object") {
          var keys = filterKeys(root, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      ;
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\camelcase-npm-5.3.1-5db8af62c5-6a3350c4ea.zip\node_modules\camelcase\index.js
  var require_camelcase = __commonJS((exports2, module2) => {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ci-info-npm-2.0.0-78012236a1-553fe83c08.zip\node_modules\ci-info\vendors.json
  var require_vendors = __commonJS((exports2, module2) => {
    module2.exports = [
      {
        name: "AppVeyor",
        constant: "APPVEYOR",
        env: "APPVEYOR",
        pr: "APPVEYOR_PULL_REQUEST_NUMBER"
      },
      {
        name: "Azure Pipelines",
        constant: "AZURE_PIPELINES",
        env: "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI",
        pr: "SYSTEM_PULLREQUEST_PULLREQUESTID"
      },
      {
        name: "Bamboo",
        constant: "BAMBOO",
        env: "bamboo_planKey"
      },
      {
        name: "Bitbucket Pipelines",
        constant: "BITBUCKET",
        env: "BITBUCKET_COMMIT",
        pr: "BITBUCKET_PR_ID"
      },
      {
        name: "Bitrise",
        constant: "BITRISE",
        env: "BITRISE_IO",
        pr: "BITRISE_PULL_REQUEST"
      },
      {
        name: "Buddy",
        constant: "BUDDY",
        env: "BUDDY_WORKSPACE_ID",
        pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
      },
      {
        name: "Buildkite",
        constant: "BUILDKITE",
        env: "BUILDKITE",
        pr: {env: "BUILDKITE_PULL_REQUEST", ne: "false"}
      },
      {
        name: "CircleCI",
        constant: "CIRCLE",
        env: "CIRCLECI",
        pr: "CIRCLE_PULL_REQUEST"
      },
      {
        name: "Cirrus CI",
        constant: "CIRRUS",
        env: "CIRRUS_CI",
        pr: "CIRRUS_PR"
      },
      {
        name: "AWS CodeBuild",
        constant: "CODEBUILD",
        env: "CODEBUILD_BUILD_ARN"
      },
      {
        name: "Codeship",
        constant: "CODESHIP",
        env: {CI_NAME: "codeship"}
      },
      {
        name: "Drone",
        constant: "DRONE",
        env: "DRONE",
        pr: {DRONE_BUILD_EVENT: "pull_request"}
      },
      {
        name: "dsari",
        constant: "DSARI",
        env: "DSARI"
      },
      {
        name: "GitLab CI",
        constant: "GITLAB",
        env: "GITLAB_CI"
      },
      {
        name: "GoCD",
        constant: "GOCD",
        env: "GO_PIPELINE_LABEL"
      },
      {
        name: "Hudson",
        constant: "HUDSON",
        env: "HUDSON_URL"
      },
      {
        name: "Jenkins",
        constant: "JENKINS",
        env: ["JENKINS_URL", "BUILD_ID"],
        pr: {any: ["ghprbPullId", "CHANGE_ID"]}
      },
      {
        name: "Magnum CI",
        constant: "MAGNUM",
        env: "MAGNUM"
      },
      {
        name: "Netlify CI",
        constant: "NETLIFY",
        env: "NETLIFY_BUILD_BASE",
        pr: {env: "PULL_REQUEST", ne: "false"}
      },
      {
        name: "Sail CI",
        constant: "SAIL",
        env: "SAILCI",
        pr: "SAIL_PULL_REQUEST_NUMBER"
      },
      {
        name: "Semaphore",
        constant: "SEMAPHORE",
        env: "SEMAPHORE",
        pr: "PULL_REQUEST_NUMBER"
      },
      {
        name: "Shippable",
        constant: "SHIPPABLE",
        env: "SHIPPABLE",
        pr: {IS_PULL_REQUEST: "true"}
      },
      {
        name: "Solano CI",
        constant: "SOLANO",
        env: "TDDIUM",
        pr: "TDDIUM_PR_ID"
      },
      {
        name: "Strider CD",
        constant: "STRIDER",
        env: "STRIDER"
      },
      {
        name: "TaskCluster",
        constant: "TASKCLUSTER",
        env: ["TASK_ID", "RUN_ID"]
      },
      {
        name: "TeamCity",
        constant: "TEAMCITY",
        env: "TEAMCITY_VERSION"
      },
      {
        name: "Travis CI",
        constant: "TRAVIS",
        env: "TRAVIS",
        pr: {env: "TRAVIS_PULL_REQUEST", ne: "false"}
      }
    ];
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ci-info-npm-2.0.0-78012236a1-553fe83c08.zip\node_modules\ci-info\index.js
  var require_ci_info = __commonJS((exports2) => {
    "use strict";
    var vendors = require_vendors();
    var env = process.env;
    Object.defineProperty(exports2, "_vendors", {
      value: vendors.map(function(v) {
        return v.constant;
      })
    });
    exports2.name = null;
    exports2.isPR = null;
    vendors.forEach(function(vendor) {
      var envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
      var isCI4 = envs.every(function(obj) {
        return checkEnv(obj);
      });
      exports2[vendor.constant] = isCI4;
      if (isCI4) {
        exports2.name = vendor.name;
        switch (typeof vendor.pr) {
          case "string":
            exports2.isPR = !!env[vendor.pr];
            break;
          case "object":
            if ("env" in vendor.pr) {
              exports2.isPR = vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
            } else if ("any" in vendor.pr) {
              exports2.isPR = vendor.pr.any.some(function(key) {
                return !!env[key];
              });
            } else {
              exports2.isPR = checkEnv(vendor.pr);
            }
            break;
          default:
            exports2.isPR = null;
        }
      }
    });
    exports2.isCI = !!(env.CI || env.CONTINUOUS_INTEGRATION || env.BUILD_NUMBER || env.RUN_ID || exports2.name || false);
    function checkEnv(obj) {
      if (typeof obj === "string")
        return !!env[obj];
      return Object.keys(obj).every(function(k) {
        return env[k] === obj[k];
      });
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\base.js
  var require_base = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = Diff;
    function Diff() {
    }
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split("");
      },
      join: function join(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value2.length ? oldValue : value2;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path6) {
      return {
        newPos: path6.newPos,
        components: path6.components.slice(0)
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\character.js
  var require_character = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffChars = diffChars;
    exports2.characterDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var characterDiff = new _base.default();
    exports2.characterDiff = characterDiff;
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\util\params.js
  var require_params = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === "function") {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\word.js
  var require_word = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffWords = diffWords;
    exports2.diffWordsWithSpace = diffWordsWithSpace;
    exports2.wordDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new _base.default();
    exports2.wordDiff = wordDiff;
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value) {
      var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, options) {
      options = (0, _params.generateOptions)(options, {
        ignoreWhitespace: true
      });
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, options) {
      return wordDiff.diff(oldStr, newStr, options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\line.js
  var require_line = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffLines = diffLines;
    exports2.diffTrimmedLines = diffTrimmedLines;
    exports2.lineDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var lineDiff = new _base.default();
    exports2.lineDiff = lineDiff;
    lineDiff.tokenize = function(value) {
      var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = (0, _params.generateOptions)(callback, {
        ignoreWhitespace: true
      });
      return lineDiff.diff(oldStr, newStr, options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\sentence.js
  var require_sentence = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffSentences = diffSentences;
    exports2.sentenceDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var sentenceDiff = new _base.default();
    exports2.sentenceDiff = sentenceDiff;
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\css.js
  var require_css = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffCss = diffCss;
    exports2.cssDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var cssDiff = new _base.default();
    exports2.cssDiff = cssDiff;
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\json.js
  var require_json2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffJson = diffJson;
    exports2.canonicalize = canonicalize;
    exports2.jsonDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _line = require_line();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new _base.default();
    exports2.jsonDiff = jsonDiff;
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = _line.lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return typeof v === "undefined" ? undefinedReplacement : v;
      } : _this$options$stringi;
      return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function(left, right) {
      return _base.default.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if (objectPrototypeToString.call(obj) === "[object Array]") {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (_typeof(obj) === "object" && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [], _key;
        for (_key in obj) {
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\diff\array.js
  var require_array2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffArrays = diffArrays;
    exports2.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    var arrayDiff = new _base.default();
    exports2.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\patch\parse.js
  var require_parse6 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
          var data = fileHeader[2].split("	", 2);
          var fileName = data[0].replace(/\\\\/g, "\\");
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          index[keyPrefix + "FileName"] = fileName;
          index[keyPrefix + "Header"] = (data[1] || "").trim();
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: +chunkHeader[2] || 1,
          newStart: +chunkHeader[3],
          newLines: +chunkHeader[4] || 1,
          lines: [],
          linedelimiters: []
        };
        var addCount = 0, removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
            break;
          }
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
          if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || "\n");
            if (operation === "+") {
              addCount++;
            } else if (operation === "-") {
              removeCount++;
            } else if (operation === " ") {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\util\distance-iterator.js
  var require_distance_iterator = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    function _default(start2, minLine, maxLine) {
      var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start2 + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start2 - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\patch\apply.js
  var require_apply = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.applyPatch = applyPatch3;
    exports2.applyPatches = applyPatches;
    var _parse = require_parse6();
    var _distanceIterator = _interopRequireDefault(require_distance_iterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
    function applyPatch3(source, uniDiff) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (typeof uniDiff === "string") {
        uniDiff = (0, _parse.parsePatch)(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error("applyPatch only works with a single input.");
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
        return line2 === patchContent;
      }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
      function hunkFits(hunk2, toPos2) {
        for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
          var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
          if (operation2 === " " || operation2 === "-") {
            if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos2++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
        var iterator = (0, _distanceIterator.default)(toPos, minLine, maxLine);
        for (; localOffset !== void 0; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === void 0) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      var diffOffset = 0;
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        if (_toPos < 0) {
          _toPos = 0;
        }
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
          if (operation === " ") {
            _toPos++;
          } else if (operation === "-") {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === "+") {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === "\\") {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === "+") {
              removeEOFNL = true;
            } else if (previousOperation === "-") {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push("");
        delimiters.push("\n");
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join("");
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === "string") {
        uniDiff = (0, _parse.parsePatch)(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch3(data, index, options);
          options.patched(index, updatedContent, function(err2) {
            if (err2) {
              return options.complete(err2);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\patch\create.js
  var require_create3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.structuredPatch = structuredPatch2;
    exports2.createTwoFilesPatch = createTwoFilesPatch;
    exports2.createPatch = createPatch;
    var _line = require_line();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
    }
    function structuredPatch2(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === "undefined") {
        options.context = 4;
      }
      var diff = (0, _line.diffLines)(oldStr, newStr, options);
      diff.push({
        value: "",
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function(entry) {
          return " " + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
      var _loop = function _loop2(i2) {
        var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i2 - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
            return (current.added ? "+" : "-") + entry;
          })));
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
              var _curRange2;
              (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i2 >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                if (!oldEOFNewline && noNlBeforeAdds) {
                  curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                }
                if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                  curRange.push("\\ No newline at end of file");
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(i);
      }
      return {
        oldFileName,
        newFileName,
        oldHeader,
        newHeader,
        hunks
      };
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      var diff = structuredPatch2(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
      var ret = [];
      if (oldFileName == newFileName) {
        ret.push("Index: " + oldFileName);
      }
      ret.push("===================================================================");
      ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
      ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join("\n") + "\n";
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\util\array.js
  var require_array3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrayEqual = arrayEqual;
    exports2.arrayStartsWith = arrayStartsWith;
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return arrayStartsWith(a, b);
    }
    function arrayStartsWith(array, start2) {
      if (start2.length > array.length) {
        return false;
      }
      for (var i = 0; i < start2.length; i++) {
        if (start2[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\patch\merge.js
  var require_merge3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.calcLineCount = calcLineCount;
    exports2.merge = merge3;
    var _create = require_create3();
    var _parse = require_parse6();
    var _array = require_array3();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
    }
    function calcLineCount(hunk) {
      var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
      if (oldLines !== void 0) {
        hunk.oldLines = oldLines;
      } else {
        delete hunk.oldLines;
      }
      if (newLines !== void 0) {
        hunk.newLines = newLines;
      } else {
        delete hunk.newLines;
      }
    }
    function merge3(mine, theirs, base) {
      mine = loadPatch(mine, base);
      theirs = loadPatch(theirs, base);
      var ret = {};
      if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
      }
      if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
          ret.oldFileName = theirs.oldFileName || mine.oldFileName;
          ret.newFileName = theirs.newFileName || mine.newFileName;
          ret.oldHeader = theirs.oldHeader || mine.oldHeader;
          ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
          ret.oldFileName = mine.oldFileName;
          ret.newFileName = mine.newFileName;
          ret.oldHeader = mine.oldHeader;
          ret.newHeader = mine.newHeader;
        } else {
          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
      }
      ret.hunks = [];
      var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
        var mineCurrent = mine.hunks[mineIndex] || {
          oldStart: Infinity
        }, theirsCurrent = theirs.hunks[theirsIndex] || {
          oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
          mineIndex++;
          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
          theirsIndex++;
          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
          var mergedHunk = {
            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
            oldLines: 0,
            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
            newLines: 0,
            lines: []
          };
          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
          theirsIndex++;
          mineIndex++;
          ret.hunks.push(mergedHunk);
        }
      }
      return ret;
    }
    function loadPatch(param, base) {
      if (typeof param === "string") {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
          return (0, _parse.parsePatch)(param)[0];
        }
        if (!base) {
          throw new Error("Must provide a base reference or pass in a patch");
        }
        return (0, _create.structuredPatch)(void 0, void 0, base, param);
      }
      return param;
    }
    function fileNameChanged(patch7) {
      return patch7.newFileName && patch7.newFileName !== patch7.oldFileName;
    }
    function selectField(index, mine, theirs) {
      if (mine === theirs) {
        return mine;
      } else {
        index.conflict = true;
        return {
          mine,
          theirs
        };
      }
    }
    function hunkBefore(test, check) {
      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
    }
    function cloneHunk(hunk, offset) {
      return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
      };
    }
    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
      var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
      }, their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
      };
      insertLeading(hunk, mine, their);
      insertLeading(hunk, their, mine);
      while (mine.index < mine.lines.length && their.index < their.lines.length) {
        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
          mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
          var _hunk$lines;
          (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
        } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
          var _hunk$lines2;
          (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
        } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
          removal(hunk, mine, their);
        } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
          removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
          hunk.lines.push(mineCurrent);
          mine.index++;
          their.index++;
        } else {
          conflict(hunk, collectChange(mine), collectChange(their));
        }
      }
      insertTrailing(hunk, mine);
      insertTrailing(hunk, their);
      calcLineCount(hunk);
    }
    function mutualChange(hunk, mine, their) {
      var myChanges = collectChange(mine), theirChanges = collectChange(their);
      if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        if ((0, _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
          var _hunk$lines3;
          (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
          return;
        } else if ((0, _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
          var _hunk$lines4;
          (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
          return;
        }
      } else if ((0, _array.arrayEqual)(myChanges, theirChanges)) {
        var _hunk$lines5;
        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
        return;
      }
      conflict(hunk, myChanges, theirChanges);
    }
    function removal(hunk, mine, their, swap) {
      var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
      if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
      } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
    }
    function conflict(hunk, mine, their) {
      hunk.conflict = true;
      hunk.lines.push({
        conflict: true,
        mine,
        theirs: their
      });
    }
    function insertLeading(hunk, insert, their) {
      while (insert.offset < their.offset && insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
      }
    }
    function insertTrailing(hunk, insert) {
      while (insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
      }
    }
    function collectChange(state) {
      var ret = [], operation = state.lines[state.index][0];
      while (state.index < state.lines.length) {
        var line = state.lines[state.index];
        if (operation === "-" && line[0] === "+") {
          operation = "+";
        }
        if (operation === line[0]) {
          ret.push(line);
          state.index++;
        } else {
          break;
        }
      }
      return ret;
    }
    function collectContext(state, matchChanges) {
      var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
      while (matchIndex < matchChanges.length && state.index < state.lines.length) {
        var change = state.lines[state.index], match2 = matchChanges[matchIndex];
        if (match2[0] === "+") {
          break;
        }
        contextChanges = contextChanges || change[0] !== " ";
        merged.push(match2);
        matchIndex++;
        if (change[0] === "+") {
          conflicted = true;
          while (change[0] === "+") {
            changes.push(change);
            change = state.lines[++state.index];
          }
        }
        if (match2.substr(1) === change.substr(1)) {
          changes.push(change);
          state.index++;
        } else {
          conflicted = true;
        }
      }
      if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
        conflicted = true;
      }
      if (conflicted) {
        return changes;
      }
      while (matchIndex < matchChanges.length) {
        merged.push(matchChanges[matchIndex++]);
      }
      return {
        merged,
        changes
      };
    }
    function allRemoves(changes) {
      return changes.reduce(function(prev, change) {
        return prev && change[0] === "-";
      }, true);
    }
    function skipRemoveSuperset(state, removeChanges, delta) {
      for (var i = 0; i < delta; i++) {
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== " " + changeContent) {
          return false;
        }
      }
      state.index += delta;
      return true;
    }
    function calcOldNewLineCount(lines) {
      var oldLines = 0;
      var newLines = 0;
      lines.forEach(function(line) {
        if (typeof line !== "string") {
          var myCount = calcOldNewLineCount(line.mine);
          var theirCount = calcOldNewLineCount(line.theirs);
          if (oldLines !== void 0) {
            if (myCount.oldLines === theirCount.oldLines) {
              oldLines += myCount.oldLines;
            } else {
              oldLines = void 0;
            }
          }
          if (newLines !== void 0) {
            if (myCount.newLines === theirCount.newLines) {
              newLines += myCount.newLines;
            } else {
              newLines = void 0;
            }
          }
        } else {
          if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
            newLines++;
          }
          if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
            oldLines++;
          }
        }
      });
      return {
        oldLines,
        newLines
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\convert\dmp.js
  var require_dmp = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [], change, operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\convert\xml.js
  var require_xml = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, "&amp;");
      n = n.replace(/</g, "&lt;");
      n = n.replace(/>/g, "&gt;");
      n = n.replace(/"/g, "&quot;");
      return n;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\diff-npm-4.0.1-4d86a500e8-be1bfedaf7.zip\node_modules\diff\lib\index.js
  var require_lib2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Diff", {
      enumerable: true,
      get: function get4() {
        return _base.default;
      }
    });
    Object.defineProperty(exports2, "diffChars", {
      enumerable: true,
      get: function get4() {
        return _character.diffChars;
      }
    });
    Object.defineProperty(exports2, "diffWords", {
      enumerable: true,
      get: function get4() {
        return _word.diffWords;
      }
    });
    Object.defineProperty(exports2, "diffWordsWithSpace", {
      enumerable: true,
      get: function get4() {
        return _word.diffWordsWithSpace;
      }
    });
    Object.defineProperty(exports2, "diffLines", {
      enumerable: true,
      get: function get4() {
        return _line.diffLines;
      }
    });
    Object.defineProperty(exports2, "diffTrimmedLines", {
      enumerable: true,
      get: function get4() {
        return _line.diffTrimmedLines;
      }
    });
    Object.defineProperty(exports2, "diffSentences", {
      enumerable: true,
      get: function get4() {
        return _sentence.diffSentences;
      }
    });
    Object.defineProperty(exports2, "diffCss", {
      enumerable: true,
      get: function get4() {
        return _css.diffCss;
      }
    });
    Object.defineProperty(exports2, "diffJson", {
      enumerable: true,
      get: function get4() {
        return _json.diffJson;
      }
    });
    Object.defineProperty(exports2, "canonicalize", {
      enumerable: true,
      get: function get4() {
        return _json.canonicalize;
      }
    });
    Object.defineProperty(exports2, "diffArrays", {
      enumerable: true,
      get: function get4() {
        return _array.diffArrays;
      }
    });
    Object.defineProperty(exports2, "applyPatch", {
      enumerable: true,
      get: function get4() {
        return _apply.applyPatch;
      }
    });
    Object.defineProperty(exports2, "applyPatches", {
      enumerable: true,
      get: function get4() {
        return _apply.applyPatches;
      }
    });
    Object.defineProperty(exports2, "parsePatch", {
      enumerable: true,
      get: function get4() {
        return _parse.parsePatch;
      }
    });
    Object.defineProperty(exports2, "merge", {
      enumerable: true,
      get: function get4() {
        return _merge.merge;
      }
    });
    Object.defineProperty(exports2, "structuredPatch", {
      enumerable: true,
      get: function get4() {
        return _create.structuredPatch;
      }
    });
    Object.defineProperty(exports2, "createTwoFilesPatch", {
      enumerable: true,
      get: function get4() {
        return _create.createTwoFilesPatch;
      }
    });
    Object.defineProperty(exports2, "createPatch", {
      enumerable: true,
      get: function get4() {
        return _create.createPatch;
      }
    });
    Object.defineProperty(exports2, "convertChangesToDMP", {
      enumerable: true,
      get: function get4() {
        return _dmp.convertChangesToDMP;
      }
    });
    Object.defineProperty(exports2, "convertChangesToXML", {
      enumerable: true,
      get: function get4() {
        return _xml.convertChangesToXML;
      }
    });
    var _base = _interopRequireDefault(require_base());
    var _character = require_character();
    var _word = require_word();
    var _line = require_line();
    var _sentence = require_sentence();
    var _css = require_css();
    var _json = require_json2();
    var _array = require_array2();
    var _apply = require_apply();
    var _parse = require_parse6();
    var _merge = require_merge3();
    var _create = require_create3();
    var _dmp = require_dmp();
    var _xml = require_xml();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {default: obj};
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isKey.js
  var require_isKey = __commonJS((exports2, module2) => {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isObject.js
  var require_isObject = __commonJS((exports2, module2) => {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isFunction.js
  var require_isFunction = __commonJS((exports2, module2) => {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_coreJsData.js
  var require_coreJsData = __commonJS((exports2, module2) => {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isMasked.js
  var require_isMasked = __commonJS((exports2, module2) => {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_toSource.js
  var require_toSource = __commonJS((exports2, module2) => {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseIsNative.js
  var require_baseIsNative = __commonJS((exports2, module2) => {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getValue.js
  var require_getValue = __commonJS((exports2, module2) => {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getNative.js
  var require_getNative = __commonJS((exports2, module2) => {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_nativeCreate.js
  var require_nativeCreate = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hashClear.js
  var require_hashClear = __commonJS((exports2, module2) => {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hashDelete.js
  var require_hashDelete = __commonJS((exports2, module2) => {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hashGet.js
  var require_hashGet = __commonJS((exports2, module2) => {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hashHas.js
  var require_hashHas = __commonJS((exports2, module2) => {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hashSet.js
  var require_hashSet = __commonJS((exports2, module2) => {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Hash.js
  var require_Hash = __commonJS((exports2, module2) => {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_listCacheClear.js
  var require_listCacheClear = __commonJS((exports2, module2) => {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\eq.js
  var require_eq2 = __commonJS((exports2, module2) => {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_assocIndexOf.js
  var require_assocIndexOf = __commonJS((exports2, module2) => {
    var eq = require_eq2();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_listCacheDelete.js
  var require_listCacheDelete = __commonJS((exports2, module2) => {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_listCacheGet.js
  var require_listCacheGet = __commonJS((exports2, module2) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_listCacheHas.js
  var require_listCacheHas = __commonJS((exports2, module2) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_listCacheSet.js
  var require_listCacheSet = __commonJS((exports2, module2) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_ListCache.js
  var require_ListCache = __commonJS((exports2, module2) => {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Map.js
  var require_Map = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_mapCacheClear.js
  var require_mapCacheClear = __commonJS((exports2, module2) => {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    module2.exports = mapCacheClear;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isKeyable.js
  var require_isKeyable = __commonJS((exports2, module2) => {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getMapData.js
  var require_getMapData = __commonJS((exports2, module2) => {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS((exports2, module2) => {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_mapCacheGet.js
  var require_mapCacheGet = __commonJS((exports2, module2) => {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_mapCacheHas.js
  var require_mapCacheHas = __commonJS((exports2, module2) => {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_mapCacheSet.js
  var require_mapCacheSet = __commonJS((exports2, module2) => {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_MapCache.js
  var require_MapCache = __commonJS((exports2, module2) => {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\memoize.js
  var require_memoize = __commonJS((exports2, module2) => {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_memoizeCapped.js
  var require_memoizeCapped = __commonJS((exports2, module2) => {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stringToPath.js
  var require_stringToPath = __commonJS((exports2, module2) => {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    module2.exports = stringToPath;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_castPath.js
  var require_castPath = __commonJS((exports2, module2) => {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_toKey.js
  var require_toKey = __commonJS((exports2, module2) => {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseGet.js
  var require_baseGet = __commonJS((exports2, module2) => {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path6) {
      path6 = castPath(path6, object);
      var index = 0, length = path6.length;
      while (object != null && index < length) {
        object = object[toKey(path6[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_defineProperty.js
  var require_defineProperty = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseAssignValue.js
  var require_baseAssignValue = __commonJS((exports2, module2) => {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_assignValue.js
  var require_assignValue = __commonJS((exports2, module2) => {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq2();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isIndex.js
  var require_isIndex = __commonJS((exports2, module2) => {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseSet.js
  var require_baseSet = __commonJS((exports2, module2) => {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path6, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path6 = castPath(path6, object);
      var index = -1, length = path6.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path6[index]), newValue = value;
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path6[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_basePickBy.js
  var require_basePickBy = __commonJS((exports2, module2) => {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path6 = paths[index], value = baseGet(object, path6);
        if (predicate(value, path6)) {
          baseSet(result, castPath(path6, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseHasIn.js
  var require_baseHasIn = __commonJS((exports2, module2) => {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseIsArguments.js
  var require_baseIsArguments = __commonJS((exports2, module2) => {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isArguments.js
  var require_isArguments = __commonJS((exports2, module2) => {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isLength.js
  var require_isLength = __commonJS((exports2, module2) => {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_hasPath.js
  var require_hasPath = __commonJS((exports2, module2) => {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path6, hasFunc) {
      path6 = castPath(path6, object);
      var index = -1, length = path6.length, result = false;
      while (++index < length) {
        var key = toKey(path6[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\hasIn.js
  var require_hasIn = __commonJS((exports2, module2) => {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path6) {
      return object != null && hasPath(object, path6, baseHasIn);
    }
    module2.exports = hasIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_basePick.js
  var require_basePick = __commonJS((exports2, module2) => {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path6) {
        return hasIn(object, path6);
      });
    }
    module2.exports = basePick;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_arrayPush.js
  var require_arrayPush = __commonJS((exports2, module2) => {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isFlattenable.js
  var require_isFlattenable = __commonJS((exports2, module2) => {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseFlatten.js
  var require_baseFlatten = __commonJS((exports2, module2) => {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\flatten.js
  var require_flatten = __commonJS((exports2, module2) => {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_apply.js
  var require_apply2 = __commonJS((exports2, module2) => {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_overRest.js
  var require_overRest = __commonJS((exports2, module2) => {
    var apply = require_apply2();
    var nativeMax = Math.max;
    function overRest(func, start2, transform) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\constant.js
  var require_constant = __commonJS((exports2, module2) => {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\identity.js
  var require_identity = __commonJS((exports2, module2) => {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseSetToString.js
  var require_baseSetToString = __commonJS((exports2, module2) => {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        configurable: true,
        enumerable: false,
        value: constant(string),
        writable: true
      });
    };
    module2.exports = baseSetToString;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_shortOut.js
  var require_shortOut = __commonJS((exports2, module2) => {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_setToString.js
  var require_setToString = __commonJS((exports2, module2) => {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_flatRest.js
  var require_flatRest = __commonJS((exports2, module2) => {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module2.exports = flatRest;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\pick.js
  var require_pick = __commonJS((exports2, module2) => {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick2 = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module2.exports = pick2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ansi-colors-npm-4.1.1-97ad42f223-50d8dfbce2.zip\node_modules\ansi-colors\symbols.js
  var require_symbols = __commonJS((exports2, module2) => {
    "use strict";
    var isHyper = process.env.TERM_PROGRAM === "Hyper";
    var isWindows = process.platform === "win32";
    var isLinux = process.platform === "linux";
    var common = {
      ballotDisabled: "\u2612",
      ballotOff: "\u2610",
      ballotOn: "\u2611",
      bullet: "\u2022",
      bulletWhite: "\u25E6",
      fullBlock: "\u2588",
      heart: "\u2764",
      identicalTo: "\u2261",
      line: "\u2500",
      mark: "\u203B",
      middot: "\xB7",
      minus: "\uFF0D",
      multiplication: "\xD7",
      obelus: "\xF7",
      pencilDownRight: "\u270E",
      pencilRight: "\u270F",
      pencilUpRight: "\u2710",
      percent: "%",
      pilcrow2: "\u2761",
      pilcrow: "\xB6",
      plusMinus: "\xB1",
      section: "\xA7",
      starsOff: "\u2606",
      starsOn: "\u2605",
      upDownArrow: "\u2195"
    };
    var windows = Object.assign({}, common, {
      check: "\u221A",
      cross: "\xD7",
      ellipsisLarge: "...",
      ellipsis: "...",
      info: "i",
      question: "?",
      questionSmall: "?",
      pointer: ">",
      pointerSmall: "\xBB",
      radioOff: "( )",
      radioOn: "(*)",
      warning: "\u203C"
    });
    var other = Object.assign({}, common, {
      ballotCross: "\u2718",
      check: "\u2714",
      cross: "\u2716",
      ellipsisLarge: "\u22EF",
      ellipsis: "\u2026",
      info: "\u2139",
      question: "?",
      questionFull: "\uFF1F",
      questionSmall: "\uFE56",
      pointer: isLinux ? "\u25B8" : "\u276F",
      pointerSmall: isLinux ? "\u2023" : "\u203A",
      radioOff: "\u25EF",
      radioOn: "\u25C9",
      warning: "\u26A0"
    });
    module2.exports = isWindows && !isHyper ? windows : other;
    Reflect.defineProperty(module2.exports, "common", {enumerable: false, value: common});
    Reflect.defineProperty(module2.exports, "windows", {enumerable: false, value: windows});
    Reflect.defineProperty(module2.exports, "other", {enumerable: false, value: other});
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ansi-colors-npm-4.1.1-97ad42f223-50d8dfbce2.zip\node_modules\ansi-colors\index.js
  var require_ansi_colors = __commonJS((exports2, module2) => {
    "use strict";
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
    var create = () => {
      const colors2 = {enabled: true, visible: true, styles: {}, keys: {}};
      if ("FORCE_COLOR" in process.env) {
        colors2.enabled = process.env.FORCE_COLOR !== "0";
      }
      const ansi = (style2) => {
        let open = style2.open = `[${style2.codes[0]}m`;
        let close = style2.close = `[${style2.codes[1]}m`;
        let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
        style2.wrap = (input, newline) => {
          if (input.includes(close))
            input = input.replace(regex, close + open);
          let output = open + input + close;
          return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
        };
        return style2;
      };
      const wrap = (style2, input, newline) => {
        return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
      };
      const style = (input, stack) => {
        if (input === "" || input == null)
          return "";
        if (colors2.enabled === false)
          return input;
        if (colors2.visible === false)
          return "";
        let str = "" + input;
        let nl = str.includes("\n");
        let n = stack.length;
        if (n > 0 && stack.includes("unstyle")) {
          stack = [...new Set(["unstyle", ...stack])].reverse();
        }
        while (n-- > 0)
          str = wrap(colors2.styles[stack[n]], str, nl);
        return str;
      };
      const define2 = (name, codes, type) => {
        colors2.styles[name] = ansi({name, codes});
        let keys = colors2.keys[type] || (colors2.keys[type] = []);
        keys.push(name);
        Reflect.defineProperty(colors2, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors2.alias(name, value);
          },
          get() {
            let color = (input) => style(input, color.stack);
            Reflect.setPrototypeOf(color, colors2);
            color.stack = this.stack ? this.stack.concat(name) : [name];
            return color;
          }
        });
      };
      define2("reset", [0, 0], "modifier");
      define2("bold", [1, 22], "modifier");
      define2("dim", [2, 22], "modifier");
      define2("italic", [3, 23], "modifier");
      define2("underline", [4, 24], "modifier");
      define2("inverse", [7, 27], "modifier");
      define2("hidden", [8, 28], "modifier");
      define2("strikethrough", [9, 29], "modifier");
      define2("black", [30, 39], "color");
      define2("red", [31, 39], "color");
      define2("green", [32, 39], "color");
      define2("yellow", [33, 39], "color");
      define2("blue", [34, 39], "color");
      define2("magenta", [35, 39], "color");
      define2("cyan", [36, 39], "color");
      define2("white", [37, 39], "color");
      define2("gray", [90, 39], "color");
      define2("grey", [90, 39], "color");
      define2("bgBlack", [40, 49], "bg");
      define2("bgRed", [41, 49], "bg");
      define2("bgGreen", [42, 49], "bg");
      define2("bgYellow", [43, 49], "bg");
      define2("bgBlue", [44, 49], "bg");
      define2("bgMagenta", [45, 49], "bg");
      define2("bgCyan", [46, 49], "bg");
      define2("bgWhite", [47, 49], "bg");
      define2("blackBright", [90, 39], "bright");
      define2("redBright", [91, 39], "bright");
      define2("greenBright", [92, 39], "bright");
      define2("yellowBright", [93, 39], "bright");
      define2("blueBright", [94, 39], "bright");
      define2("magentaBright", [95, 39], "bright");
      define2("cyanBright", [96, 39], "bright");
      define2("whiteBright", [97, 39], "bright");
      define2("bgBlackBright", [100, 49], "bgBright");
      define2("bgRedBright", [101, 49], "bgBright");
      define2("bgGreenBright", [102, 49], "bgBright");
      define2("bgYellowBright", [103, 49], "bgBright");
      define2("bgBlueBright", [104, 49], "bgBright");
      define2("bgMagentaBright", [105, 49], "bgBright");
      define2("bgCyanBright", [106, 49], "bgBright");
      define2("bgWhiteBright", [107, 49], "bgBright");
      colors2.ansiRegex = ANSI_REGEX;
      colors2.hasColor = colors2.hasAnsi = (str) => {
        colors2.ansiRegex.lastIndex = 0;
        return typeof str === "string" && str !== "" && colors2.ansiRegex.test(str);
      };
      colors2.alias = (name, color) => {
        let fn = typeof color === "string" ? colors2[color] : color;
        if (typeof fn !== "function") {
          throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
        }
        if (!fn.stack) {
          Reflect.defineProperty(fn, "name", {value: name});
          colors2.styles[name] = fn;
          fn.stack = [name];
        }
        Reflect.defineProperty(colors2, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors2.alias(name, value);
          },
          get() {
            let color2 = (input) => style(input, color2.stack);
            Reflect.setPrototypeOf(color2, colors2);
            color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
            return color2;
          }
        });
      };
      colors2.theme = (custom) => {
        if (!isObject(custom))
          throw new TypeError("Expected theme to be an object");
        for (let name of Object.keys(custom)) {
          colors2.alias(name, custom[name]);
        }
        return colors2;
      };
      colors2.alias("unstyle", (str) => {
        if (typeof str === "string" && str !== "") {
          colors2.ansiRegex.lastIndex = 0;
          return str.replace(colors2.ansiRegex, "");
        }
        return "";
      });
      colors2.alias("noop", (str) => str);
      colors2.none = colors2.clear = colors2.noop;
      colors2.stripColor = colors2.unstyle;
      colors2.symbols = require_symbols();
      colors2.define = define2;
      return colors2;
    };
    module2.exports = create();
    module2.exports.create = create;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\utils.js
  var require_utils5 = __commonJS((exports2) => {
    "use strict";
    var toString = Object.prototype.toString;
    var colors2 = require_ansi_colors();
    var called = false;
    var fns = [];
    var complements = {
      yellow: "blue",
      cyan: "red",
      green: "magenta",
      black: "white",
      blue: "yellow",
      red: "cyan",
      magenta: "green",
      white: "black"
    };
    exports2.longest = (arr, prop) => {
      return arr.reduce((a, v) => Math.max(a, prop ? v[prop].length : v.length), 0);
    };
    exports2.hasColor = (str) => !!str && colors2.hasColor(str);
    var isObject = exports2.isObject = (val) => {
      return val !== null && typeof val === "object" && !Array.isArray(val);
    };
    exports2.nativeType = (val) => {
      return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    exports2.isAsyncFn = (val) => {
      return exports2.nativeType(val) === "asyncfunction";
    };
    exports2.isPrimitive = (val) => {
      return val != null && typeof val !== "object" && typeof val !== "function";
    };
    exports2.resolve = (context, value, ...rest) => {
      if (typeof value === "function") {
        return value.call(context, ...rest);
      }
      return value;
    };
    exports2.scrollDown = (choices = []) => [...choices.slice(1), choices[0]];
    exports2.scrollUp = (choices = []) => [choices.pop(), ...choices];
    exports2.reorder = (arr = []) => {
      let res = arr.slice();
      res.sort((a, b) => {
        if (a.index > b.index)
          return 1;
        if (a.index < b.index)
          return -1;
        return 0;
      });
      return res;
    };
    exports2.swap = (arr, index, pos) => {
      let len = arr.length;
      let idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
      let choice = arr[index];
      arr[index] = arr[idx];
      arr[idx] = choice;
    };
    exports2.width = (stream, fallback = 80) => {
      let columns = stream && stream.columns ? stream.columns : fallback;
      if (stream && typeof stream.getWindowSize === "function") {
        columns = stream.getWindowSize()[0];
      }
      if (process.platform === "win32") {
        return columns - 1;
      }
      return columns;
    };
    exports2.height = (stream, fallback = 20) => {
      let rows = stream && stream.rows ? stream.rows : fallback;
      if (stream && typeof stream.getWindowSize === "function") {
        rows = stream.getWindowSize()[1];
      }
      return rows;
    };
    exports2.wordWrap = (str, options = {}) => {
      if (!str)
        return str;
      if (typeof options === "number") {
        options = {width: options};
      }
      let {indent = "", newline = "\n" + indent, width = 80} = options;
      let spaces = (newline + indent).match(/[^\S\n]/g) || [];
      width -= spaces.length;
      let source = `.{1,${width}}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)`;
      let output = str.trim();
      let regex = new RegExp(source, "g");
      let lines = output.match(regex) || [];
      lines = lines.map((line) => line.replace(/\n$/, ""));
      if (options.padEnd)
        lines = lines.map((line) => line.padEnd(width, " "));
      if (options.padStart)
        lines = lines.map((line) => line.padStart(width, " "));
      return indent + lines.join(newline);
    };
    exports2.unmute = (color) => {
      let name = color.stack.find((n) => colors2.keys.color.includes(n));
      if (name) {
        return colors2[name];
      }
      let bg = color.stack.find((n) => n.slice(2) === "bg");
      if (bg) {
        return colors2[name.slice(2)];
      }
      return (str) => str;
    };
    exports2.pascal = (str) => str ? str[0].toUpperCase() + str.slice(1) : "";
    exports2.inverse = (color) => {
      if (!color || !color.stack)
        return color;
      let name = color.stack.find((n) => colors2.keys.color.includes(n));
      if (name) {
        let col = colors2["bg" + exports2.pascal(name)];
        return col ? col.black : color;
      }
      let bg = color.stack.find((n) => n.slice(0, 2) === "bg");
      if (bg) {
        return colors2[bg.slice(2).toLowerCase()] || color;
      }
      return colors2.none;
    };
    exports2.complement = (color) => {
      if (!color || !color.stack)
        return color;
      let name = color.stack.find((n) => colors2.keys.color.includes(n));
      let bg = color.stack.find((n) => n.slice(0, 2) === "bg");
      if (name && !bg) {
        return colors2[complements[name] || name];
      }
      if (bg) {
        let lower = bg.slice(2).toLowerCase();
        let comp = complements[lower];
        if (!comp)
          return color;
        return colors2["bg" + exports2.pascal(comp)] || color;
      }
      return colors2.none;
    };
    exports2.meridiem = (date) => {
      let hours = date.getHours();
      let minutes = date.getMinutes();
      let ampm = hours >= 12 ? "pm" : "am";
      hours = hours % 12;
      let hrs = hours === 0 ? 12 : hours;
      let min = minutes < 10 ? "0" + minutes : minutes;
      return hrs + ":" + min + " " + ampm;
    };
    exports2.set = (obj = {}, prop = "", val) => {
      return prop.split(".").reduce((acc, k, i, arr) => {
        let value = arr.length - 1 > i ? acc[k] || {} : val;
        if (!exports2.isObject(value) && i < arr.length - 1)
          value = {};
        return acc[k] = value;
      }, obj);
    };
    exports2.get = (obj = {}, prop = "", fallback) => {
      let value = obj[prop] == null ? prop.split(".").reduce((acc, k) => acc && acc[k], obj) : obj[prop];
      return value == null ? fallback : value;
    };
    exports2.mixin = (target, b) => {
      if (!isObject(target))
        return b;
      if (!isObject(b))
        return target;
      for (let key of Object.keys(b)) {
        let desc = Object.getOwnPropertyDescriptor(b, key);
        if (desc.hasOwnProperty("value")) {
          if (target.hasOwnProperty(key) && isObject(desc.value)) {
            let existing = Object.getOwnPropertyDescriptor(target, key);
            if (isObject(existing.value)) {
              target[key] = exports2.merge({}, target[key], b[key]);
            } else {
              Reflect.defineProperty(target, key, desc);
            }
          } else {
            Reflect.defineProperty(target, key, desc);
          }
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      }
      return target;
    };
    exports2.merge = (...args) => {
      let target = {};
      for (let ele of args)
        exports2.mixin(target, ele);
      return target;
    };
    exports2.mixinEmitter = (obj, emitter) => {
      let proto = emitter.constructor.prototype;
      for (let key of Object.keys(proto)) {
        let val = proto[key];
        if (typeof val === "function") {
          exports2.define(obj, key, val.bind(emitter));
        } else {
          exports2.define(obj, key, val);
        }
      }
    };
    exports2.onExit = (callback) => {
      const onExit = (quit, code) => {
        if (called)
          return;
        called = true;
        fns.forEach((fn) => fn());
        if (quit === true) {
          process.exit(128 + code);
        }
      };
      if (fns.length === 0) {
        process.once("SIGTERM", onExit.bind(null, true, 15));
        process.once("SIGINT", onExit.bind(null, true, 2));
        process.once("exit", onExit);
      }
      fns.push(callback);
    };
    exports2.define = (obj, key, value) => {
      Reflect.defineProperty(obj, key, {value});
    };
    exports2.defineExport = (obj, key, fn) => {
      let custom;
      Reflect.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        set(val) {
          custom = val;
        },
        get() {
          return custom ? custom() : fn();
        }
      });
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\combos.js
  var require_combos = __commonJS((exports2) => {
    "use strict";
    exports2.ctrl = {
      a: "first",
      b: "backward",
      c: "cancel",
      d: "deleteForward",
      e: "last",
      f: "forward",
      g: "reset",
      i: "tab",
      k: "cutForward",
      l: "reset",
      n: "newItem",
      m: "cancel",
      j: "submit",
      p: "search",
      r: "remove",
      s: "save",
      u: "undo",
      w: "cutLeft",
      x: "toggleCursor",
      v: "paste"
    };
    exports2.shift = {
      up: "shiftUp",
      down: "shiftDown",
      left: "shiftLeft",
      right: "shiftRight",
      tab: "prev"
    };
    exports2.fn = {
      up: "pageUp",
      down: "pageDown",
      left: "pageLeft",
      right: "pageRight",
      delete: "deleteForward"
    };
    exports2.option = {
      b: "backward",
      f: "forward",
      d: "cutRight",
      left: "cutLeft",
      up: "altUp",
      down: "altDown"
    };
    exports2.keys = {
      pageup: "pageUp",
      pagedown: "pageDown",
      home: "home",
      end: "end",
      cancel: "cancel",
      delete: "deleteForward",
      backspace: "delete",
      down: "down",
      enter: "submit",
      escape: "cancel",
      left: "left",
      space: "space",
      number: "number",
      return: "submit",
      right: "right",
      tab: "next",
      up: "up"
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\keypress.js
  var require_keypress = __commonJS((exports2, module2) => {
    "use strict";
    var readline2 = require("readline");
    var combos = require_combos();
    var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
    var fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
    var keyName = {
      OP: "f1",
      OQ: "f2",
      OR: "f3",
      OS: "f4",
      "[11~": "f1",
      "[12~": "f2",
      "[13~": "f3",
      "[14~": "f4",
      "[[A": "f1",
      "[[B": "f2",
      "[[C": "f3",
      "[[D": "f4",
      "[[E": "f5",
      "[15~": "f5",
      "[17~": "f6",
      "[18~": "f7",
      "[19~": "f8",
      "[20~": "f9",
      "[21~": "f10",
      "[23~": "f11",
      "[24~": "f12",
      "[A": "up",
      "[B": "down",
      "[C": "right",
      "[D": "left",
      "[E": "clear",
      "[F": "end",
      "[H": "home",
      OA: "up",
      OB: "down",
      OC: "right",
      OD: "left",
      OE: "clear",
      OF: "end",
      OH: "home",
      "[1~": "home",
      "[2~": "insert",
      "[3~": "delete",
      "[4~": "end",
      "[5~": "pageup",
      "[6~": "pagedown",
      "[[5~": "pageup",
      "[[6~": "pagedown",
      "[7~": "home",
      "[8~": "end",
      "[a": "up",
      "[b": "down",
      "[c": "right",
      "[d": "left",
      "[e": "clear",
      "[2$": "insert",
      "[3$": "delete",
      "[5$": "pageup",
      "[6$": "pagedown",
      "[7$": "home",
      "[8$": "end",
      Oa: "up",
      Ob: "down",
      Oc: "right",
      Od: "left",
      Oe: "clear",
      "[2^": "insert",
      "[3^": "delete",
      "[5^": "pageup",
      "[6^": "pagedown",
      "[7^": "home",
      "[8^": "end",
      "[Z": "tab"
    };
    function isShiftKey(code) {
      return ["[a", "[b", "[c", "[d", "[e", "[2$", "[3$", "[5$", "[6$", "[7$", "[8$", "[Z"].includes(code);
    }
    function isCtrlKey(code) {
      return ["Oa", "Ob", "Oc", "Od", "Oe", "[2^", "[3^", "[5^", "[6^", "[7^", "[8^"].includes(code);
    }
    var keypress = (s = "", event = {}) => {
      let parts;
      let key = {
        name: event.name,
        ctrl: false,
        meta: false,
        shift: false,
        option: false,
        sequence: s,
        raw: s,
        ...event
      };
      if (Buffer.isBuffer(s)) {
        if (s[0] > 127 && s[1] === void 0) {
          s[0] -= 128;
          s = "" + String(s);
        } else {
          s = String(s);
        }
      } else if (s !== void 0 && typeof s !== "string") {
        s = String(s);
      } else if (!s) {
        s = key.sequence || "";
      }
      key.sequence = key.sequence || s || key.name;
      if (s === "\r") {
        key.raw = void 0;
        key.name = "return";
      } else if (s === "\n") {
        key.name = "enter";
      } else if (s === "	") {
        key.name = "tab";
      } else if (s === "\b" || s === "\x7F" || s === "\x7F" || s === "\b") {
        key.name = "backspace";
        key.meta = s.charAt(0) === "";
      } else if (s === "" || s === "") {
        key.name = "escape";
        key.meta = s.length === 2;
      } else if (s === " " || s === " ") {
        key.name = "space";
        key.meta = s.length === 2;
      } else if (s <= "") {
        key.name = String.fromCharCode(s.charCodeAt(0) + "a".charCodeAt(0) - 1);
        key.ctrl = true;
      } else if (s.length === 1 && s >= "0" && s <= "9") {
        key.name = "number";
      } else if (s.length === 1 && s >= "a" && s <= "z") {
        key.name = s;
      } else if (s.length === 1 && s >= "A" && s <= "Z") {
        key.name = s.toLowerCase();
        key.shift = true;
      } else if (parts = metaKeyCodeRe.exec(s)) {
        key.meta = true;
        key.shift = /^[A-Z]$/.test(parts[1]);
      } else if (parts = fnKeyRe.exec(s)) {
        let segs = [...s];
        if (segs[0] === "" && segs[1] === "") {
          key.option = true;
        }
        let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join("");
        let modifier = (parts[3] || parts[5] || 1) - 1;
        key.ctrl = !!(modifier & 4);
        key.meta = !!(modifier & 10);
        key.shift = !!(modifier & 1);
        key.code = code;
        key.name = keyName[code];
        key.shift = isShiftKey(code) || key.shift;
        key.ctrl = isCtrlKey(code) || key.ctrl;
      }
      return key;
    };
    keypress.listen = (options = {}, onKeypress) => {
      let {stdin} = options;
      if (!stdin || stdin !== process.stdin && !stdin.isTTY) {
        throw new Error("Invalid stream passed");
      }
      let rl = readline2.createInterface({terminal: true, input: stdin});
      readline2.emitKeypressEvents(stdin, rl);
      let on = (buf, key) => onKeypress(buf, keypress(buf, key), rl);
      let isRaw = stdin.isRaw;
      if (stdin.isTTY)
        stdin.setRawMode(true);
      stdin.on("keypress", on);
      rl.resume();
      let off = () => {
        if (stdin.isTTY)
          stdin.setRawMode(isRaw);
        stdin.removeListener("keypress", on);
        rl.pause();
        rl.close();
      };
      return off;
    };
    keypress.action = (buf, key, customActions) => {
      let obj = {...combos, ...customActions};
      if (key.ctrl) {
        key.action = obj.ctrl[key.name];
        return key;
      }
      if (key.option && obj.option) {
        key.action = obj.option[key.name];
        return key;
      }
      if (key.shift) {
        key.action = obj.shift[key.name];
        return key;
      }
      key.action = obj.keys[key.name];
      return key;
    };
    module2.exports = keypress;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\timer.js
  var require_timer = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (prompt9) => {
      prompt9.timers = prompt9.timers || {};
      let timers = prompt9.options.timers;
      if (!timers)
        return;
      for (let key of Object.keys(timers)) {
        let opts = timers[key];
        if (typeof opts === "number") {
          opts = {interval: opts};
        }
        create(prompt9, key, opts);
      }
    };
    function create(prompt9, name, options = {}) {
      let timer = prompt9.timers[name] = {name, start: Date.now(), ms: 0, tick: 0};
      let ms = options.interval || 120;
      timer.frames = options.frames || [];
      timer.loading = true;
      let interval = setInterval(() => {
        timer.ms = Date.now() - timer.start;
        timer.tick++;
        prompt9.render();
      }, ms);
      timer.stop = () => {
        timer.loading = false;
        clearInterval(interval);
      };
      Reflect.defineProperty(timer, "interval", {value: interval});
      prompt9.once("close", () => timer.stop());
      return timer.stop;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\state.js
  var require_state = __commonJS((exports2, module2) => {
    "use strict";
    var {define: define2, width} = require_utils5();
    var State = class {
      constructor(prompt9) {
        let options = prompt9.options;
        define2(this, "_prompt", prompt9);
        this.type = prompt9.type;
        this.name = prompt9.name;
        this.message = "";
        this.header = "";
        this.footer = "";
        this.error = "";
        this.hint = "";
        this.input = "";
        this.cursor = 0;
        this.index = 0;
        this.lines = 0;
        this.tick = 0;
        this.prompt = "";
        this.buffer = "";
        this.width = width(options.stdout || process.stdout);
        Object.assign(this, options);
        this.name = this.name || this.message;
        this.message = this.message || this.name;
        this.symbols = prompt9.symbols;
        this.styles = prompt9.styles;
        this.required = new Set();
        this.cancelled = false;
        this.submitted = false;
      }
      clone() {
        let state = {...this};
        state.status = this.status;
        state.buffer = Buffer.from(state.buffer);
        delete state.clone;
        return state;
      }
      set color(val) {
        this._color = val;
      }
      get color() {
        let styles = this.prompt.styles;
        if (this.cancelled)
          return styles.cancelled;
        if (this.submitted)
          return styles.submitted;
        let color = this._color || styles[this.status];
        return typeof color === "function" ? color : styles.pending;
      }
      set loading(value) {
        this._loading = value;
      }
      get loading() {
        if (typeof this._loading === "boolean")
          return this._loading;
        if (this.loadingChoices)
          return "choices";
        return false;
      }
      get status() {
        if (this.cancelled)
          return "cancelled";
        if (this.submitted)
          return "submitted";
        return "pending";
      }
    };
    module2.exports = State;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\styles.js
  var require_styles = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils5();
    var colors2 = require_ansi_colors();
    var styles = {
      default: colors2.noop,
      noop: colors2.noop,
      set inverse(custom) {
        this._inverse = custom;
      },
      get inverse() {
        return this._inverse || utils.inverse(this.primary);
      },
      set complement(custom) {
        this._complement = custom;
      },
      get complement() {
        return this._complement || utils.complement(this.primary);
      },
      primary: colors2.cyan,
      success: colors2.green,
      danger: colors2.magenta,
      strong: colors2.bold,
      warning: colors2.yellow,
      muted: colors2.dim,
      disabled: colors2.gray,
      dark: colors2.dim.gray,
      underline: colors2.underline,
      set info(custom) {
        this._info = custom;
      },
      get info() {
        return this._info || this.primary;
      },
      set em(custom) {
        this._em = custom;
      },
      get em() {
        return this._em || this.primary.underline;
      },
      set heading(custom) {
        this._heading = custom;
      },
      get heading() {
        return this._heading || this.muted.underline;
      },
      set pending(custom) {
        this._pending = custom;
      },
      get pending() {
        return this._pending || this.primary;
      },
      set submitted(custom) {
        this._submitted = custom;
      },
      get submitted() {
        return this._submitted || this.success;
      },
      set cancelled(custom) {
        this._cancelled = custom;
      },
      get cancelled() {
        return this._cancelled || this.danger;
      },
      set typing(custom) {
        this._typing = custom;
      },
      get typing() {
        return this._typing || this.dim;
      },
      set placeholder(custom) {
        this._placeholder = custom;
      },
      get placeholder() {
        return this._placeholder || this.primary.dim;
      },
      set highlight(custom) {
        this._highlight = custom;
      },
      get highlight() {
        return this._highlight || this.inverse;
      }
    };
    styles.merge = (options = {}) => {
      if (options.styles && typeof options.styles.enabled === "boolean") {
        colors2.enabled = options.styles.enabled;
      }
      if (options.styles && typeof options.styles.visible === "boolean") {
        colors2.visible = options.styles.visible;
      }
      let result = utils.merge({}, styles, options.styles);
      delete result.merge;
      for (let key of Object.keys(colors2)) {
        if (!result.hasOwnProperty(key)) {
          Reflect.defineProperty(result, key, {get: () => colors2[key]});
        }
      }
      for (let key of Object.keys(colors2.styles)) {
        if (!result.hasOwnProperty(key)) {
          Reflect.defineProperty(result, key, {get: () => colors2[key]});
        }
      }
      return result;
    };
    module2.exports = styles;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\symbols.js
  var require_symbols2 = __commonJS((exports2, module2) => {
    "use strict";
    var isWindows = process.platform === "win32";
    var colors2 = require_ansi_colors();
    var utils = require_utils5();
    var symbols = {
      ...colors2.symbols,
      upDownDoubleArrow: "\u21D5",
      upDownDoubleArrow2: "\u2B0D",
      upDownArrow: "\u2195",
      asterisk: "*",
      asterism: "\u2042",
      bulletWhite: "\u25E6",
      electricArrow: "\u2301",
      ellipsisLarge: "\u22EF",
      ellipsisSmall: "\u2026",
      fullBlock: "\u2588",
      identicalTo: "\u2261",
      indicator: colors2.symbols.check,
      leftAngle: "\u2039",
      mark: "\u203B",
      minus: "\u2212",
      multiplication: "\xD7",
      obelus: "\xF7",
      percent: "%",
      pilcrow: "\xB6",
      pilcrow2: "\u2761",
      pencilUpRight: "\u2710",
      pencilDownRight: "\u270E",
      pencilRight: "\u270F",
      plus: "+",
      plusMinus: "\xB1",
      pointRight: "\u261E",
      rightAngle: "\u203A",
      section: "\xA7",
      hexagon: {off: "\u2B21", on: "\u2B22", disabled: "\u2B22"},
      ballot: {on: "\u2611", off: "\u2610", disabled: "\u2612"},
      stars: {on: "\u2605", off: "\u2606", disabled: "\u2606"},
      folder: {on: "\u25BC", off: "\u25B6", disabled: "\u25B6"},
      prefix: {
        pending: colors2.symbols.question,
        submitted: colors2.symbols.check,
        cancelled: colors2.symbols.cross
      },
      separator: {
        pending: colors2.symbols.pointerSmall,
        submitted: colors2.symbols.middot,
        cancelled: colors2.symbols.middot
      },
      radio: {
        off: isWindows ? "( )" : "\u25EF",
        on: isWindows ? "(*)" : "\u25C9",
        disabled: isWindows ? "(|)" : "\u24BE"
      },
      numbers: ["\u24EA", "\u2460", "\u2461", "\u2462", "\u2463", "\u2464", "\u2465", "\u2466", "\u2467", "\u2468", "\u2469", "\u246A", "\u246B", "\u246C", "\u246D", "\u246E", "\u246F", "\u2470", "\u2471", "\u2472", "\u2473", "\u3251", "\u3252", "\u3253", "\u3254", "\u3255", "\u3256", "\u3257", "\u3258", "\u3259", "\u325A", "\u325B", "\u325C", "\u325D", "\u325E", "\u325F", "\u32B1", "\u32B2", "\u32B3", "\u32B4", "\u32B5", "\u32B6", "\u32B7", "\u32B8", "\u32B9", "\u32BA", "\u32BB", "\u32BC", "\u32BD", "\u32BE", "\u32BF"]
    };
    symbols.merge = (options) => {
      let result = utils.merge({}, colors2.symbols, symbols, options.symbols);
      delete result.merge;
      return result;
    };
    module2.exports = symbols;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\theme.js
  var require_theme = __commonJS((exports2, module2) => {
    "use strict";
    var styles = require_styles();
    var symbols = require_symbols2();
    var utils = require_utils5();
    module2.exports = (prompt9) => {
      prompt9.options = utils.merge({}, prompt9.options.theme, prompt9.options);
      prompt9.symbols = symbols.merge(prompt9.options);
      prompt9.styles = styles.merge(prompt9.options);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\ansi.js
  var require_ansi = __commonJS((exports2, module2) => {
    "use strict";
    var isTerm = process.env.TERM_PROGRAM === "Apple_Terminal";
    var colors2 = require_ansi_colors();
    var utils = require_utils5();
    var ansi = module2.exports = exports2;
    var ESC = "[";
    var BEL = "\x07";
    var hidden = false;
    var code = ansi.code = {
      bell: BEL,
      beep: BEL,
      beginning: `${ESC}G`,
      down: `${ESC}J`,
      esc: ESC,
      getPosition: `${ESC}6n`,
      hide: `${ESC}?25l`,
      line: `${ESC}2K`,
      lineEnd: `${ESC}K`,
      lineStart: `${ESC}1K`,
      restorePosition: ESC + (isTerm ? "8" : "u"),
      savePosition: ESC + (isTerm ? "7" : "s"),
      screen: `${ESC}2J`,
      show: `${ESC}?25h`,
      up: `${ESC}1J`
    };
    var cursor = ansi.cursor = {
      get hidden() {
        return hidden;
      },
      hide() {
        hidden = true;
        return code.hide;
      },
      show() {
        hidden = false;
        return code.show;
      },
      forward: (count = 1) => `${ESC}${count}C`,
      backward: (count = 1) => `${ESC}${count}D`,
      nextLine: (count = 1) => `${ESC}E`.repeat(count),
      prevLine: (count = 1) => `${ESC}F`.repeat(count),
      up: (count = 1) => count ? `${ESC}${count}A` : "",
      down: (count = 1) => count ? `${ESC}${count}B` : "",
      right: (count = 1) => count ? `${ESC}${count}C` : "",
      left: (count = 1) => count ? `${ESC}${count}D` : "",
      to(x, y) {
        return y ? `${ESC}${y + 1};${x + 1}H` : `${ESC}${x + 1}G`;
      },
      move(x = 0, y = 0) {
        let res = "";
        res += x < 0 ? cursor.left(-x) : x > 0 ? cursor.right(x) : "";
        res += y < 0 ? cursor.up(-y) : y > 0 ? cursor.down(y) : "";
        return res;
      },
      restore(state = {}) {
        let {after, cursor: cursor2, initial, input, prompt: prompt9, size, value} = state;
        initial = utils.isPrimitive(initial) ? String(initial) : "";
        input = utils.isPrimitive(input) ? String(input) : "";
        value = utils.isPrimitive(value) ? String(value) : "";
        if (size) {
          let codes = ansi.cursor.up(size) + ansi.cursor.to(prompt9.length);
          let diff = input.length - cursor2;
          if (diff > 0) {
            codes += ansi.cursor.left(diff);
          }
          return codes;
        }
        if (value || after) {
          let pos = !input && !!initial ? -initial.length : -input.length + cursor2;
          if (after)
            pos -= after.length;
          if (input === "" && initial && !prompt9.includes(initial)) {
            pos += initial.length;
          }
          return ansi.cursor.move(pos);
        }
      }
    };
    var erase = ansi.erase = {
      screen: code.screen,
      up: code.up,
      down: code.down,
      line: code.line,
      lineEnd: code.lineEnd,
      lineStart: code.lineStart,
      lines(n) {
        let str = "";
        for (let i = 0; i < n; i++) {
          str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : "");
        }
        if (n)
          str += ansi.code.beginning;
        return str;
      }
    };
    ansi.clear = (input = "", columns = process.stdout.columns) => {
      if (!columns)
        return erase.line + cursor.to(0);
      let width = (str) => [...colors2.unstyle(str)].length;
      let lines = input.split(/\r?\n/);
      let rows = 0;
      for (let line of lines) {
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
      }
      return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompt.js
  var require_prompt = __commonJS((exports2, module2) => {
    "use strict";
    var Events = require("events");
    var colors2 = require_ansi_colors();
    var keypress = require_keypress();
    var timer = require_timer();
    var State = require_state();
    var theme = require_theme();
    var utils = require_utils5();
    var ansi = require_ansi();
    var Prompt = class extends Events {
      constructor(options = {}) {
        super();
        this.name = options.name;
        this.type = options.type;
        this.options = options;
        theme(this);
        timer(this);
        this.state = new State(this);
        this.initial = [options.initial, options.default].find((v) => v != null);
        this.stdout = options.stdout || process.stdout;
        this.stdin = options.stdin || process.stdin;
        this.scale = options.scale || 1;
        this.term = this.options.term || process.env.TERM_PROGRAM;
        this.margin = margin(this.options.margin);
        this.setMaxListeners(0);
        setOptions(this);
      }
      async keypress(input, event = {}) {
        this.keypressed = true;
        let key = keypress.action(input, keypress(input, event), this.options.actions);
        this.state.keypress = key;
        this.emit("keypress", input, key);
        this.emit("state", this.state.clone());
        let fn = this.options[key.action] || this[key.action] || this.dispatch;
        if (typeof fn === "function") {
          return await fn.call(this, input, key);
        }
        this.alert();
      }
      alert() {
        delete this.state.alert;
        if (this.options.show === false) {
          this.emit("alert");
        } else {
          this.stdout.write(ansi.code.beep);
        }
      }
      cursorHide() {
        this.stdout.write(ansi.cursor.hide());
        utils.onExit(() => this.cursorShow());
      }
      cursorShow() {
        this.stdout.write(ansi.cursor.show());
      }
      write(str) {
        if (!str)
          return;
        if (this.stdout && this.state.show !== false) {
          this.stdout.write(str);
        }
        this.state.buffer += str;
      }
      clear(lines = 0) {
        let buffer = this.state.buffer;
        this.state.buffer = "";
        if (!buffer && !lines || this.options.show === false)
          return;
        this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
      }
      restore() {
        if (this.state.closed || this.options.show === false)
          return;
        let {prompt: prompt9, after, rest} = this.sections();
        let {cursor, initial = "", input = "", value = ""} = this;
        let size = this.state.size = rest.length;
        let state = {after, cursor, initial, input, prompt: prompt9, size, value};
        let codes = ansi.cursor.restore(state);
        if (codes) {
          this.stdout.write(codes);
        }
      }
      sections() {
        let {buffer, input, prompt: prompt9} = this.state;
        prompt9 = colors2.unstyle(prompt9);
        let buf = colors2.unstyle(buffer);
        let idx = buf.indexOf(prompt9);
        let header = buf.slice(0, idx);
        let rest = buf.slice(idx);
        let lines = rest.split("\n");
        let first = lines[0];
        let last = lines[lines.length - 1];
        let promptLine = prompt9 + (input ? " " + input : "");
        let len = promptLine.length;
        let after = len < first.length ? first.slice(len + 1) : "";
        return {header, prompt: first, after, rest: lines.slice(1), last};
      }
      async submit() {
        this.state.submitted = true;
        this.state.validating = true;
        if (this.options.onSubmit) {
          await this.options.onSubmit.call(this, this.name, this.value, this);
        }
        let result = this.state.error || await this.validate(this.value, this.state);
        if (result !== true) {
          let error = "\n" + this.symbols.pointer + " ";
          if (typeof result === "string") {
            error += result.trim();
          } else {
            error += "Invalid input";
          }
          this.state.error = "\n" + this.styles.danger(error);
          this.state.submitted = false;
          await this.render();
          await this.alert();
          this.state.validating = false;
          this.state.error = void 0;
          return;
        }
        this.state.validating = false;
        await this.render();
        await this.close();
        this.value = await this.result(this.value);
        this.emit("submit", this.value);
      }
      async cancel(err) {
        this.state.cancelled = this.state.submitted = true;
        await this.render();
        await this.close();
        if (typeof this.options.onCancel === "function") {
          await this.options.onCancel.call(this, this.name, this.value, this);
        }
        this.emit("cancel", await this.error(err));
      }
      async close() {
        this.state.closed = true;
        try {
          let sections = this.sections();
          let lines = Math.ceil(sections.prompt.length / this.width);
          if (sections.rest) {
            this.write(ansi.cursor.down(sections.rest.length));
          }
          this.write("\n".repeat(lines));
        } catch (err) {
        }
        this.emit("close");
      }
      start() {
        if (!this.stop && this.options.show !== false) {
          this.stop = keypress.listen(this, this.keypress.bind(this));
          this.once("close", this.stop);
        }
      }
      async skip() {
        this.skipped = this.options.skip === true;
        if (typeof this.options.skip === "function") {
          this.skipped = await this.options.skip.call(this, this.name, this.value);
        }
        return this.skipped;
      }
      async initialize() {
        let {format, options, result} = this;
        this.format = () => format.call(this, this.value);
        this.result = () => result.call(this, this.value);
        if (typeof options.initial === "function") {
          this.initial = await options.initial.call(this, this);
        }
        if (typeof options.onRun === "function") {
          await options.onRun.call(this, this);
        }
        if (typeof options.onSubmit === "function") {
          let onSubmit = options.onSubmit.bind(this);
          let submit = this.submit.bind(this);
          delete this.options.onSubmit;
          this.submit = async () => {
            await onSubmit(this.name, this.value, this);
            return submit();
          };
        }
        await this.start();
        await this.render();
      }
      render() {
        throw new Error("expected prompt to have a custom render method");
      }
      run() {
        return new Promise(async (resolve, reject) => {
          this.once("submit", resolve);
          this.once("cancel", reject);
          if (await this.skip()) {
            this.render = () => {
            };
            return this.submit();
          }
          await this.initialize();
          this.emit("run");
        });
      }
      async element(name, choice, i) {
        let {options, state, symbols, timers} = this;
        let timer2 = timers && timers[name];
        state.timer = timer2;
        let value = options[name] || state[name] || symbols[name];
        let val = choice && choice[name] != null ? choice[name] : await value;
        if (val === "")
          return val;
        let res = await this.resolve(val, state, choice, i);
        if (!res && choice && choice[name]) {
          return this.resolve(value, state, choice, i);
        }
        return res;
      }
      async prefix() {
        let element = await this.element("prefix") || this.symbols;
        let timer2 = this.timers && this.timers.prefix;
        let state = this.state;
        state.timer = timer2;
        if (utils.isObject(element))
          element = element[state.status] || element.pending;
        if (!utils.hasColor(element)) {
          let style = this.styles[state.status] || this.styles.pending;
          return style(element);
        }
        return element;
      }
      async message() {
        let message = await this.element("message");
        if (!utils.hasColor(message)) {
          return this.styles.strong(message);
        }
        return message;
      }
      async separator() {
        let element = await this.element("separator") || this.symbols;
        let timer2 = this.timers && this.timers.separator;
        let state = this.state;
        state.timer = timer2;
        let value = element[state.status] || element.pending || state.separator;
        let ele = await this.resolve(value, state);
        if (utils.isObject(ele))
          ele = ele[state.status] || ele.pending;
        if (!utils.hasColor(ele)) {
          return this.styles.muted(ele);
        }
        return ele;
      }
      async pointer(choice, i) {
        let val = await this.element("pointer", choice, i);
        if (typeof val === "string" && utils.hasColor(val)) {
          return val;
        }
        if (val) {
          let styles = this.styles;
          let focused = this.index === i;
          let style = focused ? styles.primary : (val2) => val2;
          let ele = await this.resolve(val[focused ? "on" : "off"] || val, this.state);
          let styled = !utils.hasColor(ele) ? style(ele) : ele;
          return focused ? styled : " ".repeat(ele.length);
        }
      }
      async indicator(choice, i) {
        let val = await this.element("indicator", choice, i);
        if (typeof val === "string" && utils.hasColor(val)) {
          return val;
        }
        if (val) {
          let styles = this.styles;
          let enabled = choice.enabled === true;
          let style = enabled ? styles.success : styles.dark;
          let ele = val[enabled ? "on" : "off"] || val;
          return !utils.hasColor(ele) ? style(ele) : ele;
        }
        return "";
      }
      body() {
        return null;
      }
      footer() {
        if (this.state.status === "pending") {
          return this.element("footer");
        }
      }
      header() {
        if (this.state.status === "pending") {
          return this.element("header");
        }
      }
      async hint() {
        if (this.state.status === "pending" && !this.isValue(this.state.input)) {
          let hint = await this.element("hint");
          if (!utils.hasColor(hint)) {
            return this.styles.muted(hint);
          }
          return hint;
        }
      }
      error(err) {
        return !this.state.submitted ? err || this.state.error : "";
      }
      format(value) {
        return value;
      }
      result(value) {
        return value;
      }
      validate(value) {
        if (this.options.required === true) {
          return this.isValue(value);
        }
        return true;
      }
      isValue(value) {
        return value != null && value !== "";
      }
      resolve(value, ...args) {
        return utils.resolve(this, value, ...args);
      }
      get base() {
        return Prompt.prototype;
      }
      get style() {
        return this.styles[this.state.status];
      }
      get height() {
        return this.options.rows || utils.height(this.stdout, 25);
      }
      get width() {
        return this.options.columns || utils.width(this.stdout, 80);
      }
      get size() {
        return {width: this.width, height: this.height};
      }
      set cursor(value) {
        this.state.cursor = value;
      }
      get cursor() {
        return this.state.cursor;
      }
      set input(value) {
        this.state.input = value;
      }
      get input() {
        return this.state.input;
      }
      set value(value) {
        this.state.value = value;
      }
      get value() {
        let {input, value} = this.state;
        let result = [value, input].find(this.isValue.bind(this));
        return this.isValue(result) ? result : this.initial;
      }
      static get prompt() {
        return (options) => new this(options).run();
      }
    };
    function setOptions(prompt9) {
      let isValidKey = (key) => {
        return prompt9[key] === void 0 || typeof prompt9[key] === "function";
      };
      let ignore = [
        "actions",
        "choices",
        "initial",
        "margin",
        "roles",
        "styles",
        "symbols",
        "theme",
        "timers",
        "value"
      ];
      let ignoreFn = [
        "body",
        "footer",
        "error",
        "header",
        "hint",
        "indicator",
        "message",
        "prefix",
        "separator",
        "skip"
      ];
      for (let key of Object.keys(prompt9.options)) {
        if (ignore.includes(key))
          continue;
        if (/^on[A-Z]/.test(key))
          continue;
        let option = prompt9.options[key];
        if (typeof option === "function" && isValidKey(key)) {
          if (!ignoreFn.includes(key)) {
            prompt9[key] = option.bind(prompt9);
          }
        } else if (typeof prompt9[key] !== "function") {
          prompt9[key] = option;
        }
      }
    }
    function margin(value) {
      if (typeof value === "number") {
        value = [value, value, value, value];
      }
      let arr = [].concat(value || []);
      let pad = (i) => i % 2 === 0 ? "\n" : " ";
      let res = [];
      for (let i = 0; i < 4; i++) {
        let char = pad(i);
        if (arr[i]) {
          res.push(char.repeat(arr[i]));
        } else {
          res.push("");
        }
      }
      return res;
    }
    module2.exports = Prompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\roles.js
  var require_roles = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils5();
    var roles = {
      default(prompt9, choice) {
        return choice;
      },
      checkbox(prompt9, choice) {
        throw new Error("checkbox role is not implemented yet");
      },
      editable(prompt9, choice) {
        throw new Error("editable role is not implemented yet");
      },
      expandable(prompt9, choice) {
        throw new Error("expandable role is not implemented yet");
      },
      heading(prompt9, choice) {
        choice.disabled = "";
        choice.indicator = [choice.indicator, " "].find((v) => v != null);
        choice.message = choice.message || "";
        return choice;
      },
      input(prompt9, choice) {
        throw new Error("input role is not implemented yet");
      },
      option(prompt9, choice) {
        return roles.default(prompt9, choice);
      },
      radio(prompt9, choice) {
        throw new Error("radio role is not implemented yet");
      },
      separator(prompt9, choice) {
        choice.disabled = "";
        choice.indicator = [choice.indicator, " "].find((v) => v != null);
        choice.message = choice.message || prompt9.symbols.line.repeat(5);
        return choice;
      },
      spacer(prompt9, choice) {
        return choice;
      }
    };
    module2.exports = (name, options = {}) => {
      let role = utils.merge({}, roles, options.roles);
      return role[name] || role.default;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\array.js
  var require_array4 = __commonJS((exports2, module2) => {
    "use strict";
    var colors2 = require_ansi_colors();
    var Prompt = require_prompt();
    var roles = require_roles();
    var utils = require_utils5();
    var {reorder, scrollUp, scrollDown, isObject, swap} = utils;
    var ArrayPrompt = class extends Prompt {
      constructor(options) {
        super(options);
        this.cursorHide();
        this.maxSelected = options.maxSelected || Infinity;
        this.multiple = options.multiple || false;
        this.initial = options.initial || 0;
        this.delay = options.delay || 0;
        this.longest = 0;
        this.num = "";
      }
      async initialize() {
        if (typeof this.options.initial === "function") {
          this.initial = await this.options.initial.call(this);
        }
        await this.reset(true);
        await super.initialize();
      }
      async reset() {
        let {choices, initial, autofocus, suggest: suggest2} = this.options;
        this.state._choices = [];
        this.state.choices = [];
        this.choices = await Promise.all(await this.toChoices(choices));
        this.choices.forEach((ch) => ch.enabled = false);
        if (typeof suggest2 !== "function" && this.selectable.length === 0) {
          throw new Error("At least one choice must be selectable");
        }
        if (isObject(initial))
          initial = Object.keys(initial);
        if (Array.isArray(initial)) {
          if (autofocus != null)
            this.index = this.findIndex(autofocus);
          initial.forEach((v) => this.enable(this.find(v)));
          await this.render();
        } else {
          if (autofocus != null)
            initial = autofocus;
          if (typeof initial === "string")
            initial = this.findIndex(initial);
          if (typeof initial === "number" && initial > -1) {
            this.index = Math.max(0, Math.min(initial, this.choices.length));
            this.enable(this.find(this.index));
          }
        }
        if (this.isDisabled(this.focused)) {
          await this.down();
        }
      }
      async toChoices(value, parent) {
        this.state.loadingChoices = true;
        let choices = [];
        let index = 0;
        let toChoices = async (items, parent2) => {
          if (typeof items === "function")
            items = await items.call(this);
          if (items instanceof Promise)
            items = await items;
          for (let i = 0; i < items.length; i++) {
            let choice = items[i] = await this.toChoice(items[i], index++, parent2);
            choices.push(choice);
            if (choice.choices) {
              await toChoices(choice.choices, choice);
            }
          }
          return choices;
        };
        return toChoices(value, parent).then((choices2) => {
          this.state.loadingChoices = false;
          return choices2;
        });
      }
      async toChoice(ele, i, parent) {
        if (typeof ele === "function")
          ele = await ele.call(this, this);
        if (ele instanceof Promise)
          ele = await ele;
        if (typeof ele === "string")
          ele = {name: ele};
        if (ele.normalized)
          return ele;
        ele.normalized = true;
        let origVal = ele.value;
        let role = roles(ele.role, this.options);
        ele = role(this, ele);
        if (typeof ele.disabled === "string" && !ele.hint) {
          ele.hint = ele.disabled;
          ele.disabled = true;
        }
        if (ele.disabled === true && ele.hint == null) {
          ele.hint = "(disabled)";
        }
        if (ele.index != null)
          return ele;
        ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
        ele.message = ele.message || ele.name || "";
        ele.value = [ele.value, ele.name].find(this.isValue.bind(this));
        ele.input = "";
        ele.index = i;
        ele.cursor = 0;
        utils.define(ele, "parent", parent);
        ele.level = parent ? parent.level + 1 : 1;
        if (ele.indent == null) {
          ele.indent = parent ? parent.indent + "  " : ele.indent || "";
        }
        ele.path = parent ? parent.path + "." + ele.name : ele.name;
        ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));
        if (!this.isDisabled(ele)) {
          this.longest = Math.max(this.longest, colors2.unstyle(ele.message).length);
        }
        let choice = {...ele};
        ele.reset = (input = choice.input, value = choice.value) => {
          for (let key of Object.keys(choice))
            ele[key] = choice[key];
          ele.input = input;
          ele.value = value;
        };
        if (origVal == null && typeof ele.initial === "function") {
          ele.input = await ele.initial.call(this, this.state, ele, i);
        }
        return ele;
      }
      async onChoice(choice, i) {
        this.emit("choice", choice, i, this);
        if (typeof choice.onChoice === "function") {
          await choice.onChoice.call(this, this.state, choice, i);
        }
      }
      async addChoice(ele, i, parent) {
        let choice = await this.toChoice(ele, i, parent);
        this.choices.push(choice);
        this.index = this.choices.length - 1;
        this.limit = this.choices.length;
        return choice;
      }
      async newItem(item, i, parent) {
        let ele = {name: "New choice name?", editable: true, newChoice: true, ...item};
        let choice = await this.addChoice(ele, i, parent);
        choice.updateChoice = () => {
          delete choice.newChoice;
          choice.name = choice.message = choice.input;
          choice.input = "";
          choice.cursor = 0;
        };
        return this.render();
      }
      indent(choice) {
        if (choice.indent == null) {
          return choice.level > 1 ? "  ".repeat(choice.level - 1) : "";
        }
        return choice.indent;
      }
      dispatch(s, key) {
        if (this.multiple && this[key.name])
          return this[key.name]();
        this.alert();
      }
      focus(choice, enabled) {
        if (typeof enabled !== "boolean")
          enabled = choice.enabled;
        if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
          return this.alert();
        }
        this.index = choice.index;
        choice.enabled = enabled && !this.isDisabled(choice);
        return choice;
      }
      space() {
        if (!this.multiple)
          return this.alert();
        this.toggle(this.focused);
        return this.render();
      }
      a() {
        if (this.maxSelected < this.choices.length)
          return this.alert();
        let enabled = this.selectable.every((ch) => ch.enabled);
        this.choices.forEach((ch) => ch.enabled = !enabled);
        return this.render();
      }
      i() {
        if (this.choices.length - this.selected.length > this.maxSelected) {
          return this.alert();
        }
        this.choices.forEach((ch) => ch.enabled = !ch.enabled);
        return this.render();
      }
      g(choice = this.focused) {
        if (!this.choices.some((ch) => !!ch.parent))
          return this.a();
        this.toggle(choice.parent && !choice.choices ? choice.parent : choice);
        return this.render();
      }
      toggle(choice, enabled) {
        if (!choice.enabled && this.selected.length >= this.maxSelected) {
          return this.alert();
        }
        if (typeof enabled !== "boolean")
          enabled = !choice.enabled;
        choice.enabled = enabled;
        if (choice.choices) {
          choice.choices.forEach((ch) => this.toggle(ch, enabled));
        }
        let parent = choice.parent;
        while (parent) {
          let choices = parent.choices.filter((ch) => this.isDisabled(ch));
          parent.enabled = choices.every((ch) => ch.enabled === true);
          parent = parent.parent;
        }
        reset(this, this.choices);
        this.emit("toggle", choice, this);
        return choice;
      }
      enable(choice) {
        if (this.selected.length >= this.maxSelected)
          return this.alert();
        choice.enabled = !this.isDisabled(choice);
        choice.choices && choice.choices.forEach(this.enable.bind(this));
        return choice;
      }
      disable(choice) {
        choice.enabled = false;
        choice.choices && choice.choices.forEach(this.disable.bind(this));
        return choice;
      }
      number(n) {
        this.num += n;
        let number = (num) => {
          let i = Number(num);
          if (i > this.choices.length - 1)
            return this.alert();
          let focused = this.focused;
          let choice = this.choices.find((ch) => i === ch.index);
          if (!choice.enabled && this.selected.length >= this.maxSelected) {
            return this.alert();
          }
          if (this.visible.indexOf(choice) === -1) {
            let choices = reorder(this.choices);
            let actualIdx = choices.indexOf(choice);
            if (focused.index > actualIdx) {
              let start2 = choices.slice(actualIdx, actualIdx + this.limit);
              let end = choices.filter((ch) => !start2.includes(ch));
              this.choices = start2.concat(end);
            } else {
              let pos = actualIdx - this.limit + 1;
              this.choices = choices.slice(pos).concat(choices.slice(0, pos));
            }
          }
          this.index = this.choices.indexOf(choice);
          this.toggle(this.focused);
          return this.render();
        };
        clearTimeout(this.numberTimeout);
        return new Promise((resolve) => {
          let len = this.choices.length;
          let num = this.num;
          let handle = (val = false, res) => {
            clearTimeout(this.numberTimeout);
            if (val)
              res = number(num);
            this.num = "";
            resolve(res);
          };
          if (num === "0" || num.length === 1 && Number(num + "0") > len) {
            return handle(true);
          }
          if (Number(num) > len) {
            return handle(false, this.alert());
          }
          this.numberTimeout = setTimeout(() => handle(true), this.delay);
        });
      }
      home() {
        this.choices = reorder(this.choices);
        this.index = 0;
        return this.render();
      }
      end() {
        let pos = this.choices.length - this.limit;
        let choices = reorder(this.choices);
        this.choices = choices.slice(pos).concat(choices.slice(0, pos));
        this.index = this.limit - 1;
        return this.render();
      }
      first() {
        this.index = 0;
        return this.render();
      }
      last() {
        this.index = this.visible.length - 1;
        return this.render();
      }
      prev() {
        if (this.visible.length <= 1)
          return this.alert();
        return this.up();
      }
      next() {
        if (this.visible.length <= 1)
          return this.alert();
        return this.down();
      }
      right() {
        if (this.cursor >= this.input.length)
          return this.alert();
        this.cursor++;
        return this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.alert();
        this.cursor--;
        return this.render();
      }
      up() {
        let len = this.choices.length;
        let vis = this.visible.length;
        let idx = this.index;
        if (this.options.scroll === false && idx === 0) {
          return this.alert();
        }
        if (len > vis && idx === 0) {
          return this.scrollUp();
        }
        this.index = (idx - 1 % len + len) % len;
        if (this.isDisabled()) {
          return this.up();
        }
        return this.render();
      }
      down() {
        let len = this.choices.length;
        let vis = this.visible.length;
        let idx = this.index;
        if (this.options.scroll === false && idx === vis - 1) {
          return this.alert();
        }
        if (len > vis && idx === vis - 1) {
          return this.scrollDown();
        }
        this.index = (idx + 1) % len;
        if (this.isDisabled()) {
          return this.down();
        }
        return this.render();
      }
      scrollUp(i = 0) {
        this.choices = scrollUp(this.choices);
        this.index = i;
        if (this.isDisabled()) {
          return this.up();
        }
        return this.render();
      }
      scrollDown(i = this.visible.length - 1) {
        this.choices = scrollDown(this.choices);
        this.index = i;
        if (this.isDisabled()) {
          return this.down();
        }
        return this.render();
      }
      async shiftUp() {
        if (this.options.sort === true) {
          this.sorting = true;
          this.swap(this.index - 1);
          await this.up();
          this.sorting = false;
          return;
        }
        return this.scrollUp(this.index);
      }
      async shiftDown() {
        if (this.options.sort === true) {
          this.sorting = true;
          this.swap(this.index + 1);
          await this.down();
          this.sorting = false;
          return;
        }
        return this.scrollDown(this.index);
      }
      pageUp() {
        if (this.visible.length <= 1)
          return this.alert();
        this.limit = Math.max(this.limit - 1, 0);
        this.index = Math.min(this.limit - 1, this.index);
        this._limit = this.limit;
        if (this.isDisabled()) {
          return this.up();
        }
        return this.render();
      }
      pageDown() {
        if (this.visible.length >= this.choices.length)
          return this.alert();
        this.index = Math.max(0, this.index);
        this.limit = Math.min(this.limit + 1, this.choices.length);
        this._limit = this.limit;
        if (this.isDisabled()) {
          return this.down();
        }
        return this.render();
      }
      swap(pos) {
        swap(this.choices, this.index, pos);
      }
      isDisabled(choice = this.focused) {
        let keys = ["disabled", "collapsed", "hidden", "completing", "readonly"];
        if (choice && keys.some((key) => choice[key] === true)) {
          return true;
        }
        return choice && choice.role === "heading";
      }
      isEnabled(choice = this.focused) {
        if (Array.isArray(choice))
          return choice.every((ch) => this.isEnabled(ch));
        if (choice.choices) {
          let choices = choice.choices.filter((ch) => !this.isDisabled(ch));
          return choice.enabled && choices.every((ch) => this.isEnabled(ch));
        }
        return choice.enabled && !this.isDisabled(choice);
      }
      isChoice(choice, value) {
        return choice.name === value || choice.index === Number(value);
      }
      isSelected(choice) {
        if (Array.isArray(this.initial)) {
          return this.initial.some((value) => this.isChoice(choice, value));
        }
        return this.isChoice(choice, this.initial);
      }
      map(names = [], prop = "value") {
        return [].concat(names || []).reduce((acc, name) => {
          acc[name] = this.find(name, prop);
          return acc;
        }, {});
      }
      filter(value, prop) {
        let isChoice = (ele, i) => [ele.name, i].includes(value);
        let fn = typeof value === "function" ? value : isChoice;
        let choices = this.options.multiple ? this.state._choices : this.choices;
        let result = choices.filter(fn);
        if (prop) {
          return result.map((ch) => ch[prop]);
        }
        return result;
      }
      find(value, prop) {
        if (isObject(value))
          return prop ? value[prop] : value;
        let isChoice = (ele, i) => [ele.name, i].includes(value);
        let fn = typeof value === "function" ? value : isChoice;
        let choice = this.choices.find(fn);
        if (choice) {
          return prop ? choice[prop] : choice;
        }
      }
      findIndex(value) {
        return this.choices.indexOf(this.find(value));
      }
      async submit() {
        let choice = this.focused;
        if (!choice)
          return this.alert();
        if (choice.newChoice) {
          if (!choice.input)
            return this.alert();
          choice.updateChoice();
          return this.render();
        }
        if (this.choices.some((ch) => ch.newChoice)) {
          return this.alert();
        }
        let {reorder: reorder2, sort} = this.options;
        let multi = this.multiple === true;
        let value = this.selected;
        if (value === void 0) {
          return this.alert();
        }
        if (Array.isArray(value) && reorder2 !== false && sort !== true) {
          value = utils.reorder(value);
        }
        this.value = multi ? value.map((ch) => ch.name) : value.name;
        return super.submit();
      }
      set choices(choices = []) {
        this.state._choices = this.state._choices || [];
        this.state.choices = choices;
        for (let choice of choices) {
          if (!this.state._choices.some((ch) => ch.name === choice.name)) {
            this.state._choices.push(choice);
          }
        }
        if (!this._initial && this.options.initial) {
          this._initial = true;
          let init = this.initial;
          if (typeof init === "string" || typeof init === "number") {
            let choice = this.find(init);
            if (choice) {
              this.initial = choice.index;
              this.focus(choice, true);
            }
          }
        }
      }
      get choices() {
        return reset(this, this.state.choices || []);
      }
      set visible(visible) {
        this.state.visible = visible;
      }
      get visible() {
        return (this.state.visible || this.choices).slice(0, this.limit);
      }
      set limit(num) {
        this.state.limit = num;
      }
      get limit() {
        let {state, options, choices} = this;
        let limit = state.limit || this._limit || options.limit || choices.length;
        return Math.min(limit, this.height);
      }
      set value(value) {
        super.value = value;
      }
      get value() {
        if (typeof super.value !== "string" && super.value === this.initial) {
          return this.input;
        }
        return super.value;
      }
      set index(i) {
        this.state.index = i;
      }
      get index() {
        return Math.max(0, this.state ? this.state.index : 0);
      }
      get enabled() {
        return this.filter(this.isEnabled.bind(this));
      }
      get focused() {
        let choice = this.choices[this.index];
        if (choice && this.state.submitted && this.multiple !== true) {
          choice.enabled = true;
        }
        return choice;
      }
      get selectable() {
        return this.choices.filter((choice) => !this.isDisabled(choice));
      }
      get selected() {
        return this.multiple ? this.enabled : this.focused;
      }
    };
    function reset(prompt9, choices) {
      if (choices instanceof Promise)
        return choices;
      if (typeof choices === "function") {
        if (utils.isAsyncFn(choices))
          return choices;
        choices = choices.call(prompt9, prompt9);
      }
      for (let choice of choices) {
        if (Array.isArray(choice.choices)) {
          let items = choice.choices.filter((ch) => !prompt9.isDisabled(ch));
          choice.enabled = items.every((ch) => ch.enabled === true);
        }
        if (prompt9.isDisabled(choice) === true) {
          delete choice.enabled;
        }
      }
      return choices;
    }
    module2.exports = ArrayPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\select.js
  var require_select = __commonJS((exports2, module2) => {
    "use strict";
    var ArrayPrompt = require_array4();
    var utils = require_utils5();
    var SelectPrompt = class extends ArrayPrompt {
      constructor(options) {
        super(options);
        this.emptyError = this.options.emptyError || "No items were selected";
      }
      async dispatch(s, key) {
        if (this.multiple) {
          return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
        }
        this.alert();
      }
      separator() {
        if (this.options.separator)
          return super.separator();
        let sep = this.styles.muted(this.symbols.ellipsis);
        return this.state.submitted ? super.separator() : sep;
      }
      pointer(choice, i) {
        return !this.multiple || this.options.pointer ? super.pointer(choice, i) : "";
      }
      indicator(choice, i) {
        return this.multiple ? super.indicator(choice, i) : "";
      }
      choiceMessage(choice, i) {
        let message = this.resolve(choice.message, this.state, choice, i);
        if (choice.role === "heading" && !utils.hasColor(message)) {
          message = this.styles.strong(message);
        }
        return this.resolve(message, this.state, choice, i);
      }
      choiceSeparator() {
        return ":";
      }
      async renderChoice(choice, i) {
        await this.onChoice(choice, i);
        let focused = this.index === i;
        let pointer = await this.pointer(choice, i);
        let check = await this.indicator(choice, i) + (choice.pad || "");
        let hint = await this.resolve(choice.hint, this.state, choice, i);
        if (hint && !utils.hasColor(hint)) {
          hint = this.styles.muted(hint);
        }
        let ind = this.indent(choice);
        let msg = await this.choiceMessage(choice, i);
        let line = () => [this.margin[3], ind + pointer + check, msg, this.margin[1], hint].filter(Boolean).join(" ");
        if (choice.role === "heading") {
          return line();
        }
        if (choice.disabled) {
          if (!utils.hasColor(msg)) {
            msg = this.styles.disabled(msg);
          }
          return line();
        }
        if (focused) {
          msg = this.styles.em(msg);
        }
        return line();
      }
      async renderChoices() {
        if (this.state.loading === "choices") {
          return this.styles.warning("Loading choices");
        }
        if (this.state.submitted)
          return "";
        let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
        let visible = await Promise.all(choices);
        if (!visible.length)
          visible.push(this.styles.danger("No matching choices"));
        let result = this.margin[0] + visible.join("\n");
        let header;
        if (this.options.choicesHeader) {
          header = await this.resolve(this.options.choicesHeader, this.state);
        }
        return [header, result].filter(Boolean).join("\n");
      }
      format() {
        if (!this.state.submitted || this.state.cancelled)
          return "";
        if (Array.isArray(this.selected)) {
          return this.selected.map((choice) => this.styles.primary(choice.name)).join(", ");
        }
        return this.styles.primary(this.selected.name);
      }
      async render() {
        let {submitted, size} = this.state;
        let prompt9 = "";
        let header = await this.header();
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        if (this.options.promptLine !== false) {
          prompt9 = [prefix, message, separator, ""].join(" ");
          this.state.prompt = prompt9;
        }
        let output = await this.format();
        let help = await this.error() || await this.hint();
        let body = await this.renderChoices();
        let footer = await this.footer();
        if (output)
          prompt9 += output;
        if (help && !prompt9.includes(help))
          prompt9 += " " + help;
        if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
          prompt9 += this.styles.danger(this.emptyError);
        }
        this.clear(size);
        this.write([header, prompt9, body, footer].filter(Boolean).join("\n"));
        this.write(this.margin[2]);
        this.restore();
      }
    };
    module2.exports = SelectPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\autocomplete.js
  var require_autocomplete = __commonJS((exports2, module2) => {
    "use strict";
    var Select = require_select();
    var highlight = (input, color) => {
      let val = input.toLowerCase();
      return (str) => {
        let s = str.toLowerCase();
        let i = s.indexOf(val);
        let colored = color(str.slice(i, i + val.length));
        return i >= 0 ? str.slice(0, i) + colored + str.slice(i + val.length) : str;
      };
    };
    var AutoComplete = class extends Select {
      constructor(options) {
        super(options);
        this.cursorShow();
      }
      moveCursor(n) {
        this.state.cursor += n;
      }
      dispatch(ch) {
        return this.append(ch);
      }
      space(ch) {
        return this.options.multiple ? super.space(ch) : this.append(ch);
      }
      append(ch) {
        let {cursor, input} = this.state;
        this.input = input.slice(0, cursor) + ch + input.slice(cursor);
        this.moveCursor(1);
        return this.complete();
      }
      delete() {
        let {cursor, input} = this.state;
        if (!input)
          return this.alert();
        this.input = input.slice(0, cursor - 1) + input.slice(cursor);
        this.moveCursor(-1);
        return this.complete();
      }
      deleteForward() {
        let {cursor, input} = this.state;
        if (input[cursor] === void 0)
          return this.alert();
        this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
        return this.complete();
      }
      number(ch) {
        return this.append(ch);
      }
      async complete() {
        this.completing = true;
        this.choices = await this.suggest(this.input, this.state._choices);
        this.state.limit = void 0;
        this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
        await this.render();
        this.completing = false;
      }
      suggest(input = this.input, choices = this.state._choices) {
        if (typeof this.options.suggest === "function") {
          return this.options.suggest.call(this, input, choices);
        }
        let str = input.toLowerCase();
        return choices.filter((ch) => ch.message.toLowerCase().includes(str));
      }
      pointer() {
        return "";
      }
      format() {
        if (!this.focused)
          return this.input;
        if (this.options.multiple && this.state.submitted) {
          return this.selected.map((ch) => this.styles.primary(ch.message)).join(", ");
        }
        if (this.state.submitted) {
          let value = this.value = this.input = this.focused.value;
          return this.styles.primary(value);
        }
        return this.input;
      }
      async render() {
        if (this.state.status !== "pending")
          return super.render();
        let style = this.options.highlight ? this.options.highlight.bind(this) : this.styles.placeholder;
        let color = highlight(this.input, style);
        let choices = this.choices;
        this.choices = choices.map((ch) => ({...ch, message: color(ch.message)}));
        await super.render();
        this.choices = choices;
      }
      submit() {
        if (this.options.multiple) {
          this.value = this.selected.map((ch) => ch.name);
        }
        return super.submit();
      }
    };
    module2.exports = AutoComplete;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\placeholder.js
  var require_placeholder = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils5();
    module2.exports = (prompt9, options = {}) => {
      prompt9.cursorHide();
      let {input = "", initial = "", pos, showCursor = true, color} = options;
      let style = color || prompt9.styles.placeholder;
      let inverse = utils.inverse(prompt9.styles.primary);
      let blinker = (str) => inverse(prompt9.styles.black(str));
      let output = input;
      let char = " ";
      let reverse = blinker(char);
      if (prompt9.blink && prompt9.blink.off === true) {
        blinker = (str) => str;
        reverse = "";
      }
      if (showCursor && pos === 0 && initial === "" && input === "") {
        return blinker(char);
      }
      if (showCursor && pos === 0 && (input === initial || input === "")) {
        return blinker(initial[0]) + style(initial.slice(1));
      }
      initial = utils.isPrimitive(initial) ? `${initial}` : "";
      input = utils.isPrimitive(input) ? `${input}` : "";
      let placeholder = initial && initial.startsWith(input) && initial !== input;
      let cursor = placeholder ? blinker(initial[input.length]) : reverse;
      if (pos !== input.length && showCursor === true) {
        output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
        cursor = "";
      }
      if (showCursor === false) {
        cursor = "";
      }
      if (placeholder) {
        let raw = prompt9.styles.unstyle(output + cursor);
        return output + cursor + style(initial.slice(raw.length));
      }
      return output + cursor;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\form.js
  var require_form = __commonJS((exports2, module2) => {
    "use strict";
    var colors2 = require_ansi_colors();
    var SelectPrompt = require_select();
    var placeholder = require_placeholder();
    var FormPrompt = class extends SelectPrompt {
      constructor(options) {
        super({...options, multiple: true});
        this.type = "form";
        this.initial = this.options.initial;
        this.align = [this.options.align, "right"].find((v) => v != null);
        this.emptyError = "";
        this.values = {};
      }
      async reset(first) {
        await super.reset();
        if (first === true)
          this._index = this.index;
        this.index = this._index;
        this.values = {};
        this.choices.forEach((choice) => choice.reset && choice.reset());
        return this.render();
      }
      dispatch(char) {
        return !!char && this.append(char);
      }
      append(char) {
        let choice = this.focused;
        if (!choice)
          return this.alert();
        let {cursor, input} = choice;
        choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);
        choice.cursor++;
        return this.render();
      }
      delete() {
        let choice = this.focused;
        if (!choice || choice.cursor <= 0)
          return this.alert();
        let {cursor, input} = choice;
        choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
        choice.cursor--;
        return this.render();
      }
      deleteForward() {
        let choice = this.focused;
        if (!choice)
          return this.alert();
        let {cursor, input} = choice;
        if (input[cursor] === void 0)
          return this.alert();
        let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
        choice.value = choice.input = str;
        return this.render();
      }
      right() {
        let choice = this.focused;
        if (!choice)
          return this.alert();
        if (choice.cursor >= choice.input.length)
          return this.alert();
        choice.cursor++;
        return this.render();
      }
      left() {
        let choice = this.focused;
        if (!choice)
          return this.alert();
        if (choice.cursor <= 0)
          return this.alert();
        choice.cursor--;
        return this.render();
      }
      space(ch, key) {
        return this.dispatch(ch, key);
      }
      number(ch, key) {
        return this.dispatch(ch, key);
      }
      next() {
        let ch = this.focused;
        if (!ch)
          return this.alert();
        let {initial, input} = ch;
        if (initial && initial.startsWith(input) && input !== initial) {
          ch.value = ch.input = initial;
          ch.cursor = ch.value.length;
          return this.render();
        }
        return super.next();
      }
      prev() {
        let ch = this.focused;
        if (!ch)
          return this.alert();
        if (ch.cursor === 0)
          return super.prev();
        ch.value = ch.input = "";
        ch.cursor = 0;
        return this.render();
      }
      separator() {
        return "";
      }
      format(value) {
        return !this.state.submitted ? super.format(value) : "";
      }
      pointer() {
        return "";
      }
      indicator(choice) {
        return choice.input ? "\u29BF" : "\u2299";
      }
      async choiceSeparator(choice, i) {
        let sep = await this.resolve(choice.separator, this.state, choice, i) || ":";
        return sep ? " " + this.styles.disabled(sep) : "";
      }
      async renderChoice(choice, i) {
        await this.onChoice(choice, i);
        let {state, styles} = this;
        let {cursor, initial = "", name, hint, input = ""} = choice;
        let {muted, submitted, primary, danger} = styles;
        let help = hint;
        let focused = this.index === i;
        let validate = choice.validate || (() => true);
        let sep = await this.choiceSeparator(choice, i);
        let msg = choice.message;
        if (this.align === "right")
          msg = msg.padStart(this.longest + 1, " ");
        if (this.align === "left")
          msg = msg.padEnd(this.longest + 1, " ");
        let value = this.values[name] = input || initial;
        let color = input ? "success" : "dark";
        if (await validate.call(choice, value, this.state) !== true) {
          color = "danger";
        }
        let style = styles[color];
        let indicator = style(await this.indicator(choice, i)) + (choice.pad || "");
        let indent = this.indent(choice);
        let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(" ");
        if (state.submitted) {
          msg = colors2.unstyle(msg);
          input = submitted(input);
          help = "";
          return line();
        }
        if (choice.format) {
          input = await choice.format.call(this, input, choice, i);
        } else {
          let color2 = this.styles.muted;
          let options = {input, initial, pos: cursor, showCursor: focused, color: color2};
          input = placeholder(this, options);
        }
        if (!this.isValue(input)) {
          input = this.styles.muted(this.symbols.ellipsis);
        }
        if (choice.result) {
          this.values[name] = await choice.result.call(this, value, choice, i);
        }
        if (focused) {
          msg = primary(msg);
        }
        if (choice.error) {
          input += (input ? " " : "") + danger(choice.error.trim());
        } else if (choice.hint) {
          input += (input ? " " : "") + muted(choice.hint.trim());
        }
        return line();
      }
      async submit() {
        this.value = this.values;
        return super.base.submit.call(this);
      }
    };
    module2.exports = FormPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\auth.js
  var require_auth = __commonJS((exports2, module2) => {
    "use strict";
    var FormPrompt = require_form();
    var defaultAuthenticate = () => {
      throw new Error("expected prompt to have a custom authenticate method");
    };
    var factory = (authenticate = defaultAuthenticate) => {
      class AuthPrompt extends FormPrompt {
        constructor(options) {
          super(options);
        }
        async submit() {
          this.value = await authenticate.call(this, this.values, this.state);
          super.base.submit.call(this);
        }
        static create(authenticate2) {
          return factory(authenticate2);
        }
      }
      return AuthPrompt;
    };
    module2.exports = factory();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\basicauth.js
  var require_basicauth = __commonJS((exports2, module2) => {
    "use strict";
    var AuthPrompt = require_auth();
    function defaultAuthenticate(value, state) {
      if (value.username === this.options.username && value.password === this.options.password) {
        return true;
      }
      return false;
    }
    var factory = (authenticate = defaultAuthenticate) => {
      const choices = [
        {name: "username", message: "username"},
        {
          name: "password",
          message: "password",
          format(input) {
            if (this.options.showPassword) {
              return input;
            }
            let color = this.state.submitted ? this.styles.primary : this.styles.muted;
            return color(this.symbols.asterisk.repeat(input.length));
          }
        }
      ];
      class BasicAuthPrompt extends AuthPrompt.create(authenticate) {
        constructor(options) {
          super({...options, choices});
        }
        static create(authenticate2) {
          return factory(authenticate2);
        }
      }
      return BasicAuthPrompt;
    };
    module2.exports = factory();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\boolean.js
  var require_boolean = __commonJS((exports2, module2) => {
    "use strict";
    var Prompt = require_prompt();
    var {isPrimitive, hasColor} = require_utils5();
    var BooleanPrompt = class extends Prompt {
      constructor(options) {
        super(options);
        this.cursorHide();
      }
      async initialize() {
        let initial = await this.resolve(this.initial, this.state);
        this.input = await this.cast(initial);
        await super.initialize();
      }
      dispatch(ch) {
        if (!this.isValue(ch))
          return this.alert();
        this.input = ch;
        return this.submit();
      }
      format(value) {
        let {styles, state} = this;
        return !state.submitted ? styles.primary(value) : styles.success(value);
      }
      cast(input) {
        return this.isTrue(input);
      }
      isTrue(input) {
        return /^[ty1]/i.test(input);
      }
      isFalse(input) {
        return /^[fn0]/i.test(input);
      }
      isValue(value) {
        return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
      }
      async hint() {
        if (this.state.status === "pending") {
          let hint = await this.element("hint");
          if (!hasColor(hint)) {
            return this.styles.muted(hint);
          }
          return hint;
        }
      }
      async render() {
        let {input, size} = this.state;
        let prefix = await this.prefix();
        let sep = await this.separator();
        let msg = await this.message();
        let hint = this.styles.muted(this.default);
        let promptLine = [prefix, msg, hint, sep].filter(Boolean).join(" ");
        this.state.prompt = promptLine;
        let header = await this.header();
        let value = this.value = this.cast(input);
        let output = await this.format(value);
        let help = await this.error() || await this.hint();
        let footer = await this.footer();
        if (help && !promptLine.includes(help))
          output += " " + help;
        promptLine += " " + output;
        this.clear(size);
        this.write([header, promptLine, footer].filter(Boolean).join("\n"));
        this.restore();
      }
      set value(value) {
        super.value = value;
      }
      get value() {
        return this.cast(super.value);
      }
    };
    module2.exports = BooleanPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\confirm.js
  var require_confirm = __commonJS((exports2, module2) => {
    "use strict";
    var BooleanPrompt = require_boolean();
    var ConfirmPrompt = class extends BooleanPrompt {
      constructor(options) {
        super(options);
        this.default = this.options.default || (this.initial ? "(Y/n)" : "(y/N)");
      }
    };
    module2.exports = ConfirmPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\editable.js
  var require_editable = __commonJS((exports2, module2) => {
    "use strict";
    var Select = require_select();
    var Form = require_form();
    var form = Form.prototype;
    var Editable = class extends Select {
      constructor(options) {
        super({...options, multiple: true});
        this.align = [this.options.align, "left"].find((v) => v != null);
        this.emptyError = "";
        this.values = {};
      }
      dispatch(char, key) {
        let choice = this.focused;
        let parent = choice.parent || {};
        if (!choice.editable && !parent.editable) {
          if (char === "a" || char === "i")
            return super[char]();
        }
        return form.dispatch.call(this, char, key);
      }
      append(char, key) {
        return form.append.call(this, char, key);
      }
      delete(char, key) {
        return form.delete.call(this, char, key);
      }
      space(char) {
        return this.focused.editable ? this.append(char) : super.space();
      }
      number(char) {
        return this.focused.editable ? this.append(char) : super.number(char);
      }
      next() {
        return this.focused.editable ? form.next.call(this) : super.next();
      }
      prev() {
        return this.focused.editable ? form.prev.call(this) : super.prev();
      }
      async indicator(choice, i) {
        let symbol = choice.indicator || "";
        let value = choice.editable ? symbol : super.indicator(choice, i);
        return await this.resolve(value, this.state, choice, i) || "";
      }
      indent(choice) {
        return choice.role === "heading" ? "" : choice.editable ? " " : "  ";
      }
      async renderChoice(choice, i) {
        choice.indent = "";
        if (choice.editable)
          return form.renderChoice.call(this, choice, i);
        return super.renderChoice(choice, i);
      }
      error() {
        return "";
      }
      footer() {
        return this.state.error;
      }
      async validate() {
        let result = true;
        for (let choice of this.choices) {
          if (typeof choice.validate !== "function") {
            continue;
          }
          if (choice.role === "heading") {
            continue;
          }
          let val = choice.parent ? this.value[choice.parent.name] : this.value;
          if (choice.editable) {
            val = choice.value === choice.name ? choice.initial || "" : choice.value;
          } else if (!this.isDisabled(choice)) {
            val = choice.enabled === true;
          }
          result = await choice.validate(val, this.state);
          if (result !== true) {
            break;
          }
        }
        if (result !== true) {
          this.state.error = typeof result === "string" ? result : "Invalid Input";
        }
        return result;
      }
      submit() {
        if (this.focused.newChoice === true)
          return super.submit();
        if (this.choices.some((ch) => ch.newChoice)) {
          return this.alert();
        }
        this.value = {};
        for (let choice of this.choices) {
          let val = choice.parent ? this.value[choice.parent.name] : this.value;
          if (choice.role === "heading") {
            this.value[choice.name] = {};
            continue;
          }
          if (choice.editable) {
            val[choice.name] = choice.value === choice.name ? choice.initial || "" : choice.value;
          } else if (!this.isDisabled(choice)) {
            val[choice.name] = choice.enabled === true;
          }
        }
        return this.base.submit.call(this);
      }
    };
    module2.exports = Editable;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\string.js
  var require_string2 = __commonJS((exports2, module2) => {
    "use strict";
    var Prompt = require_prompt();
    var placeholder = require_placeholder();
    var {isPrimitive} = require_utils5();
    var StringPrompt = class extends Prompt {
      constructor(options) {
        super(options);
        this.initial = isPrimitive(this.initial) ? String(this.initial) : "";
        if (this.initial)
          this.cursorHide();
        this.state.prevCursor = 0;
        this.state.clipboard = [];
      }
      async keypress(input, key = {}) {
        let prev = this.state.prevKeypress;
        this.state.prevKeypress = key;
        if (this.options.multiline === true && key.name === "return") {
          if (!prev || prev.name !== "return") {
            return this.append("\n", key);
          }
        }
        return super.keypress(input, key);
      }
      moveCursor(n) {
        this.cursor += n;
      }
      reset() {
        this.input = this.value = "";
        this.cursor = 0;
        return this.render();
      }
      dispatch(ch, key) {
        if (!ch || key.ctrl || key.code)
          return this.alert();
        this.append(ch);
      }
      append(ch) {
        let {cursor, input} = this.state;
        this.input = `${input}`.slice(0, cursor) + ch + `${input}`.slice(cursor);
        this.moveCursor(String(ch).length);
        this.render();
      }
      insert(str) {
        this.append(str);
      }
      delete() {
        let {cursor, input} = this.state;
        if (cursor <= 0)
          return this.alert();
        this.input = `${input}`.slice(0, cursor - 1) + `${input}`.slice(cursor);
        this.moveCursor(-1);
        this.render();
      }
      deleteForward() {
        let {cursor, input} = this.state;
        if (input[cursor] === void 0)
          return this.alert();
        this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
        this.render();
      }
      cutForward() {
        let pos = this.cursor;
        if (this.input.length <= pos)
          return this.alert();
        this.state.clipboard.push(this.input.slice(pos));
        this.input = this.input.slice(0, pos);
        this.render();
      }
      cutLeft() {
        let pos = this.cursor;
        if (pos === 0)
          return this.alert();
        let before = this.input.slice(0, pos);
        let after = this.input.slice(pos);
        let words = before.split(" ");
        this.state.clipboard.push(words.pop());
        this.input = words.join(" ");
        this.cursor = this.input.length;
        this.input += after;
        this.render();
      }
      paste() {
        if (!this.state.clipboard.length)
          return this.alert();
        this.insert(this.state.clipboard.pop());
        this.render();
      }
      toggleCursor() {
        if (this.state.prevCursor) {
          this.cursor = this.state.prevCursor;
          this.state.prevCursor = 0;
        } else {
          this.state.prevCursor = this.cursor;
          this.cursor = 0;
        }
        this.render();
      }
      first() {
        this.cursor = 0;
        this.render();
      }
      last() {
        this.cursor = this.input.length - 1;
        this.render();
      }
      next() {
        let init = this.initial != null ? String(this.initial) : "";
        if (!init || !init.startsWith(this.input))
          return this.alert();
        this.input = this.initial;
        this.cursor = this.initial.length;
        this.render();
      }
      prev() {
        if (!this.input)
          return this.alert();
        this.reset();
      }
      backward() {
        return this.left();
      }
      forward() {
        return this.right();
      }
      right() {
        if (this.cursor >= this.input.length)
          return this.alert();
        this.moveCursor(1);
        return this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.alert();
        this.moveCursor(-1);
        return this.render();
      }
      isValue(value) {
        return !!value;
      }
      async format(input = this.value) {
        let initial = await this.resolve(this.initial, this.state);
        if (!this.state.submitted) {
          return placeholder(this, {input, initial, pos: this.cursor});
        }
        return this.styles.submitted(input || initial);
      }
      async render() {
        let size = this.state.size;
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        let prompt9 = [prefix, message, separator].filter(Boolean).join(" ");
        this.state.prompt = prompt9;
        let header = await this.header();
        let output = await this.format();
        let help = await this.error() || await this.hint();
        let footer = await this.footer();
        if (help && !output.includes(help))
          output += " " + help;
        prompt9 += " " + output;
        this.clear(size);
        this.write([header, prompt9, footer].filter(Boolean).join("\n"));
        this.restore();
      }
    };
    module2.exports = StringPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\completer.js
  var require_completer = __commonJS((exports2, module2) => {
    "use strict";
    var unique = (arr) => arr.filter((v, i) => arr.lastIndexOf(v) === i);
    var compact = (arr) => unique(arr).filter(Boolean);
    module2.exports = (action, data = {}, value = "") => {
      let {past = [], present = ""} = data;
      let rest, prev;
      switch (action) {
        case "prev":
        case "undo":
          rest = past.slice(0, past.length - 1);
          prev = past[past.length - 1] || "";
          return {
            past: compact([value, ...rest]),
            present: prev
          };
        case "next":
        case "redo":
          rest = past.slice(1);
          prev = past[0] || "";
          return {
            past: compact([...rest, value]),
            present: prev
          };
        case "save":
          return {
            past: compact([...past, value]),
            present: ""
          };
        case "remove":
          prev = compact(past.filter((v) => v !== value));
          present = "";
          if (prev.length) {
            present = prev.pop();
          }
          return {
            past: prev,
            present
          };
        default: {
          throw new Error(`Invalid action: "${action}"`);
        }
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\input.js
  var require_input = __commonJS((exports2, module2) => {
    "use strict";
    var Prompt = require_string2();
    var completer = require_completer();
    var Input = class extends Prompt {
      constructor(options) {
        super(options);
        let history = this.options.history;
        if (history && history.store) {
          let initial = history.values || this.initial;
          this.autosave = !!history.autosave;
          this.store = history.store;
          this.data = this.store.get("values") || {past: [], present: initial};
          this.initial = this.data.present || this.data.past[this.data.past.length - 1];
        }
      }
      completion(action) {
        if (!this.store)
          return this.alert();
        this.data = completer(action, this.data, this.input);
        if (!this.data.present)
          return this.alert();
        this.input = this.data.present;
        this.cursor = this.input.length;
        return this.render();
      }
      altUp() {
        return this.completion("prev");
      }
      altDown() {
        return this.completion("next");
      }
      prev() {
        this.save();
        return super.prev();
      }
      save() {
        if (!this.store)
          return;
        this.data = completer("save", this.data, this.input);
        this.store.set("values", this.data);
      }
      submit() {
        if (this.store && this.autosave === true) {
          this.save();
        }
        return super.submit();
      }
    };
    module2.exports = Input;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\invisible.js
  var require_invisible = __commonJS((exports2, module2) => {
    "use strict";
    var StringPrompt = require_string2();
    var InvisiblePrompt = class extends StringPrompt {
      format() {
        return "";
      }
    };
    module2.exports = InvisiblePrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\list.js
  var require_list2 = __commonJS((exports2, module2) => {
    "use strict";
    var StringPrompt = require_string2();
    var ListPrompt = class extends StringPrompt {
      constructor(options = {}) {
        super(options);
        this.sep = this.options.separator || /, */;
        this.initial = options.initial || "";
      }
      split(input = this.value) {
        return input ? String(input).split(this.sep) : [];
      }
      format() {
        let style = this.state.submitted ? this.styles.primary : (val) => val;
        return this.list.map(style).join(", ");
      }
      async submit(value) {
        let result = this.state.error || await this.validate(this.list, this.state);
        if (result !== true) {
          this.state.error = result;
          return super.submit();
        }
        this.value = this.list;
        return super.submit();
      }
      get list() {
        return this.split();
      }
    };
    module2.exports = ListPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\multiselect.js
  var require_multiselect = __commonJS((exports2, module2) => {
    "use strict";
    var Select = require_select();
    var MultiSelect = class extends Select {
      constructor(options) {
        super({...options, multiple: true});
      }
    };
    module2.exports = MultiSelect;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\number.js
  var require_number = __commonJS((exports2, module2) => {
    "use strict";
    var StringPrompt = require_string2();
    var NumberPrompt = class extends StringPrompt {
      constructor(options = {}) {
        super({style: "number", ...options});
        this.min = this.isValue(options.min) ? this.toNumber(options.min) : -Infinity;
        this.max = this.isValue(options.max) ? this.toNumber(options.max) : Infinity;
        this.delay = options.delay != null ? options.delay : 1e3;
        this.float = options.float !== false;
        this.round = options.round === true || options.float === false;
        this.major = options.major || 10;
        this.minor = options.minor || 1;
        this.initial = options.initial != null ? options.initial : "";
        this.input = String(this.initial);
        this.cursor = this.input.length;
        this.cursorShow();
      }
      append(ch) {
        if (!/[-+.]/.test(ch) || ch === "." && this.input.includes(".")) {
          return this.alert("invalid number");
        }
        return super.append(ch);
      }
      number(ch) {
        return super.append(ch);
      }
      next() {
        if (this.input && this.input !== this.initial)
          return this.alert();
        if (!this.isValue(this.initial))
          return this.alert();
        this.input = this.initial;
        this.cursor = String(this.initial).length;
        return this.render();
      }
      up(number) {
        let step = number || this.minor;
        let num = this.toNumber(this.input);
        if (num > this.max + step)
          return this.alert();
        this.input = `${num + step}`;
        return this.render();
      }
      down(number) {
        let step = number || this.minor;
        let num = this.toNumber(this.input);
        if (num < this.min - step)
          return this.alert();
        this.input = `${num - step}`;
        return this.render();
      }
      shiftDown() {
        return this.down(this.major);
      }
      shiftUp() {
        return this.up(this.major);
      }
      format(input = this.input) {
        if (typeof this.options.format === "function") {
          return this.options.format.call(this, input);
        }
        return this.styles.info(input);
      }
      toNumber(value = "") {
        return this.float ? +value : Math.round(+value);
      }
      isValue(value) {
        return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
      }
      submit() {
        let value = [this.input, this.initial].find((v) => this.isValue(v));
        this.value = this.toNumber(value || 0);
        return super.submit();
      }
    };
    module2.exports = NumberPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\numeral.js
  var require_numeral = __commonJS((exports2, module2) => {
    module2.exports = require_number();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\password.js
  var require_password = __commonJS((exports2, module2) => {
    "use strict";
    var StringPrompt = require_string2();
    var PasswordPrompt = class extends StringPrompt {
      constructor(options) {
        super(options);
        this.cursorShow();
      }
      format(input = this.input) {
        if (!this.keypressed)
          return "";
        let color = this.state.submitted ? this.styles.primary : this.styles.muted;
        return color(this.symbols.asterisk.repeat(input.length));
      }
    };
    module2.exports = PasswordPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\scale.js
  var require_scale = __commonJS((exports2, module2) => {
    "use strict";
    var colors2 = require_ansi_colors();
    var ArrayPrompt = require_array4();
    var utils = require_utils5();
    var LikertScale = class extends ArrayPrompt {
      constructor(options = {}) {
        super(options);
        this.widths = [].concat(options.messageWidth || 50);
        this.align = [].concat(options.align || "left");
        this.linebreak = options.linebreak || false;
        this.edgeLength = options.edgeLength || 3;
        this.newline = options.newline || "\n   ";
        let start2 = options.startNumber || 1;
        if (typeof this.scale === "number") {
          this.scaleKey = false;
          this.scale = Array(this.scale).fill(0).map((v, i) => ({name: i + start2}));
        }
      }
      async reset() {
        this.tableized = false;
        await super.reset();
        return this.render();
      }
      tableize() {
        if (this.tableized === true)
          return;
        this.tableized = true;
        let longest = 0;
        for (let ch of this.choices) {
          longest = Math.max(longest, ch.message.length);
          ch.scaleIndex = ch.initial || 2;
          ch.scale = [];
          for (let i = 0; i < this.scale.length; i++) {
            ch.scale.push({index: i});
          }
        }
        this.widths[0] = Math.min(this.widths[0], longest + 3);
      }
      async dispatch(s, key) {
        if (this.multiple) {
          return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
        }
        this.alert();
      }
      heading(msg, item, i) {
        return this.styles.strong(msg);
      }
      separator() {
        return this.styles.muted(this.symbols.ellipsis);
      }
      right() {
        let choice = this.focused;
        if (choice.scaleIndex >= this.scale.length - 1)
          return this.alert();
        choice.scaleIndex++;
        return this.render();
      }
      left() {
        let choice = this.focused;
        if (choice.scaleIndex <= 0)
          return this.alert();
        choice.scaleIndex--;
        return this.render();
      }
      indent() {
        return "";
      }
      format() {
        if (this.state.submitted) {
          let values = this.choices.map((ch) => this.styles.info(ch.index));
          return values.join(", ");
        }
        return "";
      }
      pointer() {
        return "";
      }
      renderScaleKey() {
        if (this.scaleKey === false)
          return "";
        if (this.state.submitted)
          return "";
        let scale = this.scale.map((item) => `   ${item.name} - ${item.message}`);
        let key = ["", ...scale].map((item) => this.styles.muted(item));
        return key.join("\n");
      }
      renderScaleHeading(max) {
        let keys = this.scale.map((ele) => ele.name);
        if (typeof this.options.renderScaleHeading === "function") {
          keys = this.options.renderScaleHeading.call(this, max);
        }
        let diff = this.scaleLength - keys.join("").length;
        let spacing = Math.round(diff / (keys.length - 1));
        let names = keys.map((key) => this.styles.strong(key));
        let headings = names.join(" ".repeat(spacing));
        let padding = " ".repeat(this.widths[0]);
        return this.margin[3] + padding + this.margin[1] + headings;
      }
      scaleIndicator(choice, item, i) {
        if (typeof this.options.scaleIndicator === "function") {
          return this.options.scaleIndicator.call(this, choice, item, i);
        }
        let enabled = choice.scaleIndex === item.index;
        if (item.disabled)
          return this.styles.hint(this.symbols.radio.disabled);
        if (enabled)
          return this.styles.success(this.symbols.radio.on);
        return this.symbols.radio.off;
      }
      renderScale(choice, i) {
        let scale = choice.scale.map((item) => this.scaleIndicator(choice, item, i));
        let padding = this.term === "Hyper" ? "" : " ";
        return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
      }
      async renderChoice(choice, i) {
        await this.onChoice(choice, i);
        let focused = this.index === i;
        let pointer = await this.pointer(choice, i);
        let hint = await choice.hint;
        if (hint && !utils.hasColor(hint)) {
          hint = this.styles.muted(hint);
        }
        let pad = (str) => this.margin[3] + str.replace(/\s+$/, "").padEnd(this.widths[0], " ");
        let newline = this.newline;
        let ind = this.indent(choice);
        let message = await this.resolve(choice.message, this.state, choice, i);
        let scale = await this.renderScale(choice, i);
        let margin = this.margin[1] + this.margin[3];
        this.scaleLength = colors2.unstyle(scale).length;
        this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
        let msg = utils.wordWrap(message, {width: this.widths[0], newline});
        let lines = msg.split("\n").map((line) => pad(line) + this.margin[1]);
        if (focused) {
          scale = this.styles.info(scale);
          lines = lines.map((line) => this.styles.info(line));
        }
        lines[0] += scale;
        if (this.linebreak)
          lines.push("");
        return [ind + pointer, lines.join("\n")].filter(Boolean);
      }
      async renderChoices() {
        if (this.state.submitted)
          return "";
        this.tableize();
        let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
        let visible = await Promise.all(choices);
        let heading = await this.renderScaleHeading();
        return this.margin[0] + [heading, ...visible.map((v) => v.join(" "))].join("\n");
      }
      async render() {
        let {submitted, size} = this.state;
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        let prompt9 = "";
        if (this.options.promptLine !== false) {
          prompt9 = [prefix, message, separator, ""].join(" ");
          this.state.prompt = prompt9;
        }
        let header = await this.header();
        let output = await this.format();
        let key = await this.renderScaleKey();
        let help = await this.error() || await this.hint();
        let body = await this.renderChoices();
        let footer = await this.footer();
        let err = this.emptyError;
        if (output)
          prompt9 += output;
        if (help && !prompt9.includes(help))
          prompt9 += " " + help;
        if (submitted && !output && !body.trim() && this.multiple && err != null) {
          prompt9 += this.styles.danger(err);
        }
        this.clear(size);
        this.write([header, prompt9, key, body, footer].filter(Boolean).join("\n"));
        if (!this.state.submitted) {
          this.write(this.margin[2]);
        }
        this.restore();
      }
      submit() {
        this.value = {};
        for (let choice of this.choices) {
          this.value[choice.name] = choice.scaleIndex;
        }
        return this.base.submit.call(this);
      }
    };
    module2.exports = LikertScale;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\interpolate.js
  var require_interpolate = __commonJS((exports2, module2) => {
    "use strict";
    var colors2 = require_ansi_colors();
    var clean3 = (str = "") => {
      return typeof str === "string" ? str.replace(/^['"]|['"]$/g, "") : "";
    };
    var Item = class {
      constructor(token) {
        this.name = token.key;
        this.field = token.field || {};
        this.value = clean3(token.initial || this.field.initial || "");
        this.message = token.message || this.name;
        this.cursor = 0;
        this.input = "";
        this.lines = [];
      }
    };
    var tokenize = async (options = {}, defaults = {}, fn = (token) => token) => {
      let unique = new Set();
      let fields = options.fields || [];
      let input = options.template;
      let tabstops = [];
      let items = [];
      let keys = [];
      let line = 1;
      if (typeof input === "function") {
        input = await input();
      }
      let i = -1;
      let next = () => input[++i];
      let peek = () => input[i + 1];
      let push = (token) => {
        token.line = line;
        tabstops.push(token);
      };
      push({type: "bos", value: ""});
      while (i < input.length - 1) {
        let value = next();
        if (/^[^\S\n ]$/.test(value)) {
          push({type: "text", value});
          continue;
        }
        if (value === "\n") {
          push({type: "newline", value});
          line++;
          continue;
        }
        if (value === "\\") {
          value += next();
          push({type: "text", value});
          continue;
        }
        if ((value === "$" || value === "#" || value === "{") && peek() === "{") {
          let n = next();
          value += n;
          let token = {type: "template", open: value, inner: "", close: "", value};
          let ch;
          while (ch = next()) {
            if (ch === "}") {
              if (peek() === "}")
                ch += next();
              token.value += ch;
              token.close = ch;
              break;
            }
            if (ch === ":") {
              token.initial = "";
              token.key = token.inner;
            } else if (token.initial !== void 0) {
              token.initial += ch;
            }
            token.value += ch;
            token.inner += ch;
          }
          token.template = token.open + (token.initial || token.inner) + token.close;
          token.key = token.key || token.inner;
          if (defaults.hasOwnProperty(token.key)) {
            token.initial = defaults[token.key];
          }
          token = fn(token);
          push(token);
          keys.push(token.key);
          unique.add(token.key);
          let item = items.find((item2) => item2.name === token.key);
          token.field = fields.find((ch2) => ch2.name === token.key);
          if (!item) {
            item = new Item(token);
            items.push(item);
          }
          item.lines.push(token.line - 1);
          continue;
        }
        let last = tabstops[tabstops.length - 1];
        if (last.type === "text" && last.line === line) {
          last.value += value;
        } else {
          push({type: "text", value});
        }
      }
      push({type: "eos", value: ""});
      return {input, tabstops, unique, keys, items};
    };
    module2.exports = async (prompt9) => {
      let options = prompt9.options;
      let required = new Set(options.required === true ? [] : options.required || []);
      let defaults = {...options.values, ...options.initial};
      let {tabstops, items, keys} = await tokenize(options, defaults);
      let result = createFn("result", prompt9, options);
      let format = createFn("format", prompt9, options);
      let isValid = createFn("validate", prompt9, options, true);
      let isVal = prompt9.isValue.bind(prompt9);
      return async (state = {}, submitted = false) => {
        let index = 0;
        state.required = required;
        state.items = items;
        state.keys = keys;
        state.output = "";
        let validate = async (value, state2, item, index2) => {
          let error = await isValid(value, state2, item, index2);
          if (error === false) {
            return "Invalid field " + item.name;
          }
          return error;
        };
        for (let token of tabstops) {
          let value = token.value;
          let key = token.key;
          if (token.type !== "template") {
            if (value)
              state.output += value;
            continue;
          }
          if (token.type === "template") {
            let item = items.find((ch) => ch.name === key);
            if (options.required === true) {
              state.required.add(item.name);
            }
            let val = [item.input, state.values[item.value], item.value, value].find(isVal);
            let field = item.field || {};
            let message = field.message || token.inner;
            if (submitted) {
              let error = await validate(state.values[key], state, item, index);
              if (error && typeof error === "string" || error === false) {
                state.invalid.set(key, error);
                continue;
              }
              state.invalid.delete(key);
              let res = await result(state.values[key], state, item, index);
              state.output += colors2.unstyle(res);
              continue;
            }
            item.placeholder = false;
            let before = value;
            value = await format(value, state, item, index);
            if (val !== value) {
              state.values[key] = val;
              value = prompt9.styles.typing(val);
              state.missing.delete(message);
            } else {
              state.values[key] = void 0;
              val = `<${message}>`;
              value = prompt9.styles.primary(val);
              item.placeholder = true;
              if (state.required.has(key)) {
                state.missing.add(message);
              }
            }
            if (state.missing.has(message) && state.validating) {
              value = prompt9.styles.warning(val);
            }
            if (state.invalid.has(key) && state.validating) {
              value = prompt9.styles.danger(val);
            }
            if (index === state.index) {
              if (before !== value) {
                value = prompt9.styles.underline(value);
              } else {
                value = prompt9.styles.heading(colors2.unstyle(value));
              }
            }
            index++;
          }
          if (value) {
            state.output += value;
          }
        }
        let lines = state.output.split("\n").map((l) => " " + l);
        let len = items.length;
        let done = 0;
        for (let item of items) {
          if (state.invalid.has(item.name)) {
            item.lines.forEach((i) => {
              if (lines[i][0] !== " ")
                return;
              lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
            });
          }
          if (prompt9.isValue(state.values[item.name])) {
            done++;
          }
        }
        state.completed = (done / len * 100).toFixed(0);
        state.output = lines.join("\n");
        return state.output;
      };
    };
    function createFn(prop, prompt9, options, fallback) {
      return (value, state, item, index) => {
        if (typeof item.field[prop] === "function") {
          return item.field[prop].call(prompt9, value, state, item, index);
        }
        return [fallback, value].find((v) => prompt9.isValue(v));
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\snippet.js
  var require_snippet = __commonJS((exports2, module2) => {
    "use strict";
    var colors2 = require_ansi_colors();
    var interpolate = require_interpolate();
    var Prompt = require_prompt();
    var SnippetPrompt = class extends Prompt {
      constructor(options) {
        super(options);
        this.cursorHide();
        this.reset(true);
      }
      async initialize() {
        this.interpolate = await interpolate(this);
        await super.initialize();
      }
      async reset(first) {
        this.state.keys = [];
        this.state.invalid = new Map();
        this.state.missing = new Set();
        this.state.completed = 0;
        this.state.values = {};
        if (first !== true) {
          await this.initialize();
          await this.render();
        }
      }
      moveCursor(n) {
        let item = this.getItem();
        this.cursor += n;
        item.cursor += n;
      }
      dispatch(ch, key) {
        if (!key.code && !key.ctrl && ch != null && this.getItem()) {
          this.append(ch, key);
          return;
        }
        this.alert();
      }
      append(ch, key) {
        let item = this.getItem();
        let prefix = item.input.slice(0, this.cursor);
        let suffix = item.input.slice(this.cursor);
        this.input = item.input = `${prefix}${ch}${suffix}`;
        this.moveCursor(1);
        this.render();
      }
      delete() {
        let item = this.getItem();
        if (this.cursor <= 0 || !item.input)
          return this.alert();
        let suffix = item.input.slice(this.cursor);
        let prefix = item.input.slice(0, this.cursor - 1);
        this.input = item.input = `${prefix}${suffix}`;
        this.moveCursor(-1);
        this.render();
      }
      increment(i) {
        return i >= this.state.keys.length - 1 ? 0 : i + 1;
      }
      decrement(i) {
        return i <= 0 ? this.state.keys.length - 1 : i - 1;
      }
      first() {
        this.state.index = 0;
        this.render();
      }
      last() {
        this.state.index = this.state.keys.length - 1;
        this.render();
      }
      right() {
        if (this.cursor >= this.input.length)
          return this.alert();
        this.moveCursor(1);
        this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.alert();
        this.moveCursor(-1);
        this.render();
      }
      prev() {
        this.state.index = this.decrement(this.state.index);
        this.getItem();
        this.render();
      }
      next() {
        this.state.index = this.increment(this.state.index);
        this.getItem();
        this.render();
      }
      up() {
        this.prev();
      }
      down() {
        this.next();
      }
      format(value) {
        let color = this.state.completed < 100 ? this.styles.warning : this.styles.success;
        if (this.state.submitted === true && this.state.completed !== 100) {
          color = this.styles.danger;
        }
        return color(`${this.state.completed}% completed`);
      }
      async render() {
        let {index, keys = [], submitted, size} = this.state;
        let newline = [this.options.newline, "\n"].find((v) => v != null);
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        let prompt9 = [prefix, message, separator].filter(Boolean).join(" ");
        this.state.prompt = prompt9;
        let header = await this.header();
        let error = await this.error() || "";
        let hint = await this.hint() || "";
        let body = submitted ? "" : await this.interpolate(this.state);
        let key = this.state.key = keys[index] || "";
        let input = await this.format(key);
        let footer = await this.footer();
        if (input)
          prompt9 += " " + input;
        if (hint && !input && this.state.completed === 0)
          prompt9 += " " + hint;
        this.clear(size);
        let lines = [header, prompt9, body, footer, error.trim()];
        this.write(lines.filter(Boolean).join(newline));
        this.restore();
      }
      getItem(name) {
        let {items, keys, index} = this.state;
        let item = items.find((ch) => ch.name === keys[index]);
        if (item && item.input != null) {
          this.input = item.input;
          this.cursor = item.cursor;
        }
        return item;
      }
      async submit() {
        if (typeof this.interpolate !== "function")
          await this.initialize();
        await this.interpolate(this.state, true);
        let {invalid, missing, output, values} = this.state;
        if (invalid.size) {
          let err = "";
          for (let [key, value] of invalid)
            err += `Invalid ${key}: ${value}
`;
          this.state.error = err;
          return super.submit();
        }
        if (missing.size) {
          this.state.error = "Required: " + [...missing.keys()].join(", ");
          return super.submit();
        }
        let lines = colors2.unstyle(output).split("\n");
        let result = lines.map((v) => v.slice(1)).join("\n");
        this.value = {values, result};
        return super.submit();
      }
    };
    module2.exports = SnippetPrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\sort.js
  var require_sort2 = __commonJS((exports2, module2) => {
    "use strict";
    var hint = "(Use <shift>+<up/down> to sort)";
    var Prompt = require_select();
    var Sort = class extends Prompt {
      constructor(options) {
        super({...options, reorder: false, sort: true, multiple: true});
        this.state.hint = [this.options.hint, hint].find(this.isValue.bind(this));
      }
      indicator() {
        return "";
      }
      async renderChoice(choice, i) {
        let str = await super.renderChoice(choice, i);
        let sym = this.symbols.identicalTo + " ";
        let pre = this.index === i && this.sorting ? this.styles.muted(sym) : "  ";
        if (this.options.drag === false)
          pre = "";
        if (this.options.numbered === true) {
          return pre + `${i + 1} - ` + str;
        }
        return pre + str;
      }
      get selected() {
        return this.choices;
      }
      submit() {
        this.value = this.choices.map((choice) => choice.value);
        return super.submit();
      }
    };
    module2.exports = Sort;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\survey.js
  var require_survey = __commonJS((exports2, module2) => {
    "use strict";
    var ArrayPrompt = require_array4();
    var Survey = class extends ArrayPrompt {
      constructor(options = {}) {
        super(options);
        this.emptyError = options.emptyError || "No items were selected";
        this.term = process.env.TERM_PROGRAM;
        if (!this.options.header) {
          let header = ["", "4 - Strongly Agree", "3 - Agree", "2 - Neutral", "1 - Disagree", "0 - Strongly Disagree", ""];
          header = header.map((ele) => this.styles.muted(ele));
          this.state.header = header.join("\n   ");
        }
      }
      async toChoices(...args) {
        if (this.createdScales)
          return false;
        this.createdScales = true;
        let choices = await super.toChoices(...args);
        for (let choice of choices) {
          choice.scale = createScale(5, this.options);
          choice.scaleIdx = 2;
        }
        return choices;
      }
      dispatch() {
        this.alert();
      }
      space() {
        let choice = this.focused;
        let ele = choice.scale[choice.scaleIdx];
        let selected = ele.selected;
        choice.scale.forEach((e) => e.selected = false);
        ele.selected = !selected;
        return this.render();
      }
      indicator() {
        return "";
      }
      pointer() {
        return "";
      }
      separator() {
        return this.styles.muted(this.symbols.ellipsis);
      }
      right() {
        let choice = this.focused;
        if (choice.scaleIdx >= choice.scale.length - 1)
          return this.alert();
        choice.scaleIdx++;
        return this.render();
      }
      left() {
        let choice = this.focused;
        if (choice.scaleIdx <= 0)
          return this.alert();
        choice.scaleIdx--;
        return this.render();
      }
      indent() {
        return "   ";
      }
      async renderChoice(item, i) {
        await this.onChoice(item, i);
        let focused = this.index === i;
        let isHyper = this.term === "Hyper";
        let n = !isHyper ? 8 : 9;
        let s = !isHyper ? " " : "";
        let ln = this.symbols.line.repeat(n);
        let sp = " ".repeat(n + (isHyper ? 0 : 1));
        let dot = (enabled) => (enabled ? this.styles.success("\u25C9") : "\u25EF") + s;
        let num = i + 1 + ".";
        let color = focused ? this.styles.heading : this.styles.noop;
        let msg = await this.resolve(item.message, this.state, item, i);
        let indent = this.indent(item);
        let scale = indent + item.scale.map((e, i2) => dot(i2 === item.scaleIdx)).join(ln);
        let val = (i2) => i2 === item.scaleIdx ? color(i2) : i2;
        let next = indent + item.scale.map((e, i2) => val(i2)).join(sp);
        let line = () => [num, msg].filter(Boolean).join(" ");
        let lines = () => [line(), scale, next, " "].filter(Boolean).join("\n");
        if (focused) {
          scale = this.styles.cyan(scale);
          next = this.styles.cyan(next);
        }
        return lines();
      }
      async renderChoices() {
        if (this.state.submitted)
          return "";
        let choices = this.visible.map(async (ch, i) => await this.renderChoice(ch, i));
        let visible = await Promise.all(choices);
        if (!visible.length)
          visible.push(this.styles.danger("No matching choices"));
        return visible.join("\n");
      }
      format() {
        if (this.state.submitted) {
          let values = this.choices.map((ch) => this.styles.info(ch.scaleIdx));
          return values.join(", ");
        }
        return "";
      }
      async render() {
        let {submitted, size} = this.state;
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        let prompt9 = [prefix, message, separator].filter(Boolean).join(" ");
        this.state.prompt = prompt9;
        let header = await this.header();
        let output = await this.format();
        let help = await this.error() || await this.hint();
        let body = await this.renderChoices();
        let footer = await this.footer();
        if (output || !help)
          prompt9 += " " + output;
        if (help && !prompt9.includes(help))
          prompt9 += " " + help;
        if (submitted && !output && !body && this.multiple && this.type !== "form") {
          prompt9 += this.styles.danger(this.emptyError);
        }
        this.clear(size);
        this.write([prompt9, header, body, footer].filter(Boolean).join("\n"));
        this.restore();
      }
      submit() {
        this.value = {};
        for (let choice of this.choices) {
          this.value[choice.name] = choice.scaleIdx;
        }
        return this.base.submit.call(this);
      }
    };
    function createScale(n, options = {}) {
      if (Array.isArray(options.scale)) {
        return options.scale.map((ele) => ({...ele}));
      }
      let scale = [];
      for (let i = 1; i < n + 1; i++)
        scale.push({i, selected: false});
      return scale;
    }
    module2.exports = Survey;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\text.js
  var require_text = __commonJS((exports2, module2) => {
    module2.exports = require_input();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\toggle.js
  var require_toggle = __commonJS((exports2, module2) => {
    "use strict";
    var BooleanPrompt = require_boolean();
    var TogglePrompt = class extends BooleanPrompt {
      async initialize() {
        await super.initialize();
        this.value = this.initial = !!this.options.initial;
        this.disabled = this.options.disabled || "no";
        this.enabled = this.options.enabled || "yes";
        await this.render();
      }
      reset() {
        this.value = this.initial;
        this.render();
      }
      delete() {
        this.alert();
      }
      toggle() {
        this.value = !this.value;
        this.render();
      }
      enable() {
        if (this.value === true)
          return this.alert();
        this.value = true;
        this.render();
      }
      disable() {
        if (this.value === false)
          return this.alert();
        this.value = false;
        this.render();
      }
      up() {
        this.toggle();
      }
      down() {
        this.toggle();
      }
      right() {
        this.toggle();
      }
      left() {
        this.toggle();
      }
      next() {
        this.toggle();
      }
      prev() {
        this.toggle();
      }
      dispatch(ch = "", key) {
        switch (ch.toLowerCase()) {
          case " ":
            return this.toggle();
          case "1":
          case "y":
          case "t":
            return this.enable();
          case "0":
          case "n":
          case "f":
            return this.disable();
          default: {
            return this.alert();
          }
        }
      }
      format() {
        let active = (str) => this.styles.primary.underline(str);
        let value = [
          this.value ? this.disabled : active(this.disabled),
          this.value ? active(this.enabled) : this.enabled
        ];
        return value.join(this.styles.muted(" / "));
      }
      async render() {
        let {size} = this.state;
        let header = await this.header();
        let prefix = await this.prefix();
        let separator = await this.separator();
        let message = await this.message();
        let output = await this.format();
        let help = await this.error() || await this.hint();
        let footer = await this.footer();
        let prompt9 = [prefix, message, separator, output].join(" ");
        this.state.prompt = prompt9;
        if (help && !prompt9.includes(help))
          prompt9 += " " + help;
        this.clear(size);
        this.write([header, prompt9, footer].filter(Boolean).join("\n"));
        this.write(this.margin[2]);
        this.restore();
      }
    };
    module2.exports = TogglePrompt;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\quiz.js
  var require_quiz = __commonJS((exports2, module2) => {
    "use strict";
    var SelectPrompt = require_select();
    var Quiz = class extends SelectPrompt {
      constructor(options) {
        super(options);
        if (typeof this.options.correctChoice !== "number" || this.options.correctChoice < 0) {
          throw new Error("Please specify the index of the correct answer from the list of choices");
        }
      }
      async toChoices(value, parent) {
        let choices = await super.toChoices(value, parent);
        if (choices.length < 2) {
          throw new Error("Please give at least two choices to the user");
        }
        if (this.options.correctChoice > choices.length) {
          throw new Error("Please specify the index of the correct answer from the list of choices");
        }
        return choices;
      }
      check(state) {
        return state.index === this.options.correctChoice;
      }
      async result(selected) {
        return {
          selectedAnswer: selected,
          correctAnswer: this.options.choices[this.options.correctChoice].value,
          correct: await this.check(this.state)
        };
      }
    };
    module2.exports = Quiz;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\prompts\index.js
  var require_prompts = __commonJS((exports2) => {
    "use strict";
    var utils = require_utils5();
    var define2 = (key, fn) => {
      utils.defineExport(exports2, key, fn);
      utils.defineExport(exports2, key.toLowerCase(), fn);
    };
    define2("AutoComplete", () => require_autocomplete());
    define2("BasicAuth", () => require_basicauth());
    define2("Confirm", () => require_confirm());
    define2("Editable", () => require_editable());
    define2("Form", () => require_form());
    define2("Input", () => require_input());
    define2("Invisible", () => require_invisible());
    define2("List", () => require_list2());
    define2("MultiSelect", () => require_multiselect());
    define2("Numeral", () => require_numeral());
    define2("Password", () => require_password());
    define2("Scale", () => require_scale());
    define2("Select", () => require_select());
    define2("Snippet", () => require_snippet());
    define2("Sort", () => require_sort2());
    define2("Survey", () => require_survey());
    define2("Text", () => require_text());
    define2("Toggle", () => require_toggle());
    define2("Quiz", () => require_quiz());
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\lib\types\index.js
  var require_types4 = __commonJS((exports2, module2) => {
    module2.exports = {
      ArrayPrompt: require_array4(),
      AuthPrompt: require_auth(),
      BooleanPrompt: require_boolean(),
      NumberPrompt: require_number(),
      StringPrompt: require_string2()
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\enquirer-npm-2.3.6-7899175762-e249bb97bf.zip\node_modules\enquirer\index.js
  var require_enquirer = __commonJS((exports2, module2) => {
    "use strict";
    var assert = require("assert");
    var Events = require("events");
    var utils = require_utils5();
    var Enquirer = class extends Events {
      constructor(options, answers) {
        super();
        this.options = utils.merge({}, options);
        this.answers = {...answers};
      }
      register(type, fn) {
        if (utils.isObject(type)) {
          for (let key of Object.keys(type))
            this.register(key, type[key]);
          return this;
        }
        assert.equal(typeof fn, "function", "expected a function");
        let name = type.toLowerCase();
        if (fn.prototype instanceof this.Prompt) {
          this.prompts[name] = fn;
        } else {
          this.prompts[name] = fn(this.Prompt, this);
        }
        return this;
      }
      async prompt(questions = []) {
        for (let question of [].concat(questions)) {
          try {
            if (typeof question === "function")
              question = await question.call(this);
            await this.ask(utils.merge({}, this.options, question));
          } catch (err) {
            return Promise.reject(err);
          }
        }
        return this.answers;
      }
      async ask(question) {
        if (typeof question === "function") {
          question = await question.call(this);
        }
        let opts = utils.merge({}, this.options, question);
        let {type, name} = question;
        let {set, get: get4} = utils;
        if (typeof type === "function") {
          type = await type.call(this, question, this.answers);
        }
        if (!type)
          return this.answers[name];
        assert(this.prompts[type], `Prompt "${type}" is not registered`);
        let prompt9 = new this.prompts[type](opts);
        let value = get4(this.answers, name);
        prompt9.state.answers = this.answers;
        prompt9.enquirer = this;
        if (name) {
          prompt9.on("submit", (value2) => {
            this.emit("answer", name, value2, prompt9);
            set(this.answers, name, value2);
          });
        }
        let emit = prompt9.emit.bind(prompt9);
        prompt9.emit = (...args) => {
          this.emit.call(this, ...args);
          return emit(...args);
        };
        this.emit("prompt", prompt9, this);
        if (opts.autofill && value != null) {
          prompt9.value = prompt9.input = value;
          if (opts.autofill === "show") {
            await prompt9.submit();
          }
        } else {
          value = prompt9.value = await prompt9.run();
        }
        return value;
      }
      use(plugin23) {
        plugin23.call(this, this);
        return this;
      }
      set Prompt(value) {
        this._Prompt = value;
      }
      get Prompt() {
        return this._Prompt || this.constructor.Prompt;
      }
      get prompts() {
        return this.constructor.prompts;
      }
      static set Prompt(value) {
        this._Prompt = value;
      }
      static get Prompt() {
        return this._Prompt || require_prompt();
      }
      static get prompts() {
        return require_prompts();
      }
      static get types() {
        return require_types4();
      }
      static get prompt() {
        const fn = (questions, ...rest) => {
          let enquirer = new this(...rest);
          let emit = enquirer.emit.bind(enquirer);
          enquirer.emit = (...args) => {
            fn.emit(...args);
            return emit(...args);
          };
          return enquirer.prompt(questions);
        };
        utils.mixinEmitter(fn, new Events());
        return fn;
      }
    };
    utils.mixinEmitter(Enquirer, new Events());
    var prompts = Enquirer.prompts;
    for (let name of Object.keys(prompts)) {
      let key = name.toLowerCase();
      let run = (options) => new prompts[name](options).run();
      Enquirer.prompt[key] = run;
      Enquirer[key] = run;
      if (!Enquirer[name]) {
        Reflect.defineProperty(Enquirer, name, {get: () => prompts[name]});
      }
    }
    var exp = (name) => {
      utils.defineExport(Enquirer, name, () => Enquirer.types[name]);
    };
    exp("ArrayPrompt");
    exp("AuthPrompt");
    exp("BooleanPrompt");
    exp("NumberPrompt");
    exp("StringPrompt");
    module2.exports = Enquirer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\get.js
  var require_get = __commonJS((exports2, module2) => {
    var baseGet = require_baseGet();
    function get4(object, path6, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path6);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get4;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stackClear.js
  var require_stackClear = __commonJS((exports2, module2) => {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stackDelete.js
  var require_stackDelete = __commonJS((exports2, module2) => {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stackGet.js
  var require_stackGet = __commonJS((exports2, module2) => {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stackHas.js
  var require_stackHas = __commonJS((exports2, module2) => {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_stackSet.js
  var require_stackSet = __commonJS((exports2, module2) => {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Stack.js
  var require_Stack = __commonJS((exports2, module2) => {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_arrayEach.js
  var require_arrayEach = __commonJS((exports2, module2) => {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_copyObject.js
  var require_copyObject = __commonJS((exports2, module2) => {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseTimes.js
  var require_baseTimes = __commonJS((exports2, module2) => {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\stubFalse.js
  var require_stubFalse = __commonJS((exports2, module2) => {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isBuffer.js
  var require_isBuffer = __commonJS((exports2, module2) => {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS((exports2, module2) => {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseUnary.js
  var require_baseUnary = __commonJS((exports2, module2) => {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_nodeUtil.js
  var require_nodeUtil = __commonJS((exports2, module2) => {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isTypedArray.js
  var require_isTypedArray = __commonJS((exports2, module2) => {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS((exports2, module2) => {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isPrototype.js
  var require_isPrototype = __commonJS((exports2, module2) => {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_overArg.js
  var require_overArg = __commonJS((exports2, module2) => {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_nativeKeys.js
  var require_nativeKeys = __commonJS((exports2, module2) => {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseKeys.js
  var require_baseKeys = __commonJS((exports2, module2) => {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isArrayLike.js
  var require_isArrayLike = __commonJS((exports2, module2) => {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\keys.js
  var require_keys = __commonJS((exports2, module2) => {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseAssign.js
  var require_baseAssign = __commonJS((exports2, module2) => {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS((exports2, module2) => {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseKeysIn.js
  var require_baseKeysIn = __commonJS((exports2, module2) => {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\keysIn.js
  var require_keysIn = __commonJS((exports2, module2) => {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseAssignIn.js
  var require_baseAssignIn = __commonJS((exports2, module2) => {
    var copyObject = require_copyObject();
    var keysIn2 = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn2(source), object);
    }
    module2.exports = baseAssignIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneBuffer.js
  var require_cloneBuffer = __commonJS((exports2, module2) => {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_copyArray.js
  var require_copyArray = __commonJS((exports2, module2) => {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_arrayFilter.js
  var require_arrayFilter = __commonJS((exports2, module2) => {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\stubArray.js
  var require_stubArray = __commonJS((exports2, module2) => {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getSymbols.js
  var require_getSymbols = __commonJS((exports2, module2) => {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_copySymbols.js
  var require_copySymbols = __commonJS((exports2, module2) => {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getPrototype.js
  var require_getPrototype = __commonJS((exports2, module2) => {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS((exports2, module2) => {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS((exports2, module2) => {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS((exports2, module2) => {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getAllKeys.js
  var require_getAllKeys = __commonJS((exports2, module2) => {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS((exports2, module2) => {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn2 = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn2, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_DataView.js
  var require_DataView = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Promise.js
  var require_Promise = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Set.js
  var require_Set = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_WeakMap.js
  var require_WeakMap = __commonJS((exports2, module2) => {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_getTag.js
  var require_getTag = __commonJS((exports2, module2) => {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_initCloneArray.js
  var require_initCloneArray = __commonJS((exports2, module2) => {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_Uint8Array.js
  var require_Uint8Array = __commonJS((exports2, module2) => {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS((exports2, module2) => {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneDataView.js
  var require_cloneDataView = __commonJS((exports2, module2) => {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneRegExp.js
  var require_cloneRegExp = __commonJS((exports2, module2) => {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneSymbol.js
  var require_cloneSymbol = __commonJS((exports2, module2) => {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS((exports2, module2) => {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_initCloneByTag.js
  var require_initCloneByTag = __commonJS((exports2, module2) => {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseCreate.js
  var require_baseCreate = __commonJS((exports2, module2) => {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_initCloneObject.js
  var require_initCloneObject = __commonJS((exports2, module2) => {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseIsMap.js
  var require_baseIsMap = __commonJS((exports2, module2) => {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isMap.js
  var require_isMap = __commonJS((exports2, module2) => {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseIsSet.js
  var require_baseIsSet = __commonJS((exports2, module2) => {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isSet.js
  var require_isSet = __commonJS((exports2, module2) => {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseClone.js
  var require_baseClone = __commonJS((exports2, module2) => {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\cloneDeep.js
  var require_cloneDeep = __commonJS((exports2, module2) => {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep5(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep5;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\set.js
  var require_set2 = __commonJS((exports2, module2) => {
    var baseSet = require_baseSet();
    function set(object, path6, value) {
      return object == null ? object : baseSet(object, path6, value);
    }
    module2.exports = set;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\last.js
  var require_last = __commonJS((exports2, module2) => {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_parent.js
  var require_parent = __commonJS((exports2, module2) => {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path6) {
      return path6.length < 2 ? object : baseGet(object, baseSlice(path6, 0, -1));
    }
    module2.exports = parent;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseUnset.js
  var require_baseUnset = __commonJS((exports2, module2) => {
    var castPath = require_castPath();
    var last = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path6) {
      path6 = castPath(path6, object);
      object = parent(object, path6);
      return object == null || delete object[toKey(last(path6))];
    }
    module2.exports = baseUnset;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\unset.js
  var require_unset = __commonJS((exports2, module2) => {
    var baseUnset = require_baseUnset();
    function unset(object, path6) {
      return object == null ? true : baseUnset(object, path6);
    }
    module2.exports = unset;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\package.json
  var require_package = __commonJS((exports2, module2) => {
    module2.exports = {
      name: "@yarnpkg/cli",
      version: "2.4.0",
      license: "BSD-2-Clause",
      main: "./sources/index.ts",
      dependencies: {
        "@yarnpkg/core": "workspace:^2.4.0",
        "@yarnpkg/fslib": "workspace:^2.4.0",
        "@yarnpkg/libzip": "workspace:^2.2.1",
        "@yarnpkg/parsers": "workspace:^2.3.0",
        "@yarnpkg/plugin-compat": "workspace:^2.2.0",
        "@yarnpkg/plugin-dlx": "workspace:^2.1.4",
        "@yarnpkg/plugin-essentials": "workspace:^2.4.0",
        "@yarnpkg/plugin-file": "workspace:^2.2.0",
        "@yarnpkg/plugin-git": "workspace:^2.3.0",
        "@yarnpkg/plugin-github": "workspace:^2.1.2",
        "@yarnpkg/plugin-http": "workspace:^2.1.2",
        "@yarnpkg/plugin-init": "workspace:^2.2.2",
        "@yarnpkg/plugin-link": "workspace:^2.1.1",
        "@yarnpkg/plugin-node-modules": "workspace:^2.3.0",
        "@yarnpkg/plugin-npm": "workspace:^2.4.0",
        "@yarnpkg/plugin-npm-cli": "workspace:^2.3.0",
        "@yarnpkg/plugin-pack": "workspace:^2.2.3",
        "@yarnpkg/plugin-patch": "workspace:^2.1.2",
        "@yarnpkg/plugin-pnp": "workspace:^2.4.0",
        "@yarnpkg/shell": "workspace:^2.4.1",
        chalk: "^3.0.0",
        "ci-info": "^2.0.0",
        clipanion: "^3.0.0-rc.5",
        fromentries: "^1.2.0",
        semver: "^7.1.2",
        tslib: "^1.13.0",
        typanion: "^3.2.1"
      },
      devDependencies: {
        "@types/ci-info": "^2",
        "@types/semver": "^7.1.0",
        "@yarnpkg/builder": "workspace:^2.1.3",
        "@yarnpkg/monorepo": "workspace:0.0.0",
        "@yarnpkg/pnpify": "workspace:^2.4.0",
        micromatch: "^4.0.2",
        typescript: "4.1.0-beta"
      },
      peerDependencies: {
        "@yarnpkg/core": "^2.4.0"
      },
      scripts: {
        postpack: "rm -rf lib",
        prepack: 'run build:compile "$(pwd)"',
        "build:cli+hook": "run build:pnp:hook && builder build bundle",
        "build:cli": "builder build bundle",
        "run:cli": "builder run",
        "update-local": "run build:cli --no-git-hash && rsync -a --delete bundles/ bin/"
      },
      publishConfig: {
        main: "./lib/index.js",
        types: "./lib/index.d.ts",
        bin: null
      },
      files: [
        "/lib/**/*",
        "!/lib/pluginConfiguration.*",
        "!/lib/cli.*"
      ],
      "@yarnpkg/builder": {
        bundles: {
          standard: [
            "@yarnpkg/plugin-essentials",
            "@yarnpkg/plugin-compat",
            "@yarnpkg/plugin-dlx",
            "@yarnpkg/plugin-file",
            "@yarnpkg/plugin-git",
            "@yarnpkg/plugin-github",
            "@yarnpkg/plugin-http",
            "@yarnpkg/plugin-init",
            "@yarnpkg/plugin-link",
            "@yarnpkg/plugin-node-modules",
            "@yarnpkg/plugin-npm",
            "@yarnpkg/plugin-npm-cli",
            "@yarnpkg/plugin-pack",
            "@yarnpkg/plugin-patch",
            "@yarnpkg/plugin-pnp"
          ]
        }
      },
      repository: {
        type: "git",
        url: "ssh://git@github.com/yarnpkg/berry.git",
        directory: "packages/yarnpkg-cli"
      },
      engines: {
        node: ">=10.19.0"
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_assignMergeValue.js
  var require_assignMergeValue = __commonJS((exports2, module2) => {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq2();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignMergeValue;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_createBaseFor.js
  var require_createBaseFor = __commonJS((exports2, module2) => {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseFor.js
  var require_baseFor = __commonJS((exports2, module2) => {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS((exports2, module2) => {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\isPlainObject.js
  var require_isPlainObject = __commonJS((exports2, module2) => {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_safeGet.js
  var require_safeGet = __commonJS((exports2, module2) => {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module2.exports = safeGet;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\toPlainObject.js
  var require_toPlainObject = __commonJS((exports2, module2) => {
    var copyObject = require_copyObject();
    var keysIn2 = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn2(value));
    }
    module2.exports = toPlainObject;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS((exports2, module2) => {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module2.exports = baseMergeDeep;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseMerge.js
  var require_baseMerge = __commonJS((exports2, module2) => {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn2 = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn2);
    }
    module2.exports = baseMerge;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_baseRest.js
  var require_baseRest = __commonJS((exports2, module2) => {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start2) {
      return setToString(overRest(func, start2, identity), func + "");
    }
    module2.exports = baseRest;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_isIterateeCall.js
  var require_isIterateeCall = __commonJS((exports2, module2) => {
    var eq = require_eq2();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\_createAssigner.js
  var require_createAssigner = __commonJS((exports2, module2) => {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\lodash-npm-4.17.15-566d9324f7-aec3fbb757.zip\node_modules\lodash\merge.js
  var require_merge4 = __commonJS((exports2, module2) => {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge3 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module2.exports = merge3;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\dynamicRequire.ts
  var require_dynamicRequire = __commonJS((exports) => {
    __export(exports, {
      dynamicRequire: () => dynamicRequire,
      dynamicRequireNoCache: () => dynamicRequireNoCache
    });
    var dynamicRequire = eval(`require`);
    function dynamicRequireNoCache(path) {
      const physicalPath = npath.fromPortablePath(path);
      const currentCacheEntry = dynamicRequire.cache[physicalPath];
      delete dynamicRequire.cache[physicalPath];
      let result;
      try {
        result = dynamicRequire(physicalPath);
        const freshCacheEntry = dynamicRequire.cache[physicalPath];
        const dynamicModule = eval(`module`);
        const freshCacheIndex = dynamicModule.children.indexOf(freshCacheEntry);
        if (freshCacheIndex !== -1) {
          dynamicModule.children.splice(freshCacheIndex, 1);
        }
      } finally {
        dynamicRequire.cache[physicalPath] = currentCacheEntry;
      }
      return result;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\hook.js
  var require_hook = __commonJS((exports2, module2) => {
    var hook;
    module2.exports = () => {
      if (typeof hook === `undefined`)
        hook = require("zlib").brotliDecompressSync(Buffer.from("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", "base64")).toString();
      return hook;
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\semver-npm-6.3.0-b3eace8bfd-f0d155c06a.zip\node_modules\semver\semver.js
  var require_semver3 = __commonJS((exports2, module2) => {
    exports2 = module2.exports = SemVer2;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t7 = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t7[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t7.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t7.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t7.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t7.MAINVERSION] = "(" + src[t7.NUMERICIDENTIFIER] + ")\\.(" + src[t7.NUMERICIDENTIFIER] + ")\\.(" + src[t7.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t7.MAINVERSIONLOOSE] = "(" + src[t7.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t7.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t7.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t7.PRERELEASEIDENTIFIER] = "(?:" + src[t7.NUMERICIDENTIFIER] + "|" + src[t7.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t7.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t7.NUMERICIDENTIFIERLOOSE] + "|" + src[t7.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t7.PRERELEASE] = "(?:-(" + src[t7.PRERELEASEIDENTIFIER] + "(?:\\." + src[t7.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t7.PRERELEASELOOSE] = "(?:-?(" + src[t7.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t7.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t7.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t7.BUILD] = "(?:\\+(" + src[t7.BUILDIDENTIFIER] + "(?:\\." + src[t7.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t7.FULLPLAIN] = "v?" + src[t7.MAINVERSION] + src[t7.PRERELEASE] + "?" + src[t7.BUILD] + "?";
    src[t7.FULL] = "^" + src[t7.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t7.LOOSEPLAIN] = "[v=\\s]*" + src[t7.MAINVERSIONLOOSE] + src[t7.PRERELEASELOOSE] + "?" + src[t7.BUILD] + "?";
    tok("LOOSE");
    src[t7.LOOSE] = "^" + src[t7.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t7.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t7.XRANGEIDENTIFIERLOOSE] = src[t7.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t7.XRANGEIDENTIFIER] = src[t7.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t7.XRANGEPLAIN] = "[v=\\s]*(" + src[t7.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t7.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t7.XRANGEIDENTIFIER] + ")(?:" + src[t7.PRERELEASE] + ")?" + src[t7.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t7.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t7.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t7.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t7.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t7.PRERELEASELOOSE] + ")?" + src[t7.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t7.XRANGE] = "^" + src[t7.GTLT] + "\\s*" + src[t7.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t7.XRANGELOOSE] = "^" + src[t7.GTLT] + "\\s*" + src[t7.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t7.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t7.COERCERTL] = new RegExp(src[t7.COERCE], "g");
    tok("LONETILDE");
    src[t7.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t7.TILDETRIM] = "(\\s*)" + src[t7.LONETILDE] + "\\s+";
    re[t7.TILDETRIM] = new RegExp(src[t7.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t7.TILDE] = "^" + src[t7.LONETILDE] + src[t7.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t7.TILDELOOSE] = "^" + src[t7.LONETILDE] + src[t7.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t7.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t7.CARETTRIM] = "(\\s*)" + src[t7.LONECARET] + "\\s+";
    re[t7.CARETTRIM] = new RegExp(src[t7.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t7.CARET] = "^" + src[t7.LONECARET] + src[t7.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t7.CARETLOOSE] = "^" + src[t7.LONECARET] + src[t7.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t7.COMPARATORLOOSE] = "^" + src[t7.GTLT] + "\\s*(" + src[t7.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t7.COMPARATOR] = "^" + src[t7.GTLT] + "\\s*(" + src[t7.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t7.COMPARATORTRIM] = "(\\s*)" + src[t7.GTLT] + "\\s*(" + src[t7.LOOSEPLAIN] + "|" + src[t7.XRANGEPLAIN] + ")";
    re[t7.COMPARATORTRIM] = new RegExp(src[t7.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t7.HYPHENRANGE] = "^\\s*(" + src[t7.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t7.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t7.HYPHENRANGELOOSE] = "^\\s*(" + src[t7.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t7.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t7.STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug2(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    exports2.parse = parse4;
    function parse4(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer2) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t7.LOOSE] : re[t7.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer2(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse4(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean3;
    function clean3(version, options) {
      var s = parse4(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer2;
    function SemVer2(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer2) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer2)) {
        return new SemVer2(version, options);
      }
      debug2("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t7.LOOSE] : re[t7.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer2.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer2.prototype.toString = function() {
      return this.version;
    };
    SemVer2.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer2.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer2.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer2.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer2.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer2(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse4(version1);
        var v2 = parse4(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer2(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer2(a, loose).minor;
    }
    exports2.patch = patch7;
    function patch7(a, loose) {
      return new SemVer2(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer2(a, loose).compare(new SemVer2(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer2(a, loose);
      var versionB = new SemVer2(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t7.COMPARATORLOOSE] : re[t7.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer2(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer2(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t7.HYPHENRANGELOOSE] : re[t7.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(re[t7.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, re[t7.COMPARATORTRIM]);
      range = range.replace(re[t7.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t7.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t7.COMPARATORLOOSE] : re[t7.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t7.TILDELOOSE] : re[t7.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug2("caret", comp, options);
      var r = options.loose ? re[t7.CARETLOOSE] : re[t7.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t7.XRANGELOOSE] : re[t7.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t7.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer2(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer2(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer2(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer2("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer2("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer2(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange2;
    function validRange2(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer2(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse4(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer2) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match2 = null;
      if (!options.rtl) {
        match2 = version.match(re[t7.COERCE]);
      } else {
        var next;
        while ((next = re[t7.COERCERTL].exec(version)) && (!match2 || match2.index + match2[0].length !== version.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          re[t7.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t7.COERCERTL].lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      return parse4(match2[2] + "." + (match2[3] || "0") + "." + (match2[4] || "0"), options);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\make-dir-npm-3.1.0-d1d7505142-54b6f186c2.zip\node_modules\make-dir\index.js
  var require_make_dir = __commonJS((exports2, module2) => {
    "use strict";
    var fs9 = require("fs");
    var path6 = require("path");
    var {promisify: promisify4} = require("util");
    var semver30 = require_semver3();
    var useNativeRecursiveOption = semver30.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path6.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = {
        mode: 511,
        fs: fs9
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      const mkdir = promisify4(options.fs.mkdir);
      const stat = promisify4(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs9.mkdir) {
        const pth = path6.resolve(input);
        await mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path6.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path6.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
          return pth;
        }
      };
      return make(path6.resolve(input));
    };
    module2.exports = makeDir;
    module2.exports.sync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs9.mkdirSync) {
        const pth = path6.resolve(input);
        fs9.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path6.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path6.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
        }
        return pth;
      };
      return make(path6.resolve(input));
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\is-windows-npm-1.0.2-898cd6f3d7-dd1ed8339a.zip\node_modules\is-windows\index.js
  var require_is_windows = __commonJS((exports2, module2) => {
    /*!
     * is-windows <https://github.com/jonschlinkert/is-windows>
     *
     * Copyright © 2015-2018, Jon Schlinkert.
     * Released under the MIT License.
     */
    (function(factory) {
      if (exports2 && typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof window !== "undefined") {
        window.isWindows = factory();
      } else if (typeof global !== "undefined") {
        global.isWindows = factory();
      } else if (typeof self !== "undefined") {
        self.isWindows = factory();
      } else {
        this.isWindows = factory();
      }
    })(function() {
      "use strict";
      return function isWindows() {
        return process && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env.OSTYPE));
      };
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\@zkochan-cmd-shim-npm-4.3.0-00786a1c45-63f13d2755.zip\node_modules\@zkochan\cmd-shim\index.js
  var require_cmd_shim = __commonJS((exports2, module2) => {
    "use strict";
    cmdShim3.ifExists = cmdShimIfExists;
    var util_1 = require("util");
    var makeDir = require_make_dir();
    var path6 = require("path");
    var isWindows = require_is_windows();
    var shebangExpr = /^#!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+)(.*)$/;
    var DEFAULT_OPTIONS = {
      createPwshFile: true,
      createCmdFile: isWindows(),
      fs: require("fs")
    };
    var extensionToProgramMap = new Map([
      [".js", "node"],
      [".cmd", "cmd"],
      [".bat", "cmd"],
      [".ps1", "pwsh"],
      [".sh", "sh"]
    ]);
    function ingestOptions(opts) {
      const opts_ = {...DEFAULT_OPTIONS, ...opts};
      const fs9 = opts_.fs;
      opts_.fs_ = {
        chmod: fs9.chmod ? util_1.promisify(fs9.chmod) : async () => {
        },
        stat: util_1.promisify(fs9.stat),
        unlink: util_1.promisify(fs9.unlink),
        readFile: util_1.promisify(fs9.readFile),
        writeFile: util_1.promisify(fs9.writeFile)
      };
      return opts_;
    }
    async function cmdShim3(src, to, opts) {
      const opts_ = ingestOptions(opts);
      await opts_.fs_.stat(src);
      await cmdShim_(src, to, opts_);
    }
    function cmdShimIfExists(src, to, opts) {
      return cmdShim3(src, to, opts).catch(() => {
      });
    }
    function rm(path7, opts) {
      return opts.fs_.unlink(path7).catch(() => {
      });
    }
    async function cmdShim_(src, to, opts) {
      const srcRuntimeInfo = await searchScriptRuntime(src, opts);
      await writeShimsPreCommon(to, opts);
      return writeAllShims(src, to, srcRuntimeInfo, opts);
    }
    function writeShimsPreCommon(target, opts) {
      return makeDir(path6.dirname(target), {fs: opts.fs});
    }
    function writeAllShims(src, to, srcRuntimeInfo, opts) {
      const opts_ = ingestOptions(opts);
      const generatorAndExts = [{generator: generateShShim, extension: ""}];
      if (opts_.createCmdFile) {
        generatorAndExts.push({generator: generateCmdShim, extension: ".cmd"});
      }
      if (opts_.createPwshFile) {
        generatorAndExts.push({generator: generatePwshShim, extension: ".ps1"});
      }
      return Promise.all(generatorAndExts.map((generatorAndExt) => writeShim(src, to + generatorAndExt.extension, srcRuntimeInfo, generatorAndExt.generator, opts_)));
    }
    function writeShimPre(target, opts) {
      return rm(target, opts);
    }
    function writeShimPost(target, opts) {
      return chmodShim(target, opts);
    }
    async function searchScriptRuntime(target, opts) {
      const data = await opts.fs_.readFile(target, "utf8");
      const firstLine = data.trim().split(/\r*\n/)[0];
      const shebang = firstLine.match(shebangExpr);
      if (!shebang) {
        const targetExtension = path6.extname(target).toLowerCase();
        return {
          program: extensionToProgramMap.get(targetExtension) || null,
          additionalArgs: ""
        };
      }
      return {
        program: shebang[1],
        additionalArgs: shebang[2]
      };
    }
    async function writeShim(src, to, srcRuntimeInfo, generateShimScript, opts) {
      const defaultArgs = opts.preserveSymlinks ? "--preserve-symlinks" : "";
      const args = [srcRuntimeInfo.additionalArgs, defaultArgs].filter((arg) => arg).join(" ");
      opts = Object.assign({}, opts, {
        prog: srcRuntimeInfo.program,
        args
      });
      await writeShimPre(to, opts);
      await opts.fs_.writeFile(to, generateShimScript(src, to, opts), "utf8");
      return writeShimPost(to, opts);
    }
    function generateCmdShim(src, to, opts) {
      const shTarget = path6.relative(path6.dirname(to), src);
      let target = shTarget.split("/").join("\\");
      const quotedPathToTarget = path6.isAbsolute(target) ? `"${target}"` : `"%~dp0\\${target}"`;
      let longProg;
      let prog = opts.prog;
      let args = opts.args || "";
      const nodePath = normalizePathEnvVar(opts.nodePath).win32;
      if (!prog) {
        prog = quotedPathToTarget;
        args = "";
        target = "";
      } else {
        longProg = `"%~dp0\\${prog}.exe"`;
        target = quotedPathToTarget;
      }
      let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : "";
      let cmd = nodePath ? `@SET NODE_PATH=${nodePath}\r
` : "";
      if (longProg) {
        cmd += `@IF EXIST ${longProg} (\r
  ${longProg} ${args} ${target} ${progArgs}%*\r
) ELSE (\r
  @SETLOCAL\r
  @SET PATHEXT=%PATHEXT:;.JS;=;%\r
  ${prog} ${args} ${target} ${progArgs}%*\r
)`;
      } else {
        cmd += `@${prog} ${args} ${target} ${progArgs}%*\r
`;
      }
      return cmd;
    }
    function generateShShim(src, to, opts) {
      let shTarget = path6.relative(path6.dirname(to), src);
      let shProg = opts.prog && opts.prog.split("\\").join("/");
      let shLongProg;
      shTarget = shTarget.split("\\").join("/");
      const quotedPathToTarget = path6.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
      let args = opts.args || "";
      const shNodePath = normalizePathEnvVar(opts.nodePath).posix;
      if (!shProg) {
        shProg = quotedPathToTarget;
        args = "";
        shTarget = "";
      } else {
        shLongProg = `"$basedir/${opts.prog}"`;
        shTarget = quotedPathToTarget;
      }
      let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : "";
      let sh = "#!/bin/sh\n";
      sh = sh + 'basedir=$(dirname "$(echo "$0" | sed -e \'s,\\\\,/,g\')")\n\ncase `uname` in\n    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;\nesac\n\n';
      const env = opts.nodePath ? `export NODE_PATH="${shNodePath}"
` : "";
      if (shLongProg) {
        sh += env + `if [ -x ${shLongProg} ]; then
  exec ${shLongProg} ${args} ${shTarget} ${progArgs}"$@"
else 
  exec ${shProg} ${args} ${shTarget} ${progArgs}"$@"
fi
`;
      } else {
        sh += `${env}${shProg} ${args} ${shTarget} ${progArgs}"$@"
exit $?
`;
      }
      return sh;
    }
    function generatePwshShim(src, to, opts) {
      let shTarget = path6.relative(path6.dirname(to), src);
      const shProg = opts.prog && opts.prog.split("\\").join("/");
      let pwshProg = shProg && `"${shProg}$exe"`;
      let pwshLongProg;
      shTarget = shTarget.split("\\").join("/");
      const quotedPathToTarget = path6.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
      let args = opts.args || "";
      let normalizedPathEnvVar = normalizePathEnvVar(opts.nodePath);
      const nodePath = normalizedPathEnvVar.win32;
      const shNodePath = normalizedPathEnvVar.posix;
      if (!pwshProg) {
        pwshProg = quotedPathToTarget;
        args = "";
        shTarget = "";
      } else {
        pwshLongProg = `"$basedir/${opts.prog}$exe"`;
        shTarget = quotedPathToTarget;
      }
      let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : "";
      let pwsh = '#!/usr/bin/env pwsh\n$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n\n$exe=""\n' + (opts.nodePath ? `$env_node_path=$env:NODE_PATH
$env:NODE_PATH="${nodePath}"
` : "") + 'if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n  # Fix case when both the Windows and Linux builds of Node\n  # are installed in the same directory\n  $exe=".exe"\n}';
      if (opts.nodePath) {
        pwsh = pwsh + ` else {
  $env:NODE_PATH="${shNodePath}"
}`;
      }
      pwsh += "\n";
      if (pwshLongProg) {
        pwsh = pwsh + `$ret=0
if (Test-Path ${pwshLongProg}) {
  # Support pipeline input
  if ($MyInvocation.ExpectingInput) {
    $input | & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args
  } else {
    & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args
  }
  $ret=$LASTEXITCODE
} else {
  # Support pipeline input
  if ($MyInvocation.ExpectingInput) {
    $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args
  } else {
    & ${pwshProg} ${args} ${shTarget} ${progArgs}$args
  }
  $ret=$LASTEXITCODE
}
` + (opts.nodePath ? "$env:NODE_PATH=$env_node_path\n" : "") + "exit $ret\n";
      } else {
        pwsh = pwsh + `# Support pipeline input
if ($MyInvocation.ExpectingInput) {
  $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args
} else {
  & ${pwshProg} ${args} ${shTarget} ${progArgs}$args
}
` + (opts.nodePath ? "$env:NODE_PATH=$env_node_path\n" : "") + "exit $LASTEXITCODE\n";
      }
      return pwsh;
    }
    function chmodShim(to, opts) {
      return opts.fs_.chmod(to, 493);
    }
    function normalizePathEnvVar(nodePath) {
      if (!nodePath) {
        return {
          win32: "",
          posix: ""
        };
      }
      let split2 = typeof nodePath === "string" ? nodePath.split(path6.delimiter) : Array.from(nodePath);
      let result = {};
      for (let i = 0; i < split2.length; i++) {
        const win32 = split2[i].split("/").join("\\");
        const posix = isWindows() ? split2[i].split("\\").join("/").replace(/^([^:\\/]*):/, (_, $1) => `/mnt/${$1.toLowerCase()}`) : split2[i];
        result.win32 = result.win32 ? `${result.win32};${win32}` : win32;
        result.posix = result.posix ? `${result.posix}:${posix}` : posix;
        result[i] = {win32, posix};
      }
      return result;
    }
    module2.exports = cmdShim3;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\package.json
  var require_package2 = __commonJS((exports2, module2) => {
    module2.exports = {
      name: "@yarnpkg/cli",
      version: "2.4.0",
      license: "BSD-2-Clause",
      main: "./sources/index.ts",
      dependencies: {
        "@yarnpkg/core": "workspace:^2.4.0",
        "@yarnpkg/fslib": "workspace:^2.4.0",
        "@yarnpkg/libzip": "workspace:^2.2.1",
        "@yarnpkg/parsers": "workspace:^2.3.0",
        "@yarnpkg/plugin-compat": "workspace:^2.2.0",
        "@yarnpkg/plugin-dlx": "workspace:^2.1.4",
        "@yarnpkg/plugin-essentials": "workspace:^2.4.0",
        "@yarnpkg/plugin-file": "workspace:^2.2.0",
        "@yarnpkg/plugin-git": "workspace:^2.3.0",
        "@yarnpkg/plugin-github": "workspace:^2.1.2",
        "@yarnpkg/plugin-http": "workspace:^2.1.2",
        "@yarnpkg/plugin-init": "workspace:^2.2.2",
        "@yarnpkg/plugin-link": "workspace:^2.1.1",
        "@yarnpkg/plugin-node-modules": "workspace:^2.3.0",
        "@yarnpkg/plugin-npm": "workspace:^2.4.0",
        "@yarnpkg/plugin-npm-cli": "workspace:^2.3.0",
        "@yarnpkg/plugin-pack": "workspace:^2.2.3",
        "@yarnpkg/plugin-patch": "workspace:^2.1.2",
        "@yarnpkg/plugin-pnp": "workspace:^2.4.0",
        "@yarnpkg/shell": "workspace:^2.4.1",
        chalk: "^3.0.0",
        "ci-info": "^2.0.0",
        clipanion: "^3.0.0-rc.5",
        fromentries: "^1.2.0",
        semver: "^7.1.2",
        tslib: "^1.13.0",
        typanion: "^3.2.1"
      },
      devDependencies: {
        "@types/ci-info": "^2",
        "@types/semver": "^7.1.0",
        "@yarnpkg/builder": "workspace:^2.1.3",
        "@yarnpkg/monorepo": "workspace:0.0.0",
        "@yarnpkg/pnpify": "workspace:^2.4.0",
        micromatch: "^4.0.2",
        typescript: "4.1.0-beta"
      },
      peerDependencies: {
        "@yarnpkg/core": "^2.4.0"
      },
      scripts: {
        postpack: "rm -rf lib",
        prepack: 'run build:compile "$(pwd)"',
        "build:cli+hook": "run build:pnp:hook && builder build bundle",
        "build:cli": "builder build bundle",
        "run:cli": "builder run",
        "update-local": "run build:cli --no-git-hash && rsync -a --delete bundles/ bin/"
      },
      publishConfig: {
        main: "./lib/index.js",
        types: "./lib/index.d.ts",
        bin: null
      },
      files: [
        "/lib/**/*",
        "!/lib/pluginConfiguration.*",
        "!/lib/cli.*"
      ],
      "@yarnpkg/builder": {
        bundles: {
          standard: [
            "@yarnpkg/plugin-essentials",
            "@yarnpkg/plugin-compat",
            "@yarnpkg/plugin-dlx",
            "@yarnpkg/plugin-file",
            "@yarnpkg/plugin-git",
            "@yarnpkg/plugin-github",
            "@yarnpkg/plugin-http",
            "@yarnpkg/plugin-init",
            "@yarnpkg/plugin-link",
            "@yarnpkg/plugin-node-modules",
            "@yarnpkg/plugin-npm",
            "@yarnpkg/plugin-npm-cli",
            "@yarnpkg/plugin-pack",
            "@yarnpkg/plugin-patch",
            "@yarnpkg/plugin-pnp"
          ]
        }
      },
      repository: {
        type: "git",
        url: "ssh://git@github.com/yarnpkg/berry.git",
        directory: "packages/yarnpkg-cli"
      },
      engines: {
        node: ">=10.19.0"
      }
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\stream.js
  var require_stream5 = __commonJS((exports2, module2) => {
    module2.exports = require("stream");
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\buffer_list.js
  var require_buffer_list = __commonJS((exports2, module2) => {
    "use strict";
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect13 = _require2.inspect;
    var custom = inspect13 && inspect13.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      var _proto = BufferList.prototype;
      _proto.push = function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      _proto.unshift = function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      _proto.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      _proto.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      _proto.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      _proto.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      _proto.consume = function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      };
      _proto.first = function first() {
        return this.head.data;
      };
      _proto._getString = function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      };
      _proto._getBuffer = function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      };
      _proto[custom] = function(_, options) {
        return inspect13(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      };
      return BufferList;
    }();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\destroy.js
  var require_destroy = __commonJS((exports2, module2) => {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          process.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\errors.js
  var require_errors2 = __commonJS((exports2, module2) => {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage3(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage3(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start2) {
      if (typeof start2 !== "number") {
        start2 = 0;
      }
      if (start2 + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start2) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\state.js
  var require_state2 = __commonJS((exports2, module2) => {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\experimentalWarning.js
  var require_experimentalWarning = __commonJS((exports2, module2) => {
    "use strict";
    var experimentalWarnings = new Set();
    function emitExperimentalWarning(feature) {
      if (experimentalWarnings.has(feature))
        return;
      var msg = feature + " is an experimental feature. This feature could change at any time";
      experimentalWarnings.add(feature);
      process.emitWarning(msg, "ExperimentalWarning");
    }
    function noop() {
    }
    module2.exports.emitExperimentalWarning = process.emitWarning ? emitExperimentalWarning : noop;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\inherits-npm-2.0.3-401e64b080-9488f9433e.zip\node_modules\inherits\inherits_browser.js
  var require_inherits_browser = __commonJS((exports2, module2) => {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\inherits-npm-2.0.3-401e64b080-9488f9433e.zip\node_modules\inherits\inherits.js
  var require_inherits = __commonJS((exports2, module2) => {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\util-deprecate-npm-1.0.2-e3fe1a219c-73c2b1cf02.zip\node_modules\util-deprecate\node.js
  var require_node = __commonJS((exports2, module2) => {
    module2.exports = require("util").deprecate;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\_stream_writable.js
  var require_stream_writable = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = Writable5;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable5.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream5();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    require_inherits()(Writable5, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable5, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable5)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable5(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable5, this))
        return new Writable5(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable5.prototype.pipe = function() {
      this.emit("error", new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      stream.emit("error", er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        stream.emit("error", er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable5.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable5.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable5.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable5.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable5.prototype, "writableBuffer", {
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable5.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable5.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable5.prototype._writev = null;
    Writable5.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable5.prototype, "writableLength", {
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable5.prototype, "destroyed", {
      enumerable: false,
      get: function get4() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable5.prototype.destroy = destroyImpl.destroy;
    Writable5.prototype._undestroy = destroyImpl.undestroy;
    Writable5.prototype._destroy = function(err, cb) {
      cb(err);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\_stream_duplex.js
  var require_stream_duplex = __commonJS((exports2, module2) => {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable6 = require_stream_readable();
    var Writable5 = require_stream_writable();
    require_inherits()(Duplex, Readable6);
    {
      keys = objectKeys(Writable5.prototype);
      for (var v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable5.prototype[method];
      }
    }
    var keys;
    var method;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable6.call(this, options);
      Writable5.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\safe-buffer-npm-5.1.2-c27fedf6c4-2708587c1b.zip\node_modules\safe-buffer\index.js
  var require_safe_buffer = __commonJS((exports2, module2) => {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\string_decoder-npm-1.2.0-5624097b10-8b36b416df.zip\node_modules\string_decoder\lib\string_decoder.js
  var require_string_decoder = __commonJS((exports2) => {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\end-of-stream.js
  var require_end_of_stream2 = __commonJS((exports2, module2) => {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function once(callback) {
      var called = false;
      return function(err) {
        if (called)
          return;
        called = true;
        callback.call(this, err);
      };
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function onfinish2() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function onend2() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        if (readable && !(rs && rs.ended)) {
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !(ws && ws.ended)) {
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\async_iterator.js
  var require_async_iterator = __commonJS((exports2, module2) => {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(null, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(null, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(null, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kLastPromise, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(null, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\_stream_readable.js
  var require_stream_readable = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = Readable6;
    var Duplex;
    Readable6.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream5();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var _require2 = require_experimentalWarning();
    var emitExperimentalWarning = _require2.emitExperimentalWarning;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    require_inherits()(Readable6, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable6(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable6))
        return new Readable6(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable6.prototype, "destroyed", {
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable6.prototype.destroy = destroyImpl.destroy;
    Readable6.prototype._undestroy = destroyImpl.undestroy;
    Readable6.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable6.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable6.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable6.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable6.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder2(enc);
      this._readableState.encoding = this._readableState.decoder.encoding;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable6.prototype.read = function(n) {
      debug2("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.ended && state.length < state.highWaterMark) {
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable6.prototype._read = function(n) {
      this.emit("error", new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable6.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable6.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable6.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable6.prototype.addListener = Readable6.prototype.on;
    Readable6.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable6.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable6.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable6.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable6.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug2("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable6.prototype[Symbol.asyncIterator] = function() {
        emitExperimentalWarning("Readable[Symbol.asyncIterator]");
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable6.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get4() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable6.prototype, "readableBuffer", {
      enumerable: false,
      get: function get4() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable6.prototype, "readableFlowing", {
      enumerable: false,
      get: function get4() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable6._fromList = fromList;
    Object.defineProperty(Readable6.prototype, "readableLength", {
      enumerable: false,
      get: function get4() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\_stream_transform.js
  var require_stream_transform = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = Transform3;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform3, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform3(options) {
      if (!(this instanceof Transform3))
        return new Transform3(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform3.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform3.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform3.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform3.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform3.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\_stream_passthrough.js
  var require_stream_passthrough = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = PassThrough8;
    var Transform3 = require_stream_transform();
    require_inherits()(PassThrough8, Transform3);
    function PassThrough8(options) {
      if (!(this instanceof PassThrough8))
        return new PassThrough8(options);
      Transform3.call(this, options);
    }
    PassThrough8.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\lib\internal\streams\pipeline.js
  var require_pipeline = __commonJS((exports2, module2) => {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\readable-stream-npm-3.2.0-1fb3a5a0b1-15d018a55e.zip\node_modules\readable-stream\readable.js
  var require_readable = __commonJS((exports2, module2) => {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream2();
      exports2.pipeline = require_pipeline();
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\bl-npm-3.0.0-51c177509b-9222f6b9cb.zip\node_modules\bl\bl.js
  var require_bl = __commonJS((exports2, module2) => {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = require("util");
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get4(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      var offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start2, end) {
      if (typeof start2 == "number" && start2 < 0)
        start2 += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start2, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start2 = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start2) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start2, start2 + bytes) : this._bufs[off[0]].slice(start2, start2 + bytes);
      }
      if (!copy2)
        dst = Buffer.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start2;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start2);
        } else {
          this._bufs[i].copy(dst, bufoff, start2, start2 + bytes);
          break;
        }
        bufoff += l;
        bytes -= l;
        if (start2)
          start2 = 0;
      }
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start2, end) {
      start2 = start2 || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start2 < 0)
        start2 += this.length;
      if (end < 0)
        end += this.length;
      if (start2 === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start2), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start2, end) {
      return this.slice(start2, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer.from([search]);
      } else if (typeof search === "string") {
        search = Buffer.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer.isBuffer(search)) {
        search = Buffer.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-stream-npm-2.0.1-c970ce894b-963b861f61.zip\node_modules\tar-stream\headers.js
  var require_headers = __commonJS((exports2) => {
    var alloc = Buffer.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR = "ustar\x0000";
    var MASK = parseInt("7777", 8);
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++)
        sum += block[i];
      for (var j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var zero = false;
      var tuple2 = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive)
          tuple2.push(byte);
        else if (zero && byte === 0)
          tuple2.push(0);
        else if (zero) {
          zero = false;
          tuple2.push(256 - byte);
        } else
          tuple2.push(255 - byte);
      }
      var sum = 0;
      var l = tuple2.length;
      for (i = 0; i < l; i++) {
        sum += tuple2[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer.from(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len)
          return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      buf.write(USTAR, 257);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      var c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-stream-npm-2.0.1-c970ce894b-963b861f61.zip\node_modules\tar-stream\extract.js
  var require_extract2 = __commonJS((exports2, module2) => {
    var util = require("util");
    var bl = require_bl();
    var headers = require_headers();
    var Writable5 = require_readable().Writable;
    var PassThrough8 = require_readable().PassThrough;
    var noop = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough8.call(this);
    };
    util.inherits(Source, PassThrough8);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable5.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable5);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s)
          return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s)
        s.end(data);
      else
        b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\fs-constants-npm-1.0.0-59576b2177-b8382395f5.zip\node_modules\fs-constants\index.js
  var require_fs_constants = __commonJS((exports2, module2) => {
    module2.exports = require("fs").constants || require("constants");
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\once-npm-1.4.0-ccf03ef07a-57afc24653.zip\node_modules\once\once.js
  var require_once2 = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\end-of-stream-npm-1.4.1-ccccf6139c-0cef172d2a.zip\node_modules\end-of-stream\index.js
  var require_end_of_stream3 = __commonJS((exports2, module2) => {
    var once = require_once2();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        if (readable && !(rs && rs.ended))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && ws.ended))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-stream-npm-2.0.1-c970ce894b-963b861f61.zip\node_modules\tar-stream\pack.js
  var require_pack2 = __commonJS((exports2, module2) => {
    var constants3 = require_fs_constants();
    var eos = require_end_of_stream3();
    var inherits = require_inherits();
    var alloc = Buffer.alloc;
    var Readable6 = require_readable().Readable;
    var Writable5 = require_readable().Writable;
    var StringDecoder2 = require("string_decoder").StringDecoder;
    var headers = require_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants3.S_IFMT) {
        case constants3.S_IFBLK:
          return "block-device";
        case constants3.S_IFCHR:
          return "character-device";
        case constants3.S_IFDIR:
          return "directory";
        case constants3.S_IFIFO:
          return "fifo";
        case constants3.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable5.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    inherits(Sink, Writable5);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable5.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder2("utf-8");
      this._destroyed = false;
    };
    inherits(LinkSink, Writable5);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable5.call(this);
      this._destroyed = false;
    };
    inherits(Void, Writable5);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable6.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    inherits(Pack, Readable6);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = new Date();
      if (typeof buffer === "string")
        buffer = Buffer.from(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        this.push(buffer);
        overflow(self2, header.size);
        process.nextTick(callback);
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\tar-stream-npm-2.0.1-c970ce894b-963b861f61.zip\node_modules\tar-stream\index.js
  var require_tar_stream = __commonJS((exports2) => {
    exports2.extract = require_extract2();
    exports2.pack = require_pack2();
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\figgy-pudding-npm-3.5.1-6fe250523e-0de1a57197.zip\node_modules\figgy-pudding\index.js
  var require_figgy_pudding = __commonJS((exports2, module2) => {
    "use strict";
    var FiggyPudding = class {
      constructor(specs, opts, providers) {
        this.__specs = specs || {};
        Object.keys(this.__specs).forEach((alias) => {
          if (typeof this.__specs[alias] === "string") {
            const key = this.__specs[alias];
            const realSpec = this.__specs[key];
            if (realSpec) {
              const aliasArr = realSpec.aliases || [];
              aliasArr.push(alias, key);
              realSpec.aliases = [...new Set(aliasArr)];
              this.__specs[alias] = realSpec;
            } else {
              throw new Error(`Alias refers to invalid key: ${key} -> ${alias}`);
            }
          }
        });
        this.__opts = opts || {};
        this.__providers = reverse(providers.filter((x) => x != null && typeof x === "object"));
        this.__isFiggyPudding = true;
      }
      get(key) {
        return pudGet(this, key, true);
      }
      get [Symbol.toStringTag]() {
        return "FiggyPudding";
      }
      forEach(fn, thisArg = this) {
        for (let [key, value] of this.entries()) {
          fn.call(thisArg, value, key, this);
        }
      }
      toJSON() {
        const obj = {};
        this.forEach((val, key) => {
          obj[key] = val;
        });
        return obj;
      }
      *entries(_matcher) {
        for (let key of Object.keys(this.__specs)) {
          yield [key, this.get(key)];
        }
        const matcher = _matcher || this.__opts.other;
        if (matcher) {
          const seen = new Set();
          for (let p of this.__providers) {
            const iter = p.entries ? p.entries(matcher) : entries(p);
            for (let [key, val] of iter) {
              if (matcher(key) && !seen.has(key)) {
                seen.add(key);
                yield [key, val];
              }
            }
          }
        }
      }
      *[Symbol.iterator]() {
        for (let [key, value] of this.entries()) {
          yield [key, value];
        }
      }
      *keys() {
        for (let [key] of this.entries()) {
          yield key;
        }
      }
      *values() {
        for (let [, value] of this.entries()) {
          yield value;
        }
      }
      concat(...moreConfig) {
        return new Proxy(new FiggyPudding(this.__specs, this.__opts, reverse(this.__providers).concat(moreConfig)), proxyHandler);
      }
    };
    try {
      const util = require("util");
      FiggyPudding.prototype[util.inspect.custom] = function(depth, opts) {
        return this[Symbol.toStringTag] + " " + util.inspect(this.toJSON(), opts);
      };
    } catch (e) {
    }
    function BadKeyError(key) {
      throw Object.assign(new Error(`invalid config key requested: ${key}`), {code: "EBADKEY"});
    }
    function pudGet(pud, key, validate) {
      let spec = pud.__specs[key];
      if (validate && !spec && (!pud.__opts.other || !pud.__opts.other(key))) {
        BadKeyError(key);
      } else {
        if (!spec) {
          spec = {};
        }
        let ret;
        for (let p of pud.__providers) {
          ret = tryGet(key, p);
          if (ret === void 0 && spec.aliases && spec.aliases.length) {
            for (let alias of spec.aliases) {
              if (alias === key) {
                continue;
              }
              ret = tryGet(alias, p);
              if (ret !== void 0) {
                break;
              }
            }
          }
          if (ret !== void 0) {
            break;
          }
        }
        if (ret === void 0 && spec.default !== void 0) {
          if (typeof spec.default === "function") {
            return spec.default(pud);
          } else {
            return spec.default;
          }
        } else {
          return ret;
        }
      }
    }
    function tryGet(key, p) {
      let ret;
      if (p.__isFiggyPudding) {
        ret = pudGet(p, key, false);
      } else if (typeof p.get === "function") {
        ret = p.get(key);
      } else {
        ret = p[key];
      }
      return ret;
    }
    var proxyHandler = {
      has(obj, prop) {
        return prop in obj.__specs && pudGet(obj, prop, false) !== void 0;
      },
      ownKeys(obj) {
        return Object.keys(obj.__specs);
      },
      get(obj, prop) {
        if (typeof prop === "symbol" || prop.slice(0, 2) === "__" || prop in FiggyPudding.prototype) {
          return obj[prop];
        }
        return obj.get(prop);
      },
      set(obj, prop, value) {
        if (typeof prop === "symbol" || prop.slice(0, 2) === "__") {
          obj[prop] = value;
          return true;
        } else {
          throw new Error("figgyPudding options cannot be modified. Use .concat() instead.");
        }
      },
      deleteProperty() {
        throw new Error("figgyPudding options cannot be deleted. Use .concat() and shadow them instead.");
      }
    };
    module2.exports = figgyPudding;
    function figgyPudding(specs, opts) {
      function factory(...providers) {
        return new Proxy(new FiggyPudding(specs, opts, providers), proxyHandler);
      }
      return factory;
    }
    function reverse(arr) {
      const ret = [];
      arr.forEach((x) => ret.unshift(x));
      return ret;
    }
    function entries(obj) {
      return Object.keys(obj).map((k) => [k, obj[k]]);
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\cache\ssri-npm-6.0.1-a40d823fc9-828c8c24c9.zip\node_modules\ssri\index.js
  var require_ssri = __commonJS((exports2, module2) => {
    "use strict";
    var crypto2 = require("crypto");
    var figgyPudding = require_figgy_pudding();
    var Transform3 = require("stream").Transform;
    var SPEC_ALGORITHMS = ["sha256", "sha384", "sha512"];
    var BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
    var SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/;
    var STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/;
    var VCHAR_REGEX = /^[\x21-\x7E]+$/;
    var SsriOpts = figgyPudding({
      algorithms: {default: ["sha512"]},
      error: {default: false},
      integrity: {},
      options: {default: []},
      pickAlgorithm: {default: () => getPrioritizedHash},
      Promise: {default: () => Promise},
      sep: {default: " "},
      single: {default: false},
      size: {},
      strict: {default: false}
    });
    var Hash = class {
      get isHash() {
        return true;
      }
      constructor(hash, opts) {
        opts = SsriOpts(opts);
        const strict = !!opts.strict;
        this.source = hash.trim();
        const match2 = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);
        if (!match2) {
          return;
        }
        if (strict && !SPEC_ALGORITHMS.some((a) => a === match2[1])) {
          return;
        }
        this.algorithm = match2[1];
        this.digest = match2[2];
        const rawOpts = match2[3];
        this.options = rawOpts ? rawOpts.slice(1).split("?") : [];
      }
      hexDigest() {
        return this.digest && Buffer.from(this.digest, "base64").toString("hex");
      }
      toJSON() {
        return this.toString();
      }
      toString(opts) {
        opts = SsriOpts(opts);
        if (opts.strict) {
          if (!(SPEC_ALGORITHMS.some((x) => x === this.algorithm) && this.digest.match(BASE64_REGEX) && (this.options || []).every((opt) => opt.match(VCHAR_REGEX)))) {
            return "";
          }
        }
        const options = this.options && this.options.length ? `?${this.options.join("?")}` : "";
        return `${this.algorithm}-${this.digest}${options}`;
      }
    };
    var Integrity = class {
      get isIntegrity() {
        return true;
      }
      toJSON() {
        return this.toString();
      }
      toString(opts) {
        opts = SsriOpts(opts);
        let sep = opts.sep || " ";
        if (opts.strict) {
          sep = sep.replace(/\S+/g, " ");
        }
        return Object.keys(this).map((k) => {
          return this[k].map((hash) => {
            return Hash.prototype.toString.call(hash, opts);
          }).filter((x) => x.length).join(sep);
        }).filter((x) => x.length).join(sep);
      }
      concat(integrity, opts) {
        opts = SsriOpts(opts);
        const other = typeof integrity === "string" ? integrity : stringify(integrity, opts);
        return parse4(`${this.toString(opts)} ${other}`, opts);
      }
      hexDigest() {
        return parse4(this, {single: true}).hexDigest();
      }
      match(integrity, opts) {
        opts = SsriOpts(opts);
        const other = parse4(integrity, opts);
        const algo = other.pickAlgorithm(opts);
        return this[algo] && other[algo] && this[algo].find((hash) => other[algo].find((otherhash) => hash.digest === otherhash.digest)) || false;
      }
      pickAlgorithm(opts) {
        opts = SsriOpts(opts);
        const pickAlgorithm = opts.pickAlgorithm;
        const keys = Object.keys(this);
        if (!keys.length) {
          throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);
        }
        return keys.reduce((acc, algo) => {
          return pickAlgorithm(acc, algo) || acc;
        });
      }
    };
    module2.exports.parse = parse4;
    function parse4(sri, opts) {
      opts = SsriOpts(opts);
      if (typeof sri === "string") {
        return _parse(sri, opts);
      } else if (sri.algorithm && sri.digest) {
        const fullSri = new Integrity();
        fullSri[sri.algorithm] = [sri];
        return _parse(stringify(fullSri, opts), opts);
      } else {
        return _parse(stringify(sri, opts), opts);
      }
    }
    function _parse(integrity, opts) {
      if (opts.single) {
        return new Hash(integrity, opts);
      }
      return integrity.trim().split(/\s+/).reduce((acc, string) => {
        const hash = new Hash(string, opts);
        if (hash.algorithm && hash.digest) {
          const algo = hash.algorithm;
          if (!acc[algo]) {
            acc[algo] = [];
          }
          acc[algo].push(hash);
        }
        return acc;
      }, new Integrity());
    }
    module2.exports.stringify = stringify;
    function stringify(obj, opts) {
      opts = SsriOpts(opts);
      if (obj.algorithm && obj.digest) {
        return Hash.prototype.toString.call(obj, opts);
      } else if (typeof obj === "string") {
        return stringify(parse4(obj, opts), opts);
      } else {
        return Integrity.prototype.toString.call(obj, opts);
      }
    }
    module2.exports.fromHex = fromHex;
    function fromHex(hexDigest, algorithm, opts) {
      opts = SsriOpts(opts);
      const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
      return parse4(`${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`, opts);
    }
    module2.exports.fromData = fromData;
    function fromData(data, opts) {
      opts = SsriOpts(opts);
      const algorithms = opts.algorithms;
      const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
      return algorithms.reduce((acc, algo) => {
        const digest = crypto2.createHash(algo).update(data).digest("base64");
        const hash = new Hash(`${algo}-${digest}${optString}`, opts);
        if (hash.algorithm && hash.digest) {
          const algo2 = hash.algorithm;
          if (!acc[algo2]) {
            acc[algo2] = [];
          }
          acc[algo2].push(hash);
        }
        return acc;
      }, new Integrity());
    }
    module2.exports.fromStream = fromStream;
    function fromStream(stream, opts) {
      opts = SsriOpts(opts);
      const P = opts.Promise || Promise;
      const istream = integrityStream(opts);
      return new P((resolve, reject) => {
        stream.pipe(istream);
        stream.on("error", reject);
        istream.on("error", reject);
        let sri;
        istream.on("integrity", (s) => {
          sri = s;
        });
        istream.on("end", () => resolve(sri));
        istream.on("data", () => {
        });
      });
    }
    module2.exports.checkData = checkData;
    function checkData(data, sri, opts) {
      opts = SsriOpts(opts);
      sri = parse4(sri, opts);
      if (!Object.keys(sri).length) {
        if (opts.error) {
          throw Object.assign(new Error("No valid integrity hashes to check against"), {
            code: "EINTEGRITY"
          });
        } else {
          return false;
        }
      }
      const algorithm = sri.pickAlgorithm(opts);
      const digest = crypto2.createHash(algorithm).update(data).digest("base64");
      const newSri = parse4({algorithm, digest});
      const match2 = newSri.match(sri, opts);
      if (match2 || !opts.error) {
        return match2;
      } else if (typeof opts.size === "number" && data.length !== opts.size) {
        const err = new Error(`data size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${data.length}`);
        err.code = "EBADSIZE";
        err.found = data.length;
        err.expected = opts.size;
        err.sri = sri;
        throw err;
      } else {
        const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);
        err.code = "EINTEGRITY";
        err.found = newSri;
        err.expected = sri;
        err.algorithm = algorithm;
        err.sri = sri;
        throw err;
      }
    }
    module2.exports.checkStream = checkStream;
    function checkStream(stream, sri, opts) {
      opts = SsriOpts(opts);
      const P = opts.Promise || Promise;
      const checker = integrityStream(opts.concat({
        integrity: sri
      }));
      return new P((resolve, reject) => {
        stream.pipe(checker);
        stream.on("error", reject);
        checker.on("error", reject);
        let sri2;
        checker.on("verified", (s) => {
          sri2 = s;
        });
        checker.on("end", () => resolve(sri2));
        checker.on("data", () => {
        });
      });
    }
    module2.exports.integrityStream = integrityStream;
    function integrityStream(opts) {
      opts = SsriOpts(opts);
      const sri = opts.integrity && parse4(opts.integrity, opts);
      const goodSri = sri && Object.keys(sri).length;
      const algorithm = goodSri && sri.pickAlgorithm(opts);
      const digests = goodSri && sri[algorithm];
      const algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));
      const hashes = algorithms.map(crypto2.createHash);
      let streamSize = 0;
      const stream = new Transform3({
        transform(chunk, enc, cb) {
          streamSize += chunk.length;
          hashes.forEach((h) => h.update(chunk, enc));
          cb(null, chunk, enc);
        }
      }).on("end", () => {
        const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
        const newSri = parse4(hashes.map((h, i) => {
          return `${algorithms[i]}-${h.digest("base64")}${optString}`;
        }).join(" "), opts);
        const match2 = goodSri && newSri.match(sri, opts);
        if (typeof opts.size === "number" && streamSize !== opts.size) {
          const err = new Error(`stream size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${streamSize}`);
          err.code = "EBADSIZE";
          err.found = streamSize;
          err.expected = opts.size;
          err.sri = sri;
          stream.emit("error", err);
        } else if (opts.integrity && !match2) {
          const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);
          err.code = "EINTEGRITY";
          err.found = newSri;
          err.expected = digests;
          err.algorithm = algorithm;
          err.sri = sri;
          stream.emit("error", err);
        } else {
          stream.emit("size", streamSize);
          stream.emit("integrity", newSri);
          match2 && stream.emit("verified", match2);
        }
      });
      return stream;
    }
    module2.exports.create = createIntegrity;
    function createIntegrity(opts) {
      opts = SsriOpts(opts);
      const algorithms = opts.algorithms;
      const optString = opts.options.length ? `?${opts.options.join("?")}` : "";
      const hashes = algorithms.map(crypto2.createHash);
      return {
        update: function(chunk, enc) {
          hashes.forEach((h) => h.update(chunk, enc));
          return this;
        },
        digest: function(enc) {
          const integrity = algorithms.reduce((acc, algo) => {
            const digest = hashes.shift().digest("base64");
            const hash = new Hash(`${algo}-${digest}${optString}`, opts);
            if (hash.algorithm && hash.digest) {
              const algo2 = hash.algorithm;
              if (!acc[algo2]) {
                acc[algo2] = [];
              }
              acc[algo2].push(hash);
            }
            return acc;
          }, new Integrity());
          return integrity;
        }
      };
    }
    var NODE_HASHES = new Set(crypto2.getHashes());
    var DEFAULT_PRIORITY = [
      "md5",
      "whirlpool",
      "sha1",
      "sha224",
      "sha256",
      "sha384",
      "sha512",
      "sha3",
      "sha3-256",
      "sha3-384",
      "sha3-512",
      "sha3_256",
      "sha3_384",
      "sha3_512"
    ].filter((algo) => NODE_HASHES.has(algo));
    function getPrioritizedHash(algo1, algo2) {
      return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\polyfills.ts
  var import_fromentries = __toModule(require_fromentries());
  if (!Object.fromEntries)
    Object.fromEntries = import_fromentries.default;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\index.ts
  var sources_exports4 = {};
  __export(sources_exports4, {
    BuildType: () => BuildType,
    Cache: () => Cache,
    Configuration: () => Configuration,
    DEFAULT_LOCK_FILENAME: () => DEFAULT_LOCK_FILENAME,
    DEFAULT_RC_FILENAME: () => DEFAULT_RC_FILENAME,
    FormatType: () => FormatType,
    LightReport: () => LightReport,
    LinkType: () => LinkType,
    Manifest: () => Manifest,
    MessageName: () => MessageName,
    PackageExtensionStatus: () => PackageExtensionStatus,
    PackageExtensionType: () => PackageExtensionType,
    Project: () => Project,
    ProjectLookup: () => ProjectLookup,
    Report: () => Report,
    ReportError: () => ReportError,
    SettingsType: () => SettingsType,
    StreamReport: () => StreamReport,
    TAG_REGEXP: () => TAG_REGEXP,
    TelemetryManager: () => TelemetryManager,
    ThrowReport: () => ThrowReport,
    VirtualFetcher: () => VirtualFetcher,
    Workspace: () => Workspace,
    WorkspaceResolver: () => WorkspaceResolver,
    YarnVersion: () => YarnVersion,
    execUtils: () => execUtils_exports,
    folderUtils: () => folderUtils_exports,
    formatUtils: () => formatUtils_exports,
    hashUtils: () => hashUtils_exports,
    httpUtils: () => httpUtils_exports,
    miscUtils: () => miscUtils10,
    scriptUtils: () => scriptUtils_exports,
    semverUtils: () => semverUtils_exports,
    structUtils: () => structUtils_exports,
    tgzUtils: () => tgzUtils_exports,
    treeUtils: () => treeUtils_exports
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\execUtils.ts
  var execUtils_exports = {};
  __export(execUtils_exports, {
    EndStrategy: () => EndStrategy,
    execvp: () => execvp,
    pipevp: () => pipevp
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\index.ts
  var sources_exports = {};
  __export(sources_exports, {
    AliasFS: () => AliasFS,
    CwdFS: () => CwdFS,
    DEFAULT_COMPRESSION_LEVEL: () => DEFAULT_COMPRESSION_LEVEL,
    FakeFS: () => FakeFS,
    Filename: () => Filename,
    JailFS: () => JailFS,
    LazyFS: () => LazyFS,
    NoFS: () => NoFS,
    NodeFS: () => NodeFS,
    PortablePath: () => PortablePath2,
    PosixFS: () => PosixFS,
    ProxiedFS: () => ProxiedFS,
    VirtualFS: () => VirtualFS,
    ZipFS: () => ZipFS,
    ZipOpenFS: () => ZipOpenFS,
    extendFs: () => extendFs,
    normalizeLineEndings: () => normalizeLineEndings,
    npath: () => npath,
    opendir: () => opendir,
    patchFs: () => patchFs,
    ppath: () => ppath,
    statUtils: () => statUtils_exports,
    toFilename: () => toFilename,
    xfs: () => xfs
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\statUtils.ts
  var statUtils_exports = {};
  __export(statUtils_exports, {
    BigIntStatsEntry: () => BigIntStatsEntry,
    DirEntry: () => DirEntry,
    StatEntry: () => StatEntry,
    areStatsEqual: () => areStatsEqual,
    clearStats: () => clearStats,
    convertToBigIntStats: () => convertToBigIntStats,
    makeDefaultStats: () => makeDefaultStats,
    makeEmptyStats: () => makeEmptyStats
  });
  var nodeUtils = __toModule(require("util"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\constants.ts
  var S_IFMT = 61440;
  var S_IFDIR = 16384;
  var S_IFREG = 32768;
  var S_IFLNK = 40960;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\statUtils.ts
  var DirEntry = class {
    constructor() {
      this.name = ``;
      this.mode = 0;
    }
    isBlockDevice() {
      return false;
    }
    isCharacterDevice() {
      return false;
    }
    isDirectory() {
      return (this.mode & S_IFMT) === S_IFDIR;
    }
    isFIFO() {
      return false;
    }
    isFile() {
      return (this.mode & S_IFMT) === S_IFREG;
    }
    isSocket() {
      return false;
    }
    isSymbolicLink() {
      return (this.mode & S_IFMT) === S_IFLNK;
    }
  };
  var StatEntry = class {
    constructor() {
      this.uid = 0;
      this.gid = 0;
      this.size = 0;
      this.blksize = 0;
      this.atimeMs = 0;
      this.mtimeMs = 0;
      this.ctimeMs = 0;
      this.birthtimeMs = 0;
      this.atime = new Date(0);
      this.mtime = new Date(0);
      this.ctime = new Date(0);
      this.birthtime = new Date(0);
      this.dev = 0;
      this.ino = 0;
      this.mode = S_IFREG | 420;
      this.nlink = 1;
      this.rdev = 0;
      this.blocks = 1;
    }
    isBlockDevice() {
      return false;
    }
    isCharacterDevice() {
      return false;
    }
    isDirectory() {
      return (this.mode & S_IFMT) === S_IFDIR;
    }
    isFIFO() {
      return false;
    }
    isFile() {
      return (this.mode & S_IFMT) === S_IFREG;
    }
    isSocket() {
      return false;
    }
    isSymbolicLink() {
      return (this.mode & S_IFMT) === S_IFLNK;
    }
  };
  var BigIntStatsEntry = class {
    constructor() {
      this.uid = BigInt(0);
      this.gid = BigInt(0);
      this.size = BigInt(0);
      this.blksize = BigInt(0);
      this.atimeMs = BigInt(0);
      this.mtimeMs = BigInt(0);
      this.ctimeMs = BigInt(0);
      this.birthtimeMs = BigInt(0);
      this.atimeNs = BigInt(0);
      this.mtimeNs = BigInt(0);
      this.ctimeNs = BigInt(0);
      this.birthtimeNs = BigInt(0);
      this.atime = new Date(0);
      this.mtime = new Date(0);
      this.ctime = new Date(0);
      this.birthtime = new Date(0);
      this.dev = BigInt(0);
      this.ino = BigInt(0);
      this.mode = BigInt(S_IFREG | 420);
      this.nlink = BigInt(1);
      this.rdev = BigInt(0);
      this.blocks = BigInt(1);
    }
    isBlockDevice() {
      return false;
    }
    isCharacterDevice() {
      return false;
    }
    isDirectory() {
      return (this.mode & BigInt(S_IFMT)) === BigInt(S_IFDIR);
    }
    isFIFO() {
      return false;
    }
    isFile() {
      return (this.mode & BigInt(S_IFMT)) === BigInt(S_IFREG);
    }
    isSocket() {
      return false;
    }
    isSymbolicLink() {
      return (this.mode & BigInt(S_IFMT)) === BigInt(S_IFLNK);
    }
  };
  function makeDefaultStats() {
    return new StatEntry();
  }
  function makeEmptyStats() {
    return clearStats(makeDefaultStats());
  }
  function clearStats(stats) {
    for (const key in stats) {
      if (Object.prototype.hasOwnProperty.call(stats, key)) {
        const element = stats[key];
        if (typeof element === `number`) {
          stats[key] = 0;
        } else if (typeof element === `bigint`) {
          stats[key] = BigInt(0);
        } else if (nodeUtils.types.isDate(element)) {
          stats[key] = new Date(0);
        }
      }
    }
    return stats;
  }
  function convertToBigIntStats(stats) {
    const bigintStats = new BigIntStatsEntry();
    for (const key in stats) {
      if (Object.prototype.hasOwnProperty.call(stats, key)) {
        const element = stats[key];
        if (typeof element === `number`) {
          bigintStats[key] = BigInt(element);
        } else if (nodeUtils.types.isDate(element)) {
          bigintStats[key] = new Date(element);
        }
      }
    }
    bigintStats.atimeNs = bigintStats.atimeMs * BigInt(1e6);
    bigintStats.mtimeNs = bigintStats.mtimeMs * BigInt(1e6);
    bigintStats.ctimeNs = bigintStats.ctimeMs * BigInt(1e6);
    bigintStats.birthtimeNs = bigintStats.birthtimeMs * BigInt(1e6);
    return bigintStats;
  }
  function areStatsEqual(a, b) {
    if (a.atimeMs !== b.atimeMs)
      return false;
    if (a.birthtimeMs !== b.birthtimeMs)
      return false;
    if (a.blksize !== b.blksize)
      return false;
    if (a.blocks !== b.blocks)
      return false;
    if (a.ctimeMs !== b.ctimeMs)
      return false;
    if (a.dev !== b.dev)
      return false;
    if (a.gid !== b.gid)
      return false;
    if (a.ino !== b.ino)
      return false;
    if (a.isBlockDevice() !== b.isBlockDevice())
      return false;
    if (a.isCharacterDevice() !== b.isCharacterDevice())
      return false;
    if (a.isDirectory() !== b.isDirectory())
      return false;
    if (a.isFIFO() !== b.isFIFO())
      return false;
    if (a.isFile() !== b.isFile())
      return false;
    if (a.isSocket() !== b.isSocket())
      return false;
    if (a.isSymbolicLink() !== b.isSymbolicLink())
      return false;
    if (a.mode !== b.mode)
      return false;
    if (a.mtimeMs !== b.mtimeMs)
      return false;
    if (a.nlink !== b.nlink)
      return false;
    if (a.rdev !== b.rdev)
      return false;
    if (a.size !== b.size)
      return false;
    if (a.uid !== b.uid)
      return false;
    const aN = a;
    const bN = b;
    if (aN.atimeNs !== bN.atimeNs)
      return false;
    if (aN.mtimeNs !== bN.mtimeNs)
      return false;
    if (aN.ctimeNs !== bN.ctimeNs)
      return false;
    if (aN.birthtimeNs !== bN.birthtimeNs)
      return false;
    return true;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\errors.ts
  function makeError(code, message) {
    return Object.assign(new Error(`${code}: ${message}`), {code});
  }
  function EBUSY(message) {
    return makeError(`EBUSY`, message);
  }
  function ENOSYS(message, reason) {
    return makeError(`ENOSYS`, `${message}, ${reason}`);
  }
  function EINVAL(reason) {
    return makeError(`EINVAL`, `invalid argument, ${reason}`);
  }
  function EBADF(reason) {
    return makeError(`EBADF`, `bad file descriptor, ${reason}`);
  }
  function ENOENT(reason) {
    return makeError(`ENOENT`, `no such file or directory, ${reason}`);
  }
  function ENOTDIR(reason) {
    return makeError(`ENOTDIR`, `not a directory, ${reason}`);
  }
  function EISDIR(reason) {
    return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
  }
  function EEXIST(reason) {
    return makeError(`EEXIST`, `file already exists, ${reason}`);
  }
  function EROFS(reason) {
    return makeError(`EROFS`, `read-only filesystem, ${reason}`);
  }
  function ENOTEMPTY(reason) {
    return makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
  }
  function EOPNOTSUPP(reason) {
    return makeError(`EOPNOTSUPP`, `operation not supported, ${reason}`);
  }
  function ERR_DIR_CLOSED() {
    return makeError(`ERR_DIR_CLOSED`, `Directory handle was closed`);
  }
  var LibzipError = class extends Error {
    constructor(message, code) {
      super(message);
      this.name = `Libzip Error`;
      this.code = code;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\algorithms\opendir.ts
  var CustomDir = class {
    constructor(path6, nextDirent, opts = {}) {
      this.path = path6;
      this.nextDirent = nextDirent;
      this.opts = opts;
      this.closed = false;
    }
    throwIfClosed() {
      if (this.closed) {
        throw ERR_DIR_CLOSED();
      }
    }
    async *[Symbol.asyncIterator]() {
      try {
        let dirent;
        while ((dirent = await this.read()) !== null) {
          yield dirent;
        }
      } finally {
        await this.close();
      }
    }
    read(cb) {
      const dirent = this.readSync();
      if (typeof cb !== `undefined`)
        return cb(null, dirent);
      return Promise.resolve(dirent);
    }
    readSync() {
      this.throwIfClosed();
      return this.nextDirent();
    }
    close(cb) {
      this.closeSync();
      if (typeof cb !== `undefined`)
        return cb(null);
      return Promise.resolve();
    }
    closeSync() {
      var _a2, _b;
      this.throwIfClosed();
      (_b = (_a2 = this.opts).onClose) == null ? void 0 : _b.call(_a2);
      this.closed = true;
    }
  };
  function opendir(fakeFs, path6, entries, opts) {
    const nextDirent = () => {
      const filename = entries.shift();
      if (typeof filename === `undefined`)
        return null;
      return Object.assign(fakeFs.statSync(fakeFs.pathUtils.join(path6, filename)), {
        name: filename
      });
    };
    return new CustomDir(path6, nextDirent, opts);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\FakeFS.ts
  var import_os = __toModule(require("os"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\algorithms\copyPromise.ts
  var import_fs = __toModule(require("fs"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\path.ts
  var import_path = __toModule(require("path"));
  var PathType;
  (function(PathType2) {
    PathType2[PathType2["File"] = 0] = "File";
    PathType2[PathType2["Portable"] = 1] = "Portable";
    PathType2[PathType2["Native"] = 2] = "Native";
  })(PathType || (PathType = {}));
  var PortablePath2 = {
    root: `/`,
    dot: `.`
  };
  var Filename = {
    nodeModules: `node_modules`,
    manifest: `package.json`,
    lockfile: `yarn.lock`,
    pnpJs: `.pnp.js`,
    pnpCjs: `.pnp.cjs`,
    rc: `.yarnrc.yml`
  };
  var npath = Object.create(import_path.default);
  var ppath = Object.create(import_path.default.posix);
  npath.cwd = () => process.cwd();
  ppath.cwd = () => toPortablePath(process.cwd());
  ppath.resolve = (...segments) => {
    if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
      return import_path.default.posix.resolve(...segments);
    } else {
      return import_path.default.posix.resolve(ppath.cwd(), ...segments);
    }
  };
  var contains = function(pathUtils, from, to) {
    from = pathUtils.normalize(from);
    to = pathUtils.normalize(to);
    if (from === to)
      return `.`;
    if (!from.endsWith(pathUtils.sep))
      from = from + pathUtils.sep;
    if (to.startsWith(from)) {
      return to.slice(from.length);
    } else {
      return null;
    }
  };
  npath.fromPortablePath = fromPortablePath;
  npath.toPortablePath = toPortablePath;
  npath.contains = (from, to) => contains(npath, from, to);
  ppath.contains = (from, to) => contains(ppath, from, to);
  var WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
  var UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
  var PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
  var UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
  function fromPortablePath(p) {
    if (process.platform !== `win32`)
      return p;
    if (p.match(PORTABLE_PATH_REGEXP))
      p = p.replace(PORTABLE_PATH_REGEXP, `$1`);
    else if (p.match(UNC_PORTABLE_PATH_REGEXP))
      p = p.replace(UNC_PORTABLE_PATH_REGEXP, (match2, p1, p2) => `\\\\${p1 ? `.\\` : ``}${p2}`);
    else
      return p;
    return p.replace(/\//g, `\\`);
  }
  function toPortablePath(p) {
    if (process.platform !== `win32`)
      return p;
    if (p.match(WINDOWS_PATH_REGEXP))
      p = p.replace(WINDOWS_PATH_REGEXP, `/$1`);
    else if (p.match(UNC_WINDOWS_PATH_REGEXP))
      p = p.replace(UNC_WINDOWS_PATH_REGEXP, (match2, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
    return p.replace(/\\/g, `/`);
  }
  function convertPath(targetPathUtils, sourcePath) {
    return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
  }
  function toFilename(filename) {
    if (npath.parse(filename).dir !== `` || ppath.parse(filename).dir !== ``)
      throw new Error(`Invalid filename: "${filename}"`);
    return filename;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\algorithms\copyPromise.ts
  var defaultTime = new Date(315532800 * 1e3);
  async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
    const normalizedDestination = destinationFs.pathUtils.normalize(destination);
    const normalizedSource = sourceFs.pathUtils.normalize(source);
    const prelayout = [];
    const postlayout = [];
    await destinationFs.mkdirPromise(destinationFs.pathUtils.dirname(destination), {recursive: true});
    const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
    await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, opts);
    for (const operation of prelayout)
      await operation();
    await Promise.all(postlayout.map((operation) => {
      return operation();
    }));
  }
  async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
    var _a2, _b;
    const destinationStat = await maybeLStat(destinationFs, destination);
    const sourceStat = await sourceFs.lstatPromise(source);
    const referenceTime = opts.stableTime ? {mtime: defaultTime, atime: defaultTime} : sourceStat;
    let updated;
    switch (true) {
      case sourceStat.isDirectory():
        {
          updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
        }
        break;
      case sourceStat.isFile():
        {
          updated = await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
        }
        break;
      case sourceStat.isSymbolicLink():
        {
          updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
        }
        break;
      default:
        {
          throw new Error(`Unsupported file type (${sourceStat.mode})`);
        }
        break;
    }
    if (updated || ((_a2 = destinationStat == null ? void 0 : destinationStat.mtime) == null ? void 0 : _a2.getTime()) !== referenceTime.mtime.getTime() || ((_b = destinationStat == null ? void 0 : destinationStat.atime) == null ? void 0 : _b.getTime()) !== referenceTime.atime.getTime()) {
      postlayout.push(() => updateTime(destination, referenceTime.atime, referenceTime.mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
    return updated;
  }
  async function maybeLStat(baseFs, p) {
    try {
      return await baseFs.lstatPromise(p);
    } catch (e) {
      return null;
    }
  }
  async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
    if (destinationStat !== null && !destinationStat.isDirectory()) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
    let updated = false;
    if (destinationStat === null) {
      prelayout.push(async () => destinationFs.mkdirPromise(destination, {mode: sourceStat.mode}));
      updated = true;
    }
    const entries = await sourceFs.readdirPromise(source);
    if (opts.stableSort) {
      for (const entry of entries.sort()) {
        if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts)) {
          updated = true;
        }
      }
    } else {
      const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
        await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
      }));
      if (entriesUpdateStatus.some((status) => status)) {
        updated = true;
      }
    }
    return updated;
  }
  async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
    if (destinationStat !== null) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
    const op = destinationFs === sourceFs ? async () => destinationFs.copyFilePromise(source, destination, import_fs.default.constants.COPYFILE_FICLONE) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
    prelayout.push(async () => op());
    return true;
  }
  async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
    if (destinationStat !== null) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
    prelayout.push(async () => {
      await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
    });
    return true;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\FakeFS.ts
  var FakeFS = class {
    constructor(pathUtils) {
      this.pathUtils = pathUtils;
    }
    async *genTraversePromise(init, {stableSort = false} = {}) {
      const stack = [init];
      while (stack.length > 0) {
        const p = stack.shift();
        const entry = await this.lstatPromise(p);
        if (entry.isDirectory()) {
          const entries = await this.readdirPromise(p);
          if (stableSort) {
            for (const entry2 of entries.sort()) {
              stack.push(this.pathUtils.join(p, entry2));
            }
          } else {
            throw new Error(`Not supported`);
          }
        } else {
          yield p;
        }
      }
    }
    async removePromise(p, {recursive = true, maxRetries = 5} = {}) {
      let stat;
      try {
        stat = await this.lstatPromise(p);
      } catch (error) {
        if (error.code === `ENOENT`) {
          return;
        } else {
          throw error;
        }
      }
      if (stat.isDirectory()) {
        if (recursive)
          for (const entry of await this.readdirPromise(p))
            await this.removePromise(this.pathUtils.resolve(p, entry));
        let t7 = 0;
        do {
          try {
            await this.rmdirPromise(p);
            break;
          } catch (error) {
            if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
              if (maxRetries === 0) {
                break;
              } else {
                await new Promise((resolve) => setTimeout(resolve, t7 * 100));
                continue;
              }
            } else {
              throw error;
            }
          }
        } while (t7++ < maxRetries);
      } else {
        await this.unlinkPromise(p);
      }
    }
    removeSync(p, {recursive = true} = {}) {
      let stat;
      try {
        stat = this.lstatSync(p);
      } catch (error) {
        if (error.code === `ENOENT`) {
          return;
        } else {
          throw error;
        }
      }
      if (stat.isDirectory()) {
        if (recursive)
          for (const entry of this.readdirSync(p))
            this.removeSync(this.pathUtils.resolve(p, entry));
        this.rmdirSync(p);
      } else {
        this.unlinkSync(p);
      }
    }
    async mkdirpPromise(p, {chmod, utimes} = {}) {
      p = this.resolve(p);
      if (p === this.pathUtils.dirname(p))
        return;
      const parts = p.split(this.pathUtils.sep);
      for (let u = 2; u <= parts.length; ++u) {
        const subPath = parts.slice(0, u).join(this.pathUtils.sep);
        if (!this.existsSync(subPath)) {
          try {
            await this.mkdirPromise(subPath);
          } catch (error) {
            if (error.code === `EEXIST`) {
              continue;
            } else {
              throw error;
            }
          }
          if (chmod != null)
            await this.chmodPromise(subPath, chmod);
          if (utimes != null) {
            await this.utimesPromise(subPath, utimes[0], utimes[1]);
          } else {
            const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
            await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
          }
        }
      }
    }
    mkdirpSync(p, {chmod, utimes} = {}) {
      p = this.resolve(p);
      if (p === this.pathUtils.dirname(p))
        return;
      const parts = p.split(this.pathUtils.sep);
      for (let u = 2; u <= parts.length; ++u) {
        const subPath = parts.slice(0, u).join(this.pathUtils.sep);
        if (!this.existsSync(subPath)) {
          try {
            this.mkdirSync(subPath);
          } catch (error) {
            if (error.code === `EEXIST`) {
              continue;
            } else {
              throw error;
            }
          }
          if (chmod != null)
            this.chmodSync(subPath, chmod);
          if (utimes != null) {
            this.utimesSync(subPath, utimes[0], utimes[1]);
          } else {
            const parentStat = this.statSync(this.pathUtils.dirname(subPath));
            this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
          }
        }
      }
    }
    async copyPromise(destination, source, {baseFs = this, overwrite = true, stableSort = false, stableTime = false} = {}) {
      return await copyPromise(this, destination, baseFs, source, {overwrite, stableSort, stableTime});
    }
    copySync(destination, source, {baseFs = this, overwrite = true} = {}) {
      const stat = baseFs.lstatSync(source);
      const exists = this.existsSync(destination);
      if (stat.isDirectory()) {
        this.mkdirpSync(destination);
        const directoryListing = baseFs.readdirSync(source);
        for (const entry of directoryListing) {
          this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {baseFs, overwrite});
        }
      } else if (stat.isFile()) {
        if (!exists || overwrite) {
          if (exists)
            this.removeSync(destination);
          const content = baseFs.readFileSync(source);
          this.writeFileSync(destination, content);
        }
      } else if (stat.isSymbolicLink()) {
        if (!exists || overwrite) {
          if (exists)
            this.removeSync(destination);
          const target = baseFs.readlinkSync(source);
          this.symlinkSync(convertPath(this.pathUtils, target), destination);
        }
      } else {
        throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
      }
      const mode = stat.mode & 511;
      this.chmodSync(destination, mode);
    }
    async changeFilePromise(p, content, opts = {}) {
      if (Buffer.isBuffer(content)) {
        return this.changeFileBufferPromise(p, content);
      } else {
        return this.changeFileTextPromise(p, content, opts);
      }
    }
    async changeFileBufferPromise(p, content) {
      let current = Buffer.alloc(0);
      try {
        current = await this.readFilePromise(p);
      } catch (error) {
      }
      if (Buffer.compare(current, content) === 0)
        return;
      await this.writeFilePromise(p, content);
    }
    async changeFileTextPromise(p, content, {automaticNewlines} = {}) {
      let current = ``;
      try {
        current = await this.readFilePromise(p, `utf8`);
      } catch (error) {
      }
      const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
      if (current === normalizedContent)
        return;
      await this.writeFilePromise(p, normalizedContent);
    }
    changeFileSync(p, content, opts = {}) {
      if (Buffer.isBuffer(content)) {
        return this.changeFileBufferSync(p, content);
      } else {
        return this.changeFileTextSync(p, content, opts);
      }
    }
    changeFileBufferSync(p, content) {
      let current = Buffer.alloc(0);
      try {
        current = this.readFileSync(p);
      } catch (error) {
      }
      if (Buffer.compare(current, content) === 0)
        return;
      this.writeFileSync(p, content);
    }
    changeFileTextSync(p, content, {automaticNewlines = false} = {}) {
      let current = ``;
      try {
        current = this.readFileSync(p, `utf8`);
      } catch (error) {
      }
      const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
      if (current === normalizedContent)
        return;
      this.writeFileSync(p, normalizedContent);
    }
    async movePromise(fromP, toP) {
      try {
        await this.renamePromise(fromP, toP);
      } catch (error) {
        if (error.code === `EXDEV`) {
          await this.copyPromise(toP, fromP);
          await this.removePromise(fromP);
        } else {
          throw error;
        }
      }
    }
    moveSync(fromP, toP) {
      try {
        this.renameSync(fromP, toP);
      } catch (error) {
        if (error.code === `EXDEV`) {
          this.copySync(toP, fromP);
          this.removeSync(fromP);
        } else {
          throw error;
        }
      }
    }
    async lockPromise(affectedPath, callback) {
      const lockPath = `${affectedPath}.flock`;
      const interval = 1e3 / 60;
      const startTime = Date.now();
      let fd = null;
      const isAlive = async () => {
        let pid;
        try {
          [pid] = await this.readJsonPromise(lockPath);
        } catch (error) {
          return Date.now() - startTime < 500;
        }
        try {
          process.kill(pid, 0);
          return true;
        } catch (error) {
          return false;
        }
      };
      while (fd === null) {
        try {
          fd = await this.openPromise(lockPath, `wx`);
        } catch (error) {
          if (error.code === `EEXIST`) {
            if (!await isAlive()) {
              try {
                await this.unlinkPromise(lockPath);
                continue;
              } catch (error2) {
              }
            }
            if (Date.now() - startTime < 60 * 1e3) {
              await new Promise((resolve) => setTimeout(resolve, interval));
            } else {
              throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
            }
          } else {
            throw error;
          }
        }
      }
      await this.writePromise(fd, JSON.stringify([process.pid]));
      try {
        return await callback();
      } finally {
        try {
          await this.closePromise(fd);
          await this.unlinkPromise(lockPath);
        } catch (error) {
        }
      }
    }
    async readJsonPromise(p) {
      const content = await this.readFilePromise(p, `utf8`);
      try {
        return JSON.parse(content);
      } catch (error) {
        error.message += ` (in ${p})`;
        throw error;
      }
    }
    readJsonSync(p) {
      const content = this.readFileSync(p, `utf8`);
      try {
        return JSON.parse(content);
      } catch (error) {
        error.message += ` (in ${p})`;
        throw error;
      }
    }
    async writeJsonPromise(p, data) {
      return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}
`);
    }
    writeJsonSync(p, data) {
      return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}
`);
    }
    async preserveTimePromise(p, cb) {
      const stat = await this.lstatPromise(p);
      const result = await cb();
      if (typeof result !== `undefined`)
        p = result;
      if (this.lutimesPromise) {
        await this.lutimesPromise(p, stat.atime, stat.mtime);
      } else if (!stat.isSymbolicLink()) {
        await this.utimesPromise(p, stat.atime, stat.mtime);
      }
    }
    async preserveTimeSync(p, cb) {
      const stat = this.lstatSync(p);
      const result = cb();
      if (typeof result !== `undefined`)
        p = result;
      if (this.lutimesSync) {
        this.lutimesSync(p, stat.atime, stat.mtime);
      } else if (!stat.isSymbolicLink()) {
        this.utimesSync(p, stat.atime, stat.mtime);
      }
    }
  };
  FakeFS.DEFAULT_TIME = 315532800;
  var BasePortableFakeFS = class extends FakeFS {
    constructor() {
      super(ppath);
    }
  };
  function getEndOfLine(content) {
    const matches = content.match(/\r?\n/g);
    if (matches === null)
      return import_os.EOL;
    const crlf = matches.filter((nl) => nl === `\r
`).length;
    const lf = matches.length - crlf;
    return crlf > lf ? `\r
` : `
`;
  }
  function normalizeLineEndings(originalContent, newContent) {
    return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\ZipFS.ts
  var import_fs3 = __toModule(require("fs"));
  var import_stream = __toModule(require("stream"));
  var import_util = __toModule(require("util"));
  var import_zlib = __toModule(require("zlib"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\NodeFS.ts
  var import_fs2 = __toModule(require("fs"));
  var NodeFS = class extends BasePortableFakeFS {
    constructor(realFs = import_fs2.default) {
      super();
      this.realFs = realFs;
      if (typeof this.realFs.lutimes !== `undefined`) {
        this.lutimesPromise = this.lutimesPromiseImpl;
        this.lutimesSync = this.lutimesSyncImpl;
      }
    }
    getExtractHint() {
      return false;
    }
    getRealPath() {
      return PortablePath2.root;
    }
    resolve(p) {
      return ppath.resolve(p);
    }
    async openPromise(p, flags, mode) {
      return await new Promise((resolve, reject) => {
        this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
      });
    }
    openSync(p, flags, mode) {
      return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
    }
    async opendirPromise(p, opts) {
      return await new Promise((resolve, reject) => {
        if (typeof opts !== `undefined`) {
          this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
        }
      }).then((dir) => {
        return Object.defineProperty(dir, `path`, {value: p, configurable: true, writable: true});
      });
    }
    opendirSync(p, opts) {
      const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
      return Object.defineProperty(dir, `path`, {value: p, configurable: true, writable: true});
    }
    async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
      return await new Promise((resolve, reject) => {
        this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
          if (error) {
            reject(error);
          } else {
            resolve(bytesRead);
          }
        });
      });
    }
    readSync(fd, buffer, offset, length, position) {
      return this.realFs.readSync(fd, buffer, offset, length, position);
    }
    async writePromise(fd, buffer, offset, length, position) {
      return await new Promise((resolve, reject) => {
        if (typeof buffer === `string`) {
          return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
        } else {
          return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
        }
      });
    }
    writeSync(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return this.realFs.writeSync(fd, buffer, offset);
      } else {
        return this.realFs.writeSync(fd, buffer, offset, length, position);
      }
    }
    async closePromise(fd) {
      await new Promise((resolve, reject) => {
        this.realFs.close(fd, this.makeCallback(resolve, reject));
      });
    }
    closeSync(fd) {
      this.realFs.closeSync(fd);
    }
    createReadStream(p, opts) {
      const realPath = p !== null ? npath.fromPortablePath(p) : p;
      return this.realFs.createReadStream(realPath, opts);
    }
    createWriteStream(p, opts) {
      const realPath = p !== null ? npath.fromPortablePath(p) : p;
      return this.realFs.createWriteStream(realPath, opts);
    }
    async realpathPromise(p) {
      return await new Promise((resolve, reject) => {
        this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
      }).then((path6) => {
        return npath.toPortablePath(path6);
      });
    }
    realpathSync(p) {
      return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
    }
    async existsPromise(p) {
      return await new Promise((resolve) => {
        this.realFs.exists(npath.fromPortablePath(p), resolve);
      });
    }
    accessSync(p, mode) {
      return this.realFs.accessSync(npath.fromPortablePath(p), mode);
    }
    async accessPromise(p, mode) {
      return await new Promise((resolve, reject) => {
        this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
      });
    }
    existsSync(p) {
      return this.realFs.existsSync(npath.fromPortablePath(p));
    }
    async statPromise(p, opts) {
      return await new Promise((resolve, reject) => {
        if (opts) {
          this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
        }
      });
    }
    statSync(p, opts) {
      if (opts) {
        return this.realFs.statSync(npath.fromPortablePath(p), opts);
      } else {
        return this.realFs.statSync(npath.fromPortablePath(p));
      }
    }
    async fstatPromise(fd, opts) {
      return await new Promise((resolve, reject) => {
        if (opts) {
          this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.fstat(fd, this.makeCallback(resolve, reject));
        }
      });
    }
    fstatSync(fd, opts) {
      if (opts) {
        return this.realFs.fstatSync(fd, opts);
      } else {
        return this.realFs.fstatSync(fd);
      }
    }
    async lstatPromise(p, opts) {
      return await new Promise((resolve, reject) => {
        if (opts) {
          this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
        }
      });
    }
    lstatSync(p, opts) {
      if (opts) {
        return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
      } else {
        return this.realFs.lstatSync(npath.fromPortablePath(p));
      }
    }
    async chmodPromise(p, mask) {
      return await new Promise((resolve, reject) => {
        this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
      });
    }
    chmodSync(p, mask) {
      return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
    }
    async chownPromise(p, uid, gid) {
      return await new Promise((resolve, reject) => {
        this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
      });
    }
    chownSync(p, uid, gid) {
      return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
    }
    async renamePromise(oldP, newP) {
      return await new Promise((resolve, reject) => {
        this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
      });
    }
    renameSync(oldP, newP) {
      return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
    }
    async copyFilePromise(sourceP, destP, flags = 0) {
      return await new Promise((resolve, reject) => {
        this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
      });
    }
    copyFileSync(sourceP, destP, flags = 0) {
      return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
    }
    async appendFilePromise(p, content, opts) {
      return await new Promise((resolve, reject) => {
        const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
        if (opts) {
          this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
        }
      });
    }
    appendFileSync(p, content, opts) {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFileSync(fsNativePath, content, opts);
      } else {
        this.realFs.appendFileSync(fsNativePath, content);
      }
    }
    async writeFilePromise(p, content, opts) {
      return await new Promise((resolve, reject) => {
        const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
        if (opts) {
          this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
        }
      });
    }
    writeFileSync(p, content, opts) {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFileSync(fsNativePath, content, opts);
      } else {
        this.realFs.writeFileSync(fsNativePath, content);
      }
    }
    async unlinkPromise(p) {
      return await new Promise((resolve, reject) => {
        this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      });
    }
    unlinkSync(p) {
      return this.realFs.unlinkSync(npath.fromPortablePath(p));
    }
    async utimesPromise(p, atime, mtime) {
      return await new Promise((resolve, reject) => {
        this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
      });
    }
    utimesSync(p, atime, mtime) {
      this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
    }
    async lutimesPromiseImpl(p, atime, mtime) {
      const lutimes = this.realFs.lutimes;
      if (typeof lutimes === `undefined`)
        throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
      return await new Promise((resolve, reject) => {
        lutimes.call(this.realFs, npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
      });
    }
    lutimesSyncImpl(p, atime, mtime) {
      const lutimesSync = this.realFs.lutimesSync;
      if (typeof lutimesSync === `undefined`)
        throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
      lutimesSync.call(this.realFs, npath.fromPortablePath(p), atime, mtime);
    }
    async mkdirPromise(p, opts) {
      return await new Promise((resolve, reject) => {
        this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      });
    }
    mkdirSync(p, opts) {
      return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
    }
    async rmdirPromise(p, opts) {
      return await new Promise((resolve, reject) => {
        if (opts) {
          this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        } else {
          this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
        }
      });
    }
    rmdirSync(p, opts) {
      return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
    }
    async linkPromise(existingP, newP) {
      return await new Promise((resolve, reject) => {
        this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
      });
    }
    linkSync(existingP, newP) {
      return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
    }
    async symlinkPromise(target, p, type) {
      const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
      return await new Promise((resolve, reject) => {
        this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), symlinkType, this.makeCallback(resolve, reject));
      });
    }
    symlinkSync(target, p, type) {
      const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
      return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), symlinkType);
    }
    async readFilePromise(p, encoding) {
      return await new Promise((resolve, reject) => {
        const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
        this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
      });
    }
    readFileSync(p, encoding) {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      return this.realFs.readFileSync(fsNativePath, encoding);
    }
    async readdirPromise(p, {withFileTypes} = {}) {
      return await new Promise((resolve, reject) => {
        if (withFileTypes) {
          this.realFs.readdir(npath.fromPortablePath(p), {withFileTypes: true}, this.makeCallback(resolve, reject));
        } else {
          this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
        }
      });
    }
    readdirSync(p, {withFileTypes} = {}) {
      if (withFileTypes) {
        return this.realFs.readdirSync(npath.fromPortablePath(p), {withFileTypes: true});
      } else {
        return this.realFs.readdirSync(npath.fromPortablePath(p));
      }
    }
    async readlinkPromise(p) {
      return await new Promise((resolve, reject) => {
        this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }).then((path6) => {
        return npath.toPortablePath(path6);
      });
    }
    readlinkSync(p) {
      return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
    }
    async truncatePromise(p, len) {
      return await new Promise((resolve, reject) => {
        this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
      });
    }
    truncateSync(p, len) {
      return this.realFs.truncateSync(npath.fromPortablePath(p), len);
    }
    watch(p, a, b) {
      return this.realFs.watch(npath.fromPortablePath(p), a, b);
    }
    watchFile(p, a, b) {
      return this.realFs.watchFile(npath.fromPortablePath(p), a, b);
    }
    unwatchFile(p, cb) {
      return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
    }
    makeCallback(resolve, reject) {
      return (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\algorithms\watchFile\CustomStatWatcher.ts
  var import_events = __toModule(require("events"));
  var Event;
  (function(Event2) {
    Event2["Change"] = `change`;
    Event2["Stop"] = `stop`;
  })(Event || (Event = {}));
  var Status;
  (function(Status2) {
    Status2["Ready"] = `ready`;
    Status2["Running"] = `running`;
    Status2["Stopped"] = `stopped`;
  })(Status || (Status = {}));
  function assertStatus(current, expected) {
    if (current !== expected) {
      throw new Error(`Invalid StatWatcher status: expected '${expected}', got '${current}'`);
    }
  }
  var CustomStatWatcher = class extends import_events.EventEmitter {
    constructor(fakeFs, path6, {bigint = false} = {}) {
      super();
      this.status = Status.Ready;
      this.changeListeners = new Map();
      this.startTimeout = null;
      this.fakeFs = fakeFs;
      this.path = path6;
      this.bigint = bigint;
      this.lastStats = this.stat();
    }
    static create(fakeFs, path6, opts) {
      const statWatcher = new CustomStatWatcher(fakeFs, path6, opts);
      statWatcher.start();
      return statWatcher;
    }
    start() {
      assertStatus(this.status, Status.Ready);
      this.status = Status.Running;
      this.startTimeout = setTimeout(() => {
        this.startTimeout = null;
        if (!this.fakeFs.existsSync(this.path)) {
          this.emit(Event.Change, this.lastStats, this.lastStats);
        }
      }, 3);
    }
    stop() {
      assertStatus(this.status, Status.Running);
      this.status = Status.Stopped;
      if (this.startTimeout !== null) {
        clearTimeout(this.startTimeout);
        this.startTimeout = null;
      }
      this.emit(Event.Stop);
    }
    stat() {
      try {
        return this.fakeFs.statSync(this.path, {bigint: this.bigint});
      } catch (error) {
        if (error.code === `ENOENT`) {
          const statInstance = this.bigint ? new BigIntStatsEntry() : new StatEntry();
          return clearStats(statInstance);
        } else {
          throw error;
        }
      }
    }
    makeInterval(opts) {
      const interval = setInterval(() => {
        const currentStats = this.stat();
        const previousStats = this.lastStats;
        if (areStatsEqual(currentStats, previousStats))
          return;
        this.lastStats = currentStats;
        this.emit(Event.Change, currentStats, previousStats);
      }, opts.interval);
      return opts.persistent ? interval : interval.unref();
    }
    registerChangeListener(listener, opts) {
      this.addListener(Event.Change, listener);
      this.changeListeners.set(listener, this.makeInterval(opts));
    }
    unregisterChangeListener(listener) {
      this.removeListener(Event.Change, listener);
      const interval = this.changeListeners.get(listener);
      if (typeof interval !== `undefined`)
        clearInterval(interval);
      this.changeListeners.delete(listener);
    }
    unregisterAllChangeListeners() {
      for (const listener of this.changeListeners.keys()) {
        this.unregisterChangeListener(listener);
      }
    }
    hasChangeListeners() {
      return this.changeListeners.size > 0;
    }
    ref() {
      for (const interval of this.changeListeners.values())
        interval.ref();
      return this;
    }
    unref() {
      for (const interval of this.changeListeners.values())
        interval.unref();
      return this;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\algorithms\watchFile.ts
  var statWatchersByFakeFS = new WeakMap();
  function watchFile(fakeFs, path6, a, b) {
    let bigint;
    let persistent;
    let interval;
    let listener;
    switch (typeof a) {
      case `function`:
        {
          bigint = false;
          persistent = true;
          interval = 5007;
          listener = a;
        }
        break;
      default:
        {
          ({
            bigint = false,
            persistent = true,
            interval = 5007
          } = a);
          listener = b;
        }
        break;
    }
    let statWatchers = statWatchersByFakeFS.get(fakeFs);
    if (typeof statWatchers === `undefined`)
      statWatchersByFakeFS.set(fakeFs, statWatchers = new Map());
    let statWatcher = statWatchers.get(path6);
    if (typeof statWatcher === `undefined`) {
      statWatcher = CustomStatWatcher.create(fakeFs, path6, {bigint});
      statWatchers.set(path6, statWatcher);
    }
    statWatcher.registerChangeListener(listener, {persistent, interval});
    return statWatcher;
  }
  function unwatchFile(fakeFs, path6, cb) {
    const statWatchers = statWatchersByFakeFS.get(fakeFs);
    if (typeof statWatchers === `undefined`)
      return;
    const statWatcher = statWatchers.get(path6);
    if (typeof statWatcher === `undefined`)
      return;
    if (typeof cb === `undefined`)
      statWatcher.unregisterAllChangeListeners();
    else
      statWatcher.unregisterChangeListener(cb);
    if (!statWatcher.hasChangeListeners()) {
      statWatcher.stop();
      statWatchers.delete(path6);
    }
  }
  function unwatchAllFiles(fakeFs) {
    const statWatchers = statWatchersByFakeFS.get(fakeFs);
    if (typeof statWatchers === `undefined`)
      return;
    for (const path6 of statWatchers.keys()) {
      unwatchFile(fakeFs, path6);
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\ZipFS.ts
  var DEFAULT_COMPRESSION_LEVEL = `mixed`;
  function toUnixTimestamp(time) {
    if (typeof time === `string` && String(+time) === time)
      return +time;
    if (Number.isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      } else {
        return time;
      }
    }
    if (import_util.isDate(time))
      return time.getTime() / 1e3;
    throw new Error(`Invalid time`);
  }
  var ZipFS = class extends BasePortableFakeFS {
    constructor(source, opts) {
      super();
      this.lzSource = null;
      this.listings = new Map();
      this.entries = new Map();
      this.fileSources = new Map();
      this.fds = new Map();
      this.nextFd = 0;
      this.ready = false;
      this.readOnly = false;
      this.libzip = opts.libzip;
      const pathOptions = opts;
      this.level = typeof pathOptions.level !== `undefined` ? pathOptions.level : DEFAULT_COMPRESSION_LEVEL;
      if (source === null) {
        source = Buffer.from([
          80,
          75,
          5,
          6,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
      }
      if (typeof source === `string`) {
        const {baseFs = new NodeFS()} = pathOptions;
        this.baseFs = baseFs;
        this.path = source;
      } else {
        this.path = null;
        this.baseFs = null;
      }
      if (opts.stats) {
        this.stats = opts.stats;
      } else {
        if (typeof source === `string`) {
          try {
            this.stats = this.baseFs.statSync(source);
          } catch (error) {
            if (error.code === `ENOENT` && pathOptions.create) {
              this.stats = makeDefaultStats();
            } else {
              throw error;
            }
          }
        } else {
          this.stats = makeDefaultStats();
        }
      }
      const errPtr = this.libzip.malloc(4);
      try {
        let flags = 0;
        if (typeof source === `string` && pathOptions.create)
          flags |= this.libzip.ZIP_CREATE | this.libzip.ZIP_TRUNCATE;
        if (opts.readOnly) {
          flags |= this.libzip.ZIP_RDONLY;
          this.readOnly = true;
        }
        if (typeof source === `string`) {
          this.zip = this.libzip.open(npath.fromPortablePath(source), flags, errPtr);
        } else {
          const lzSource = this.allocateUnattachedSource(source);
          try {
            this.zip = this.libzip.openFromSource(lzSource, flags, errPtr);
            this.lzSource = lzSource;
          } catch (error) {
            this.libzip.source.free(lzSource);
            throw error;
          }
        }
        if (this.zip === 0) {
          const error = this.libzip.struct.errorS();
          this.libzip.error.initWithCode(error, this.libzip.getValue(errPtr, `i32`));
          throw this.makeLibzipError(error);
        }
      } finally {
        this.libzip.free(errPtr);
      }
      this.listings.set(PortablePath2.root, new Set());
      const entryCount = this.libzip.getNumEntries(this.zip, 0);
      for (let t7 = 0; t7 < entryCount; ++t7) {
        const raw = this.libzip.getName(this.zip, t7, 0);
        if (ppath.isAbsolute(raw))
          continue;
        const p = ppath.resolve(PortablePath2.root, raw);
        this.registerEntry(p, t7);
        if (raw.endsWith(`/`)) {
          this.registerListing(p);
        }
      }
      this.symlinkCount = this.libzip.ext.countSymlinks(this.zip);
      if (this.symlinkCount === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      this.ready = true;
    }
    makeLibzipError(error) {
      const errorCode = this.libzip.struct.errorCodeZip(error);
      const strerror = this.libzip.error.strerror(error);
      const libzipError = new LibzipError(strerror, this.libzip.errors[errorCode]);
      if (errorCode === this.libzip.errors.ZIP_ER_CHANGED)
        throw new Error(`Assertion failed: Unexpected libzip error: ${libzipError.message}`);
      return libzipError;
    }
    getExtractHint(hints) {
      for (const fileName of this.entries.keys()) {
        const ext = this.pathUtils.extname(fileName);
        if (hints.relevantExtensions.has(ext)) {
          return true;
        }
      }
      return false;
    }
    getAllFiles() {
      return Array.from(this.entries.keys());
    }
    getRealPath() {
      if (!this.path)
        throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
      return this.path;
    }
    getBufferAndClose() {
      this.prepareClose();
      if (!this.lzSource)
        throw new Error(`ZipFS was not created from a Buffer`);
      try {
        this.libzip.source.keep(this.lzSource);
        if (this.libzip.close(this.zip) === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        if (this.libzip.source.open(this.lzSource) === -1)
          throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
        if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_END) === -1)
          throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
        const size = this.libzip.source.tell(this.lzSource);
        if (size === -1)
          throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
        if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_SET) === -1)
          throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
        const buffer = this.libzip.malloc(size);
        if (!buffer)
          throw new Error(`Couldn't allocate enough memory`);
        try {
          const rc = this.libzip.source.read(this.lzSource, buffer, size);
          if (rc === -1)
            throw this.makeLibzipError(this.libzip.source.error(this.lzSource));
          else if (rc < size)
            throw new Error(`Incomplete read`);
          else if (rc > size)
            throw new Error(`Overread`);
          const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
          return Buffer.from(memory);
        } finally {
          this.libzip.free(buffer);
        }
      } finally {
        this.libzip.source.close(this.lzSource);
        this.libzip.source.free(this.lzSource);
        this.ready = false;
      }
    }
    prepareClose() {
      if (!this.ready)
        throw EBUSY(`archive closed, close`);
      unwatchAllFiles(this);
    }
    saveAndClose() {
      if (!this.path || !this.baseFs)
        throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
      this.prepareClose();
      if (this.readOnly) {
        this.discardAndClose();
        return;
      }
      const previousMod = this.baseFs.existsSync(this.path) ? this.baseFs.statSync(this.path).mode & 511 : null;
      const rc = this.libzip.close(this.zip);
      if (rc === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      if (previousMod === null)
        this.baseFs.chmodSync(this.path, this.stats.mode);
      else if (previousMod !== (this.baseFs.statSync(this.path).mode & 511))
        this.baseFs.chmodSync(this.path, previousMod);
      this.ready = false;
    }
    discardAndClose() {
      this.prepareClose();
      this.libzip.discard(this.zip);
      this.ready = false;
    }
    resolve(p) {
      return ppath.resolve(PortablePath2.root, p);
    }
    async openPromise(p, flags, mode) {
      return this.openSync(p, flags, mode);
    }
    openSync(p, flags, mode) {
      const fd = this.nextFd++;
      this.fds.set(fd, {cursor: 0, p});
      return fd;
    }
    hasOpenFileHandles() {
      return !!this.fds.size;
    }
    async opendirPromise(p, opts) {
      return this.opendirSync(p, opts);
    }
    opendirSync(p, opts = {}) {
      const resolvedP = this.resolveFilename(`opendir '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`opendir '${p}'`);
      const directoryListing = this.listings.get(resolvedP);
      if (!directoryListing)
        throw ENOTDIR(`opendir '${p}'`);
      const entries = [...directoryListing];
      const fd = this.openSync(resolvedP, `r`);
      const onClose = () => {
        this.closeSync(fd);
      };
      return opendir(this, resolvedP, entries, {onClose});
    }
    async readPromise(fd, buffer, offset, length, position) {
      return this.readSync(fd, buffer, offset, length, position);
    }
    readSync(fd, buffer, offset = 0, length = 0, position = -1) {
      const entry = this.fds.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`read`);
      let realPosition;
      if (position === -1 || position === null)
        realPosition = entry.cursor;
      else
        realPosition = position;
      const source = this.readFileSync(entry.p);
      source.copy(buffer, offset, realPosition, realPosition + length);
      const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
      if (position === -1 || position === null)
        entry.cursor += bytesRead;
      return bytesRead;
    }
    async writePromise(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return this.writeSync(fd, buffer, position);
      } else {
        return this.writeSync(fd, buffer, offset, length, position);
      }
    }
    writeSync(fd, buffer, offset, length, position) {
      const entry = this.fds.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`read`);
      throw new Error(`Unimplemented`);
    }
    async closePromise(fd) {
      return this.closeSync(fd);
    }
    closeSync(fd) {
      const entry = this.fds.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`read`);
      this.fds.delete(fd);
    }
    createReadStream(p, {encoding} = {}) {
      if (p === null)
        throw new Error(`Unimplemented`);
      const fd = this.openSync(p, `r`);
      const stream = Object.assign(new import_stream.PassThrough({
        emitClose: true,
        autoDestroy: true,
        destroy: (error, callback) => {
          clearImmediate(immediate);
          this.closeSync(fd);
          callback(error);
        }
      }), {
        close() {
          stream.destroy();
        },
        bytesRead: 0,
        path: p
      });
      const immediate = setImmediate(async () => {
        try {
          const data = await this.readFilePromise(p, encoding);
          stream.bytesRead = data.length;
          stream.end(data);
        } catch (error) {
          stream.destroy(error);
        }
      });
      return stream;
    }
    createWriteStream(p, {encoding} = {}) {
      if (this.readOnly)
        throw EROFS(`open '${p}'`);
      if (p === null)
        throw new Error(`Unimplemented`);
      const chunks = [];
      const fd = this.openSync(p, `w`);
      const stream = Object.assign(new import_stream.PassThrough({
        autoDestroy: true,
        emitClose: true,
        destroy: (error, callback) => {
          try {
            if (error) {
              callback(error);
            } else {
              this.writeFileSync(p, Buffer.concat(chunks), encoding);
              callback(null);
            }
          } catch (err) {
            callback(err);
          } finally {
            this.closeSync(fd);
          }
        }
      }), {
        bytesWritten: 0,
        path: p,
        close() {
          stream.destroy();
        }
      });
      stream.on(`data`, (chunk) => {
        const chunkBuffer = Buffer.from(chunk);
        stream.bytesWritten += chunkBuffer.length;
        chunks.push(chunkBuffer);
      });
      return stream;
    }
    async realpathPromise(p) {
      return this.realpathSync(p);
    }
    realpathSync(p) {
      const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`lstat '${p}'`);
      return resolvedP;
    }
    async existsPromise(p) {
      return this.existsSync(p);
    }
    existsSync(p) {
      if (!this.ready)
        throw EBUSY(`archive closed, existsSync '${p}'`);
      if (this.symlinkCount === 0) {
        const resolvedP2 = ppath.resolve(PortablePath2.root, p);
        return this.entries.has(resolvedP2) || this.listings.has(resolvedP2);
      }
      let resolvedP;
      try {
        resolvedP = this.resolveFilename(`stat '${p}'`, p);
      } catch (error) {
        return false;
      }
      return this.entries.has(resolvedP) || this.listings.has(resolvedP);
    }
    async accessPromise(p, mode) {
      return this.accessSync(p, mode);
    }
    accessSync(p, mode = import_fs3.constants.F_OK) {
      const resolvedP = this.resolveFilename(`access '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`access '${p}'`);
      if (this.readOnly && mode & import_fs3.constants.W_OK) {
        throw EROFS(`access '${p}'`);
      }
    }
    async statPromise(p, opts) {
      return this.statSync(p, opts);
    }
    statSync(p, opts) {
      const resolvedP = this.resolveFilename(`stat '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`stat '${p}'`);
      if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
        throw ENOTDIR(`stat '${p}'`);
      return this.statImpl(`stat '${p}'`, resolvedP, opts);
    }
    async fstatPromise(fd, opts) {
      return this.fstatSync(fd, opts);
    }
    fstatSync(fd, opts) {
      const entry = this.fds.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`fstatSync`);
      const {p} = entry;
      const resolvedP = this.resolveFilename(`stat '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`stat '${p}'`);
      if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
        throw ENOTDIR(`stat '${p}'`);
      return this.statImpl(`fstat '${p}'`, resolvedP, opts);
    }
    async lstatPromise(p, opts) {
      return this.lstatSync(p, opts);
    }
    lstatSync(p, opts) {
      const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`lstat '${p}'`);
      if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
        throw ENOTDIR(`lstat '${p}'`);
      return this.statImpl(`lstat '${p}'`, resolvedP, opts);
    }
    statImpl(reason, p, opts = {}) {
      const entry = this.entries.get(p);
      if (typeof entry !== `undefined`) {
        const stat = this.libzip.struct.statS();
        const rc = this.libzip.statIndex(this.zip, entry, 0, 0, stat);
        if (rc === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        const uid = this.stats.uid;
        const gid = this.stats.gid;
        const size = this.libzip.struct.statSize(stat) >>> 0;
        const blksize = 512;
        const blocks = Math.ceil(size / blksize);
        const mtimeMs = (this.libzip.struct.statMtime(stat) >>> 0) * 1e3;
        const atimeMs = mtimeMs;
        const birthtimeMs = mtimeMs;
        const ctimeMs = mtimeMs;
        const atime = new Date(atimeMs);
        const birthtime = new Date(birthtimeMs);
        const ctime = new Date(ctimeMs);
        const mtime = new Date(mtimeMs);
        const type = this.listings.has(p) ? S_IFDIR : this.isSymbolicLink(entry) ? S_IFLNK : S_IFREG;
        const defaultMode = type === S_IFDIR ? 493 : 420;
        const mode = type | this.getUnixMode(entry, defaultMode) & 511;
        const statInstance = Object.assign(new StatEntry(), {uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode});
        return opts.bigint === true ? convertToBigIntStats(statInstance) : statInstance;
      }
      if (this.listings.has(p)) {
        const uid = this.stats.uid;
        const gid = this.stats.gid;
        const size = 0;
        const blksize = 512;
        const blocks = 0;
        const atimeMs = this.stats.mtimeMs;
        const birthtimeMs = this.stats.mtimeMs;
        const ctimeMs = this.stats.mtimeMs;
        const mtimeMs = this.stats.mtimeMs;
        const atime = new Date(atimeMs);
        const birthtime = new Date(birthtimeMs);
        const ctime = new Date(ctimeMs);
        const mtime = new Date(mtimeMs);
        const mode = S_IFDIR | 493;
        const statInstance = Object.assign(new StatEntry(), {uid, gid, size, blksize, blocks, atime, birthtime, ctime, mtime, atimeMs, birthtimeMs, ctimeMs, mtimeMs, mode});
        return opts.bigint === true ? convertToBigIntStats(statInstance) : statInstance;
      }
      throw new Error(`Unreachable`);
    }
    getUnixMode(index, defaultMode) {
      const rc = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
      if (rc === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
      if (opsys !== this.libzip.ZIP_OPSYS_UNIX)
        return defaultMode;
      return this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
    }
    registerListing(p) {
      let listing = this.listings.get(p);
      if (listing)
        return listing;
      const parentListing = this.registerListing(ppath.dirname(p));
      listing = new Set();
      parentListing.add(ppath.basename(p));
      this.listings.set(p, listing);
      return listing;
    }
    registerEntry(p, index) {
      const parentListing = this.registerListing(ppath.dirname(p));
      parentListing.add(ppath.basename(p));
      this.entries.set(p, index);
    }
    unregisterListing(p) {
      this.listings.delete(p);
      const parentListing = this.listings.get(ppath.dirname(p));
      parentListing == null ? void 0 : parentListing.delete(ppath.basename(p));
    }
    unregisterEntry(p) {
      this.unregisterListing(p);
      const entry = this.entries.get(p);
      this.entries.delete(p);
      if (typeof entry === `undefined`)
        return;
      this.fileSources.delete(entry);
      if (this.isSymbolicLink(entry)) {
        this.symlinkCount--;
      }
    }
    deleteEntry(p, index) {
      this.unregisterEntry(p);
      const rc = this.libzip.delete(this.zip, index);
      if (rc === -1) {
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      }
    }
    resolveFilename(reason, p, resolveLastComponent = true) {
      if (!this.ready)
        throw EBUSY(`archive closed, ${reason}`);
      let resolvedP = ppath.resolve(PortablePath2.root, p);
      if (resolvedP === `/`)
        return PortablePath2.root;
      const fileIndex = this.entries.get(resolvedP);
      if (resolveLastComponent && fileIndex !== void 0) {
        if (this.symlinkCount !== 0 && this.isSymbolicLink(fileIndex)) {
          const target = this.getFileSource(fileIndex).toString();
          return this.resolveFilename(reason, ppath.resolve(ppath.dirname(resolvedP), target), true);
        } else {
          return resolvedP;
        }
      }
      while (true) {
        const parentP = this.resolveFilename(reason, ppath.dirname(resolvedP), true);
        const isDir = this.listings.has(parentP);
        const doesExist = this.entries.has(parentP);
        if (!isDir && !doesExist)
          throw ENOENT(reason);
        if (!isDir)
          throw ENOTDIR(reason);
        resolvedP = ppath.resolve(parentP, ppath.basename(resolvedP));
        if (!resolveLastComponent || this.symlinkCount === 0)
          break;
        const index = this.libzip.name.locate(this.zip, resolvedP.slice(1));
        if (index === -1)
          break;
        if (this.isSymbolicLink(index)) {
          const target = this.getFileSource(index).toString();
          resolvedP = ppath.resolve(ppath.dirname(resolvedP), target);
        } else {
          break;
        }
      }
      return resolvedP;
    }
    allocateBuffer(content) {
      if (!Buffer.isBuffer(content))
        content = Buffer.from(content);
      const buffer = this.libzip.malloc(content.byteLength);
      if (!buffer)
        throw new Error(`Couldn't allocate enough memory`);
      const heap = new Uint8Array(this.libzip.HEAPU8.buffer, buffer, content.byteLength);
      heap.set(content);
      return {buffer, byteLength: content.byteLength};
    }
    allocateUnattachedSource(content) {
      const error = this.libzip.struct.errorS();
      const {buffer, byteLength} = this.allocateBuffer(content);
      const source = this.libzip.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);
      if (source === 0) {
        this.libzip.free(error);
        throw this.makeLibzipError(error);
      }
      return source;
    }
    allocateSource(content) {
      const {buffer, byteLength} = this.allocateBuffer(content);
      const source = this.libzip.source.fromBuffer(this.zip, buffer, byteLength, 0, true);
      if (source === 0) {
        this.libzip.free(buffer);
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      }
      return source;
    }
    setFileSource(p, content) {
      const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content);
      const target = ppath.relative(PortablePath2.root, p);
      const lzSource = this.allocateSource(content);
      try {
        const newIndex = this.libzip.file.add(this.zip, target, lzSource, this.libzip.ZIP_FL_OVERWRITE);
        if (newIndex === -1)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        if (this.level !== `mixed`) {
          let method;
          if (this.level === 0)
            method = this.libzip.ZIP_CM_STORE;
          else
            method = this.libzip.ZIP_CM_DEFLATE;
          const rc = this.libzip.file.setCompression(this.zip, newIndex, 0, method, this.level);
          if (rc === -1) {
            throw this.makeLibzipError(this.libzip.getError(this.zip));
          }
        }
        this.fileSources.set(newIndex, buffer);
        return newIndex;
      } catch (error) {
        this.libzip.source.free(lzSource);
        throw error;
      }
    }
    isSymbolicLink(index) {
      if (this.symlinkCount === 0)
        return false;
      const attrs = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
      if (attrs === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
      if (opsys !== this.libzip.ZIP_OPSYS_UNIX)
        return false;
      const attributes = this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
      return (attributes & S_IFMT) === S_IFLNK;
    }
    getFileSource(index, opts = {asyncDecompress: false}) {
      const cachedFileSource = this.fileSources.get(index);
      if (typeof cachedFileSource !== `undefined`)
        return cachedFileSource;
      const stat = this.libzip.struct.statS();
      const rc = this.libzip.statIndex(this.zip, index, 0, 0, stat);
      if (rc === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      const size = this.libzip.struct.statCompSize(stat);
      const compressionMethod = this.libzip.struct.statCompMethod(stat);
      const buffer = this.libzip.malloc(size);
      try {
        const file = this.libzip.fopenIndex(this.zip, index, 0, this.libzip.ZIP_FL_COMPRESSED);
        if (file === 0)
          throw this.makeLibzipError(this.libzip.getError(this.zip));
        try {
          const rc2 = this.libzip.fread(file, buffer, size, 0);
          if (rc2 === -1)
            throw this.makeLibzipError(this.libzip.file.getError(file));
          else if (rc2 < size)
            throw new Error(`Incomplete read`);
          else if (rc2 > size)
            throw new Error(`Overread`);
          const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
          const data = Buffer.from(memory);
          if (compressionMethod === 0) {
            this.fileSources.set(index, data);
            return data;
          } else if (opts.asyncDecompress) {
            return new Promise((resolve, reject) => {
              import_zlib.default.inflateRaw(data, (error, result) => {
                if (error) {
                  reject(error);
                } else {
                  this.fileSources.set(index, result);
                  resolve(result);
                }
              });
            });
          } else {
            const decompressedData = import_zlib.default.inflateRawSync(data);
            this.fileSources.set(index, decompressedData);
            return decompressedData;
          }
        } finally {
          this.libzip.fclose(file);
        }
      } finally {
        this.libzip.free(buffer);
      }
    }
    async chmodPromise(p, mask) {
      return this.chmodSync(p, mask);
    }
    chmodSync(p, mask) {
      if (this.readOnly)
        throw EROFS(`chmod '${p}'`);
      mask &= 493;
      const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
      const entry = this.entries.get(resolvedP);
      if (typeof entry === `undefined`)
        throw new Error(`Assertion failed: The entry should have been registered (${resolvedP})`);
      const oldMod = this.getUnixMode(entry, S_IFREG | 0);
      const newMod = oldMod & ~511 | mask;
      const rc = this.libzip.file.setExternalAttributes(this.zip, entry, 0, 0, this.libzip.ZIP_OPSYS_UNIX, newMod << 16);
      if (rc === -1) {
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      }
    }
    async chownPromise(p, uid, gid) {
      return this.chownSync(p, uid, gid);
    }
    chownSync(p, uid, gid) {
      throw new Error(`Unimplemented`);
    }
    async renamePromise(oldP, newP) {
      return this.renameSync(oldP, newP);
    }
    renameSync(oldP, newP) {
      throw new Error(`Unimplemented`);
    }
    async copyFilePromise(sourceP, destP, flags) {
      const {indexSource, indexDest, resolvedDestP} = this.prepareCopyFile(sourceP, destP, flags);
      const source = await this.getFileSource(indexSource, {asyncDecompress: true});
      const newIndex = this.setFileSource(resolvedDestP, source);
      if (newIndex !== indexDest) {
        this.registerEntry(resolvedDestP, newIndex);
      }
    }
    copyFileSync(sourceP, destP, flags = 0) {
      const {indexSource, indexDest, resolvedDestP} = this.prepareCopyFile(sourceP, destP, flags);
      const source = this.getFileSource(indexSource);
      const newIndex = this.setFileSource(resolvedDestP, source);
      if (newIndex !== indexDest) {
        this.registerEntry(resolvedDestP, newIndex);
      }
    }
    prepareCopyFile(sourceP, destP, flags = 0) {
      if (this.readOnly)
        throw EROFS(`copyfile '${sourceP} -> '${destP}'`);
      if ((flags & import_fs3.constants.COPYFILE_FICLONE_FORCE) !== 0)
        throw ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
      const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
      const indexSource = this.entries.get(resolvedSourceP);
      if (typeof indexSource === `undefined`)
        throw EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
      const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
      const indexDest = this.entries.get(resolvedDestP);
      if ((flags & (import_fs3.constants.COPYFILE_EXCL | import_fs3.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`)
        throw EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
      return {
        indexSource,
        resolvedDestP,
        indexDest
      };
    }
    async appendFilePromise(p, content, opts) {
      if (this.readOnly)
        throw EROFS(`open '${p}'`);
      if (typeof opts === `undefined`)
        opts = {flag: `a`};
      else if (typeof opts === `string`)
        opts = {flag: `a`, encoding: opts};
      else if (typeof opts.flag === `undefined`)
        opts = {flag: `a`, ...opts};
      return this.writeFilePromise(p, content, opts);
    }
    appendFileSync(p, content, opts = {}) {
      if (this.readOnly)
        throw EROFS(`open '${p}'`);
      if (typeof opts === `undefined`)
        opts = {flag: `a`};
      else if (typeof opts === `string`)
        opts = {flag: `a`, encoding: opts};
      else if (typeof opts.flag === `undefined`)
        opts = {flag: `a`, ...opts};
      return this.writeFileSync(p, content, opts);
    }
    async writeFilePromise(p, content, opts) {
      const {encoding, index, resolvedP} = this.prepareWriteFile(p, opts);
      if (index !== void 0 && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
        content = Buffer.concat([await this.getFileSource(index, {asyncDecompress: true}), Buffer.from(content)]);
      if (encoding !== null)
        content = content.toString(encoding);
      const newIndex = this.setFileSource(resolvedP, content);
      if (newIndex !== index) {
        this.registerEntry(resolvedP, newIndex);
      }
    }
    writeFileSync(p, content, opts) {
      const {encoding, index, resolvedP} = this.prepareWriteFile(p, opts);
      if (index !== void 0 && typeof opts === `object` && opts.flag && opts.flag.includes(`a`))
        content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
      if (encoding !== null)
        content = content.toString(encoding);
      const newIndex = this.setFileSource(resolvedP, content);
      if (newIndex !== index) {
        this.registerEntry(resolvedP, newIndex);
      }
    }
    prepareWriteFile(p, opts) {
      if (typeof p !== `string`)
        throw EBADF(`read`);
      if (this.readOnly)
        throw EROFS(`open '${p}'`);
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      if (this.listings.has(resolvedP))
        throw EISDIR(`open '${p}'`);
      let encoding = null;
      if (typeof opts === `string`)
        encoding = opts;
      else if (typeof opts === `object` && opts.encoding)
        encoding = opts.encoding;
      const index = this.entries.get(resolvedP);
      return {
        encoding,
        resolvedP,
        index
      };
    }
    async unlinkPromise(p) {
      return this.unlinkSync(p);
    }
    unlinkSync(p) {
      if (this.readOnly)
        throw EROFS(`unlink '${p}'`);
      const resolvedP = this.resolveFilename(`unlink '${p}'`, p);
      if (this.listings.has(resolvedP))
        throw EISDIR(`unlink '${p}'`);
      const index = this.entries.get(resolvedP);
      if (typeof index === `undefined`)
        throw EINVAL(`unlink '${p}'`);
      this.deleteEntry(resolvedP, index);
    }
    async utimesPromise(p, atime, mtime) {
      return this.utimesSync(p, atime, mtime);
    }
    utimesSync(p, atime, mtime) {
      if (this.readOnly)
        throw EROFS(`utimes '${p}'`);
      const resolvedP = this.resolveFilename(`utimes '${p}'`, p);
      this.utimesImpl(resolvedP, mtime);
    }
    async lutimesPromise(p, atime, mtime) {
      return this.lutimesSync(p, atime, mtime);
    }
    lutimesSync(p, atime, mtime) {
      if (this.readOnly)
        throw EROFS(`lutimes '${p}'`);
      const resolvedP = this.resolveFilename(`utimes '${p}'`, p, false);
      this.utimesImpl(resolvedP, mtime);
    }
    utimesImpl(resolvedP, mtime) {
      if (this.listings.has(resolvedP)) {
        if (!this.entries.has(resolvedP))
          this.hydrateDirectory(resolvedP);
      }
      const entry = this.entries.get(resolvedP);
      if (entry === void 0)
        throw new Error(`Unreachable`);
      const rc = this.libzip.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);
      if (rc === -1) {
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      }
    }
    async mkdirPromise(p, opts) {
      return this.mkdirSync(p, opts);
    }
    mkdirSync(p, {mode = 493, recursive = false} = {}) {
      if (recursive) {
        this.mkdirpSync(p, {chmod: mode});
        return;
      }
      if (this.readOnly)
        throw EROFS(`mkdir '${p}'`);
      const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
      if (this.entries.has(resolvedP) || this.listings.has(resolvedP))
        throw EEXIST(`mkdir '${p}'`);
      this.hydrateDirectory(resolvedP);
      this.chmodSync(resolvedP, mode);
    }
    async rmdirPromise(p, opts) {
      return this.rmdirSync(p, opts);
    }
    rmdirSync(p, {recursive = false} = {}) {
      if (this.readOnly)
        throw EROFS(`rmdir '${p}'`);
      if (recursive) {
        this.removeSync(p);
        return;
      }
      const resolvedP = this.resolveFilename(`rmdir '${p}'`, p);
      const directoryListing = this.listings.get(resolvedP);
      if (!directoryListing)
        throw ENOTDIR(`rmdir '${p}'`);
      if (directoryListing.size > 0)
        throw ENOTEMPTY(`rmdir '${p}'`);
      const index = this.entries.get(resolvedP);
      if (typeof index === `undefined`)
        throw EINVAL(`rmdir '${p}'`);
      this.deleteEntry(p, index);
    }
    hydrateDirectory(resolvedP) {
      const index = this.libzip.dir.add(this.zip, ppath.relative(PortablePath2.root, resolvedP));
      if (index === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      this.registerListing(resolvedP);
      this.registerEntry(resolvedP, index);
      return index;
    }
    async linkPromise(existingP, newP) {
      return this.linkSync(existingP, newP);
    }
    linkSync(existingP, newP) {
      throw EOPNOTSUPP(`link '${existingP}' -> '${newP}'`);
    }
    async symlinkPromise(target, p) {
      return this.symlinkSync(target, p);
    }
    symlinkSync(target, p) {
      if (this.readOnly)
        throw EROFS(`symlink '${target}' -> '${p}'`);
      const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
      if (this.listings.has(resolvedP))
        throw EISDIR(`symlink '${target}' -> '${p}'`);
      if (this.entries.has(resolvedP))
        throw EEXIST(`symlink '${target}' -> '${p}'`);
      const index = this.setFileSource(resolvedP, target);
      this.registerEntry(resolvedP, index);
      const rc = this.libzip.file.setExternalAttributes(this.zip, index, 0, 0, this.libzip.ZIP_OPSYS_UNIX, (S_IFLNK | 511) << 16);
      if (rc === -1)
        throw this.makeLibzipError(this.libzip.getError(this.zip));
      this.symlinkCount += 1;
    }
    async readFilePromise(p, encoding) {
      if (typeof encoding === `object`)
        encoding = encoding ? encoding.encoding : void 0;
      const data = await this.readFileBuffer(p, {asyncDecompress: true});
      return encoding ? data.toString(encoding) : data;
    }
    readFileSync(p, encoding) {
      if (typeof encoding === `object`)
        encoding = encoding ? encoding.encoding : void 0;
      const data = this.readFileBuffer(p);
      return encoding ? data.toString(encoding) : data;
    }
    readFileBuffer(p, opts = {asyncDecompress: false}) {
      if (typeof p !== `string`)
        throw EBADF(`read`);
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`open '${p}'`);
      if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
        throw ENOTDIR(`open '${p}'`);
      if (this.listings.has(resolvedP))
        throw EISDIR(`read`);
      const entry = this.entries.get(resolvedP);
      if (entry === void 0)
        throw new Error(`Unreachable`);
      return this.getFileSource(entry, opts);
    }
    async readdirPromise(p, {withFileTypes} = {}) {
      return this.readdirSync(p, {withFileTypes});
    }
    readdirSync(p, {withFileTypes} = {}) {
      const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`scandir '${p}'`);
      const directoryListing = this.listings.get(resolvedP);
      if (!directoryListing)
        throw ENOTDIR(`scandir '${p}'`);
      const entries = [...directoryListing];
      if (!withFileTypes)
        return entries;
      return entries.map((name) => {
        return Object.assign(this.statImpl(`lstat`, ppath.join(p, name)), {
          name
        });
      });
    }
    async readlinkPromise(p) {
      const entry = this.prepareReadlink(p);
      return (await this.getFileSource(entry, {asyncDecompress: true})).toString();
    }
    readlinkSync(p) {
      const entry = this.prepareReadlink(p);
      return this.getFileSource(entry).toString();
    }
    prepareReadlink(p) {
      const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
      if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP))
        throw ENOENT(`readlink '${p}'`);
      if (p[p.length - 1] === `/` && !this.listings.has(resolvedP))
        throw ENOTDIR(`open '${p}'`);
      if (this.listings.has(resolvedP))
        throw EINVAL(`readlink '${p}'`);
      const entry = this.entries.get(resolvedP);
      if (entry === void 0)
        throw new Error(`Unreachable`);
      if (!this.isSymbolicLink(entry))
        throw EINVAL(`readlink '${p}'`);
      return entry;
    }
    async truncatePromise(p, len = 0) {
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      const index = this.entries.get(resolvedP);
      if (typeof index === `undefined`)
        throw EINVAL(`open '${p}'`);
      const source = await this.getFileSource(index, {asyncDecompress: true});
      const truncated = Buffer.alloc(len, 0);
      source.copy(truncated);
      return await this.writeFilePromise(p, truncated);
    }
    truncateSync(p, len = 0) {
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      const index = this.entries.get(resolvedP);
      if (typeof index === `undefined`)
        throw EINVAL(`open '${p}'`);
      const source = this.getFileSource(index);
      const truncated = Buffer.alloc(len, 0);
      source.copy(truncated);
      return this.writeFileSync(p, truncated);
    }
    watch(p, a, b) {
      let persistent;
      switch (typeof a) {
        case `function`:
        case `string`:
        case `undefined`:
          {
            persistent = true;
          }
          break;
        default:
          {
            ({persistent = true} = a);
          }
          break;
      }
      if (!persistent)
        return {on: () => {
        }, close: () => {
        }};
      const interval = setInterval(() => {
      }, 24 * 60 * 60 * 1e3);
      return {on: () => {
      }, close: () => {
        clearInterval(interval);
      }};
    }
    watchFile(p, a, b) {
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      return watchFile(this, resolvedP, a, b);
    }
    unwatchFile(p, cb) {
      const resolvedP = this.resolveFilename(`open '${p}'`, p);
      return unwatchFile(this, resolvedP, cb);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\ProxiedFS.ts
  var ProxiedFS = class extends FakeFS {
    getExtractHint(hints) {
      return this.baseFs.getExtractHint(hints);
    }
    resolve(path6) {
      return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path6)));
    }
    getRealPath() {
      return this.mapFromBase(this.baseFs.getRealPath());
    }
    async openPromise(p, flags, mode) {
      return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
    }
    openSync(p, flags, mode) {
      return this.baseFs.openSync(this.mapToBase(p), flags, mode);
    }
    async opendirPromise(p, opts) {
      return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), {path: p});
    }
    opendirSync(p, opts) {
      return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), {path: p});
    }
    async readPromise(fd, buffer, offset, length, position) {
      return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    }
    readSync(fd, buffer, offset, length, position) {
      return this.baseFs.readSync(fd, buffer, offset, length, position);
    }
    async writePromise(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }
    writeSync(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }
    async closePromise(fd) {
      return this.baseFs.closePromise(fd);
    }
    closeSync(fd) {
      this.baseFs.closeSync(fd);
    }
    createReadStream(p, opts) {
      return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
    }
    createWriteStream(p, opts) {
      return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
    }
    async realpathPromise(p) {
      return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
    }
    realpathSync(p) {
      return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
    }
    async existsPromise(p) {
      return this.baseFs.existsPromise(this.mapToBase(p));
    }
    existsSync(p) {
      return this.baseFs.existsSync(this.mapToBase(p));
    }
    accessSync(p, mode) {
      return this.baseFs.accessSync(this.mapToBase(p), mode);
    }
    async accessPromise(p, mode) {
      return this.baseFs.accessPromise(this.mapToBase(p), mode);
    }
    async statPromise(p, opts) {
      return this.baseFs.statPromise(this.mapToBase(p), opts);
    }
    statSync(p, opts) {
      return this.baseFs.statSync(this.mapToBase(p), opts);
    }
    async fstatPromise(fd, opts) {
      return this.baseFs.fstatPromise(fd, opts);
    }
    fstatSync(fd, opts) {
      return this.baseFs.fstatSync(fd, opts);
    }
    async lstatPromise(p, opts) {
      return this.baseFs.lstatPromise(this.mapToBase(p), opts);
    }
    lstatSync(p, opts) {
      return this.baseFs.lstatSync(this.mapToBase(p), opts);
    }
    async chmodPromise(p, mask) {
      return this.baseFs.chmodPromise(this.mapToBase(p), mask);
    }
    chmodSync(p, mask) {
      return this.baseFs.chmodSync(this.mapToBase(p), mask);
    }
    async chownPromise(p, uid, gid) {
      return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
    }
    chownSync(p, uid, gid) {
      return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
    }
    async renamePromise(oldP, newP) {
      return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
    }
    renameSync(oldP, newP) {
      return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
    }
    async copyFilePromise(sourceP, destP, flags = 0) {
      return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
    }
    copyFileSync(sourceP, destP, flags = 0) {
      return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
    }
    async appendFilePromise(p, content, opts) {
      return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
    }
    appendFileSync(p, content, opts) {
      return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
    }
    async writeFilePromise(p, content, opts) {
      return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
    }
    writeFileSync(p, content, opts) {
      return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
    }
    async unlinkPromise(p) {
      return this.baseFs.unlinkPromise(this.mapToBase(p));
    }
    unlinkSync(p) {
      return this.baseFs.unlinkSync(this.mapToBase(p));
    }
    async utimesPromise(p, atime, mtime) {
      return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
    }
    utimesSync(p, atime, mtime) {
      return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
    }
    async mkdirPromise(p, opts) {
      return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
    }
    mkdirSync(p, opts) {
      return this.baseFs.mkdirSync(this.mapToBase(p), opts);
    }
    async rmdirPromise(p, opts) {
      return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
    }
    rmdirSync(p, opts) {
      return this.baseFs.rmdirSync(this.mapToBase(p), opts);
    }
    async linkPromise(existingP, newP) {
      return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
    }
    linkSync(existingP, newP) {
      return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
    }
    async symlinkPromise(target, p, type) {
      return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p), type);
    }
    symlinkSync(target, p, type) {
      return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p), type);
    }
    async readFilePromise(p, encoding) {
      if (encoding === `utf8`) {
        return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
      } else {
        return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
      }
    }
    readFileSync(p, encoding) {
      if (encoding === `utf8`) {
        return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
      } else {
        return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
      }
    }
    async readdirPromise(p, {withFileTypes} = {}) {
      return this.baseFs.readdirPromise(this.mapToBase(p), {withFileTypes});
    }
    readdirSync(p, {withFileTypes} = {}) {
      return this.baseFs.readdirSync(this.mapToBase(p), {withFileTypes});
    }
    async readlinkPromise(p) {
      return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
    }
    readlinkSync(p) {
      return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
    }
    async truncatePromise(p, len) {
      return this.baseFs.truncatePromise(this.mapToBase(p), len);
    }
    truncateSync(p, len) {
      return this.baseFs.truncateSync(this.mapToBase(p), len);
    }
    watch(p, a, b) {
      return this.baseFs.watch(this.mapToBase(p), a, b);
    }
    watchFile(p, a, b) {
      return this.baseFs.watchFile(this.mapToBase(p), a, b);
    }
    unwatchFile(p, cb) {
      return this.baseFs.unwatchFile(this.mapToBase(p), cb);
    }
    fsMapToBase(p) {
      if (typeof p === `number`) {
        return p;
      } else {
        return this.mapToBase(p);
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\AliasFS.ts
  var AliasFS = class extends ProxiedFS {
    constructor(target, {baseFs, pathUtils}) {
      super(pathUtils);
      this.target = target;
      this.baseFs = baseFs;
    }
    getRealPath() {
      return this.target;
    }
    getBaseFs() {
      return this.baseFs;
    }
    mapFromBase(p) {
      return p;
    }
    mapToBase(p) {
      return p;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\CwdFS.ts
  var CwdFS = class extends ProxiedFS {
    constructor(target, {baseFs = new NodeFS()} = {}) {
      super(ppath);
      this.target = this.pathUtils.normalize(target);
      this.baseFs = baseFs;
    }
    getRealPath() {
      return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
    }
    resolve(p) {
      if (this.pathUtils.isAbsolute(p)) {
        return ppath.normalize(p);
      } else {
        return this.baseFs.resolve(ppath.join(this.target, p));
      }
    }
    mapFromBase(path6) {
      return path6;
    }
    mapToBase(path6) {
      if (this.pathUtils.isAbsolute(path6)) {
        return path6;
      } else {
        return this.pathUtils.join(this.target, path6);
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\JailFS.ts
  var JAIL_ROOT = PortablePath2.root;
  var JailFS = class extends ProxiedFS {
    constructor(target, {baseFs = new NodeFS()} = {}) {
      super(ppath);
      this.target = this.pathUtils.resolve(PortablePath2.root, target);
      this.baseFs = baseFs;
    }
    getRealPath() {
      return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative(PortablePath2.root, this.target));
    }
    getTarget() {
      return this.target;
    }
    getBaseFs() {
      return this.baseFs;
    }
    mapToBase(p) {
      const normalized = this.pathUtils.normalize(p);
      if (this.pathUtils.isAbsolute(p))
        return this.pathUtils.resolve(this.target, this.pathUtils.relative(JAIL_ROOT, p));
      if (normalized.match(/^\.\.\/?/))
        throw new Error(`Resolving this path (${p}) would escape the jail`);
      return this.pathUtils.resolve(this.target, p);
    }
    mapFromBase(p) {
      return this.pathUtils.resolve(JAIL_ROOT, this.pathUtils.relative(this.target, p));
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\LazyFS.ts
  var LazyFS = class extends ProxiedFS {
    constructor(factory, pathUtils) {
      super(pathUtils);
      this.instance = null;
      this.factory = factory;
    }
    get baseFs() {
      if (!this.instance)
        this.instance = this.factory();
      return this.instance;
    }
    set baseFs(value) {
      this.instance = value;
    }
    mapFromBase(p) {
      return p;
    }
    mapToBase(p) {
      return p;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\NoFS.ts
  var makeError2 = () => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), {code: `ENOSYS`});
  var NoFS2 = class extends FakeFS {
    constructor() {
      super(ppath);
    }
    getExtractHint() {
      throw makeError2();
    }
    getRealPath() {
      throw makeError2();
    }
    resolve() {
      throw makeError2();
    }
    async openPromise() {
      throw makeError2();
    }
    openSync() {
      throw makeError2();
    }
    async opendirPromise() {
      throw makeError2();
    }
    opendirSync() {
      throw makeError2();
    }
    async readPromise() {
      throw makeError2();
    }
    readSync() {
      throw makeError2();
    }
    async writePromise() {
      throw makeError2();
    }
    writeSync() {
      throw makeError2();
    }
    async closePromise() {
      throw makeError2();
    }
    closeSync() {
      throw makeError2();
    }
    createWriteStream() {
      throw makeError2();
    }
    createReadStream() {
      throw makeError2();
    }
    async realpathPromise() {
      throw makeError2();
    }
    realpathSync() {
      throw makeError2();
    }
    async readdirPromise() {
      throw makeError2();
    }
    readdirSync() {
      throw makeError2();
    }
    async existsPromise(p) {
      throw makeError2();
    }
    existsSync(p) {
      throw makeError2();
    }
    async accessPromise() {
      throw makeError2();
    }
    accessSync() {
      throw makeError2();
    }
    async statPromise() {
      throw makeError2();
    }
    statSync() {
      throw makeError2();
    }
    async fstatPromise(fd) {
      throw makeError2();
    }
    fstatSync(fd) {
      throw makeError2();
    }
    async lstatPromise(p) {
      throw makeError2();
    }
    lstatSync(p) {
      throw makeError2();
    }
    async chmodPromise() {
      throw makeError2();
    }
    chmodSync() {
      throw makeError2();
    }
    async chownPromise() {
      throw makeError2();
    }
    chownSync() {
      throw makeError2();
    }
    async mkdirPromise() {
      throw makeError2();
    }
    mkdirSync() {
      throw makeError2();
    }
    async rmdirPromise() {
      throw makeError2();
    }
    rmdirSync() {
      throw makeError2();
    }
    async linkPromise() {
      throw makeError2();
    }
    linkSync() {
      throw makeError2();
    }
    async symlinkPromise() {
      throw makeError2();
    }
    symlinkSync() {
      throw makeError2();
    }
    async renamePromise() {
      throw makeError2();
    }
    renameSync() {
      throw makeError2();
    }
    async copyFilePromise() {
      throw makeError2();
    }
    copyFileSync() {
      throw makeError2();
    }
    async appendFilePromise() {
      throw makeError2();
    }
    appendFileSync() {
      throw makeError2();
    }
    async writeFilePromise() {
      throw makeError2();
    }
    writeFileSync() {
      throw makeError2();
    }
    async unlinkPromise() {
      throw makeError2();
    }
    unlinkSync() {
      throw makeError2();
    }
    async utimesPromise() {
      throw makeError2();
    }
    utimesSync() {
      throw makeError2();
    }
    async readFilePromise() {
      throw makeError2();
    }
    readFileSync() {
      throw makeError2();
    }
    async readlinkPromise() {
      throw makeError2();
    }
    readlinkSync() {
      throw makeError2();
    }
    async truncatePromise() {
      throw makeError2();
    }
    truncateSync() {
      throw makeError2();
    }
    watch() {
      throw makeError2();
    }
    watchFile() {
      throw makeError2();
    }
    unwatchFile() {
      throw makeError2();
    }
  };
  var NoFS = NoFS2;
  NoFS.instance = new NoFS2();

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\PosixFS.ts
  var PosixFS = class extends ProxiedFS {
    constructor(baseFs) {
      super(npath);
      this.baseFs = baseFs;
    }
    mapFromBase(path6) {
      return npath.fromPortablePath(path6);
    }
    mapToBase(path6) {
      return npath.toPortablePath(path6);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\VirtualFS.ts
  var NUMBER_REGEXP = /^[0-9]+$/;
  var VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?\$\$virtual)((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
  var VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
  var VirtualFS = class extends ProxiedFS {
    static makeVirtualPath(base, component, to) {
      if (ppath.basename(base) !== `$$virtual`)
        throw new Error(`Assertion failed: Virtual folders must be named "$$virtual"`);
      if (!ppath.basename(component).match(VALID_COMPONENT))
        throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
      const target = ppath.relative(ppath.dirname(base), to);
      const segments = target.split(`/`);
      let depth = 0;
      while (depth < segments.length && segments[depth] === `..`)
        depth += 1;
      const finalSegments = segments.slice(depth);
      const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
      return fullVirtualPath;
    }
    static resolveVirtual(p) {
      const match2 = p.match(VIRTUAL_REGEXP);
      if (!match2 || !match2[3] && match2[5])
        return p;
      const target = ppath.dirname(match2[1]);
      if (!match2[3] || !match2[4])
        return target;
      const isnum = NUMBER_REGEXP.test(match2[4]);
      if (!isnum)
        return p;
      const depth = Number(match2[4]);
      const backstep = `../`.repeat(depth);
      const subpath = match2[5] || `.`;
      return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
    }
    constructor({baseFs = new NodeFS()} = {}) {
      super(ppath);
      this.baseFs = baseFs;
    }
    getExtractHint(hints) {
      return this.baseFs.getExtractHint(hints);
    }
    getRealPath() {
      return this.baseFs.getRealPath();
    }
    realpathSync(p) {
      const match2 = p.match(VIRTUAL_REGEXP);
      if (!match2)
        return this.baseFs.realpathSync(p);
      if (!match2[5])
        return p;
      const realpath = this.baseFs.realpathSync(this.mapToBase(p));
      return VirtualFS.makeVirtualPath(match2[1], match2[3], realpath);
    }
    async realpathPromise(p) {
      const match2 = p.match(VIRTUAL_REGEXP);
      if (!match2)
        return await this.baseFs.realpathPromise(p);
      if (!match2[5])
        return p;
      const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
      return VirtualFS.makeVirtualPath(match2[1], match2[3], realpath);
    }
    mapToBase(p) {
      if (this.pathUtils.isAbsolute(p))
        return VirtualFS.resolveVirtual(p);
      const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath2.dot));
      const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
      return ppath.relative(resolvedRoot, resolvedP);
    }
    mapFromBase(p) {
      return p;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\ZipOpenFS.ts
  var import_fs4 = __toModule(require("fs"));
  var ZIP_FD = 2147483648;
  var FILE_PARTS_REGEX = /.*?(?<!\/)\.zip(?=\/|$)/;
  var ZipOpenFS = class extends BasePortableFakeFS {
    constructor({libzip, baseFs = new NodeFS(), filter = null, maxOpenFiles = Infinity, readOnlyArchives = false, useCache = true, maxAge = 5e3}) {
      super();
      this.fdMap = new Map();
      this.nextFd = 3;
      this.isZip = new Set();
      this.notZip = new Set();
      this.realPaths = new Map();
      this.limitOpenFilesTimeout = null;
      this.libzip = libzip;
      this.baseFs = baseFs;
      this.zipInstances = useCache ? new Map() : null;
      this.filter = filter;
      this.maxOpenFiles = maxOpenFiles;
      this.readOnlyArchives = readOnlyArchives;
      this.maxAge = maxAge;
    }
    static async openPromise(fn, opts) {
      const zipOpenFs = new ZipOpenFS(opts);
      try {
        return await fn(zipOpenFs);
      } finally {
        zipOpenFs.saveAndClose();
      }
    }
    getExtractHint(hints) {
      return this.baseFs.getExtractHint(hints);
    }
    getRealPath() {
      return this.baseFs.getRealPath();
    }
    saveAndClose() {
      unwatchAllFiles(this);
      if (this.zipInstances) {
        for (const [path6, {zipFs}] of this.zipInstances.entries()) {
          zipFs.saveAndClose();
          this.zipInstances.delete(path6);
        }
      }
    }
    discardAndClose() {
      unwatchAllFiles(this);
      if (this.zipInstances) {
        for (const [path6, {zipFs}] of this.zipInstances.entries()) {
          zipFs.discardAndClose();
          this.zipInstances.delete(path6);
        }
      }
    }
    resolve(p) {
      return this.baseFs.resolve(p);
    }
    remapFd(zipFs, fd) {
      const remappedFd = this.nextFd++ | ZIP_FD;
      this.fdMap.set(remappedFd, [zipFs, fd]);
      return remappedFd;
    }
    async openPromise(p, flags, mode) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.openPromise(p, flags, mode);
      }, async (zipFs, {subPath}) => {
        return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
      });
    }
    openSync(p, flags, mode) {
      return this.makeCallSync(p, () => {
        return this.baseFs.openSync(p, flags, mode);
      }, (zipFs, {subPath}) => {
        return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
      });
    }
    async opendirPromise(p, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.opendirPromise(p, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.opendirPromise(subPath, opts);
      }, {
        requireSubpath: false
      });
    }
    opendirSync(p, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.opendirSync(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.opendirSync(subPath, opts);
      }, {
        requireSubpath: false
      });
    }
    async readPromise(fd, buffer, offset, length, position) {
      if ((fd & ZIP_FD) === 0)
        return await this.baseFs.readPromise(fd, buffer, offset, length, position);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`read`);
      const [zipFs, realFd] = entry;
      return await zipFs.readPromise(realFd, buffer, offset, length, position);
    }
    readSync(fd, buffer, offset, length, position) {
      if ((fd & ZIP_FD) === 0)
        return this.baseFs.readSync(fd, buffer, offset, length, position);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`readSync`);
      const [zipFs, realFd] = entry;
      return zipFs.readSync(realFd, buffer, offset, length, position);
    }
    async writePromise(fd, buffer, offset, length, position) {
      if ((fd & ZIP_FD) === 0) {
        if (typeof buffer === `string`) {
          return await this.baseFs.writePromise(fd, buffer, offset);
        } else {
          return await this.baseFs.writePromise(fd, buffer, offset, length, position);
        }
      }
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`write`);
      const [zipFs, realFd] = entry;
      if (typeof buffer === `string`) {
        return await zipFs.writePromise(realFd, buffer, offset);
      } else {
        return await zipFs.writePromise(realFd, buffer, offset, length, position);
      }
    }
    writeSync(fd, buffer, offset, length, position) {
      if ((fd & ZIP_FD) === 0) {
        if (typeof buffer === `string`) {
          return this.baseFs.writeSync(fd, buffer, offset);
        } else {
          return this.baseFs.writeSync(fd, buffer, offset, length, position);
        }
      }
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`writeSync`);
      const [zipFs, realFd] = entry;
      if (typeof buffer === `string`) {
        return zipFs.writeSync(realFd, buffer, offset);
      } else {
        return zipFs.writeSync(realFd, buffer, offset, length, position);
      }
    }
    async closePromise(fd) {
      if ((fd & ZIP_FD) === 0)
        return await this.baseFs.closePromise(fd);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`close`);
      this.fdMap.delete(fd);
      const [zipFs, realFd] = entry;
      return await zipFs.closePromise(realFd);
    }
    closeSync(fd) {
      if ((fd & ZIP_FD) === 0)
        return this.baseFs.closeSync(fd);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`closeSync`);
      this.fdMap.delete(fd);
      const [zipFs, realFd] = entry;
      return zipFs.closeSync(realFd);
    }
    createReadStream(p, opts) {
      if (p === null)
        return this.baseFs.createReadStream(p, opts);
      return this.makeCallSync(p, () => {
        return this.baseFs.createReadStream(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.createReadStream(subPath, opts);
      });
    }
    createWriteStream(p, opts) {
      if (p === null)
        return this.baseFs.createWriteStream(p, opts);
      return this.makeCallSync(p, () => {
        return this.baseFs.createWriteStream(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.createWriteStream(subPath, opts);
      });
    }
    async realpathPromise(p) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.realpathPromise(p);
      }, async (zipFs, {archivePath, subPath}) => {
        let realArchivePath = this.realPaths.get(archivePath);
        if (typeof realArchivePath === `undefined`) {
          realArchivePath = await this.baseFs.realpathPromise(archivePath);
          this.realPaths.set(archivePath, realArchivePath);
        }
        return this.pathUtils.join(realArchivePath, this.pathUtils.relative(PortablePath2.root, await zipFs.realpathPromise(subPath)));
      });
    }
    realpathSync(p) {
      return this.makeCallSync(p, () => {
        return this.baseFs.realpathSync(p);
      }, (zipFs, {archivePath, subPath}) => {
        let realArchivePath = this.realPaths.get(archivePath);
        if (typeof realArchivePath === `undefined`) {
          realArchivePath = this.baseFs.realpathSync(archivePath);
          this.realPaths.set(archivePath, realArchivePath);
        }
        return this.pathUtils.join(realArchivePath, this.pathUtils.relative(PortablePath2.root, zipFs.realpathSync(subPath)));
      });
    }
    async existsPromise(p) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.existsPromise(p);
      }, async (zipFs, {subPath}) => {
        return await zipFs.existsPromise(subPath);
      });
    }
    existsSync(p) {
      return this.makeCallSync(p, () => {
        return this.baseFs.existsSync(p);
      }, (zipFs, {subPath}) => {
        return zipFs.existsSync(subPath);
      });
    }
    async accessPromise(p, mode) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.accessPromise(p, mode);
      }, async (zipFs, {subPath}) => {
        return await zipFs.accessPromise(subPath, mode);
      });
    }
    accessSync(p, mode) {
      return this.makeCallSync(p, () => {
        return this.baseFs.accessSync(p, mode);
      }, (zipFs, {subPath}) => {
        return zipFs.accessSync(subPath, mode);
      });
    }
    async statPromise(p, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.statPromise(p, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.statPromise(subPath, opts);
      });
    }
    statSync(p, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.statSync(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.statSync(subPath, opts);
      });
    }
    async fstatPromise(fd, opts) {
      if ((fd & ZIP_FD) === 0)
        return this.baseFs.fstatPromise(fd, opts);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`fstat`);
      const [zipFs, realFd] = entry;
      return zipFs.fstatPromise(realFd, opts);
    }
    fstatSync(fd, opts) {
      if ((fd & ZIP_FD) === 0)
        return this.baseFs.fstatSync(fd, opts);
      const entry = this.fdMap.get(fd);
      if (typeof entry === `undefined`)
        throw EBADF(`fstatSync`);
      const [zipFs, realFd] = entry;
      return zipFs.fstatSync(realFd, opts);
    }
    async lstatPromise(p, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.lstatPromise(p, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.lstatPromise(subPath, opts);
      });
    }
    lstatSync(p, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.lstatSync(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.lstatSync(subPath, opts);
      });
    }
    async chmodPromise(p, mask) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.chmodPromise(p, mask);
      }, async (zipFs, {subPath}) => {
        return await zipFs.chmodPromise(subPath, mask);
      });
    }
    chmodSync(p, mask) {
      return this.makeCallSync(p, () => {
        return this.baseFs.chmodSync(p, mask);
      }, (zipFs, {subPath}) => {
        return zipFs.chmodSync(subPath, mask);
      });
    }
    async chownPromise(p, uid, gid) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.chownPromise(p, uid, gid);
      }, async (zipFs, {subPath}) => {
        return await zipFs.chownPromise(subPath, uid, gid);
      });
    }
    chownSync(p, uid, gid) {
      return this.makeCallSync(p, () => {
        return this.baseFs.chownSync(p, uid, gid);
      }, (zipFs, {subPath}) => {
        return zipFs.chownSync(subPath, uid, gid);
      });
    }
    async renamePromise(oldP, newP) {
      return await this.makeCallPromise(oldP, async () => {
        return await this.makeCallPromise(newP, async () => {
          return await this.baseFs.renamePromise(oldP, newP);
        }, async () => {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
        });
      }, async (zipFsO, {subPath: subPathO}) => {
        return await this.makeCallPromise(newP, async () => {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
        }, async (zipFsN, {subPath: subPathN}) => {
          if (zipFsO !== zipFsN) {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
          } else {
            return await zipFsO.renamePromise(subPathO, subPathN);
          }
        });
      });
    }
    renameSync(oldP, newP) {
      return this.makeCallSync(oldP, () => {
        return this.makeCallSync(newP, () => {
          return this.baseFs.renameSync(oldP, newP);
        }, async () => {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
        });
      }, (zipFsO, {subPath: subPathO}) => {
        return this.makeCallSync(newP, () => {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
        }, (zipFsN, {subPath: subPathN}) => {
          if (zipFsO !== zipFsN) {
            throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {code: `EEXDEV`});
          } else {
            return zipFsO.renameSync(subPathO, subPathN);
          }
        });
      });
    }
    async copyFilePromise(sourceP, destP, flags = 0) {
      const fallback = async (sourceFs, sourceP2, destFs, destP2) => {
        if ((flags & import_fs4.constants.COPYFILE_FICLONE_FORCE) !== 0)
          throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP2}' -> ${destP2}'`), {code: `EXDEV`});
        if (flags & import_fs4.constants.COPYFILE_EXCL && await this.existsPromise(sourceP2))
          throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP2}' -> '${destP2}'`), {code: `EEXIST`});
        let content;
        try {
          content = await sourceFs.readFilePromise(sourceP2);
        } catch (error) {
          throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP2}' -> '${destP2}'`), {code: `EINVAL`});
        }
        await destFs.writeFilePromise(destP2, content);
      };
      return await this.makeCallPromise(sourceP, async () => {
        return await this.makeCallPromise(destP, async () => {
          return await this.baseFs.copyFilePromise(sourceP, destP, flags);
        }, async (zipFsD, {subPath: subPathD}) => {
          return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
        });
      }, async (zipFsS, {subPath: subPathS}) => {
        return await this.makeCallPromise(destP, async () => {
          return await fallback(zipFsS, subPathS, this.baseFs, destP);
        }, async (zipFsD, {subPath: subPathD}) => {
          if (zipFsS !== zipFsD) {
            return await fallback(zipFsS, subPathS, zipFsD, subPathD);
          } else {
            return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
          }
        });
      });
    }
    copyFileSync(sourceP, destP, flags = 0) {
      const fallback = (sourceFs, sourceP2, destFs, destP2) => {
        if ((flags & import_fs4.constants.COPYFILE_FICLONE_FORCE) !== 0)
          throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP2}' -> ${destP2}'`), {code: `EXDEV`});
        if (flags & import_fs4.constants.COPYFILE_EXCL && this.existsSync(sourceP2))
          throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP2}' -> '${destP2}'`), {code: `EEXIST`});
        let content;
        try {
          content = sourceFs.readFileSync(sourceP2);
        } catch (error) {
          throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP2}' -> '${destP2}'`), {code: `EINVAL`});
        }
        destFs.writeFileSync(destP2, content);
      };
      return this.makeCallSync(sourceP, () => {
        return this.makeCallSync(destP, () => {
          return this.baseFs.copyFileSync(sourceP, destP, flags);
        }, (zipFsD, {subPath: subPathD}) => {
          return fallback(this.baseFs, sourceP, zipFsD, subPathD);
        });
      }, (zipFsS, {subPath: subPathS}) => {
        return this.makeCallSync(destP, () => {
          return fallback(zipFsS, subPathS, this.baseFs, destP);
        }, (zipFsD, {subPath: subPathD}) => {
          if (zipFsS !== zipFsD) {
            return fallback(zipFsS, subPathS, zipFsD, subPathD);
          } else {
            return zipFsS.copyFileSync(subPathS, subPathD, flags);
          }
        });
      });
    }
    async appendFilePromise(p, content, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.appendFilePromise(p, content, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.appendFilePromise(subPath, content, opts);
      });
    }
    appendFileSync(p, content, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.appendFileSync(p, content, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.appendFileSync(subPath, content, opts);
      });
    }
    async writeFilePromise(p, content, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.writeFilePromise(p, content, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.writeFilePromise(subPath, content, opts);
      });
    }
    writeFileSync(p, content, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.writeFileSync(p, content, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.writeFileSync(subPath, content, opts);
      });
    }
    async unlinkPromise(p) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.unlinkPromise(p);
      }, async (zipFs, {subPath}) => {
        return await zipFs.unlinkPromise(subPath);
      });
    }
    unlinkSync(p) {
      return this.makeCallSync(p, () => {
        return this.baseFs.unlinkSync(p);
      }, (zipFs, {subPath}) => {
        return zipFs.unlinkSync(subPath);
      });
    }
    async utimesPromise(p, atime, mtime) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.utimesPromise(p, atime, mtime);
      }, async (zipFs, {subPath}) => {
        return await zipFs.utimesPromise(subPath, atime, mtime);
      });
    }
    utimesSync(p, atime, mtime) {
      return this.makeCallSync(p, () => {
        return this.baseFs.utimesSync(p, atime, mtime);
      }, (zipFs, {subPath}) => {
        return zipFs.utimesSync(subPath, atime, mtime);
      });
    }
    async mkdirPromise(p, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.mkdirPromise(p, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.mkdirPromise(subPath, opts);
      });
    }
    mkdirSync(p, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.mkdirSync(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.mkdirSync(subPath, opts);
      });
    }
    async rmdirPromise(p, opts) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.rmdirPromise(p, opts);
      }, async (zipFs, {subPath}) => {
        return await zipFs.rmdirPromise(subPath, opts);
      });
    }
    rmdirSync(p, opts) {
      return this.makeCallSync(p, () => {
        return this.baseFs.rmdirSync(p, opts);
      }, (zipFs, {subPath}) => {
        return zipFs.rmdirSync(subPath, opts);
      });
    }
    async linkPromise(existingP, newP) {
      return await this.makeCallPromise(newP, async () => {
        return await this.baseFs.linkPromise(existingP, newP);
      }, async (zipFs, {subPath}) => {
        return await zipFs.linkPromise(existingP, subPath);
      });
    }
    linkSync(existingP, newP) {
      return this.makeCallSync(newP, () => {
        return this.baseFs.linkSync(existingP, newP);
      }, (zipFs, {subPath}) => {
        return zipFs.linkSync(existingP, subPath);
      });
    }
    async symlinkPromise(target, p, type) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.symlinkPromise(target, p, type);
      }, async (zipFs, {subPath}) => {
        return await zipFs.symlinkPromise(target, subPath);
      });
    }
    symlinkSync(target, p, type) {
      return this.makeCallSync(p, () => {
        return this.baseFs.symlinkSync(target, p, type);
      }, (zipFs, {subPath}) => {
        return zipFs.symlinkSync(target, subPath);
      });
    }
    async readFilePromise(p, encoding) {
      return this.makeCallPromise(p, async () => {
        switch (encoding) {
          case `utf8`:
            return await this.baseFs.readFilePromise(p, encoding);
          default:
            return await this.baseFs.readFilePromise(p, encoding);
        }
      }, async (zipFs, {subPath}) => {
        return await zipFs.readFilePromise(subPath, encoding);
      });
    }
    readFileSync(p, encoding) {
      return this.makeCallSync(p, () => {
        switch (encoding) {
          case `utf8`:
            return this.baseFs.readFileSync(p, encoding);
          default:
            return this.baseFs.readFileSync(p, encoding);
        }
      }, (zipFs, {subPath}) => {
        return zipFs.readFileSync(subPath, encoding);
      });
    }
    async readdirPromise(p, {withFileTypes} = {}) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.readdirPromise(p, {withFileTypes});
      }, async (zipFs, {subPath}) => {
        return await zipFs.readdirPromise(subPath, {withFileTypes});
      }, {
        requireSubpath: false
      });
    }
    readdirSync(p, {withFileTypes} = {}) {
      return this.makeCallSync(p, () => {
        return this.baseFs.readdirSync(p, {withFileTypes});
      }, (zipFs, {subPath}) => {
        return zipFs.readdirSync(subPath, {withFileTypes});
      }, {
        requireSubpath: false
      });
    }
    async readlinkPromise(p) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.readlinkPromise(p);
      }, async (zipFs, {subPath}) => {
        return await zipFs.readlinkPromise(subPath);
      });
    }
    readlinkSync(p) {
      return this.makeCallSync(p, () => {
        return this.baseFs.readlinkSync(p);
      }, (zipFs, {subPath}) => {
        return zipFs.readlinkSync(subPath);
      });
    }
    async truncatePromise(p, len) {
      return await this.makeCallPromise(p, async () => {
        return await this.baseFs.truncatePromise(p, len);
      }, async (zipFs, {subPath}) => {
        return await zipFs.truncatePromise(subPath, len);
      });
    }
    truncateSync(p, len) {
      return this.makeCallSync(p, () => {
        return this.baseFs.truncateSync(p, len);
      }, (zipFs, {subPath}) => {
        return zipFs.truncateSync(subPath, len);
      });
    }
    watch(p, a, b) {
      return this.makeCallSync(p, () => {
        return this.baseFs.watch(p, a, b);
      }, (zipFs, {subPath}) => {
        return zipFs.watch(subPath, a, b);
      });
    }
    watchFile(p, a, b) {
      return this.makeCallSync(p, () => {
        return this.baseFs.watchFile(p, a, b);
      }, () => {
        return watchFile(this, p, a, b);
      });
    }
    unwatchFile(p, cb) {
      return this.makeCallSync(p, () => {
        return this.baseFs.unwatchFile(p, cb);
      }, () => {
        return unwatchFile(this, p, cb);
      });
    }
    async makeCallPromise(p, discard, accept, {requireSubpath = true} = {}) {
      if (typeof p !== `string`)
        return await discard();
      const normalizedP = this.resolve(p);
      const zipInfo = this.findZip(normalizedP);
      if (!zipInfo)
        return await discard();
      if (requireSubpath && zipInfo.subPath === `/`)
        return await discard();
      return await this.getZipPromise(zipInfo.archivePath, async (zipFs) => await accept(zipFs, zipInfo));
    }
    makeCallSync(p, discard, accept, {requireSubpath = true} = {}) {
      if (typeof p !== `string`)
        return discard();
      const normalizedP = this.resolve(p);
      const zipInfo = this.findZip(normalizedP);
      if (!zipInfo)
        return discard();
      if (requireSubpath && zipInfo.subPath === `/`)
        return discard();
      return this.getZipSync(zipInfo.archivePath, (zipFs) => accept(zipFs, zipInfo));
    }
    findZip(p) {
      if (this.filter && !this.filter.test(p))
        return null;
      let filePath = ``;
      while (true) {
        const parts = FILE_PARTS_REGEX.exec(p.substr(filePath.length));
        if (!parts)
          return null;
        filePath = this.pathUtils.join(filePath, parts[0]);
        if (this.isZip.has(filePath) === false) {
          if (this.notZip.has(filePath))
            continue;
          try {
            if (!this.baseFs.lstatSync(filePath).isFile()) {
              this.notZip.add(filePath);
              continue;
            }
          } catch {
            return null;
          }
          this.isZip.add(filePath);
        }
        return {
          archivePath: filePath,
          subPath: this.pathUtils.join(PortablePath2.root, p.substr(filePath.length))
        };
      }
    }
    limitOpenFiles(max) {
      if (this.zipInstances === null)
        return;
      const now2 = Date.now();
      let nextExpiresAt = now2 + this.maxAge;
      let closeCount = max === null ? 0 : this.zipInstances.size - max;
      for (const [path6, {zipFs, expiresAt, refCount}] of this.zipInstances.entries()) {
        if (refCount !== 0 || zipFs.hasOpenFileHandles()) {
          continue;
        } else if (now2 >= expiresAt) {
          zipFs.saveAndClose();
          this.zipInstances.delete(path6);
          closeCount -= 1;
          continue;
        } else if (max === null || closeCount <= 0) {
          nextExpiresAt = expiresAt;
          break;
        }
        zipFs.saveAndClose();
        this.zipInstances.delete(path6);
        closeCount -= 1;
      }
      if (this.limitOpenFilesTimeout === null && (max === null && this.zipInstances.size > 0 || max !== null)) {
        this.limitOpenFilesTimeout = setTimeout(() => {
          this.limitOpenFilesTimeout = null;
          this.limitOpenFiles(null);
        }, nextExpiresAt - now2).unref();
      }
    }
    async getZipPromise(p, accept) {
      const getZipOptions = async () => ({
        baseFs: this.baseFs,
        libzip: this.libzip,
        readOnly: this.readOnlyArchives,
        stats: await this.baseFs.statPromise(p)
      });
      if (this.zipInstances) {
        let cachedZipFs = this.zipInstances.get(p);
        if (!cachedZipFs) {
          const zipOptions = await getZipOptions();
          cachedZipFs = this.zipInstances.get(p);
          if (!cachedZipFs) {
            cachedZipFs = {
              zipFs: new ZipFS(p, zipOptions),
              expiresAt: 0,
              refCount: 0
            };
          }
        }
        this.zipInstances.delete(p);
        this.limitOpenFiles(this.maxOpenFiles - 1);
        this.zipInstances.set(p, cachedZipFs);
        cachedZipFs.expiresAt = Date.now() + this.maxAge;
        cachedZipFs.refCount += 1;
        try {
          return await accept(cachedZipFs.zipFs);
        } finally {
          cachedZipFs.refCount -= 1;
        }
      } else {
        const zipFs = new ZipFS(p, await getZipOptions());
        try {
          return await accept(zipFs);
        } finally {
          zipFs.saveAndClose();
        }
      }
    }
    getZipSync(p, accept) {
      const getZipOptions = () => ({
        baseFs: this.baseFs,
        libzip: this.libzip,
        readOnly: this.readOnlyArchives,
        stats: this.baseFs.statSync(p)
      });
      if (this.zipInstances) {
        let cachedZipFs = this.zipInstances.get(p);
        if (!cachedZipFs) {
          cachedZipFs = {
            zipFs: new ZipFS(p, getZipOptions()),
            expiresAt: 0,
            refCount: 0
          };
        }
        this.zipInstances.delete(p);
        this.limitOpenFiles(this.maxOpenFiles - 1);
        this.zipInstances.set(p, cachedZipFs);
        cachedZipFs.expiresAt = Date.now() + this.maxAge;
        return accept(cachedZipFs.zipFs);
      } else {
        const zipFs = new ZipFS(p, getZipOptions());
        try {
          return accept(zipFs);
        } finally {
          zipFs.saveAndClose();
        }
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\patchFs.ts
  var import_util2 = __toModule(require("util"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\URLFS.ts
  var import_url = __toModule(require("url"));
  var URLFS = class extends ProxiedFS {
    constructor(baseFs) {
      super(npath);
      this.baseFs = baseFs;
    }
    mapFromBase(path6) {
      return path6;
    }
    mapToBase(path6) {
      if (path6 instanceof import_url.URL)
        return import_url.fileURLToPath(path6);
      return path6;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\patchFs.ts
  var SYNC_IMPLEMENTATIONS = new Set([
    `accessSync`,
    `appendFileSync`,
    `createReadStream`,
    `chmodSync`,
    `chownSync`,
    `closeSync`,
    `copyFileSync`,
    `linkSync`,
    `lstatSync`,
    `fstatSync`,
    `lutimesSync`,
    `mkdirSync`,
    `openSync`,
    `opendirSync`,
    `readSync`,
    `readlinkSync`,
    `readFileSync`,
    `readdirSync`,
    `readlinkSync`,
    `realpathSync`,
    `renameSync`,
    `rmdirSync`,
    `statSync`,
    `symlinkSync`,
    `truncateSync`,
    `unlinkSync`,
    `unwatchFile`,
    `utimesSync`,
    `watch`,
    `watchFile`,
    `writeFileSync`,
    `writeSync`
  ]);
  var ASYNC_IMPLEMENTATIONS = new Set([
    `accessPromise`,
    `appendFilePromise`,
    `chmodPromise`,
    `chownPromise`,
    `closePromise`,
    `copyFilePromise`,
    `linkPromise`,
    `fstatPromise`,
    `lstatPromise`,
    `lutimesPromise`,
    `mkdirPromise`,
    `openPromise`,
    `opendirPromise`,
    `readdirPromise`,
    `realpathPromise`,
    `readFilePromise`,
    `readdirPromise`,
    `readlinkPromise`,
    `renamePromise`,
    `rmdirPromise`,
    `statPromise`,
    `symlinkPromise`,
    `truncatePromise`,
    `unlinkPromise`,
    `utimesPromise`,
    `writeFilePromise`,
    `writeSync`
  ]);
  var FILEHANDLE_IMPLEMENTATIONS = new Set([
    `appendFilePromise`,
    `chmodPromise`,
    `chownPromise`,
    `closePromise`,
    `readPromise`,
    `readFilePromise`,
    `statPromise`,
    `truncatePromise`,
    `utimesPromise`,
    `writePromise`,
    `writeFilePromise`
  ]);
  function patchFs(patchedFs, fakeFs) {
    fakeFs = new URLFS(fakeFs);
    const setupFn = (target, name, replacement) => {
      const orig = target[name];
      target[name] = replacement;
      if (typeof (orig == null ? void 0 : orig[import_util2.promisify.custom]) !== `undefined`) {
        replacement[import_util2.promisify.custom] = orig[import_util2.promisify.custom];
      }
    };
    {
      setupFn(patchedFs, `exists`, (p, ...args) => {
        const hasCallback = typeof args[args.length - 1] === `function`;
        const callback = hasCallback ? args.pop() : () => {
        };
        process.nextTick(() => {
          fakeFs.existsPromise(p).then((exists) => {
            callback(exists);
          }, () => {
            callback(false);
          });
        });
      });
      setupFn(patchedFs, `read`, (p, buffer, ...args) => {
        const hasCallback = typeof args[args.length - 1] === `function`;
        const callback = hasCallback ? args.pop() : () => {
        };
        process.nextTick(() => {
          fakeFs.readPromise(p, buffer, ...args).then((bytesRead) => {
            callback(null, bytesRead, buffer);
          }, (error) => {
            callback(error);
          });
        });
      });
      for (const fnName of ASYNC_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        if (typeof patchedFs[origName] === `undefined`)
          continue;
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`)
          continue;
        const wrapper = (...args) => {
          const hasCallback = typeof args[args.length - 1] === `function`;
          const callback = hasCallback ? args.pop() : () => {
          };
          process.nextTick(() => {
            fakeImpl.apply(fakeFs, args).then((result) => {
              callback(null, result);
            }, (error) => {
              callback(error);
            });
          });
        };
        setupFn(patchedFs, origName, wrapper);
      }
      patchedFs.realpath.native = patchedFs.realpath;
    }
    {
      setupFn(patchedFs, `existsSync`, (p) => {
        try {
          return fakeFs.existsSync(p);
        } catch (error) {
          return false;
        }
      });
      for (const fnName of SYNC_IMPLEMENTATIONS) {
        const origName = fnName;
        if (typeof patchedFs[origName] === `undefined`)
          continue;
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`)
          continue;
        setupFn(patchedFs, origName, fakeImpl.bind(fakeFs));
      }
      patchedFs.realpathSync.native = patchedFs.realpathSync;
    }
    {
      const origEmitWarning = process.emitWarning;
      process.emitWarning = () => {
      };
      let patchedFsPromises;
      try {
        patchedFsPromises = patchedFs.promises;
      } finally {
        process.emitWarning = origEmitWarning;
      }
      if (typeof patchedFsPromises !== `undefined`) {
        for (const fnName of ASYNC_IMPLEMENTATIONS) {
          const origName = fnName.replace(/Promise$/, ``);
          if (typeof patchedFsPromises[origName] === `undefined`)
            continue;
          const fakeImpl = fakeFs[fnName];
          if (typeof fakeImpl === `undefined`)
            continue;
          if (fnName === `open`)
            continue;
          setupFn(patchedFsPromises, origName, fakeImpl.bind(fakeFs));
        }
        class FileHandle {
          constructor(fd) {
            this.fd = fd;
          }
        }
        for (const fnName of FILEHANDLE_IMPLEMENTATIONS) {
          const origName = fnName.replace(/Promise$/, ``);
          const fakeImpl = fakeFs[fnName];
          if (typeof fakeImpl === `undefined`)
            continue;
          setupFn(FileHandle.prototype, origName, function(...args) {
            return fakeImpl.call(fakeFs, this.fd, ...args);
          });
        }
        setupFn(patchedFsPromises, `open`, async (...args) => {
          const fd = await fakeFs.openPromise(...args);
          return new FileHandle(fd);
        });
      }
    }
    {
      patchedFs.read[import_util2.promisify.custom] = async (p, buffer, ...args) => {
        const res = fakeFs.readPromise(p, buffer, ...args);
        return {bytesRead: await res, buffer};
      };
    }
  }
  function extendFs(realFs, fakeFs) {
    const patchedFs = Object.create(realFs);
    patchFs(patchedFs, fakeFs);
    return patchedFs;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-fslib\sources\xfs.ts
  var import_os2 = __toModule(require("os"));
  function getTempName(prefix) {
    const tmpdir5 = npath.toPortablePath(import_os2.default.tmpdir());
    const hash = Math.ceil(Math.random() * 4294967296).toString(16).padStart(8, `0`);
    return ppath.join(tmpdir5, `${prefix}${hash}`);
  }
  var tmpdirs = new Set();
  var cleanExitRegistered = false;
  function registerCleanExit() {
    if (cleanExitRegistered)
      return;
    cleanExitRegistered = true;
    process.once(`exit`, () => {
      xfs.rmtempSync();
    });
  }
  var xfs = Object.assign(new NodeFS(), {
    detachTemp(p) {
      tmpdirs.delete(p);
    },
    mktempSync(cb) {
      registerCleanExit();
      while (true) {
        const p = getTempName(`xfs-`);
        try {
          this.mkdirSync(p);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        const realP = this.realpathSync(p);
        tmpdirs.add(realP);
        if (typeof cb !== `undefined`) {
          try {
            return cb(realP);
          } finally {
            if (tmpdirs.has(realP)) {
              tmpdirs.delete(realP);
              try {
                this.removeSync(realP);
              } catch {
              }
            }
          }
        } else {
          return realP;
        }
      }
    },
    async mktempPromise(cb) {
      registerCleanExit();
      while (true) {
        const p = getTempName(`xfs-`);
        try {
          await this.mkdirPromise(p);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        const realP = await this.realpathPromise(p);
        tmpdirs.add(realP);
        if (typeof cb !== `undefined`) {
          try {
            return await cb(realP);
          } finally {
            if (tmpdirs.has(realP)) {
              tmpdirs.delete(realP);
              try {
                await this.removePromise(realP);
              } catch {
              }
            }
          }
        } else {
          return realP;
        }
      }
    },
    async rmtempPromise() {
      await Promise.all(Array.from(tmpdirs.values()).map(async (p) => {
        try {
          await xfs.removePromise(p, {maxRetries: 0});
          tmpdirs.delete(p);
        } catch {
        }
      }));
    },
    rmtempSync() {
      for (const p of tmpdirs) {
        try {
          xfs.removeSync(p);
          tmpdirs.delete(p);
        } catch {
        }
      }
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\execUtils.ts
  var import_cross_spawn = __toModule(require_cross_spawn());
  var EndStrategy;
  (function(EndStrategy2) {
    EndStrategy2[EndStrategy2["Never"] = 0] = "Never";
    EndStrategy2[EndStrategy2["ErrorCode"] = 1] = "ErrorCode";
    EndStrategy2[EndStrategy2["Always"] = 2] = "Always";
  })(EndStrategy || (EndStrategy = {}));
  function hasFd(stream) {
    return stream !== null && typeof stream.fd === `number`;
  }
  var activeChildren = new Set();
  function sigintHandler() {
  }
  function sigtermHandler() {
    for (const child of activeChildren) {
      child.kill();
    }
  }
  async function pipevp(fileName, args, {cwd, env = process.env, strict = false, stdin = null, stdout, stderr, end = 2}) {
    const stdio = [`pipe`, `pipe`, `pipe`];
    if (stdin === null)
      stdio[0] = `ignore`;
    else if (hasFd(stdin))
      stdio[0] = stdin;
    if (hasFd(stdout))
      stdio[1] = stdout;
    if (hasFd(stderr))
      stdio[2] = stderr;
    const child = import_cross_spawn.default(fileName, args, {
      cwd: npath.fromPortablePath(cwd),
      env: {
        ...env,
        PWD: npath.fromPortablePath(cwd)
      },
      stdio
    });
    activeChildren.add(child);
    if (activeChildren.size === 1) {
      process.on(`SIGINT`, sigintHandler);
      process.on(`SIGTERM`, sigtermHandler);
    }
    if (!hasFd(stdin) && stdin !== null)
      stdin.pipe(child.stdin);
    if (!hasFd(stdout))
      child.stdout.pipe(stdout, {end: false});
    if (!hasFd(stderr))
      child.stderr.pipe(stderr, {end: false});
    const closeStreams = () => {
      for (const stream of new Set([stdout, stderr])) {
        if (!hasFd(stream)) {
          stream.end();
        }
      }
    };
    return new Promise((resolve, reject) => {
      child.on(`error`, (error) => {
        activeChildren.delete(child);
        if (activeChildren.size === 0) {
          process.off(`SIGINT`, sigintHandler);
          process.off(`SIGTERM`, sigtermHandler);
        }
        if (end === 2 || end === 1)
          closeStreams();
        reject(error);
      });
      child.on(`close`, (code, sig) => {
        activeChildren.delete(child);
        if (activeChildren.size === 0) {
          process.off(`SIGINT`, sigintHandler);
          process.off(`SIGTERM`, sigtermHandler);
        }
        if (end === 2 || end === 1 && code > 0)
          closeStreams();
        if (code === 0 || !strict) {
          resolve({code: getExitCode(code, sig)});
        } else if (code !== null) {
          reject(new Error(`Child "${fileName}" exited with exit code ${code}`));
        } else {
          reject(new Error(`Child "${fileName}" exited with signal ${sig}`));
        }
      });
    });
  }
  async function execvp(fileName, args, {cwd, env = process.env, encoding = `utf8`, strict = false}) {
    const stdio = [`ignore`, `pipe`, `pipe`];
    const stdoutChunks = [];
    const stderrChunks = [];
    const nativeCwd = npath.fromPortablePath(cwd);
    if (typeof env.PWD !== `undefined`)
      env = {...env, PWD: nativeCwd};
    const subprocess = import_cross_spawn.default(fileName, args, {
      cwd: nativeCwd,
      env,
      stdio
    });
    subprocess.stdout.on(`data`, (chunk) => {
      stdoutChunks.push(chunk);
    });
    subprocess.stderr.on(`data`, (chunk) => {
      stderrChunks.push(chunk);
    });
    return await new Promise((resolve, reject) => {
      subprocess.on(`error`, () => {
        reject();
      });
      subprocess.on(`close`, (code, signal) => {
        const stdout = encoding === `buffer` ? Buffer.concat(stdoutChunks) : Buffer.concat(stdoutChunks).toString(encoding);
        const stderr = encoding === `buffer` ? Buffer.concat(stderrChunks) : Buffer.concat(stderrChunks).toString(encoding);
        if (code === 0 || !strict) {
          resolve({
            code: getExitCode(code, signal),
            stdout,
            stderr
          });
        } else {
          reject(Object.assign(new Error(`Child "${fileName}" exited with exit code ${code}

${stderr}`), {
            code: getExitCode(code, signal),
            stdout,
            stderr
          }));
        }
      });
    });
  }
  var signalToCodeMap = new Map([
    [`SIGINT`, 2],
    [`SIGQUIT`, 3],
    [`SIGKILL`, 9],
    [`SIGTERM`, 15]
  ]);
  function getExitCode(code, signal) {
    const signalCode = signalToCodeMap.get(signal);
    if (typeof signalCode !== `undefined`) {
      return 128 + signalCode;
    } else {
      return code != null ? code : 1;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\folderUtils.ts
  var folderUtils_exports = {};
  __export(folderUtils_exports, {
    getDefaultGlobalFolder: () => getDefaultGlobalFolder,
    getHomeFolder: () => getHomeFolder,
    isFolderInside: () => isFolderInside
  });
  var import_os3 = __toModule(require("os"));
  function getDefaultGlobalFolder() {
    if (process.platform === `win32`) {
      const base = npath.toPortablePath(process.env.LOCALAPPDATA || npath.join(import_os3.homedir(), `AppData`, `Local`));
      return ppath.resolve(base, `Yarn/Berry`);
    }
    if (process.env.XDG_DATA_HOME) {
      const base = npath.toPortablePath(process.env.XDG_DATA_HOME);
      return ppath.resolve(base, `yarn/berry`);
    }
    return ppath.resolve(getHomeFolder(), `.yarn/berry`);
  }
  function getHomeFolder() {
    return npath.toPortablePath(import_os3.homedir() || `/usr/local/share`);
  }
  function isFolderInside(target, parent) {
    const relative = ppath.relative(parent, target);
    return relative && !relative.startsWith(`..`) && !ppath.isAbsolute(relative);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\formatUtils.ts
  var formatUtils_exports = {};
  __export(formatUtils_exports, {
    LogLevel: () => LogLevel,
    Style: () => Style,
    Type: () => Type,
    addLogFilterSupport: () => addLogFilterSupport,
    applyColor: () => applyColor,
    applyStyle: () => applyStyle,
    json: () => json,
    mark: () => mark,
    pretty: () => pretty,
    prettyList: () => prettyList,
    supportsColor: () => supportsColor,
    supportsHyperlinks: () => supportsHyperlinks,
    tuple: () => tuple
  });
  var import_chalk = __toModule(require_source());
  var import_strip_ansi = __toModule(require_strip_ansi());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\MessageName.ts
  var MessageName;
  (function(MessageName2) {
    MessageName2[MessageName2["UNNAMED"] = 0] = "UNNAMED";
    MessageName2[MessageName2["EXCEPTION"] = 1] = "EXCEPTION";
    MessageName2[MessageName2["MISSING_PEER_DEPENDENCY"] = 2] = "MISSING_PEER_DEPENDENCY";
    MessageName2[MessageName2["CYCLIC_DEPENDENCIES"] = 3] = "CYCLIC_DEPENDENCIES";
    MessageName2[MessageName2["DISABLED_BUILD_SCRIPTS"] = 4] = "DISABLED_BUILD_SCRIPTS";
    MessageName2[MessageName2["BUILD_DISABLED"] = 5] = "BUILD_DISABLED";
    MessageName2[MessageName2["SOFT_LINK_BUILD"] = 6] = "SOFT_LINK_BUILD";
    MessageName2[MessageName2["MUST_BUILD"] = 7] = "MUST_BUILD";
    MessageName2[MessageName2["MUST_REBUILD"] = 8] = "MUST_REBUILD";
    MessageName2[MessageName2["BUILD_FAILED"] = 9] = "BUILD_FAILED";
    MessageName2[MessageName2["RESOLVER_NOT_FOUND"] = 10] = "RESOLVER_NOT_FOUND";
    MessageName2[MessageName2["FETCHER_NOT_FOUND"] = 11] = "FETCHER_NOT_FOUND";
    MessageName2[MessageName2["LINKER_NOT_FOUND"] = 12] = "LINKER_NOT_FOUND";
    MessageName2[MessageName2["FETCH_NOT_CACHED"] = 13] = "FETCH_NOT_CACHED";
    MessageName2[MessageName2["YARN_IMPORT_FAILED"] = 14] = "YARN_IMPORT_FAILED";
    MessageName2[MessageName2["REMOTE_INVALID"] = 15] = "REMOTE_INVALID";
    MessageName2[MessageName2["REMOTE_NOT_FOUND"] = 16] = "REMOTE_NOT_FOUND";
    MessageName2[MessageName2["RESOLUTION_PACK"] = 17] = "RESOLUTION_PACK";
    MessageName2[MessageName2["CACHE_CHECKSUM_MISMATCH"] = 18] = "CACHE_CHECKSUM_MISMATCH";
    MessageName2[MessageName2["UNUSED_CACHE_ENTRY"] = 19] = "UNUSED_CACHE_ENTRY";
    MessageName2[MessageName2["MISSING_LOCKFILE_ENTRY"] = 20] = "MISSING_LOCKFILE_ENTRY";
    MessageName2[MessageName2["WORKSPACE_NOT_FOUND"] = 21] = "WORKSPACE_NOT_FOUND";
    MessageName2[MessageName2["TOO_MANY_MATCHING_WORKSPACES"] = 22] = "TOO_MANY_MATCHING_WORKSPACES";
    MessageName2[MessageName2["CONSTRAINTS_MISSING_DEPENDENCY"] = 23] = "CONSTRAINTS_MISSING_DEPENDENCY";
    MessageName2[MessageName2["CONSTRAINTS_INCOMPATIBLE_DEPENDENCY"] = 24] = "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY";
    MessageName2[MessageName2["CONSTRAINTS_EXTRANEOUS_DEPENDENCY"] = 25] = "CONSTRAINTS_EXTRANEOUS_DEPENDENCY";
    MessageName2[MessageName2["CONSTRAINTS_INVALID_DEPENDENCY"] = 26] = "CONSTRAINTS_INVALID_DEPENDENCY";
    MessageName2[MessageName2["CANT_SUGGEST_RESOLUTIONS"] = 27] = "CANT_SUGGEST_RESOLUTIONS";
    MessageName2[MessageName2["FROZEN_LOCKFILE_EXCEPTION"] = 28] = "FROZEN_LOCKFILE_EXCEPTION";
    MessageName2[MessageName2["CROSS_DRIVE_VIRTUAL_LOCAL"] = 29] = "CROSS_DRIVE_VIRTUAL_LOCAL";
    MessageName2[MessageName2["FETCH_FAILED"] = 30] = "FETCH_FAILED";
    MessageName2[MessageName2["DANGEROUS_NODE_MODULES"] = 31] = "DANGEROUS_NODE_MODULES";
    MessageName2[MessageName2["NODE_GYP_INJECTED"] = 32] = "NODE_GYP_INJECTED";
    MessageName2[MessageName2["AUTHENTICATION_NOT_FOUND"] = 33] = "AUTHENTICATION_NOT_FOUND";
    MessageName2[MessageName2["INVALID_CONFIGURATION_KEY"] = 34] = "INVALID_CONFIGURATION_KEY";
    MessageName2[MessageName2["NETWORK_ERROR"] = 35] = "NETWORK_ERROR";
    MessageName2[MessageName2["LIFECYCLE_SCRIPT"] = 36] = "LIFECYCLE_SCRIPT";
    MessageName2[MessageName2["CONSTRAINTS_MISSING_FIELD"] = 37] = "CONSTRAINTS_MISSING_FIELD";
    MessageName2[MessageName2["CONSTRAINTS_INCOMPATIBLE_FIELD"] = 38] = "CONSTRAINTS_INCOMPATIBLE_FIELD";
    MessageName2[MessageName2["CONSTRAINTS_EXTRANEOUS_FIELD"] = 39] = "CONSTRAINTS_EXTRANEOUS_FIELD";
    MessageName2[MessageName2["CONSTRAINTS_INVALID_FIELD"] = 40] = "CONSTRAINTS_INVALID_FIELD";
    MessageName2[MessageName2["AUTHENTICATION_INVALID"] = 41] = "AUTHENTICATION_INVALID";
    MessageName2[MessageName2["PROLOG_UNKNOWN_ERROR"] = 42] = "PROLOG_UNKNOWN_ERROR";
    MessageName2[MessageName2["PROLOG_SYNTAX_ERROR"] = 43] = "PROLOG_SYNTAX_ERROR";
    MessageName2[MessageName2["PROLOG_EXISTENCE_ERROR"] = 44] = "PROLOG_EXISTENCE_ERROR";
    MessageName2[MessageName2["STACK_OVERFLOW_RESOLUTION"] = 45] = "STACK_OVERFLOW_RESOLUTION";
    MessageName2[MessageName2["AUTOMERGE_FAILED_TO_PARSE"] = 46] = "AUTOMERGE_FAILED_TO_PARSE";
    MessageName2[MessageName2["AUTOMERGE_IMMUTABLE"] = 47] = "AUTOMERGE_IMMUTABLE";
    MessageName2[MessageName2["AUTOMERGE_SUCCESS"] = 48] = "AUTOMERGE_SUCCESS";
    MessageName2[MessageName2["AUTOMERGE_REQUIRED"] = 49] = "AUTOMERGE_REQUIRED";
    MessageName2[MessageName2["DEPRECATED_CLI_SETTINGS"] = 50] = "DEPRECATED_CLI_SETTINGS";
    MessageName2[MessageName2["PLUGIN_NAME_NOT_FOUND"] = 51] = "PLUGIN_NAME_NOT_FOUND";
    MessageName2[MessageName2["INVALID_PLUGIN_REFERENCE"] = 52] = "INVALID_PLUGIN_REFERENCE";
    MessageName2[MessageName2["CONSTRAINTS_AMBIGUITY"] = 53] = "CONSTRAINTS_AMBIGUITY";
    MessageName2[MessageName2["CACHE_OUTSIDE_PROJECT"] = 54] = "CACHE_OUTSIDE_PROJECT";
    MessageName2[MessageName2["IMMUTABLE_INSTALL"] = 55] = "IMMUTABLE_INSTALL";
    MessageName2[MessageName2["IMMUTABLE_CACHE"] = 56] = "IMMUTABLE_CACHE";
    MessageName2[MessageName2["INVALID_MANIFEST"] = 57] = "INVALID_MANIFEST";
    MessageName2[MessageName2["PACKAGE_PREPARATION_FAILED"] = 58] = "PACKAGE_PREPARATION_FAILED";
    MessageName2[MessageName2["INVALID_RANGE_PEER_DEPENDENCY"] = 59] = "INVALID_RANGE_PEER_DEPENDENCY";
    MessageName2[MessageName2["INCOMPATIBLE_PEER_DEPENDENCY"] = 60] = "INCOMPATIBLE_PEER_DEPENDENCY";
    MessageName2[MessageName2["DEPRECATED_PACKAGE"] = 61] = "DEPRECATED_PACKAGE";
    MessageName2[MessageName2["INCOMPATIBLE_OS"] = 62] = "INCOMPATIBLE_OS";
    MessageName2[MessageName2["INCOMPATIBLE_CPU"] = 63] = "INCOMPATIBLE_CPU";
    MessageName2[MessageName2["FROZEN_ARTIFACT_EXCEPTION"] = 64] = "FROZEN_ARTIFACT_EXCEPTION";
    MessageName2[MessageName2["TELEMETRY_NOTICE"] = 65] = "TELEMETRY_NOTICE";
    MessageName2[MessageName2["PATCH_HUNK_FAILED"] = 66] = "PATCH_HUNK_FAILED";
    MessageName2[MessageName2["INVALID_CONFIGURATION_VALUE"] = 67] = "INVALID_CONFIGURATION_VALUE";
    MessageName2[MessageName2["UNUSED_PACKAGE_EXTENSION"] = 68] = "UNUSED_PACKAGE_EXTENSION";
    MessageName2[MessageName2["REDUNDANT_PACKAGE_EXTENSION"] = 69] = "REDUNDANT_PACKAGE_EXTENSION";
  })(MessageName || (MessageName = {}));
  function stringifyMessageName(name) {
    return `YN${name.toString(10).padStart(4, `0`)}`;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\index.mjs
  var advanced_exports = {};
  __export(advanced_exports, {
    Builtins: () => builtins_exports,
    Cli: () => Cli,
    Command: () => Command,
    Option: () => options_exports,
    UsageError: () => UsageError
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\constants.mjs
  var NODE_INITIAL = 0;
  var NODE_SUCCESS = 1;
  var NODE_ERRORED = 2;
  var START_OF_INPUT = ``;
  var END_OF_INPUT = `\0`;
  var HELP_COMMAND_INDEX = -1;
  var HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;
  var OPTION_REGEX = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;
  var BATCH_REGEX = /^-[a-zA-Z]{2,}$/;
  var BINDING_REGEX = /^([^=]+)=([\s\S]*)$/;
  var DEBUG = process.env.DEBUG_CLI === `1`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\errors.mjs
  var UsageError = class extends Error {
    constructor(message) {
      super(message);
      this.clipanion = {type: `usage`};
      this.name = `UsageError`;
    }
  };
  var UnknownSyntaxError = class extends Error {
    constructor(input, candidates) {
      super();
      this.input = input;
      this.candidates = candidates;
      this.clipanion = {type: `none`};
      this.name = `UnknownSyntaxError`;
      if (this.candidates.length === 0) {
        this.message = `Command not found, but we're not sure what's the alternative.`;
      } else if (this.candidates.every((candidate) => candidate.reason !== null && candidate.reason === candidates[0].reason)) {
        const [{reason}] = this.candidates;
        this.message = `${reason}

${this.candidates.map(({usage}) => `$ ${usage}`).join(`
`)}`;
      } else if (this.candidates.length === 1) {
        const [{usage}] = this.candidates;
        this.message = `Command not found; did you mean:

$ ${usage}
${whileRunning(input)}`;
      } else {
        this.message = `Command not found; did you mean one of:

${this.candidates.map(({usage}, index) => {
          return `${`${index}.`.padStart(4)} ${usage}`;
        }).join(`
`)}

${whileRunning(input)}`;
      }
    }
  };
  var AmbiguousSyntaxError = class extends Error {
    constructor(input, usages) {
      super();
      this.input = input;
      this.usages = usages;
      this.clipanion = {type: `none`};
      this.name = `AmbiguousSyntaxError`;
      this.message = `Cannot find who to pick amongst the following alternatives:

${this.usages.map((usage, index) => {
        return `${`${index}.`.padStart(4)} ${usage}`;
      }).join(`
`)}

${whileRunning(input)}`;
    }
  };
  var whileRunning = (input) => `While running ${input.filter((token) => {
    return token !== END_OF_INPUT;
  }).map((token) => {
    const json2 = JSON.stringify(token);
    if (token.match(/\s/) || token.length === 0 || json2 !== `"${token}"`) {
      return json2;
    } else {
      return token;
    }
  }).join(` `)}`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\utils.mjs
  var isOptionSymbol = Symbol(`clipanion/isOption`);
  function makeCommandOption(spec) {
    return {...spec, [isOptionSymbol]: true};
  }
  function rerouteArguments(a, b) {
    if (typeof a === `undefined`)
      return [a, b];
    if (typeof a === `object` && a !== null && !Array.isArray(a)) {
      return [void 0, a];
    } else {
      return [a, b];
    }
  }
  function cleanValidationError(message, lowerCase = false) {
    let cleaned = message.replace(/^\.: /, ``);
    if (lowerCase)
      cleaned = cleaned[0].toLowerCase() + cleaned.slice(1);
    return cleaned;
  }
  function formatError(message, errors4) {
    if (errors4.length === 1) {
      return new UsageError(`${message}: ${cleanValidationError(errors4[0], true)}`);
    } else {
      return new UsageError(`${message}:
${errors4.map((error) => `
- ${cleanValidationError(error)}`).join(``)}`);
    }
  }
  function applyValidator(name, value, validator) {
    if (typeof validator === `undefined`)
      return value;
    const errors4 = [];
    const coercions = [];
    const check = validator(value, {errors: errors4, coercions, coercion: (v) => {
      value = v;
    }});
    if (!check)
      throw formatError(`Invalid value for ${name}`, errors4);
    for (const [, op] of coercions)
      op();
    return value;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\Command.mjs
  var Command = class {
    constructor() {
      this.help = false;
    }
    static Usage(usage) {
      return usage;
    }
    async catch(error) {
      throw error;
    }
    async validateAndExecute() {
      const commandClass = this.constructor;
      const cascade = commandClass.schema;
      if (typeof cascade !== `undefined`) {
        const {isDict, isUnknown, applyCascade: applyCascade3} = await Promise.resolve().then(() => __toModule(require_lib()));
        const schema = applyCascade3(isDict(isUnknown()), cascade);
        const errors4 = [];
        const coercions = [];
        const check = schema(this, {errors: errors4, coercions});
        if (!check)
          throw formatError(`Invalid option schema`, errors4);
        for (const [, op] of coercions) {
          op();
        }
      }
      const exitCode = await this.execute();
      if (typeof exitCode !== `undefined`) {
        return exitCode;
      } else {
        return 0;
      }
    }
  };
  Command.isOption = isOptionSymbol;
  Command.Default = [];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\core.mjs
  function debug(str) {
    if (DEBUG) {
      console.log(str);
    }
  }
  var basicHelpState = {
    candidateUsage: null,
    requiredOptions: [],
    errorMessage: null,
    ignoreOptions: false,
    path: [],
    positionals: [],
    options: [],
    remainder: null,
    selectedIndex: HELP_COMMAND_INDEX
  };
  function makeStateMachine() {
    return {
      nodes: [makeNode(), makeNode(), makeNode()]
    };
  }
  function makeAnyOfMachine(inputs) {
    const output = makeStateMachine();
    const heads = [];
    let offset = output.nodes.length;
    for (const input of inputs) {
      heads.push(offset);
      for (let t7 = 0; t7 < input.nodes.length; ++t7)
        if (!isTerminalNode(t7))
          output.nodes.push(cloneNode(input.nodes[t7], offset));
      offset += input.nodes.length - 2;
    }
    for (const head of heads)
      registerShortcut(output, NODE_INITIAL, head);
    return output;
  }
  function injectNode(machine, node) {
    machine.nodes.push(node);
    return machine.nodes.length - 1;
  }
  function simplifyMachine(input) {
    const visited = new Set();
    const process2 = (node) => {
      if (visited.has(node))
        return;
      visited.add(node);
      const nodeDef = input.nodes[node];
      for (const transitions of Object.values(nodeDef.statics))
        for (const {to} of transitions)
          process2(to);
      for (const [, {to}] of nodeDef.dynamics)
        process2(to);
      for (const {to} of nodeDef.shortcuts)
        process2(to);
      const shortcuts = new Set(nodeDef.shortcuts.map(({to}) => to));
      while (nodeDef.shortcuts.length > 0) {
        const {to} = nodeDef.shortcuts.shift();
        const toDef = input.nodes[to];
        for (const [segment, transitions] of Object.entries(toDef.statics)) {
          const store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment) ? nodeDef.statics[segment] = [] : nodeDef.statics[segment];
          for (const transition of transitions) {
            if (!store.some(({to: to2}) => transition.to === to2)) {
              store.push(transition);
            }
          }
        }
        for (const [test, transition] of toDef.dynamics)
          if (!nodeDef.dynamics.some(([otherTest, {to: to2}]) => test === otherTest && transition.to === to2))
            nodeDef.dynamics.push([test, transition]);
        for (const transition of toDef.shortcuts) {
          if (!shortcuts.has(transition.to)) {
            nodeDef.shortcuts.push(transition);
            shortcuts.add(transition.to);
          }
        }
      }
    };
    process2(NODE_INITIAL);
  }
  function debugMachine(machine, {prefix = ``} = {}) {
    debug(`${prefix}Nodes are:`);
    for (let t7 = 0; t7 < machine.nodes.length; ++t7) {
      debug(`${prefix}  ${t7}: ${JSON.stringify(machine.nodes[t7])}`);
    }
  }
  function runMachineInternal(machine, input, partial = false) {
    debug(`Running a vm on ${JSON.stringify(input)}`);
    let branches = [{node: NODE_INITIAL, state: {
      candidateUsage: null,
      requiredOptions: [],
      errorMessage: null,
      ignoreOptions: false,
      options: [],
      path: [],
      positionals: [],
      remainder: null,
      selectedIndex: null
    }}];
    debugMachine(machine, {prefix: `  `});
    const tokens = [START_OF_INPUT, ...input];
    for (let t7 = 0; t7 < tokens.length; ++t7) {
      const segment = tokens[t7];
      debug(`  Processing ${JSON.stringify(segment)}`);
      const nextBranches = [];
      for (const {node, state} of branches) {
        debug(`    Current node is ${node}`);
        const nodeDef = machine.nodes[node];
        if (node === NODE_ERRORED) {
          nextBranches.push({node, state});
          continue;
        }
        console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);
        const hasExactMatch = Object.prototype.hasOwnProperty.call(nodeDef.statics, segment);
        if (!partial || t7 < tokens.length - 1 || hasExactMatch) {
          if (hasExactMatch) {
            const transitions = nodeDef.statics[segment];
            for (const {to, reducer} of transitions) {
              nextBranches.push({node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state});
              debug(`      Static transition to ${to} found`);
            }
          } else {
            debug(`      No static transition found`);
          }
        } else {
          let hasMatches = false;
          for (const candidate of Object.keys(nodeDef.statics)) {
            if (!candidate.startsWith(segment))
              continue;
            if (segment === candidate) {
              for (const {to, reducer} of nodeDef.statics[candidate]) {
                nextBranches.push({node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state});
                debug(`      Static transition to ${to} found`);
              }
            } else {
              for (const {to} of nodeDef.statics[candidate]) {
                nextBranches.push({node: to, state: {...state, remainder: candidate.slice(segment.length)}});
                debug(`      Static transition to ${to} found (partial match)`);
              }
            }
            hasMatches = true;
          }
          if (!hasMatches) {
            debug(`      No partial static transition found`);
          }
        }
        if (segment !== END_OF_INPUT) {
          for (const [test, {to, reducer}] of nodeDef.dynamics) {
            if (execute(tests, test, state, segment)) {
              nextBranches.push({node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state});
              debug(`      Dynamic transition to ${to} found (via ${test})`);
            }
          }
        }
      }
      if (nextBranches.length === 0 && segment === END_OF_INPUT && input.length === 1) {
        return [{
          node: NODE_INITIAL,
          state: basicHelpState
        }];
      }
      if (nextBranches.length === 0) {
        throw new UnknownSyntaxError(input, branches.filter(({node}) => {
          return node !== NODE_ERRORED;
        }).map(({state}) => {
          return {usage: state.candidateUsage, reason: null};
        }));
      }
      if (nextBranches.every(({node}) => node === NODE_ERRORED)) {
        throw new UnknownSyntaxError(input, nextBranches.map(({state}) => {
          return {usage: state.candidateUsage, reason: state.errorMessage};
        }));
      }
      branches = trimSmallerBranches(nextBranches);
    }
    if (branches.length > 0) {
      debug(`  Results:`);
      for (const branch of branches) {
        debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);
      }
    } else {
      debug(`  No results`);
    }
    return branches;
  }
  function checkIfNodeIsFinished(node, state) {
    if (state.selectedIndex !== null)
      return true;
    if (Object.prototype.hasOwnProperty.call(node.statics, END_OF_INPUT)) {
      for (const {to} of node.statics[END_OF_INPUT])
        if (to === NODE_SUCCESS)
          return true;
    }
    return false;
  }
  function suggestMachine(machine, input, partial) {
    const prefix = partial && input.length > 0 ? [``] : [];
    const branches = runMachineInternal(machine, input, partial);
    const suggestions = [];
    const suggestionsJson = new Set();
    const traverseSuggestion = (suggestion, node, skipFirst = true) => {
      let nextNodes = [node];
      while (nextNodes.length > 0) {
        const currentNodes = nextNodes;
        nextNodes = [];
        for (const node2 of currentNodes) {
          const nodeDef = machine.nodes[node2];
          const keys = Object.keys(nodeDef.statics);
          for (const key of Object.keys(nodeDef.statics)) {
            const segment = keys[0];
            for (const {to, reducer} of nodeDef.statics[segment]) {
              if (reducer !== `pushPath`)
                continue;
              if (!skipFirst)
                suggestion.push(segment);
              nextNodes.push(to);
            }
          }
        }
        skipFirst = false;
      }
      const json2 = JSON.stringify(suggestion);
      if (suggestionsJson.has(json2))
        return;
      suggestions.push(suggestion);
      suggestionsJson.add(json2);
    };
    for (const {node, state} of branches) {
      if (state.remainder !== null) {
        traverseSuggestion([state.remainder], node);
        continue;
      }
      const nodeDef = machine.nodes[node];
      const isFinished = checkIfNodeIsFinished(nodeDef, state);
      for (const [candidate, transitions] of Object.entries(nodeDef.statics))
        if (isFinished && candidate !== END_OF_INPUT || !candidate.startsWith(`-`) && transitions.some(({reducer}) => reducer === `pushPath`))
          traverseSuggestion([...prefix, candidate], node);
      if (!isFinished)
        continue;
      for (const [test, {to}] of nodeDef.dynamics) {
        if (to === NODE_ERRORED)
          continue;
        const tokens = suggest(test, state);
        if (tokens === null)
          continue;
        for (const token of tokens) {
          traverseSuggestion([...prefix, token], node);
        }
      }
    }
    return [...suggestions].sort();
  }
  function runMachine(machine, input) {
    const branches = runMachineInternal(machine, [...input, END_OF_INPUT]);
    return selectBestState(input, branches.map(({state}) => {
      return state;
    }));
  }
  function trimSmallerBranches(branches) {
    let maxPathSize = 0;
    for (const {state} of branches)
      if (state.path.length > maxPathSize)
        maxPathSize = state.path.length;
    return branches.filter(({state}) => {
      return state.path.length === maxPathSize;
    });
  }
  function selectBestState(input, states) {
    const terminalStates = states.filter((state) => {
      return state.selectedIndex !== null;
    });
    if (terminalStates.length === 0)
      throw new Error();
    const requiredOptionsSetStates = terminalStates.filter((state) => state.requiredOptions.every((names) => names.some((name) => state.options.find((opt) => opt.name === name))));
    if (requiredOptionsSetStates.length === 0) {
      throw new UnknownSyntaxError(input, terminalStates.map((state) => ({
        usage: state.candidateUsage,
        reason: null
      })));
    }
    let maxPathSize = 0;
    for (const state of requiredOptionsSetStates)
      if (state.path.length > maxPathSize)
        maxPathSize = state.path.length;
    const bestPathBranches = requiredOptionsSetStates.filter((state) => {
      return state.path.length === maxPathSize;
    });
    const getPositionalCount = (state) => state.positionals.filter(({extra}) => {
      return !extra;
    }).length + state.options.length;
    const statesWithPositionalCount = bestPathBranches.map((state) => {
      return {state, positionalCount: getPositionalCount(state)};
    });
    let maxPositionalCount = 0;
    for (const {positionalCount} of statesWithPositionalCount)
      if (positionalCount > maxPositionalCount)
        maxPositionalCount = positionalCount;
    const bestPositionalStates = statesWithPositionalCount.filter(({positionalCount}) => {
      return positionalCount === maxPositionalCount;
    }).map(({state}) => {
      return state;
    });
    const fixedStates = aggregateHelpStates(bestPositionalStates);
    if (fixedStates.length > 1)
      throw new AmbiguousSyntaxError(input, fixedStates.map((state) => state.candidateUsage));
    return fixedStates[0];
  }
  function aggregateHelpStates(states) {
    const notHelps = [];
    const helps = [];
    for (const state of states) {
      if (state.selectedIndex === HELP_COMMAND_INDEX) {
        helps.push(state);
      } else {
        notHelps.push(state);
      }
    }
    if (helps.length > 0) {
      notHelps.push({
        ...basicHelpState,
        path: findCommonPrefix(...helps.map((state) => state.path)),
        options: helps.reduce((options, state) => options.concat(state.options), [])
      });
    }
    return notHelps;
  }
  function findCommonPrefix(firstPath, secondPath, ...rest) {
    if (secondPath === void 0)
      return Array.from(firstPath);
    return findCommonPrefix(firstPath.filter((segment, i) => segment === secondPath[i]), ...rest);
  }
  function makeNode() {
    return {
      dynamics: [],
      shortcuts: [],
      statics: {}
    };
  }
  function isTerminalNode(node) {
    return node === NODE_SUCCESS || node === NODE_ERRORED;
  }
  function cloneTransition(input, offset = 0) {
    return {
      to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,
      reducer: input.reducer
    };
  }
  function cloneNode(input, offset = 0) {
    const output = makeNode();
    for (const [test, transition] of input.dynamics)
      output.dynamics.push([test, cloneTransition(transition, offset)]);
    for (const transition of input.shortcuts)
      output.shortcuts.push(cloneTransition(transition, offset));
    for (const [segment, transitions] of Object.entries(input.statics))
      output.statics[segment] = transitions.map((transition) => cloneTransition(transition, offset));
    return output;
  }
  function registerDynamic(machine, from, test, to, reducer) {
    machine.nodes[from].dynamics.push([
      test,
      {to, reducer}
    ]);
  }
  function registerShortcut(machine, from, to, reducer) {
    machine.nodes[from].shortcuts.push({to, reducer});
  }
  function registerStatic(machine, from, test, to, reducer) {
    const store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test) ? machine.nodes[from].statics[test] = [] : machine.nodes[from].statics[test];
    store.push({to, reducer});
  }
  function execute(store, callback, state, segment) {
    if (Array.isArray(callback)) {
      const [name, ...args] = callback;
      return store[name](state, segment, ...args);
    } else {
      return store[callback](state, segment);
    }
  }
  function suggest(callback, state) {
    const fn = Array.isArray(callback) ? tests[callback[0]] : tests[callback];
    if (typeof fn.suggest === `undefined`)
      return null;
    const args = Array.isArray(callback) ? callback.slice(1) : [];
    return fn.suggest(state, ...args);
  }
  var tests = {
    always: () => {
      return true;
    },
    isOptionLike: (state, segment) => {
      return !state.ignoreOptions && segment.startsWith(`-`);
    },
    isNotOptionLike: (state, segment) => {
      return state.ignoreOptions || !segment.startsWith(`-`);
    },
    isOption: (state, segment, name, hidden) => {
      return !state.ignoreOptions && segment === name;
    },
    isBatchOption: (state, segment, names) => {
      return !state.ignoreOptions && BATCH_REGEX.test(segment) && [...segment.slice(1)].every((name) => names.includes(`-${name}`));
    },
    isBoundOption: (state, segment, names, options) => {
      const optionParsing = segment.match(BINDING_REGEX);
      return !state.ignoreOptions && !!optionParsing && OPTION_REGEX.test(optionParsing[1]) && names.includes(optionParsing[1]) && options.filter((opt) => opt.names.includes(optionParsing[1])).every((opt) => opt.allowBinding);
    },
    isNegatedOption: (state, segment, name) => {
      return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;
    },
    isHelp: (state, segment) => {
      return !state.ignoreOptions && HELP_REGEX.test(segment);
    },
    isUnsupportedOption: (state, segment, names) => {
      return !state.ignoreOptions && segment.startsWith(`-`) && OPTION_REGEX.test(segment) && !names.includes(segment);
    },
    isInvalidOption: (state, segment) => {
      return !state.ignoreOptions && segment.startsWith(`-`) && !OPTION_REGEX.test(segment);
    }
  };
  tests.isOption.suggest = (state, name, hidden = true) => {
    return !hidden ? [name] : null;
  };
  var reducers = {
    setCandidateState: (state, segment, candidateState) => {
      return {...state, ...candidateState};
    },
    setSelectedIndex: (state, segment, index) => {
      return {...state, selectedIndex: index};
    },
    pushBatch: (state, segment) => {
      return {...state, options: state.options.concat([...segment.slice(1)].map((name) => ({name: `-${name}`, value: true})))};
    },
    pushBound: (state, segment) => {
      const [, name, value] = segment.match(BINDING_REGEX);
      return {...state, options: state.options.concat({name, value})};
    },
    pushPath: (state, segment) => {
      return {...state, path: state.path.concat(segment)};
    },
    pushPositional: (state, segment) => {
      return {...state, positionals: state.positionals.concat({value: segment, extra: false})};
    },
    pushExtra: (state, segment) => {
      return {...state, positionals: state.positionals.concat({value: segment, extra: true})};
    },
    pushExtraNoLimits: (state, segment) => {
      return {...state, positionals: state.positionals.concat({value: segment, extra: NoLimits})};
    },
    pushTrue: (state, segment, name = segment) => {
      return {...state, options: state.options.concat({name: segment, value: true})};
    },
    pushFalse: (state, segment, name = segment) => {
      return {...state, options: state.options.concat({name, value: false})};
    },
    pushUndefined: (state, segment) => {
      return {...state, options: state.options.concat({name: segment, value: void 0})};
    },
    pushStringValue: (state, segment) => {
      var _a2;
      const copy = {...state, options: [...state.options]};
      const lastOption = state.options[state.options.length - 1];
      lastOption.value = ((_a2 = lastOption.value) !== null && _a2 !== void 0 ? _a2 : []).concat([segment]);
      return copy;
    },
    setStringValue: (state, segment) => {
      const copy = {...state, options: [...state.options]};
      const lastOption = state.options[state.options.length - 1];
      lastOption.value = segment;
      return copy;
    },
    inhibateOptions: (state) => {
      return {...state, ignoreOptions: true};
    },
    useHelp: (state, segment, command) => {
      const [, , index] = segment.match(HELP_REGEX);
      if (typeof index !== `undefined`) {
        return {...state, options: [{name: `-c`, value: String(command)}, {name: `-i`, value: index}]};
      } else {
        return {...state, options: [{name: `-c`, value: String(command)}]};
      }
    },
    setError: (state, segment, errorMessage) => {
      if (segment === END_OF_INPUT) {
        return {...state, errorMessage: `${errorMessage}.`};
      } else {
        return {...state, errorMessage: `${errorMessage} ("${segment}").`};
      }
    },
    setOptionArityError: (state, segment) => {
      const lastOption = state.options[state.options.length - 1];
      return {...state, errorMessage: `Not enough arguments to option ${lastOption.name}.`};
    }
  };
  var NoLimits = Symbol();
  var CommandBuilder = class {
    constructor(cliIndex, cliOpts) {
      this.allOptionNames = [];
      this.arity = {leading: [], trailing: [], extra: [], proxy: false};
      this.options = [];
      this.paths = [];
      this.cliIndex = cliIndex;
      this.cliOpts = cliOpts;
    }
    addPath(path6) {
      this.paths.push(path6);
    }
    setArity({leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy}) {
      Object.assign(this.arity, {leading, trailing, extra, proxy});
    }
    addPositional({name = `arg`, required = true} = {}) {
      if (!required && this.arity.extra === NoLimits)
        throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);
      if (!required && this.arity.trailing.length > 0)
        throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);
      if (!required && this.arity.extra !== NoLimits) {
        this.arity.extra.push(name);
      } else if (this.arity.extra !== NoLimits && this.arity.extra.length === 0) {
        this.arity.leading.push(name);
      } else {
        this.arity.trailing.push(name);
      }
    }
    addRest({name = `arg`, required = 0} = {}) {
      if (this.arity.extra === NoLimits)
        throw new Error(`Infinite lists cannot be declared multiple times in the same command`);
      if (this.arity.trailing.length > 0)
        throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);
      for (let t7 = 0; t7 < required; ++t7)
        this.addPositional({name});
      this.arity.extra = NoLimits;
    }
    addProxy({required = 0} = {}) {
      this.addRest({required});
      this.arity.proxy = true;
    }
    addOption({names, description, arity = 0, hidden = false, required = false, allowBinding = true}) {
      if (!allowBinding && arity > 1)
        throw new Error(`The arity cannot be higher than 1 when the option only supports the --arg=value syntax`);
      if (!Number.isInteger(arity))
        throw new Error(`The arity must be an integer, got ${arity}`);
      if (arity < 0)
        throw new Error(`The arity must be positive, got ${arity}`);
      this.allOptionNames.push(...names);
      this.options.push({names, description, arity, hidden, required, allowBinding});
    }
    setContext(context) {
      this.context = context;
    }
    usage({detailed = true, inlineOptions = true} = {}) {
      const segments = [this.cliOpts.binaryName];
      const detailedOptionList = [];
      if (this.paths.length > 0)
        segments.push(...this.paths[0]);
      if (detailed) {
        for (const {names, arity, hidden, description, required} of this.options) {
          if (hidden)
            continue;
          const args = [];
          for (let t7 = 0; t7 < arity; ++t7)
            args.push(` #${t7}`);
          const definition = `${names.join(`,`)}${args.join(``)}`;
          if (!inlineOptions && description) {
            detailedOptionList.push({definition, description, required});
          } else {
            segments.push(required ? `<${definition}>` : `[${definition}]`);
          }
        }
        segments.push(...this.arity.leading.map((name) => `<${name}>`));
        if (this.arity.extra === NoLimits)
          segments.push(`...`);
        else
          segments.push(...this.arity.extra.map((name) => `[${name}]`));
        segments.push(...this.arity.trailing.map((name) => `<${name}>`));
      }
      const usage = segments.join(` `);
      return {usage, options: detailedOptionList};
    }
    compile() {
      if (typeof this.context === `undefined`)
        throw new Error(`Assertion failed: No context attached`);
      const machine = makeStateMachine();
      let firstNode = NODE_INITIAL;
      const candidateUsage = this.usage().usage;
      const requiredOptions = this.options.filter((opt) => opt.required).map((opt) => opt.names);
      firstNode = injectNode(machine, makeNode());
      registerStatic(machine, NODE_INITIAL, START_OF_INPUT, firstNode, [`setCandidateState`, {candidateUsage, requiredOptions}]);
      const positionalArgument = this.arity.proxy ? `always` : `isNotOptionLike`;
      const paths = this.paths.length > 0 ? this.paths : [[]];
      for (const path6 of paths) {
        let lastPathNode = firstNode;
        if (path6.length > 0) {
          const optionPathNode = injectNode(machine, makeNode());
          registerShortcut(machine, lastPathNode, optionPathNode);
          this.registerOptions(machine, optionPathNode);
          lastPathNode = optionPathNode;
        }
        for (let t7 = 0; t7 < path6.length; ++t7) {
          const nextPathNode = injectNode(machine, makeNode());
          registerStatic(machine, lastPathNode, path6[t7], nextPathNode, `pushPath`);
          lastPathNode = nextPathNode;
        }
        if (this.arity.leading.length > 0 || !this.arity.proxy) {
          const helpNode = injectNode(machine, makeNode());
          registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);
          registerStatic(machine, helpNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, HELP_COMMAND_INDEX]);
          this.registerOptions(machine, lastPathNode);
        }
        if (this.arity.leading.length > 0)
          registerStatic(machine, lastPathNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
        let lastLeadingNode = lastPathNode;
        for (let t7 = 0; t7 < this.arity.leading.length; ++t7) {
          const nextLeadingNode = injectNode(machine, makeNode());
          if (!this.arity.proxy)
            this.registerOptions(machine, nextLeadingNode);
          if (this.arity.trailing.length > 0 || t7 + 1 !== this.arity.leading.length)
            registerStatic(machine, nextLeadingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
          registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);
          lastLeadingNode = nextLeadingNode;
        }
        let lastExtraNode = lastLeadingNode;
        if (this.arity.extra === NoLimits || this.arity.extra.length > 0) {
          const extraShortcutNode = injectNode(machine, makeNode());
          registerShortcut(machine, lastLeadingNode, extraShortcutNode);
          if (this.arity.extra === NoLimits) {
            const extraNode = injectNode(machine, makeNode());
            if (!this.arity.proxy)
              this.registerOptions(machine, extraNode);
            registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtraNoLimits`);
            registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtraNoLimits`);
            registerShortcut(machine, extraNode, extraShortcutNode);
          } else {
            for (let t7 = 0; t7 < this.arity.extra.length; ++t7) {
              const nextExtraNode = injectNode(machine, makeNode());
              if (!this.arity.proxy)
                this.registerOptions(machine, nextExtraNode);
              registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);
              registerShortcut(machine, nextExtraNode, extraShortcutNode);
              lastExtraNode = nextExtraNode;
            }
          }
          lastExtraNode = extraShortcutNode;
        }
        if (this.arity.trailing.length > 0)
          registerStatic(machine, lastExtraNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
        let lastTrailingNode = lastExtraNode;
        for (let t7 = 0; t7 < this.arity.trailing.length; ++t7) {
          const nextTrailingNode = injectNode(machine, makeNode());
          if (!this.arity.proxy)
            this.registerOptions(machine, nextTrailingNode);
          if (t7 + 1 < this.arity.trailing.length)
            registerStatic(machine, nextTrailingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
          registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);
          lastTrailingNode = nextTrailingNode;
        }
        registerDynamic(machine, lastTrailingNode, positionalArgument, NODE_ERRORED, [`setError`, `Extraneous positional argument`]);
        registerStatic(machine, lastTrailingNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);
      }
      return {
        machine,
        context: this.context
      };
    }
    registerOptions(machine, node) {
      registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);
      registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);
      registerDynamic(machine, node, [`isBoundOption`, this.allOptionNames, this.options], node, `pushBound`);
      registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], NODE_ERRORED, [`setError`, `Unsupported option name`]);
      registerDynamic(machine, node, [`isInvalidOption`], NODE_ERRORED, [`setError`, `Invalid option name`]);
      for (const option of this.options) {
        const longestName = option.names.reduce((longestName2, name) => {
          return name.length > longestName2.length ? name : longestName2;
        }, ``);
        if (option.arity === 0) {
          for (const name of option.names) {
            registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], node, `pushTrue`);
            if (name.startsWith(`--`) && !name.startsWith(`--no-`)) {
              registerDynamic(machine, node, [`isNegatedOption`, name], node, [`pushFalse`, name]);
            }
          }
        } else {
          let lastNode = injectNode(machine, makeNode());
          for (const name of option.names)
            registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], lastNode, `pushUndefined`);
          for (let t7 = 0; t7 < option.arity; ++t7) {
            const nextNode = injectNode(machine, makeNode());
            registerStatic(machine, lastNode, END_OF_INPUT, NODE_ERRORED, `setOptionArityError`);
            registerDynamic(machine, lastNode, `isOptionLike`, NODE_ERRORED, `setOptionArityError`);
            const action = option.arity === 1 ? `setStringValue` : `pushStringValue`;
            registerDynamic(machine, lastNode, `isNotOptionLike`, nextNode, action);
            lastNode = nextNode;
          }
          registerShortcut(machine, lastNode, node);
        }
      }
    }
  };
  var CliBuilder = class {
    constructor({binaryName = `...`} = {}) {
      this.builders = [];
      this.opts = {binaryName};
    }
    static build(cbs, opts = {}) {
      return new CliBuilder(opts).commands(cbs).compile();
    }
    getBuilderByIndex(n) {
      if (!(n >= 0 && n < this.builders.length))
        throw new Error(`Assertion failed: Out-of-bound command index (${n})`);
      return this.builders[n];
    }
    commands(cbs) {
      for (const cb of cbs)
        cb(this.command());
      return this;
    }
    command() {
      const builder = new CommandBuilder(this.builders.length, this.opts);
      this.builders.push(builder);
      return builder;
    }
    compile() {
      const machines = [];
      const contexts = [];
      for (const builder of this.builders) {
        const {machine: machine2, context} = builder.compile();
        machines.push(machine2);
        contexts.push(context);
      }
      const machine = makeAnyOfMachine(machines);
      simplifyMachine(machine);
      return {
        machine,
        contexts,
        process: (input) => {
          return runMachine(machine, input);
        },
        suggest: (input, partial) => {
          return suggestMachine(machine, input, partial);
        }
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\format.mjs
  var richFormat = {
    bold: (str) => `[1m${str}[22m`,
    error: (str) => `[31m[1m${str}[22m[39m`,
    code: (str) => `[36m${str}[39m`
  };
  var textFormat = {
    bold: (str) => str,
    error: (str) => str,
    code: (str) => str
  };
  function formatMarkdownish(text, {format, paragraphs}) {
    text = text.replace(/\r\n?/g, `
`);
    text = text.replace(/^[\t ]+|[\t ]+$/gm, ``);
    text = text.replace(/^\n+|\n+$/g, ``);
    text = text.replace(/^-([^\n]*?)\n+/gm, `-$1

`);
    text = text.replace(/\n(\n)?\n*/g, `$1`);
    if (paragraphs) {
      text = text.split(/\n/).map((paragraph) => {
        const bulletMatch = paragraph.match(/^[*-][\t ]+(.*)/);
        if (!bulletMatch)
          return paragraph.match(/(.{1,80})(?: |$)/g).join(`
`);
        return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {
          return (index === 0 ? `- ` : `  `) + line;
        }).join(`
`);
      }).join(`

`);
    }
    text = text.replace(/(`+)((?:.|[\n])*?)\1/g, ($0, $1, $2) => {
      return format.code($1 + $2 + $1);
    });
    return text ? `${text}
` : ``;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\HelpCommand.mjs
  var HelpCommand = class extends Command {
    constructor(contexts) {
      super();
      this.contexts = contexts;
      this.commands = [];
    }
    static from(state, contexts) {
      const command = new HelpCommand(contexts);
      command.path = state.path;
      for (const opt of state.options) {
        switch (opt.name) {
          case `-c`:
            {
              command.commands.push(Number(opt.value));
            }
            break;
          case `-i`:
            {
              command.index = Number(opt.value);
            }
            break;
        }
      }
      return command;
    }
    async execute() {
      let commands = this.commands;
      if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)
        commands = [commands[this.index]];
      if (commands.length === 0) {
        this.context.stdout.write(this.cli.usage());
      } else if (commands.length === 1) {
        this.context.stdout.write(this.cli.usage(this.contexts[commands[0]].commandClass, {detailed: true}));
      } else if (commands.length > 1) {
        this.context.stdout.write(`Multiple commands match your selection:
`);
        this.context.stdout.write(`
`);
        let index = 0;
        for (const command of this.commands)
          this.context.stdout.write(this.cli.usage(this.contexts[command].commandClass, {prefix: `${index++}. `.padStart(5)}));
        this.context.stdout.write(`
`);
        this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.
`);
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\Cli.mjs
  var errorCommandSymbol = Symbol(`clipanion/errorCommand`);
  function getDefaultColorSettings() {
    if (process.env.FORCE_COLOR === `0`)
      return false;
    if (process.env.FORCE_COLOR === `1`)
      return true;
    if (typeof process.stdout !== `undefined` && process.stdout.isTTY)
      return true;
    return false;
  }
  var Cli = class {
    constructor({binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion, enableColors = getDefaultColorSettings()} = {}) {
      this.registrations = new Map();
      this.builder = new CliBuilder({binaryName: binaryNameOpt});
      this.binaryLabel = binaryLabel;
      this.binaryName = binaryNameOpt;
      this.binaryVersion = binaryVersion;
      this.enableColors = enableColors;
    }
    static from(commandClasses, options = {}) {
      const cli = new Cli(options);
      for (const commandClass of commandClasses)
        cli.register(commandClass);
      return cli;
    }
    register(commandClass) {
      const specs = new Map();
      const builder = this.builder.command();
      const index = builder.cliIndex;
      if (typeof commandClass.paths !== `undefined`)
        for (const path6 of commandClass.paths)
          builder.addPath(path6);
      const command = new commandClass();
      for (const [key, value] of Object.entries(command))
        if (typeof value === `object` && value !== null && value[Command.isOption])
          specs.set(key, value);
      this.registrations.set(commandClass, {specs, builder, index});
      for (const [key, {definition}] of specs.entries())
        definition(builder, key);
      builder.setContext({
        commandClass
      });
    }
    process(input) {
      const {contexts, process: process2} = this.builder.compile();
      const state = process2(input);
      switch (state.selectedIndex) {
        case HELP_COMMAND_INDEX: {
          return HelpCommand.from(state, contexts);
        }
        default:
          {
            const {commandClass} = contexts[state.selectedIndex];
            const record = this.registrations.get(commandClass);
            if (typeof record === `undefined`)
              throw new Error(`Assertion failed: Expected the command class to have been registered.`);
            const command = new commandClass();
            command.path = state.path;
            try {
              for (const [key, {transformer}] of record.specs.entries())
                command[key] = transformer(record.builder, key, state);
              return command;
            } catch (error) {
              error[errorCommandSymbol] = command;
              throw error;
            }
          }
          break;
      }
    }
    async run(input, context) {
      let command;
      if (!Array.isArray(input)) {
        command = input;
      } else {
        try {
          command = this.process(input);
        } catch (error) {
          context.stdout.write(this.error(error));
          return 1;
        }
      }
      if (command.help) {
        context.stdout.write(this.usage(command, {detailed: true}));
        return 0;
      }
      command.context = context;
      command.cli = {
        binaryLabel: this.binaryLabel,
        binaryName: this.binaryName,
        binaryVersion: this.binaryVersion,
        enableColors: this.enableColors,
        definitions: () => this.definitions(),
        error: (error, opts) => this.error(error, opts),
        process: (input2) => this.process(input2),
        run: (input2, subContext) => this.run(input2, {...context, ...subContext}),
        usage: (command2, opts) => this.usage(command2, opts)
      };
      let exitCode;
      try {
        exitCode = await command.validateAndExecute().catch((error) => command.catch(error).then(() => 0));
      } catch (error) {
        context.stdout.write(this.error(error, {command}));
        return 1;
      }
      return exitCode;
    }
    async runExit(input, context) {
      process.exitCode = await this.run(input, context);
    }
    suggest(input, partial) {
      const {suggest: suggest2} = this.builder.compile();
      return suggest2(input, partial);
    }
    definitions({colored = false} = {}) {
      const data = [];
      for (const [commandClass, {index}] of this.registrations) {
        if (typeof commandClass.usage === `undefined`)
          continue;
        const {usage: path6} = this.getUsageByIndex(index, {detailed: false});
        const {usage, options} = this.getUsageByIndex(index, {detailed: true, inlineOptions: false});
        const category = typeof commandClass.usage.category !== `undefined` ? formatMarkdownish(commandClass.usage.category, {format: this.format(colored), paragraphs: false}) : void 0;
        const description = typeof commandClass.usage.description !== `undefined` ? formatMarkdownish(commandClass.usage.description, {format: this.format(colored), paragraphs: false}) : void 0;
        const details = typeof commandClass.usage.details !== `undefined` ? formatMarkdownish(commandClass.usage.details, {format: this.format(colored), paragraphs: true}) : void 0;
        const examples = typeof commandClass.usage.examples !== `undefined` ? commandClass.usage.examples.map(([label, cli]) => [formatMarkdownish(label, {format: this.format(colored), paragraphs: false}), cli.replace(/\$0/g, this.binaryName)]) : void 0;
        data.push({path: path6, usage, category, description, details, examples, options});
      }
      return data;
    }
    usage(command = null, {colored, detailed = false, prefix = `$ `} = {}) {
      const commandClass = command !== null && command instanceof Command ? command.constructor : command;
      let result = ``;
      if (!commandClass) {
        const commandsByCategories = new Map();
        for (const [commandClass2, {index}] of this.registrations.entries()) {
          if (typeof commandClass2.usage === `undefined`)
            continue;
          const category = typeof commandClass2.usage.category !== `undefined` ? formatMarkdownish(commandClass2.usage.category, {format: this.format(colored), paragraphs: false}) : null;
          let categoryCommands = commandsByCategories.get(category);
          if (typeof categoryCommands === `undefined`)
            commandsByCategories.set(category, categoryCommands = []);
          const {usage} = this.getUsageByIndex(index);
          categoryCommands.push({commandClass: commandClass2, usage});
        }
        const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {
          if (a === null)
            return -1;
          if (b === null)
            return 1;
          return a.localeCompare(b, `en`, {usage: `sort`, caseFirst: `upper`});
        });
        const hasLabel = typeof this.binaryLabel !== `undefined`;
        const hasVersion = typeof this.binaryVersion !== `undefined`;
        if (hasLabel || hasVersion) {
          if (hasLabel && hasVersion)
            result += `${this.format(colored).bold(`${this.binaryLabel} - ${this.binaryVersion}`)}

`;
          else if (hasLabel)
            result += `${this.format(colored).bold(`${this.binaryLabel}`)}
`;
          else
            result += `${this.format(colored).bold(`${this.binaryVersion}`)}
`;
          result += `  ${this.format(colored).bold(prefix)}${this.binaryName} <command>
`;
        } else {
          result += `${this.format(colored).bold(prefix)}${this.binaryName} <command>
`;
        }
        for (const categoryName of categoryNames) {
          const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {
            return a.usage.localeCompare(b.usage, `en`, {usage: `sort`, caseFirst: `upper`});
          });
          const header = categoryName !== null ? categoryName.trim() : `Where <command> is one of`;
          result += `
`;
          result += `${this.format(colored).bold(`${header}:`)}
`;
          for (const {commandClass: commandClass2, usage} of commands) {
            const doc = commandClass2.usage.description || `undocumented`;
            result += `
`;
            result += `  ${this.format(colored).bold(usage)}
`;
            result += `    ${formatMarkdownish(doc, {format: this.format(colored), paragraphs: false})}`;
          }
        }
        result += `
`;
        result += formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \`-h,--help\` flag right after the command name.`, {format: this.format(colored), paragraphs: true});
      } else {
        if (!detailed) {
          const {usage} = this.getUsageByRegistration(commandClass);
          result += `${this.format(colored).bold(prefix)}${usage}
`;
        } else {
          const {description = ``, details = ``, examples = []} = commandClass.usage || {};
          if (description !== ``) {
            result += formatMarkdownish(description, {format: this.format(colored), paragraphs: false}).replace(/^./, ($0) => $0.toUpperCase());
            result += `
`;
          }
          if (details !== `` || examples.length > 0) {
            result += `${this.format(colored).bold(`Usage:`)}
`;
            result += `
`;
          }
          const {usage, options} = this.getUsageByRegistration(commandClass, {inlineOptions: false});
          result += `${this.format(colored).bold(prefix)}${usage}
`;
          if (options.length > 0) {
            result += `
`;
            result += `${richFormat.bold(`Options:`)}
`;
            const maxDefinitionLength = options.reduce((length, option) => {
              return Math.max(length, option.definition.length);
            }, 0);
            result += `
`;
            for (const {definition, description: description2} of options) {
              result += `  ${definition.padEnd(maxDefinitionLength)}    ${formatMarkdownish(description2, {format: this.format(colored), paragraphs: false})}`;
            }
          }
          if (details !== ``) {
            result += `
`;
            result += `${this.format(colored).bold(`Details:`)}
`;
            result += `
`;
            result += formatMarkdownish(details, {format: this.format(colored), paragraphs: true});
          }
          if (examples.length > 0) {
            result += `
`;
            result += `${this.format(colored).bold(`Examples:`)}
`;
            for (const [description2, example] of examples) {
              result += `
`;
              result += formatMarkdownish(description2, {format: this.format(colored), paragraphs: false});
              result += `${example.replace(/^/m, `  ${this.format(colored).bold(prefix)}`).replace(/\$0/g, this.binaryName)}
`;
            }
          }
        }
      }
      return result;
    }
    error(error, _a2) {
      var _b;
      var {colored, command = (_b = error[errorCommandSymbol]) !== null && _b !== void 0 ? _b : null} = _a2 === void 0 ? {} : _a2;
      if (!(error instanceof Error))
        error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);
      let result = ``;
      let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);
      if (name === `Error`)
        name = `Internal Error`;
      result += `${this.format(colored).error(name)}: ${error.message}
`;
      const meta = error.clipanion;
      if (typeof meta !== `undefined`) {
        if (meta.type === `usage`) {
          result += `
`;
          result += this.usage(command);
        }
      } else {
        if (error.stack) {
          result += `${error.stack.replace(/^.*\n/, ``)}
`;
        }
      }
      return result;
    }
    getUsageByRegistration(klass, opts) {
      const record = this.registrations.get(klass);
      if (typeof record === `undefined`)
        throw new Error(`Assertion failed: Unregistered command`);
      return this.getUsageByIndex(record.index, opts);
    }
    getUsageByIndex(n, opts) {
      return this.builder.getBuilderByIndex(n).usage(opts);
    }
    format(colored = this.enableColors) {
      return colored ? richFormat : textFormat;
    }
  };
  Cli.defaultContext = {
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\builtins\index.mjs
  var builtins_exports = {};
  __export(builtins_exports, {
    DefinitionsCommand: () => DefinitionsCommand,
    HelpCommand: () => HelpCommand2,
    VersionCommand: () => VersionCommand
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\builtins\definitions.mjs
  var DefinitionsCommand = class extends Command {
    async execute() {
      this.context.stdout.write(`${JSON.stringify(this.cli.definitions(), null, 2)}
`);
    }
  };
  DefinitionsCommand.path = [[`--clipanion=definitions`]];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\builtins\help.mjs
  var HelpCommand2 = class extends Command {
    async execute() {
      this.context.stdout.write(this.cli.usage(null));
    }
  };
  HelpCommand2.paths = [[`-h`], [`--help`]];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\builtins\version.mjs
  var VersionCommand = class extends Command {
    async execute() {
      var _a2;
      this.context.stdout.write(`${(_a2 = this.cli.binaryVersion) !== null && _a2 !== void 0 ? _a2 : `<unknown>`}
`);
    }
  };
  VersionCommand.paths = [[`-v`], [`--version`]];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\index.mjs
  var options_exports = {};
  __export(options_exports, {
    Array: () => Array2,
    Boolean: () => Boolean2,
    Counter: () => Counter,
    Proxy: () => Proxy2,
    Rest: () => Rest,
    String: () => String2,
    applyValidator: () => applyValidator,
    cleanValidationError: () => cleanValidationError,
    formatError: () => formatError,
    isOptionSymbol: () => isOptionSymbol,
    makeCommandOption: () => makeCommandOption,
    rerouteArguments: () => rerouteArguments
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\Array.mjs
  function Array2(descriptor, initialValueBase, optsBase) {
    const [initialValue, opts] = rerouteArguments(initialValueBase, optsBase !== null && optsBase !== void 0 ? optsBase : {});
    const {arity = 1} = opts;
    const optNames = descriptor.split(`,`);
    const nameSet = new Set(optNames);
    return makeCommandOption({
      definition(builder) {
        builder.addOption({
          names: optNames,
          arity,
          hidden: opts === null || opts === void 0 ? void 0 : opts.hidden,
          description: opts === null || opts === void 0 ? void 0 : opts.description,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        let currentValue = typeof initialValue !== `undefined` ? [...initialValue] : void 0;
        for (const {name, value} of state.options) {
          if (!nameSet.has(name))
            continue;
          currentValue = currentValue !== null && currentValue !== void 0 ? currentValue : [];
          currentValue.push(value);
        }
        return currentValue;
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\Boolean.mjs
  function Boolean2(descriptor, initialValueBase, optsBase) {
    const [initialValue, opts] = rerouteArguments(initialValueBase, optsBase !== null && optsBase !== void 0 ? optsBase : {});
    const optNames = descriptor.split(`,`);
    const nameSet = new Set(optNames);
    return makeCommandOption({
      definition(builder) {
        builder.addOption({
          names: optNames,
          allowBinding: false,
          arity: 0,
          hidden: opts.hidden,
          description: opts.description,
          required: opts.required
        });
      },
      transformer(builer, key, state) {
        let currentValue = initialValue;
        for (const {name, value} of state.options) {
          if (!nameSet.has(name))
            continue;
          currentValue = value;
        }
        return currentValue;
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\Counter.mjs
  function Counter(descriptor, initialValueBase, optsBase) {
    const [initialValue, opts] = rerouteArguments(initialValueBase, optsBase !== null && optsBase !== void 0 ? optsBase : {});
    const optNames = descriptor.split(`,`);
    const nameSet = new Set(optNames);
    return makeCommandOption({
      definition(builder) {
        builder.addOption({
          names: optNames,
          allowBinding: false,
          arity: 0,
          hidden: opts.hidden,
          description: opts.description,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        let currentValue = initialValue;
        for (const {name, value} of state.options) {
          if (!nameSet.has(name))
            continue;
          currentValue !== null && currentValue !== void 0 ? currentValue : currentValue = 0;
          if (!value) {
            currentValue = 0;
          } else {
            currentValue += 1;
          }
        }
        return currentValue;
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\Proxy.mjs
  function Proxy2(opts = {}) {
    return makeCommandOption({
      definition(builder, key) {
        var _a2;
        builder.addProxy({
          name: (_a2 = opts.name) !== null && _a2 !== void 0 ? _a2 : key,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        return state.positionals.map(({value}) => value);
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\Rest.mjs
  function Rest(opts = {}) {
    return makeCommandOption({
      definition(builder, key) {
        var _a2;
        builder.addRest({
          name: (_a2 = opts.name) !== null && _a2 !== void 0 ? _a2 : key,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        const isRestPositional = (index) => {
          const positional = state.positionals[index];
          if (positional.extra === NoLimits)
            return true;
          if (positional.extra === false && index < builder.arity.leading.length)
            return true;
          return false;
        };
        let count = 0;
        while (count < state.positionals.length && isRestPositional(count))
          count += 1;
        return state.positionals.splice(0, count).map(({value}) => value);
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\clipanion-virtual-e624d19a8b\0\cache\clipanion-npm-3.0.0-rc.5-65b2e45ea2-cfa07beb10.zip\node_modules\clipanion\lib\advanced\options\String.mjs
  function StringOption(descriptor, initialValueBase, optsBase) {
    const [initialValue, opts] = rerouteArguments(initialValueBase, optsBase !== null && optsBase !== void 0 ? optsBase : {});
    const {arity = 1} = opts;
    const optNames = descriptor.split(`,`);
    const nameSet = new Set(optNames);
    return makeCommandOption({
      definition(builder) {
        builder.addOption({
          names: optNames,
          arity: opts.tolerateBoolean ? 0 : arity,
          hidden: opts.hidden,
          description: opts.description,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        let usedName;
        let currentValue = initialValue;
        for (const {name, value} of state.options) {
          if (!nameSet.has(name))
            continue;
          usedName = name;
          currentValue = value;
        }
        if (typeof initialValue === `undefined` && typeof currentValue === `undefined`)
          return void 0;
        return applyValidator(usedName !== null && usedName !== void 0 ? usedName : key, currentValue, opts.validator);
      }
    });
  }
  function StringPositional(opts = {}) {
    const {required = true} = opts;
    return makeCommandOption({
      definition(builder, key) {
        var _a2;
        builder.addPositional({
          name: (_a2 = opts.name) !== null && _a2 !== void 0 ? _a2 : key,
          required: opts.required
        });
      },
      transformer(builder, key, state) {
        for (let i = 0; i < state.positionals.length; ++i) {
          if (state.positionals[i].extra === NoLimits)
            continue;
          if (required && state.positionals[i].extra === true)
            continue;
          if (!required && state.positionals[i].extra === false)
            continue;
          const [positional] = state.positionals.splice(i, 1);
          return positional.value;
        }
        return void 0;
      }
    });
  }
  function String2(descriptor, ...args) {
    if (typeof descriptor === `string`) {
      return StringOption(descriptor, ...args);
    } else {
      return StringPositional(descriptor);
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\formatUtils.ts
  var miscUtils2 = __toModule(require_miscUtils());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\structUtils.ts
  var structUtils_exports = {};
  __export(structUtils_exports, {
    areDescriptorsEqual: () => areDescriptorsEqual,
    areIdentsEqual: () => areIdentsEqual,
    areLocatorsEqual: () => areLocatorsEqual,
    areVirtualPackagesEquivalent: () => areVirtualPackagesEquivalent,
    bindDescriptor: () => bindDescriptor,
    bindLocator: () => bindLocator,
    convertDescriptorToLocator: () => convertDescriptorToLocator,
    convertLocatorToDescriptor: () => convertLocatorToDescriptor,
    convertPackageToLocator: () => convertPackageToLocator,
    convertToIdent: () => convertToIdent,
    convertToManifestRange: () => convertToManifestRange,
    copyPackage: () => copyPackage,
    devirtualizeDescriptor: () => devirtualizeDescriptor,
    devirtualizeLocator: () => devirtualizeLocator,
    getIdentVendorPath: () => getIdentVendorPath,
    isVirtualDescriptor: () => isVirtualDescriptor,
    isVirtualLocator: () => isVirtualLocator,
    makeDescriptor: () => makeDescriptor,
    makeIdent: () => makeIdent,
    makeLocator: () => makeLocator,
    makeRange: () => makeRange,
    parseDescriptor: () => parseDescriptor,
    parseFileStyleRange: () => parseFileStyleRange,
    parseIdent: () => parseIdent,
    parseLocator: () => parseLocator,
    parseRange: () => parseRange,
    prettyDependent: () => prettyDependent,
    prettyDescriptor: () => prettyDescriptor,
    prettyIdent: () => prettyIdent,
    prettyLocator: () => prettyLocator,
    prettyLocatorNoColors: () => prettyLocatorNoColors,
    prettyRange: () => prettyRange,
    prettyReference: () => prettyReference,
    prettyResolution: () => prettyResolution,
    prettyWorkspace: () => prettyWorkspace,
    renamePackage: () => renamePackage,
    slugifyIdent: () => slugifyIdent,
    slugifyLocator: () => slugifyLocator,
    sortDescriptors: () => sortDescriptors,
    stringifyDescriptor: () => stringifyDescriptor,
    stringifyIdent: () => stringifyIdent,
    stringifyLocator: () => stringifyLocator,
    tryParseDescriptor: () => tryParseDescriptor,
    tryParseIdent: () => tryParseIdent,
    tryParseLocator: () => tryParseLocator,
    virtualizeDescriptor: () => virtualizeDescriptor,
    virtualizePackage: () => virtualizePackage
  });
  var import_querystring = __toModule(require("querystring"));
  var import_semver = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\hashUtils.ts
  var hashUtils_exports = {};
  __export(hashUtils_exports, {
    checksumFile: () => checksumFile,
    checksumPattern: () => checksumPattern,
    makeHash: () => makeHash
  });
  var import_crypto = __toModule(require("crypto"));
  var import_globby = __toModule(require_globby());
  function makeHash(...args) {
    const hash = import_crypto.createHash(`sha512`);
    for (const arg of args)
      hash.update(arg ? arg : ``);
    return hash.digest(`hex`);
  }
  function checksumFile(path6) {
    return new Promise((resolve, reject) => {
      const hash = import_crypto.createHash(`sha512`);
      const stream = xfs.createReadStream(path6);
      stream.on(`data`, (chunk) => {
        hash.update(chunk);
      });
      stream.on(`error`, (error) => {
        reject(error);
      });
      stream.on(`end`, () => {
        resolve(hash.digest(`hex`));
      });
    });
  }
  async function checksumPattern(pattern, {cwd}) {
    const dirListing = await import_globby.default(pattern, {
      cwd: npath.fromPortablePath(cwd),
      expandDirectories: false,
      onlyDirectories: true,
      unique: true
    });
    const dirPatterns = dirListing.map((entry) => {
      return `${entry}/**/*`;
    });
    const listing = await import_globby.default([pattern, ...dirPatterns], {
      cwd: npath.fromPortablePath(cwd),
      expandDirectories: false,
      onlyFiles: false,
      unique: true
    });
    listing.sort();
    const hashes = await Promise.all(listing.map(async (entry) => {
      const parts = [Buffer.from(entry)];
      const p = npath.toPortablePath(entry);
      const stat = await xfs.lstatPromise(p);
      if (stat.isSymbolicLink())
        parts.push(Buffer.from(await xfs.readlinkPromise(p)));
      else if (stat.isFile())
        parts.push(await xfs.readFilePromise(p));
      return parts.join(`\0`);
    }));
    const hash = import_crypto.createHash(`sha512`);
    for (const sub of hashes)
      hash.update(sub);
    return hash.digest(`hex`);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\structUtils.ts
  var miscUtils = __toModule(require_miscUtils());
  var VIRTUAL_PROTOCOL = `virtual:`;
  var VIRTUAL_ABBREVIATE = 5;
  function makeIdent(scope, name) {
    if (scope == null ? void 0 : scope.startsWith(`@`))
      throw new Error(`Invalid scope: don't prefix it with '@'`);
    return {identHash: makeHash(scope, name), scope, name};
  }
  function makeDescriptor(ident, range) {
    return {identHash: ident.identHash, scope: ident.scope, name: ident.name, descriptorHash: makeHash(ident.identHash, range), range};
  }
  function makeLocator(ident, reference) {
    return {identHash: ident.identHash, scope: ident.scope, name: ident.name, locatorHash: makeHash(ident.identHash, reference), reference};
  }
  function convertToIdent(source) {
    return {identHash: source.identHash, scope: source.scope, name: source.name};
  }
  function convertDescriptorToLocator(descriptor) {
    return {identHash: descriptor.identHash, scope: descriptor.scope, name: descriptor.name, locatorHash: descriptor.descriptorHash, reference: descriptor.range};
  }
  function convertLocatorToDescriptor(locator) {
    return {identHash: locator.identHash, scope: locator.scope, name: locator.name, descriptorHash: locator.locatorHash, range: locator.reference};
  }
  function convertPackageToLocator(pkg) {
    return {identHash: pkg.identHash, scope: pkg.scope, name: pkg.name, locatorHash: pkg.locatorHash, reference: pkg.reference};
  }
  function renamePackage(pkg, locator) {
    return {
      identHash: locator.identHash,
      scope: locator.scope,
      name: locator.name,
      locatorHash: locator.locatorHash,
      reference: locator.reference,
      version: pkg.version,
      languageName: pkg.languageName,
      linkType: pkg.linkType,
      dependencies: new Map(pkg.dependencies),
      peerDependencies: new Map(pkg.peerDependencies),
      dependenciesMeta: new Map(pkg.dependenciesMeta),
      peerDependenciesMeta: new Map(pkg.peerDependenciesMeta),
      bin: new Map(pkg.bin)
    };
  }
  function copyPackage(pkg) {
    return renamePackage(pkg, pkg);
  }
  function virtualizeDescriptor(descriptor, entropy) {
    if (entropy.includes(`#`))
      throw new Error(`Invalid entropy`);
    return makeDescriptor(descriptor, `virtual:${entropy}#${descriptor.range}`);
  }
  function virtualizePackage(pkg, entropy) {
    if (entropy.includes(`#`))
      throw new Error(`Invalid entropy`);
    return renamePackage(pkg, makeLocator(pkg, `virtual:${entropy}#${pkg.reference}`));
  }
  function isVirtualDescriptor(descriptor) {
    return descriptor.range.startsWith(VIRTUAL_PROTOCOL);
  }
  function isVirtualLocator(locator) {
    return locator.reference.startsWith(VIRTUAL_PROTOCOL);
  }
  function devirtualizeDescriptor(descriptor) {
    if (!isVirtualDescriptor(descriptor))
      throw new Error(`Not a virtual descriptor`);
    return makeDescriptor(descriptor, descriptor.range.replace(/^[^#]*#/, ``));
  }
  function devirtualizeLocator(locator) {
    if (!isVirtualLocator(locator))
      throw new Error(`Not a virtual descriptor`);
    return makeLocator(locator, locator.reference.replace(/^[^#]*#/, ``));
  }
  function bindDescriptor(descriptor, params) {
    if (descriptor.range.includes(`::`))
      return descriptor;
    return makeDescriptor(descriptor, `${descriptor.range}::${import_querystring.default.stringify(params)}`);
  }
  function bindLocator(locator, params) {
    if (locator.reference.includes(`::`))
      return locator;
    return makeLocator(locator, `${locator.reference}::${import_querystring.default.stringify(params)}`);
  }
  function areIdentsEqual(a, b) {
    return a.identHash === b.identHash;
  }
  function areDescriptorsEqual(a, b) {
    return a.descriptorHash === b.descriptorHash;
  }
  function areLocatorsEqual(a, b) {
    return a.locatorHash === b.locatorHash;
  }
  function areVirtualPackagesEquivalent(a, b) {
    if (!isVirtualLocator(a))
      throw new Error(`Invalid package type`);
    if (!isVirtualLocator(b))
      throw new Error(`Invalid package type`);
    if (!areIdentsEqual(a, b))
      return false;
    if (a.dependencies.size !== b.dependencies.size)
      return false;
    for (const dependencyDescriptorA of a.dependencies.values()) {
      const dependencyDescriptorB = b.dependencies.get(dependencyDescriptorA.identHash);
      if (!dependencyDescriptorB)
        return false;
      if (!areDescriptorsEqual(dependencyDescriptorA, dependencyDescriptorB)) {
        return false;
      }
    }
    return true;
  }
  function parseIdent(string) {
    const ident = tryParseIdent(string);
    if (!ident)
      throw new Error(`Invalid ident (${string})`);
    return ident;
  }
  function tryParseIdent(string) {
    const match2 = string.match(/^(?:@([^/]+?)\/)?([^/]+)$/);
    if (!match2)
      return null;
    const [, scope, name] = match2;
    const realScope = typeof scope !== `undefined` ? scope : null;
    return makeIdent(realScope, name);
  }
  function parseDescriptor(string, strict = false) {
    const descriptor = tryParseDescriptor(string, strict);
    if (!descriptor)
      throw new Error(`Invalid descriptor (${string})`);
    return descriptor;
  }
  function tryParseDescriptor(string, strict = false) {
    const match2 = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
    if (!match2)
      return null;
    const [, scope, name, range] = match2;
    if (range === `unknown`)
      throw new Error(`Invalid range (${string})`);
    const realScope = typeof scope !== `undefined` ? scope : null;
    const realRange = typeof range !== `undefined` ? range : `unknown`;
    return makeDescriptor(makeIdent(realScope, name), realRange);
  }
  function parseLocator(string, strict = false) {
    const locator = tryParseLocator(string, strict);
    if (!locator)
      throw new Error(`Invalid locator (${string})`);
    return locator;
  }
  function tryParseLocator(string, strict = false) {
    const match2 = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
    if (!match2)
      return null;
    const [, scope, name, reference] = match2;
    if (reference === `unknown`)
      throw new Error(`Invalid reference (${string})`);
    const realScope = typeof scope !== `undefined` ? scope : null;
    const realReference = typeof reference !== `undefined` ? reference : `unknown`;
    return makeLocator(makeIdent(realScope, name), realReference);
  }
  function parseRange(range, opts) {
    const match2 = range.match(/^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$/);
    if (match2 === null)
      throw new Error(`Invalid range (${range})`);
    const protocol = typeof match2[1] !== `undefined` ? match2[1] : null;
    if (typeof (opts == null ? void 0 : opts.requireProtocol) === `string` && protocol !== opts.requireProtocol)
      throw new Error(`Invalid protocol (${protocol})`);
    else if ((opts == null ? void 0 : opts.requireProtocol) && protocol === null)
      throw new Error(`Missing protocol (${protocol})`);
    const source = typeof match2[3] !== `undefined` ? decodeURIComponent(match2[2]) : null;
    if ((opts == null ? void 0 : opts.requireSource) && source === null)
      throw new Error(`Missing source (${range})`);
    const rawSelector = typeof match2[3] !== `undefined` ? decodeURIComponent(match2[3]) : decodeURIComponent(match2[2]);
    const selector = (opts == null ? void 0 : opts.parseSelector) ? import_querystring.default.parse(rawSelector) : rawSelector;
    const params = typeof match2[4] !== `undefined` ? import_querystring.default.parse(match2[4]) : null;
    return {
      protocol,
      source,
      selector,
      params
    };
  }
  function parseFileStyleRange(range, {protocol}) {
    const {selector, params} = parseRange(range, {
      requireProtocol: protocol,
      requireBindings: true
    });
    if (typeof params.locator !== `string`)
      throw new Error(`Assertion failed: Invalid bindings for ${range}`);
    const parentLocator = parseLocator(params.locator, true);
    const path6 = selector;
    return {parentLocator, path: path6};
  }
  function encodeUnsafeCharacters(str) {
    str = str.replace(/%/g, `%25`);
    str = str.replace(/:/g, `%3A`);
    str = str.replace(/#/g, `%23`);
    return str;
  }
  function hasParams(params) {
    if (params === null)
      return false;
    return Object.entries(params).length > 0;
  }
  function makeRange({protocol, source, selector, params}) {
    let range = ``;
    if (protocol !== null)
      range += `${protocol}`;
    if (source !== null)
      range += `${encodeUnsafeCharacters(source)}#`;
    range += encodeUnsafeCharacters(selector);
    if (hasParams(params))
      range += `::${import_querystring.default.stringify(params)}`;
    return range;
  }
  function convertToManifestRange(range) {
    const {params, protocol, source, selector} = parseRange(range);
    for (const name in params)
      if (name.startsWith(`__`))
        delete params[name];
    return makeRange({protocol, source, params, selector});
  }
  function stringifyIdent(ident) {
    if (ident.scope) {
      return `@${ident.scope}/${ident.name}`;
    } else {
      return `${ident.name}`;
    }
  }
  function stringifyDescriptor(descriptor) {
    if (descriptor.scope) {
      return `@${descriptor.scope}/${descriptor.name}@${descriptor.range}`;
    } else {
      return `${descriptor.name}@${descriptor.range}`;
    }
  }
  function stringifyLocator(locator) {
    if (locator.scope) {
      return `@${locator.scope}/${locator.name}@${locator.reference}`;
    } else {
      return `${locator.name}@${locator.reference}`;
    }
  }
  function slugifyIdent(ident) {
    if (ident.scope !== null) {
      return `@${ident.scope}-${ident.name}`;
    } else {
      return ident.name;
    }
  }
  function slugifyLocator(locator) {
    const {protocol, selector} = parseRange(locator.reference);
    const humanProtocol = protocol !== null ? protocol.replace(/:$/, ``) : `exotic`;
    const humanVersion = import_semver.default.valid(selector);
    const humanReference = humanVersion !== null ? `${humanProtocol}-${humanVersion}` : `${humanProtocol}`;
    const hashTruncate = 10;
    const slug = locator.scope ? `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}` : `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`;
    return toFilename(slug);
  }
  function prettyIdent(configuration, ident) {
    if (ident.scope) {
      return `${pretty(configuration, `@${ident.scope}/`, Type.SCOPE)}${pretty(configuration, ident.name, Type.NAME)}`;
    } else {
      return `${pretty(configuration, ident.name, Type.NAME)}`;
    }
  }
  function prettyRangeNoColors(range) {
    if (range.startsWith(VIRTUAL_PROTOCOL)) {
      const nested = prettyRangeNoColors(range.substr(range.indexOf(`#`) + 1));
      const abbrev = range.substr(VIRTUAL_PROTOCOL.length, VIRTUAL_ABBREVIATE);
      return false ? `${nested} (virtual:${abbrev})` : `${nested} [${abbrev}]`;
    } else {
      return range.replace(/\?.*/, `?[...]`);
    }
  }
  function prettyRange(configuration, range) {
    return `${pretty(configuration, prettyRangeNoColors(range), Type.RANGE)}`;
  }
  function prettyDescriptor(configuration, descriptor) {
    return `${prettyIdent(configuration, descriptor)}${pretty(configuration, `@`, Type.RANGE)}${prettyRange(configuration, descriptor.range)}`;
  }
  function prettyReference(configuration, reference) {
    return `${pretty(configuration, prettyRangeNoColors(reference), Type.REFERENCE)}`;
  }
  function prettyLocator(configuration, locator) {
    return `${prettyIdent(configuration, locator)}${pretty(configuration, `@`, Type.REFERENCE)}${prettyReference(configuration, locator.reference)}`;
  }
  function prettyLocatorNoColors(locator) {
    return `${stringifyIdent(locator)}@${prettyRangeNoColors(locator.reference)}`;
  }
  function sortDescriptors(descriptors) {
    return miscUtils.sortMap(descriptors, [
      (descriptor) => stringifyIdent(descriptor),
      (descriptor) => descriptor.range
    ]);
  }
  function prettyWorkspace(configuration, workspace) {
    return prettyIdent(configuration, workspace.locator);
  }
  function prettyResolution(configuration, descriptor, locator) {
    const devirtualizedDescriptor = isVirtualDescriptor(descriptor) ? devirtualizeDescriptor(descriptor) : descriptor;
    if (locator === null) {
      return `${prettyDescriptor(configuration, devirtualizedDescriptor)} \u2192 ${mark(configuration).Cross}`;
    } else if (devirtualizedDescriptor.identHash === locator.identHash) {
      return `${prettyDescriptor(configuration, devirtualizedDescriptor)} \u2192 ${prettyReference(configuration, locator.reference)}`;
    } else {
      return `${prettyDescriptor(configuration, devirtualizedDescriptor)} \u2192 ${prettyLocator(configuration, locator)}`;
    }
  }
  function prettyDependent(configuration, locator, descriptor) {
    if (descriptor === null) {
      return `${prettyLocator(configuration, locator)}`;
    } else {
      return `${prettyLocator(configuration, locator)} (via ${prettyRange(configuration, descriptor.range)})`;
    }
  }
  function getIdentVendorPath(ident) {
    return `node_modules/${stringifyIdent(ident)}`;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\types.ts
  var LinkType;
  (function(LinkType4) {
    LinkType4["HARD"] = `HARD`;
    LinkType4["SOFT"] = `SOFT`;
  })(LinkType || (LinkType = {}));
  var PackageExtensionType;
  (function(PackageExtensionType2) {
    PackageExtensionType2["Dependency"] = `Dependency`;
    PackageExtensionType2["PeerDependency"] = `PeerDependency`;
    PackageExtensionType2["PeerDependencyMeta"] = `PeerDependencyMeta`;
  })(PackageExtensionType || (PackageExtensionType = {}));
  var PackageExtensionStatus;
  (function(PackageExtensionStatus2) {
    PackageExtensionStatus2["Inactive"] = `inactive`;
    PackageExtensionStatus2["Redundant"] = `redundant`;
    PackageExtensionStatus2["Active"] = `active`;
  })(PackageExtensionStatus || (PackageExtensionStatus = {}));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\formatUtils.ts
  var Type = {
    NO_HINT: `NO_HINT`,
    NULL: `NULL`,
    SCOPE: `SCOPE`,
    NAME: `NAME`,
    RANGE: `RANGE`,
    REFERENCE: `REFERENCE`,
    NUMBER: `NUMBER`,
    PATH: `PATH`,
    URL: `URL`,
    ADDED: `ADDED`,
    REMOVED: `REMOVED`,
    CODE: `CODE`,
    DURATION: `DURATION`,
    SIZE: `SIZE`,
    IDENT: `IDENT`,
    DESCRIPTOR: `DESCRIPTOR`,
    LOCATOR: `LOCATOR`,
    RESOLUTION: `RESOLUTION`,
    DEPENDENT: `DEPENDENT`,
    PACKAGE_EXTENSION: `PACKAGE_EXTENSION`
  };
  var Style;
  (function(Style2) {
    Style2[Style2["BOLD"] = 2] = "BOLD";
  })(Style || (Style = {}));
  var chalkOptions = process.env.GITHUB_ACTIONS ? {level: 2} : import_chalk.default.supportsColor ? {level: import_chalk.default.supportsColor.level} : {level: 0};
  var supportsColor = chalkOptions.level !== 0;
  var supportsHyperlinks = supportsColor && !process.env.GITHUB_ACTIONS;
  var chalkInstance = new import_chalk.default.Instance(chalkOptions);
  var colors = new Map([
    [Type.NO_HINT, null],
    [Type.NULL, [`#a853b5`, 129]],
    [Type.SCOPE, [`#d75f00`, 166]],
    [Type.NAME, [`#d7875f`, 173]],
    [Type.RANGE, [`#00afaf`, 37]],
    [Type.REFERENCE, [`#87afff`, 111]],
    [Type.NUMBER, [`#ffd700`, 220]],
    [Type.PATH, [`#d75fd7`, 170]],
    [Type.URL, [`#d75fd7`, 170]],
    [Type.ADDED, [`#5faf00`, 70]],
    [Type.REMOVED, [`#d70000`, 160]],
    [Type.CODE, [`#87afff`, 111]],
    [Type.SIZE, [`#ffd700`, 220]]
  ]);
  var validateTransform = (spec) => spec;
  var transforms = {
    [Type.NUMBER]: validateTransform({
      pretty: (configuration, value) => {
        return `${value}`;
      },
      json: (value) => {
        return value;
      }
    }),
    [Type.IDENT]: validateTransform({
      pretty: (configuration, ident) => {
        return prettyIdent(configuration, ident);
      },
      json: (ident) => {
        return stringifyIdent(ident);
      }
    }),
    [Type.LOCATOR]: validateTransform({
      pretty: (configuration, locator) => {
        return prettyLocator(configuration, locator);
      },
      json: (locator) => {
        return stringifyLocator(locator);
      }
    }),
    [Type.DESCRIPTOR]: validateTransform({
      pretty: (configuration, descriptor) => {
        return prettyDescriptor(configuration, descriptor);
      },
      json: (descriptor) => {
        return stringifyDescriptor(descriptor);
      }
    }),
    [Type.RESOLUTION]: validateTransform({
      pretty: (configuration, {descriptor, locator}) => {
        return prettyResolution(configuration, descriptor, locator);
      },
      json: ({descriptor, locator}) => {
        return {
          descriptor: stringifyDescriptor(descriptor),
          locator: locator !== null ? stringifyLocator(locator) : null
        };
      }
    }),
    [Type.DEPENDENT]: validateTransform({
      pretty: (configuration, {locator, descriptor}) => {
        return prettyDependent(configuration, locator, descriptor);
      },
      json: ({locator, descriptor}) => {
        return {
          locator: stringifyLocator(locator),
          descriptor: stringifyDescriptor(descriptor)
        };
      }
    }),
    [Type.PACKAGE_EXTENSION]: validateTransform({
      pretty: (configuration, packageExtension) => {
        switch (packageExtension.type) {
          case PackageExtensionType.Dependency:
            return `${prettyIdent(configuration, packageExtension.parentDescriptor)} \u27A4 ${applyColor(configuration, `dependencies`, Type.CODE)} \u27A4 ${prettyIdent(configuration, packageExtension.descriptor)}`;
          case PackageExtensionType.PeerDependency:
            return `${prettyIdent(configuration, packageExtension.parentDescriptor)} \u27A4 ${applyColor(configuration, `peerDependencies`, Type.CODE)} \u27A4 ${prettyIdent(configuration, packageExtension.descriptor)}`;
          case PackageExtensionType.PeerDependencyMeta:
            return `${prettyIdent(configuration, packageExtension.parentDescriptor)} \u27A4 ${applyColor(configuration, `peerDependenciesMeta`, Type.CODE)} \u27A4 ${prettyIdent(configuration, parseIdent(packageExtension.selector))} \u27A4 ${applyColor(configuration, packageExtension.key, Type.CODE)}`;
          default:
            throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
        }
      },
      json: (packageExtension) => {
        switch (packageExtension.type) {
          case PackageExtensionType.Dependency:
            return `${stringifyIdent(packageExtension.parentDescriptor)} > ${stringifyIdent(packageExtension.descriptor)}`;
          case PackageExtensionType.PeerDependency:
            return `${stringifyIdent(packageExtension.parentDescriptor)} >> ${stringifyIdent(packageExtension.descriptor)}`;
          case PackageExtensionType.PeerDependencyMeta:
            return `${stringifyIdent(packageExtension.parentDescriptor)} >> ${packageExtension.selector} / ${packageExtension.key}`;
          default:
            throw new Error(`Assertion failed: Unsupported package extension type: ${packageExtension.type}`);
        }
      }
    }),
    [Type.DURATION]: validateTransform({
      pretty: (configuration, duration) => {
        if (duration > 1e3 * 60) {
          const minutes = Math.floor(duration / 1e3 / 60);
          const seconds = Math.ceil((duration - minutes * 60 * 1e3) / 1e3);
          return seconds === 0 ? `${minutes}m` : `${minutes}m ${seconds}s`;
        } else {
          const seconds = Math.floor(duration / 1e3);
          const milliseconds = duration - seconds * 1e3;
          return milliseconds === 0 ? `${seconds}s` : `${seconds}s ${milliseconds}ms`;
        }
      },
      json: (duration) => {
        return duration;
      }
    }),
    [Type.SIZE]: validateTransform({
      pretty: (configuration, size) => {
        const thresholds = [`KB`, `MB`, `GB`, `TB`];
        let power = thresholds.length;
        while (power > 1 && size < 1024 ** power)
          power -= 1;
        const factor = 1024 ** power;
        const value = Math.floor(size * 100 / factor) / 100;
        return applyColor(configuration, `${value} ${thresholds[power - 1]}`, Type.NUMBER);
      },
      json: (size) => {
        return size;
      }
    }),
    [Type.PATH]: validateTransform({
      pretty: (configuration, filePath) => {
        return applyColor(configuration, npath.fromPortablePath(filePath), Type.PATH);
      },
      json: (filePath) => {
        return npath.fromPortablePath(filePath);
      }
    })
  };
  function tuple(formatType, value) {
    return [value, formatType];
  }
  function applyStyle(configuration, text, flags) {
    if (!configuration.get(`enableColors`))
      return text;
    if (flags & 2)
      text = import_chalk.default.bold(text);
    return text;
  }
  function applyColor(configuration, value, formatType) {
    if (!configuration.get(`enableColors`))
      return value;
    const colorSpec = colors.get(formatType);
    if (colorSpec === null)
      return value;
    const color = typeof colorSpec === `undefined` ? formatType : chalkOptions.level >= 3 ? colorSpec[0] : colorSpec[1];
    const fn = typeof color === `number` ? chalkInstance.ansi256(color) : color.startsWith(`#`) ? chalkInstance.hex(color) : chalkInstance[color];
    if (typeof fn !== `function`)
      throw new Error(`Invalid format type ${color}`);
    return fn(value);
  }
  function pretty(configuration, value, formatType) {
    if (value === null)
      return applyColor(configuration, `null`, Type.NULL);
    if (Object.prototype.hasOwnProperty.call(transforms, formatType)) {
      const transform = transforms[formatType];
      const typedTransform = transform;
      return typedTransform.pretty(configuration, value);
    }
    if (typeof value !== `string`)
      throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
    return applyColor(configuration, value, formatType);
  }
  function prettyList(configuration, values, formatType, {separator = `, `} = {}) {
    return [...values].map((value) => pretty(configuration, value, formatType)).join(separator);
  }
  function json(value, formatType) {
    if (value === null)
      return null;
    if (Object.prototype.hasOwnProperty.call(transforms, formatType)) {
      miscUtils2.overrideType(formatType);
      return transforms[formatType].json(value);
    }
    if (typeof value !== `string`)
      throw new Error(`Assertion failed: Expected the value to be a string, got ${typeof value}`);
    return value;
  }
  function mark(configuration) {
    return {
      Check: applyColor(configuration, `\u2713`, `green`),
      Cross: applyColor(configuration, `\u2718`, `red`),
      Question: applyColor(configuration, `?`, `cyan`)
    };
  }
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["Error"] = `error`;
    LogLevel2["Warning"] = `warning`;
    LogLevel2["Info"] = `info`;
    LogLevel2["Discard"] = `discard`;
  })(LogLevel || (LogLevel = {}));
  function addLogFilterSupport(report, {configuration}) {
    const logFilters = configuration.get(`logFilters`);
    const logFiltersByCode = new Map();
    const logFiltersByText = new Map();
    for (const filter of logFilters) {
      const level = filter.get(`level`);
      if (typeof level === `undefined`)
        continue;
      const code = filter.get(`code`);
      if (typeof code !== `undefined`)
        logFiltersByCode.set(code, level);
      const text = filter.get(`text`);
      if (typeof text !== `undefined`) {
        logFiltersByText.set(text, level);
      }
    }
    const findLogLevel = (name, text, defaultLevel) => {
      if (name === null || name === MessageName.UNNAMED)
        return defaultLevel;
      if (logFiltersByText.size > 0) {
        const level = logFiltersByText.get(import_strip_ansi.default(text));
        if (typeof level !== `undefined`) {
          return level != null ? level : defaultLevel;
        }
      }
      if (logFiltersByCode.size > 0) {
        const level = logFiltersByCode.get(stringifyMessageName(name));
        if (typeof level !== `undefined`) {
          return level != null ? level : defaultLevel;
        }
      }
      return defaultLevel;
    };
    const reportInfo = report.reportInfo;
    const reportWarning = report.reportWarning;
    const reportError = report.reportError;
    const routeMessage = function(report2, name, text, level) {
      switch (findLogLevel(name, text, level)) {
        case LogLevel.Info:
          {
            reportInfo.call(report2, name, text);
          }
          break;
        case LogLevel.Warning:
          {
            reportWarning.call(report2, name != null ? name : MessageName.UNNAMED, text);
          }
          break;
        case LogLevel.Error:
          {
            reportError.call(report2, name != null ? name : MessageName.UNNAMED, text);
          }
          break;
      }
    };
    report.reportInfo = function(...args) {
      return routeMessage(this, ...args, LogLevel.Info);
    };
    report.reportWarning = function(...args) {
      return routeMessage(this, ...args, LogLevel.Warning);
    };
    report.reportError = function(...args) {
      return routeMessage(this, ...args, LogLevel.Error);
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\httpUtils.ts
  var httpUtils_exports = {};
  __export(httpUtils_exports, {
    Method: () => Method,
    del: () => del,
    get: () => get,
    getNetworkSettings: () => getNetworkSettings,
    post: () => post,
    put: () => put,
    request: () => request
  });
  var import_https = __toModule(require("https"));
  var import_http = __toModule(require("http"));
  var import_micromatch = __toModule(require_micromatch());
  var import_tunnel = __toModule(require_tunnel2());
  var import_url2 = __toModule(require("url"));
  var cache = new Map();
  var certCache = new Map();
  var globalHttpAgent = new import_http.Agent({keepAlive: true});
  var globalHttpsAgent = new import_https.Agent({keepAlive: true});
  function parseProxy(specifier) {
    const url = new import_url2.URL(specifier);
    const proxy = {host: url.hostname, headers: {}};
    if (url.port)
      proxy.port = Number(url.port);
    return {proxy};
  }
  async function getCachedCertificate(caFilePath) {
    let certificate = certCache.get(caFilePath);
    if (!certificate) {
      certificate = xfs.readFilePromise(caFilePath).then((cert) => {
        certCache.set(caFilePath, cert);
        return cert;
      });
      certCache.set(caFilePath, certificate);
    }
    return certificate;
  }
  function getNetworkSettings(target, opts) {
    const networkSettings = [...opts.configuration.get(`networkSettings`)].sort(([keyA], [keyB]) => {
      return keyB.length - keyA.length;
    });
    const mergedNetworkSettings = {
      enableNetwork: void 0,
      caFilePath: void 0,
      httpProxy: void 0,
      httpsProxy: void 0
    };
    const mergableKeys = Object.keys(mergedNetworkSettings);
    const url = new import_url2.URL(target);
    for (const [glob, config] of networkSettings) {
      if (import_micromatch.default.isMatch(url.hostname, glob)) {
        for (const key of mergableKeys) {
          const setting = config.get(key);
          if (setting !== null && typeof mergedNetworkSettings[key] === `undefined`) {
            mergedNetworkSettings[key] = setting;
          }
        }
      }
    }
    for (const key of mergableKeys) {
      if (typeof mergedNetworkSettings[key] === `undefined`) {
        mergedNetworkSettings[key] = opts.configuration.get(key);
      }
    }
    return mergedNetworkSettings;
  }
  var Method;
  (function(Method2) {
    Method2["GET"] = `GET`;
    Method2["PUT"] = `PUT`;
    Method2["POST"] = `POST`;
    Method2["DELETE"] = `DELETE`;
  })(Method || (Method = {}));
  async function request(target, body, {configuration, headers, jsonRequest, jsonResponse, method = Method.GET}) {
    const networkConfig = getNetworkSettings(target, {configuration});
    if (networkConfig.enableNetwork === false)
      throw new Error(`Request to '${target}' has been blocked because of your configuration settings`);
    const url = new import_url2.URL(target);
    if (url.protocol === `http:` && !import_micromatch.default.isMatch(url.hostname, configuration.get(`unsafeHttpWhitelist`)))
      throw new Error(`Unsafe http requests must be explicitly whitelisted in your configuration (${url.hostname})`);
    const agent = {
      http: networkConfig.httpProxy ? import_tunnel.default.httpOverHttp(parseProxy(networkConfig.httpProxy)) : globalHttpAgent,
      https: networkConfig.httpsProxy ? import_tunnel.default.httpsOverHttp(parseProxy(networkConfig.httpsProxy)) : globalHttpsAgent
    };
    const gotOptions = {agent, headers, method};
    gotOptions.responseType = jsonResponse ? `json` : `buffer`;
    if (body !== null) {
      if (Buffer.isBuffer(body) || !jsonRequest && typeof body === `string`) {
        gotOptions.body = body;
      } else {
        gotOptions.json = body;
      }
    }
    const socketTimeout = configuration.get(`httpTimeout`);
    const retry = configuration.get(`httpRetry`);
    const rejectUnauthorized = configuration.get(`enableStrictSsl`);
    const caFilePath = networkConfig.caFilePath;
    const {default: got} = await Promise.resolve().then(() => __toModule(require_source6()));
    const certificateAuthority = caFilePath ? await getCachedCertificate(caFilePath) : void 0;
    const gotClient = got.extend({
      timeout: {
        socket: socketTimeout
      },
      retry,
      https: {
        rejectUnauthorized,
        certificateAuthority
      },
      ...gotOptions
    });
    return configuration.getLimit(`networkConcurrency`)(() => {
      return gotClient(target);
    });
  }
  async function get(target, {configuration, jsonResponse, ...rest}) {
    let entry = cache.get(target);
    if (!entry) {
      entry = request(target, null, {configuration, ...rest}).then((response) => {
        cache.set(target, response.body);
        return response.body;
      });
      cache.set(target, entry);
    }
    if (Buffer.isBuffer(entry) === false)
      entry = await entry;
    if (jsonResponse) {
      return JSON.parse(entry.toString());
    } else {
      return entry;
    }
  }
  async function put(target, body, options) {
    const response = await request(target, body, {...options, method: Method.PUT});
    return response.body;
  }
  async function post(target, body, options) {
    const response = await request(target, body, {...options, method: Method.POST});
    return response.body;
  }
  async function del(target, options) {
    const response = await request(target, null, {...options, method: Method.DELETE});
    return response.body;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\index.ts
  var miscUtils10 = __toModule(require_miscUtils());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\scriptUtils.ts
  var scriptUtils_exports = {};
  __export(scriptUtils_exports, {
    executePackageAccessibleBinary: () => executePackageAccessibleBinary,
    executePackageScript: () => executePackageScript,
    executePackageShellcode: () => executePackageShellcode,
    executeWorkspaceAccessibleBinary: () => executeWorkspaceAccessibleBinary,
    executeWorkspaceLifecycleScript: () => executeWorkspaceLifecycleScript,
    executeWorkspaceScript: () => executeWorkspaceScript,
    getPackageAccessibleBinaries: () => getPackageAccessibleBinaries,
    getWorkspaceAccessibleBinaries: () => getWorkspaceAccessibleBinaries,
    hasPackageScript: () => hasPackageScript,
    hasWorkspaceScript: () => hasWorkspaceScript,
    makeScriptEnv: () => makeScriptEnv,
    maybeExecuteWorkspaceLifecycleScript: () => maybeExecuteWorkspaceLifecycleScript,
    prepareExternalProject: () => prepareExternalProject
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-libzip\sources\sync.ts
  var sync_exports = {};
  __export(sync_exports, {
    getLibzipPromise: () => getLibzipPromise,
    getLibzipSync: () => getLibzipSync
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-libzip\sources\makeInterface.ts
  var number64 = [
    `number`,
    `number`
  ];
  var Errors;
  (function(Errors2) {
    Errors2[Errors2["ZIP_ER_OK"] = 0] = "ZIP_ER_OK";
    Errors2[Errors2["ZIP_ER_MULTIDISK"] = 1] = "ZIP_ER_MULTIDISK";
    Errors2[Errors2["ZIP_ER_RENAME"] = 2] = "ZIP_ER_RENAME";
    Errors2[Errors2["ZIP_ER_CLOSE"] = 3] = "ZIP_ER_CLOSE";
    Errors2[Errors2["ZIP_ER_SEEK"] = 4] = "ZIP_ER_SEEK";
    Errors2[Errors2["ZIP_ER_READ"] = 5] = "ZIP_ER_READ";
    Errors2[Errors2["ZIP_ER_WRITE"] = 6] = "ZIP_ER_WRITE";
    Errors2[Errors2["ZIP_ER_CRC"] = 7] = "ZIP_ER_CRC";
    Errors2[Errors2["ZIP_ER_ZIPCLOSED"] = 8] = "ZIP_ER_ZIPCLOSED";
    Errors2[Errors2["ZIP_ER_NOENT"] = 9] = "ZIP_ER_NOENT";
    Errors2[Errors2["ZIP_ER_EXISTS"] = 10] = "ZIP_ER_EXISTS";
    Errors2[Errors2["ZIP_ER_OPEN"] = 11] = "ZIP_ER_OPEN";
    Errors2[Errors2["ZIP_ER_TMPOPEN"] = 12] = "ZIP_ER_TMPOPEN";
    Errors2[Errors2["ZIP_ER_ZLIB"] = 13] = "ZIP_ER_ZLIB";
    Errors2[Errors2["ZIP_ER_MEMORY"] = 14] = "ZIP_ER_MEMORY";
    Errors2[Errors2["ZIP_ER_CHANGED"] = 15] = "ZIP_ER_CHANGED";
    Errors2[Errors2["ZIP_ER_COMPNOTSUPP"] = 16] = "ZIP_ER_COMPNOTSUPP";
    Errors2[Errors2["ZIP_ER_EOF"] = 17] = "ZIP_ER_EOF";
    Errors2[Errors2["ZIP_ER_INVAL"] = 18] = "ZIP_ER_INVAL";
    Errors2[Errors2["ZIP_ER_NOZIP"] = 19] = "ZIP_ER_NOZIP";
    Errors2[Errors2["ZIP_ER_INTERNAL"] = 20] = "ZIP_ER_INTERNAL";
    Errors2[Errors2["ZIP_ER_INCONS"] = 21] = "ZIP_ER_INCONS";
    Errors2[Errors2["ZIP_ER_REMOVE"] = 22] = "ZIP_ER_REMOVE";
    Errors2[Errors2["ZIP_ER_DELETED"] = 23] = "ZIP_ER_DELETED";
    Errors2[Errors2["ZIP_ER_ENCRNOTSUPP"] = 24] = "ZIP_ER_ENCRNOTSUPP";
    Errors2[Errors2["ZIP_ER_RDONLY"] = 25] = "ZIP_ER_RDONLY";
    Errors2[Errors2["ZIP_ER_NOPASSWD"] = 26] = "ZIP_ER_NOPASSWD";
    Errors2[Errors2["ZIP_ER_WRONGPASSWD"] = 27] = "ZIP_ER_WRONGPASSWD";
    Errors2[Errors2["ZIP_ER_OPNOTSUPP"] = 28] = "ZIP_ER_OPNOTSUPP";
    Errors2[Errors2["ZIP_ER_INUSE"] = 29] = "ZIP_ER_INUSE";
    Errors2[Errors2["ZIP_ER_TELL"] = 30] = "ZIP_ER_TELL";
    Errors2[Errors2["ZIP_ER_COMPRESSED_DATA"] = 31] = "ZIP_ER_COMPRESSED_DATA";
  })(Errors || (Errors = {}));
  var makeInterface = (libzip) => ({
    get HEAP8() {
      return libzip.HEAP8;
    },
    get HEAPU8() {
      return libzip.HEAPU8;
    },
    errors: Errors,
    SEEK_SET: 0,
    SEEK_CUR: 1,
    SEEK_END: 2,
    ZIP_CHECKCONS: 4,
    ZIP_CREATE: 1,
    ZIP_EXCL: 2,
    ZIP_TRUNCATE: 8,
    ZIP_RDONLY: 16,
    ZIP_FL_OVERWRITE: 8192,
    ZIP_FL_COMPRESSED: 4,
    ZIP_OPSYS_DOS: 0,
    ZIP_OPSYS_AMIGA: 1,
    ZIP_OPSYS_OPENVMS: 2,
    ZIP_OPSYS_UNIX: 3,
    ZIP_OPSYS_VM_CMS: 4,
    ZIP_OPSYS_ATARI_ST: 5,
    ZIP_OPSYS_OS_2: 6,
    ZIP_OPSYS_MACINTOSH: 7,
    ZIP_OPSYS_Z_SYSTEM: 8,
    ZIP_OPSYS_CPM: 9,
    ZIP_OPSYS_WINDOWS_NTFS: 10,
    ZIP_OPSYS_MVS: 11,
    ZIP_OPSYS_VSE: 12,
    ZIP_OPSYS_ACORN_RISC: 13,
    ZIP_OPSYS_VFAT: 14,
    ZIP_OPSYS_ALTERNATE_MVS: 15,
    ZIP_OPSYS_BEOS: 16,
    ZIP_OPSYS_TANDEM: 17,
    ZIP_OPSYS_OS_400: 18,
    ZIP_OPSYS_OS_X: 19,
    ZIP_CM_DEFAULT: -1,
    ZIP_CM_STORE: 0,
    ZIP_CM_DEFLATE: 8,
    uint08S: libzip._malloc(1),
    uint16S: libzip._malloc(2),
    uint32S: libzip._malloc(4),
    uint64S: libzip._malloc(8),
    malloc: libzip._malloc,
    free: libzip._free,
    getValue: libzip.getValue,
    open: libzip.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
    openFromSource: libzip.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
    close: libzip.cwrap(`zip_close`, `number`, [`number`]),
    discard: libzip.cwrap(`zip_discard`, null, [`number`]),
    getError: libzip.cwrap(`zip_get_error`, `number`, [`number`]),
    getName: libzip.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
    getNumEntries: libzip.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
    delete: libzip.cwrap(`zip_delete`, `number`, [`number`, `number`]),
    stat: libzip.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
    statIndex: libzip.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
    fopen: libzip.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
    fopenIndex: libzip.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
    fread: libzip.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
    fclose: libzip.cwrap(`zip_fclose`, `number`, [`number`]),
    dir: {
      add: libzip.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
    },
    file: {
      add: libzip.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
      getError: libzip.cwrap(`zip_file_get_error`, `number`, [`number`]),
      getExternalAttributes: libzip.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
      setExternalAttributes: libzip.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
      setMtime: libzip.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`]),
      setCompression: libzip.cwrap(`zip_set_file_compression`, `number`, [`number`, ...number64, `number`, `number`])
    },
    ext: {
      countSymlinks: libzip.cwrap(`zip_ext_count_symlinks`, `number`, [`number`])
    },
    error: {
      initWithCode: libzip.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
      strerror: libzip.cwrap(`zip_error_strerror`, `string`, [`number`])
    },
    name: {
      locate: libzip.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
    },
    source: {
      fromUnattachedBuffer: libzip.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
      fromBuffer: libzip.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
      free: libzip.cwrap(`zip_source_free`, null, [`number`]),
      keep: libzip.cwrap(`zip_source_keep`, null, [`number`]),
      open: libzip.cwrap(`zip_source_open`, `number`, [`number`]),
      close: libzip.cwrap(`zip_source_close`, `number`, [`number`]),
      seek: libzip.cwrap(`zip_source_seek`, `number`, [`number`, ...number64, `number`]),
      tell: libzip.cwrap(`zip_source_tell`, `number`, [`number`]),
      read: libzip.cwrap(`zip_source_read`, `number`, [`number`, `number`, `number`]),
      error: libzip.cwrap(`zip_source_error`, `number`, [`number`]),
      setMtime: libzip.cwrap(`zip_source_set_mtime`, `number`, [`number`, `number`])
    },
    struct: {
      stat: libzip.cwrap(`zipstruct_stat`, `number`, []),
      statS: libzip.cwrap(`zipstruct_statS`, `number`, []),
      statName: libzip.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
      statIndex: libzip.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
      statSize: libzip.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
      statCompSize: libzip.cwrap(`zipstruct_stat_comp_size`, `number`, [`number`]),
      statCompMethod: libzip.cwrap(`zipstruct_stat_comp_method`, `number`, [`number`]),
      statMtime: libzip.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
      error: libzip.cwrap(`zipstruct_error`, `number`, []),
      errorS: libzip.cwrap(`zipstruct_errorS`, `number`, []),
      errorCodeZip: libzip.cwrap(`zipstruct_error_code_zip`, `number`, [`number`])
    }
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-libzip\sources\sync.ts
  var mod = null;
  function getLibzipSync() {
    if (mod === null)
      mod = makeInterface(require_libzipSync());
    return mod;
  }
  async function getLibzipPromise() {
    return getLibzipSync();
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\index.ts
  var sources_exports3 = {};
  __export(sources_exports3, {
    ShellError: () => ShellError,
    execute: () => execute2,
    globUtils: () => globUtils_exports
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\index.ts
  var sources_exports2 = {};
  __export(sources_exports2, {
    parseResolution: () => parseResolution,
    parseShell: () => parseShell,
    parseSyml: () => parseSyml,
    stringifyResolution: () => stringifyResolution,
    stringifySyml: () => stringifySyml
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\shell.ts
  var import_shell = __toModule(require_shell());
  function parseShell(source, options = {isGlobPattern: () => false}) {
    try {
      return import_shell.parse(source, options);
    } catch (error) {
      if (error.location)
        error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
      throw error;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\resolution.ts
  var import_resolution = __toModule(require_resolution());
  function parseResolution(source) {
    const legacyResolution = source.match(/^\*{1,2}\/(.*)/);
    if (legacyResolution)
      throw new Error(`The override for '${source}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${legacyResolution[1]}' instead.`);
    try {
      return import_resolution.parse(source);
    } catch (error) {
      if (error.location)
        error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
      throw error;
    }
  }
  function stringifyResolution(resolution) {
    let str = ``;
    if (resolution.from) {
      str += resolution.from.fullName;
      if (resolution.from.description)
        str += `@${resolution.from.description}`;
      str += `/`;
    }
    str += resolution.descriptor.fullName;
    if (resolution.descriptor.description)
      str += `@${resolution.descriptor.description}`;
    return str;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-parsers\sources\syml.ts
  var import_js_yaml = __toModule(require_js_yaml2());
  var import_syml = __toModule(require_syml());
  var simpleStringPattern = /^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/;
  var specialObjectKeys = [`__metadata`, `version`, `resolution`, `dependencies`, `peerDependencies`, `dependenciesMeta`, `peerDependenciesMeta`, `binaries`];
  var PreserveOrdering = class {
    constructor(data) {
      this.data = data;
    }
  };
  function stringifyString(value) {
    if (value.match(simpleStringPattern)) {
      return value;
    } else {
      return JSON.stringify(value);
    }
  }
  function isRemovableField(value) {
    if (typeof value === `undefined`)
      return true;
    if (typeof value === `object` && value !== null)
      return Object.keys(value).every((key) => isRemovableField(value[key]));
    return false;
  }
  function stringifyValue(value, indentLevel, newLineIfObject) {
    if (value === null)
      return `null
`;
    if (typeof value === `number` || typeof value === `boolean`)
      return `${value.toString()}
`;
    if (typeof value === `string`)
      return `${stringifyString(value)}
`;
    if (Array.isArray(value)) {
      if (value.length === 0)
        return `[]
`;
      const indent = `  `.repeat(indentLevel);
      const serialized = value.map((sub) => {
        return `${indent}- ${stringifyValue(sub, indentLevel + 1, false)}`;
      }).join(``);
      return `
${serialized}`;
    }
    if (typeof value === `object` && value) {
      let data;
      let sort;
      if (value instanceof PreserveOrdering) {
        data = value.data;
        sort = false;
      } else {
        data = value;
        sort = true;
      }
      const indent = `  `.repeat(indentLevel);
      const keys = Object.keys(data);
      if (sort) {
        keys.sort((a, b) => {
          const aIndex = specialObjectKeys.indexOf(a);
          const bIndex = specialObjectKeys.indexOf(b);
          if (aIndex === -1 && bIndex === -1)
            return a < b ? -1 : a > b ? 1 : 0;
          if (aIndex !== -1 && bIndex === -1)
            return -1;
          if (aIndex === -1 && bIndex !== -1)
            return 1;
          return aIndex - bIndex;
        });
      }
      const fields = keys.filter((key) => {
        return !isRemovableField(data[key]);
      }).map((key, index) => {
        const value2 = data[key];
        const stringifiedKey = stringifyString(key);
        const stringifiedValue = stringifyValue(value2, indentLevel + 1, true);
        const recordIndentation = index > 0 || newLineIfObject ? indent : ``;
        if (stringifiedValue.startsWith(`
`)) {
          return `${recordIndentation}${stringifiedKey}:${stringifiedValue}`;
        } else {
          return `${recordIndentation}${stringifiedKey}: ${stringifiedValue}`;
        }
      }).join(indentLevel === 0 ? `
` : ``) || `
`;
      if (!newLineIfObject) {
        return `${fields}`;
      } else {
        return `
${fields}`;
      }
    }
    throw new Error(`Unsupported value type (${value})`);
  }
  function stringifySyml(value) {
    try {
      const stringified = stringifyValue(value, 0, false);
      return stringified !== `
` ? stringified : ``;
    } catch (error) {
      if (error.location)
        error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
      throw error;
    }
  }
  stringifySyml.PreserveOrdering = PreserveOrdering;
  function parseViaPeg(source) {
    if (!source.endsWith(`
`))
      source += `
`;
    return import_syml.parse(source);
  }
  var LEGACY_REGEXP = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;
  function parseViaJsYaml(source) {
    if (LEGACY_REGEXP.test(source))
      return parseViaPeg(source);
    const value = import_js_yaml.safeLoad(source, {
      schema: import_js_yaml.FAILSAFE_SCHEMA,
      json: true
    });
    if (value === void 0 || value === null)
      return {};
    if (typeof value !== `object`)
      throw new Error(`Expected an indexed object, got a ${typeof value} instead. Does your file follow Yaml's rules?`);
    if (Array.isArray(value))
      throw new Error(`Expected an indexed object, got an array instead. Does your file follow Yaml's rules?`);
    return value;
  }
  function parseSyml(source) {
    return parseViaJsYaml(source);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\index.ts
  var import_os4 = __toModule(require("os"));
  var import_stream3 = __toModule(require("stream"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\errors.ts
  var ShellError = class extends Error {
    constructor(message) {
      super(message);
      this.name = `ShellError`;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\globUtils.ts
  var globUtils_exports = {};
  __export(globUtils_exports, {
    fastGlobOptions: () => fastGlobOptions,
    isBraceExpansion: () => isBraceExpansion,
    isGlobPattern: () => isGlobPattern,
    match: () => match,
    micromatchOptions: () => micromatchOptions
  });
  var import_fast_glob = __toModule(require_out4());
  var import_fs5 = __toModule(require("fs"));
  var import_micromatch2 = __toModule(require_micromatch());
  var micromatchOptions = {
    strictBrackets: true
  };
  var fastGlobOptions = {
    onlyDirectories: false,
    onlyFiles: false
  };
  function isGlobPattern(pattern) {
    if (!import_micromatch2.default.scan(pattern, micromatchOptions).isGlob)
      return false;
    try {
      import_micromatch2.default.parse(pattern, micromatchOptions);
    } catch {
      return false;
    }
    return true;
  }
  function match(pattern, {cwd, baseFs}) {
    return import_fast_glob.default(pattern, {
      ...fastGlobOptions,
      cwd: npath.fromPortablePath(cwd),
      fs: extendFs(import_fs5.default, new PosixFS(baseFs))
    });
  }
  function isBraceExpansion(pattern) {
    return import_micromatch2.default.scan(pattern, micromatchOptions).isBrace;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\pipe.ts
  var import_cross_spawn2 = __toModule(require_cross_spawn());
  var import_stream2 = __toModule(require("stream"));
  var Pipe;
  (function(Pipe2) {
    Pipe2[Pipe2["STDIN"] = 0] = "STDIN";
    Pipe2[Pipe2["STDOUT"] = 1] = "STDOUT";
    Pipe2[Pipe2["STDERR"] = 2] = "STDERR";
  })(Pipe || (Pipe = {}));
  var activeChildren2 = new Set();
  function sigintHandler2() {
  }
  function sigtermHandler2() {
    for (const child of activeChildren2) {
      child.kill();
    }
  }
  function makeProcess(name, args, opts, spawnOpts) {
    return (stdio) => {
      const stdin = stdio[0] instanceof import_stream2.Transform ? `pipe` : stdio[0];
      const stdout = stdio[1] instanceof import_stream2.Transform ? `pipe` : stdio[1];
      const stderr = stdio[2] instanceof import_stream2.Transform ? `pipe` : stdio[2];
      const child = import_cross_spawn2.default(name, args, {...spawnOpts, stdio: [
        stdin,
        stdout,
        stderr
      ]});
      activeChildren2.add(child);
      if (activeChildren2.size === 1) {
        process.on(`SIGINT`, sigintHandler2);
        process.on(`SIGTERM`, sigtermHandler2);
      }
      if (stdio[0] instanceof import_stream2.Transform)
        stdio[0].pipe(child.stdin);
      if (stdio[1] instanceof import_stream2.Transform)
        child.stdout.pipe(stdio[1], {end: false});
      if (stdio[2] instanceof import_stream2.Transform)
        child.stderr.pipe(stdio[2], {end: false});
      return {
        stdin: child.stdin,
        promise: new Promise((resolve) => {
          child.on(`error`, (error) => {
            activeChildren2.delete(child);
            if (activeChildren2.size === 0) {
              process.off(`SIGINT`, sigintHandler2);
              process.off(`SIGTERM`, sigtermHandler2);
            }
            switch (error.code) {
              case `ENOENT`:
                {
                  stdio[2].write(`command not found: ${name}
`);
                  resolve(127);
                }
                break;
              case `EACCES`:
                {
                  stdio[2].write(`permission denied: ${name}
`);
                  resolve(128);
                }
                break;
              default:
                {
                  stdio[2].write(`uncaught error: ${error.message}
`);
                  resolve(1);
                }
                break;
            }
          });
          child.on(`exit`, (code) => {
            activeChildren2.delete(child);
            if (activeChildren2.size === 0) {
              process.off(`SIGINT`, sigintHandler2);
              process.off(`SIGTERM`, sigtermHandler2);
            }
            if (code !== null) {
              resolve(code);
            } else {
              resolve(129);
            }
          });
        })
      };
    };
  }
  function makeBuiltin(builtin) {
    return (stdio) => {
      const stdin = stdio[0] === `pipe` ? new import_stream2.PassThrough() : stdio[0];
      return {
        stdin,
        promise: Promise.resolve().then(() => builtin({
          stdin,
          stdout: stdio[1],
          stderr: stdio[2]
        }))
      };
    };
  }
  var ProtectedStream = class {
    constructor(stream) {
      this.stream = stream;
    }
    close() {
    }
    get() {
      return this.stream;
    }
  };
  var PipeStream = class {
    constructor() {
      this.stream = null;
    }
    close() {
      if (this.stream === null) {
        throw new Error(`Assertion failed: No stream attached`);
      } else {
        this.stream.end();
      }
    }
    attach(stream) {
      this.stream = stream;
    }
    get() {
      if (this.stream === null) {
        throw new Error(`Assertion failed: No stream attached`);
      } else {
        return this.stream;
      }
    }
  };
  var Handle = class {
    constructor(ancestor, implementation) {
      this.stdin = null;
      this.stdout = null;
      this.stderr = null;
      this.pipe = null;
      this.ancestor = ancestor;
      this.implementation = implementation;
    }
    static start(implementation, {stdin, stdout, stderr}) {
      const chain = new Handle(null, implementation);
      chain.stdin = stdin;
      chain.stdout = stdout;
      chain.stderr = stderr;
      return chain;
    }
    pipeTo(implementation, source = 1) {
      const next = new Handle(this, implementation);
      const pipe = new PipeStream();
      next.pipe = pipe;
      next.stdout = this.stdout;
      next.stderr = this.stderr;
      if ((source & 1) === 1)
        this.stdout = pipe;
      else if (this.ancestor !== null)
        this.stderr = this.ancestor.stdout;
      if ((source & 2) === 2)
        this.stderr = pipe;
      else if (this.ancestor !== null)
        this.stderr = this.ancestor.stderr;
      return next;
    }
    async exec() {
      const stdio = [
        `ignore`,
        `ignore`,
        `ignore`
      ];
      if (this.pipe) {
        stdio[0] = `pipe`;
      } else {
        if (this.stdin === null) {
          throw new Error(`Assertion failed: No input stream registered`);
        } else {
          stdio[0] = this.stdin.get();
        }
      }
      let stdoutLock;
      if (this.stdout === null) {
        throw new Error(`Assertion failed: No output stream registered`);
      } else {
        stdoutLock = this.stdout;
        stdio[1] = stdoutLock.get();
      }
      let stderrLock;
      if (this.stderr === null) {
        throw new Error(`Assertion failed: No error stream registered`);
      } else {
        stderrLock = this.stderr;
        stdio[2] = stderrLock.get();
      }
      const child = this.implementation(stdio);
      if (this.pipe)
        this.pipe.attach(child.stdin);
      return await child.promise.then((code) => {
        stdoutLock.close();
        stderrLock.close();
        return code;
      });
    }
    async run() {
      const promises = [];
      for (let handle = this; handle; handle = handle.ancestor)
        promises.push(handle.exec());
      const exitCodes = await Promise.all(promises);
      return exitCodes[0];
    }
  };
  function start(p, opts) {
    return Handle.start(p, opts);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-shell\sources\index.ts
  var StreamType;
  (function(StreamType2) {
    StreamType2[StreamType2["Readable"] = 1] = "Readable";
    StreamType2[StreamType2["Writable"] = 2] = "Writable";
  })(StreamType || (StreamType = {}));
  function getFileDescriptorStream(fd, type, state) {
    const stream = new import_stream3.PassThrough({autoDestroy: true});
    switch (fd) {
      case Pipe.STDIN:
        {
          if ((type & 1) === 1)
            state.stdin.pipe(stream, {end: false});
          if ((type & 2) === 2 && state.stdin instanceof import_stream3.Writable) {
            stream.pipe(state.stdin, {end: false});
          }
        }
        break;
      case Pipe.STDOUT:
        {
          if ((type & 1) === 1)
            state.stdout.pipe(stream, {end: false});
          if ((type & 2) === 2) {
            stream.pipe(state.stdout, {end: false});
          }
        }
        break;
      case Pipe.STDERR:
        {
          if ((type & 1) === 1)
            state.stderr.pipe(stream, {end: false});
          if ((type & 2) === 2) {
            stream.pipe(state.stderr, {end: false});
          }
        }
        break;
      default: {
        throw new ShellError(`Bad file descriptor: "${fd}"`);
      }
    }
    return stream;
  }
  function cloneState(state, mergeWith = {}) {
    const newState = {...state, ...mergeWith};
    newState.environment = {...state.environment, ...mergeWith.environment};
    newState.variables = {...state.variables, ...mergeWith.variables};
    return newState;
  }
  var BUILTINS = new Map([
    [`cd`, async ([target = import_os4.homedir(), ...rest], opts, state) => {
      const resolvedTarget = ppath.resolve(state.cwd, npath.toPortablePath(target));
      const stat = await opts.baseFs.statPromise(resolvedTarget);
      if (!stat.isDirectory()) {
        state.stderr.write(`cd: not a directory
`);
        return 1;
      } else {
        state.cwd = resolvedTarget;
        return 0;
      }
    }],
    [`pwd`, async (args, opts, state) => {
      state.stdout.write(`${npath.fromPortablePath(state.cwd)}
`);
      return 0;
    }],
    [`:`, async (args, opts, state) => {
      return 0;
    }],
    [`true`, async (args, opts, state) => {
      return 0;
    }],
    [`false`, async (args, opts, state) => {
      return 1;
    }],
    [`exit`, async ([code, ...rest], opts, state) => {
      return state.exitCode = parseInt(code != null ? code : state.variables[`?`], 10);
    }],
    [`echo`, async (args, opts, state) => {
      state.stdout.write(`${args.join(` `)}
`);
      return 0;
    }],
    [`__ysh_run_procedure`, async (args, opts, state) => {
      const procedure = state.procedures[args[0]];
      const exitCode = await start(procedure, {
        stdin: new ProtectedStream(state.stdin),
        stdout: new ProtectedStream(state.stdout),
        stderr: new ProtectedStream(state.stderr)
      }).run();
      return exitCode;
    }],
    [`__ysh_set_redirects`, async (args, opts, state) => {
      let stdin = state.stdin;
      let stdout = state.stdout;
      const stderr = state.stderr;
      const inputs = [];
      const outputs = [];
      let t7 = 0;
      while (args[t7] !== `--`) {
        const type = args[t7++];
        const count = Number(args[t7++]);
        const last = t7 + count;
        for (let u = t7; u < last; ++t7, ++u) {
          switch (type) {
            case `<`:
              {
                inputs.push(() => {
                  return opts.baseFs.createReadStream(ppath.resolve(state.cwd, npath.toPortablePath(args[u])));
                });
              }
              break;
            case `<<<`:
              {
                inputs.push(() => {
                  const input = new import_stream3.PassThrough();
                  process.nextTick(() => {
                    input.write(`${args[u]}
`);
                    input.end();
                  });
                  return input;
                });
              }
              break;
            case `<&`:
              {
                inputs.push(() => getFileDescriptorStream(Number(args[u]), 1, state));
              }
              break;
            case `>`:
            case `>>`:
              {
                const outputPath = ppath.resolve(state.cwd, npath.toPortablePath(args[u]));
                if (outputPath === `/dev/null`) {
                  outputs.push(new import_stream3.Writable({
                    autoDestroy: true,
                    emitClose: true,
                    write(chunk, encoding, callback) {
                      setImmediate(callback);
                    }
                  }));
                } else {
                  outputs.push(opts.baseFs.createWriteStream(outputPath, type === `>>` ? {flags: `a`} : void 0));
                }
              }
              break;
            case `>&`:
              {
                outputs.push(getFileDescriptorStream(Number(args[u]), 2, state));
              }
              break;
            default: {
              throw new Error(`Assertion failed: Unsupported redirection type: "${type}"`);
            }
          }
        }
      }
      if (inputs.length > 0) {
        const pipe = new import_stream3.PassThrough();
        stdin = pipe;
        const bindInput = (n) => {
          if (n === inputs.length) {
            pipe.end();
          } else {
            const input = inputs[n]();
            input.pipe(pipe, {end: false});
            input.on(`end`, () => {
              bindInput(n + 1);
            });
          }
        };
        bindInput(0);
      }
      if (outputs.length > 0) {
        const pipe = new import_stream3.PassThrough();
        stdout = pipe;
        for (const output of outputs) {
          pipe.pipe(output);
        }
      }
      const exitCode = await start(makeCommandAction(args.slice(t7 + 1), opts, state), {
        stdin: new ProtectedStream(stdin),
        stdout: new ProtectedStream(stdout),
        stderr: new ProtectedStream(stderr)
      }).run();
      await Promise.all(outputs.map((output) => {
        return new Promise((resolve) => {
          output.on(`close`, () => {
            resolve();
          });
          output.end();
        });
      }));
      return exitCode;
    }]
  ]);
  async function executeBufferedSubshell(ast, opts, state) {
    const chunks = [];
    const stdout = new import_stream3.PassThrough();
    stdout.on(`data`, (chunk) => chunks.push(chunk));
    await executeShellLine(ast, opts, cloneState(state, {stdout}));
    return Buffer.concat(chunks).toString().replace(/[\r\n]+$/, ``);
  }
  async function applyEnvVariables(environmentSegments, opts, state) {
    const envPromises = environmentSegments.map(async (envSegment) => {
      const interpolatedArgs = await interpolateArguments(envSegment.args, opts, state);
      return {
        name: envSegment.name,
        value: interpolatedArgs.join(` `)
      };
    });
    const interpolatedEnvs = await Promise.all(envPromises);
    return interpolatedEnvs.reduce((envs, env) => {
      envs[env.name] = env.value;
      return envs;
    }, {});
  }
  function split(raw) {
    return raw.match(/[^ \r\n\t]+/g) || [];
  }
  async function evaluateVariable(segment, opts, state, push, pushAndClose = push) {
    switch (segment.name) {
      case `$`:
        {
          push(String(process.pid));
        }
        break;
      case `#`:
        {
          push(String(opts.args.length));
        }
        break;
      case `@`:
        {
          if (segment.quoted) {
            for (const raw of opts.args) {
              pushAndClose(raw);
            }
          } else {
            for (const raw of opts.args) {
              const parts = split(raw);
              for (let t7 = 0; t7 < parts.length - 1; ++t7)
                pushAndClose(parts[t7]);
              push(parts[parts.length - 1]);
            }
          }
        }
        break;
      case `*`:
        {
          const raw = opts.args.join(` `);
          if (segment.quoted) {
            push(raw);
          } else {
            for (const part of split(raw)) {
              pushAndClose(part);
            }
          }
        }
        break;
      case `PPID`:
        {
          push(String(process.ppid));
        }
        break;
      case `RANDOM`:
        {
          push(String(Math.floor(Math.random() * 32768)));
        }
        break;
      default:
        {
          const argIndex = parseInt(segment.name, 10);
          if (Number.isFinite(argIndex)) {
            if (argIndex >= 0 && argIndex < opts.args.length) {
              push(opts.args[argIndex]);
            } else if (segment.defaultValue) {
              push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
            } else {
              throw new ShellError(`Unbound argument #${argIndex}`);
            }
          } else {
            if (Object.prototype.hasOwnProperty.call(state.variables, segment.name)) {
              push(state.variables[segment.name]);
            } else if (Object.prototype.hasOwnProperty.call(state.environment, segment.name)) {
              push(state.environment[segment.name]);
            } else if (segment.defaultValue) {
              push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
            } else {
              throw new ShellError(`Unbound variable "${segment.name}"`);
            }
          }
        }
        break;
    }
  }
  var operators = {
    addition: (left, right) => left + right,
    subtraction: (left, right) => left - right,
    multiplication: (left, right) => left * right,
    division: (left, right) => Math.trunc(left / right)
  };
  async function evaluateArithmetic(arithmetic, opts, state) {
    if (arithmetic.type === `number`) {
      if (!Number.isInteger(arithmetic.value)) {
        throw new Error(`Invalid number: "${arithmetic.value}", only integers are allowed`);
      } else {
        return arithmetic.value;
      }
    } else if (arithmetic.type === `variable`) {
      const parts = [];
      await evaluateVariable({...arithmetic, quoted: true}, opts, state, (result) => parts.push(result));
      const number = Number(parts.join(` `));
      if (Number.isNaN(number)) {
        return evaluateArithmetic({type: `variable`, name: parts.join(` `)}, opts, state);
      } else {
        return evaluateArithmetic({type: `number`, value: number}, opts, state);
      }
    } else {
      return operators[arithmetic.type](await evaluateArithmetic(arithmetic.left, opts, state), await evaluateArithmetic(arithmetic.right, opts, state));
    }
  }
  async function interpolateArguments(commandArgs, opts, state) {
    const redirections = new Map();
    const interpolated = [];
    let interpolatedSegments = [];
    const push = (segment) => {
      interpolatedSegments.push(segment);
    };
    const close = () => {
      if (interpolatedSegments.length > 0)
        interpolated.push(interpolatedSegments.join(``));
      interpolatedSegments = [];
    };
    const pushAndClose = (segment) => {
      push(segment);
      close();
    };
    const redirect = (type, target) => {
      let targets = redirections.get(type);
      if (typeof targets === `undefined`)
        redirections.set(type, targets = []);
      targets.push(target);
    };
    for (const commandArg of commandArgs) {
      let isGlob = false;
      switch (commandArg.type) {
        case `redirection`:
          {
            const interpolatedArgs = await interpolateArguments(commandArg.args, opts, state);
            for (const interpolatedArg of interpolatedArgs) {
              redirect(commandArg.subtype, interpolatedArg);
            }
          }
          break;
        case `argument`:
          {
            for (const segment of commandArg.segments) {
              switch (segment.type) {
                case `text`:
                  {
                    push(segment.text);
                  }
                  break;
                case `glob`:
                  {
                    push(segment.pattern);
                    isGlob = true;
                  }
                  break;
                case `shell`:
                  {
                    const raw = await executeBufferedSubshell(segment.shell, opts, state);
                    if (segment.quoted) {
                      push(raw);
                    } else {
                      const parts = split(raw);
                      for (let t7 = 0; t7 < parts.length - 1; ++t7)
                        pushAndClose(parts[t7]);
                      push(parts[parts.length - 1]);
                    }
                  }
                  break;
                case `variable`:
                  {
                    await evaluateVariable(segment, opts, state, push, pushAndClose);
                  }
                  break;
                case `arithmetic`:
                  {
                    push(String(await evaluateArithmetic(segment.arithmetic, opts, state)));
                  }
                  break;
              }
            }
          }
          break;
      }
      close();
      if (isGlob) {
        const pattern = interpolated.pop();
        if (typeof pattern === `undefined`)
          throw new Error(`Assertion failed: Expected a glob pattern to have been set`);
        const matches = await opts.glob.match(pattern, {cwd: state.cwd, baseFs: opts.baseFs});
        if (matches.length === 0) {
          const braceExpansionNotice = isBraceExpansion(pattern) ? `. Note: Brace expansion of arbitrary strings isn't currently supported. For more details, please read this issue: https://github.com/yarnpkg/berry/issues/22` : ``;
          throw new ShellError(`No matches found: "${pattern}"${braceExpansionNotice}`);
        }
        for (const match2 of matches.sort()) {
          pushAndClose(match2);
        }
      }
    }
    if (redirections.size > 0) {
      const redirectionArgs = [];
      for (const [subtype, targets] of redirections.entries())
        redirectionArgs.splice(redirectionArgs.length, 0, subtype, String(targets.length), ...targets);
      interpolated.splice(0, 0, `__ysh_set_redirects`, ...redirectionArgs, `--`);
    }
    return interpolated;
  }
  function makeCommandAction(args, opts, state) {
    if (!opts.builtins.has(args[0]))
      args = [`command`, ...args];
    const nativeCwd = npath.fromPortablePath(state.cwd);
    let env = state.environment;
    if (typeof env.PWD !== `undefined`)
      env = {...env, PWD: nativeCwd};
    const [name, ...rest] = args;
    if (name === `command`) {
      return makeProcess(rest[0], rest.slice(1), opts, {
        cwd: nativeCwd,
        env
      });
    }
    const builtin = opts.builtins.get(name);
    if (typeof builtin === `undefined`)
      throw new Error(`Assertion failed: A builtin should exist for "${name}"`);
    return makeBuiltin(async ({stdin, stdout, stderr}) => {
      state.stdin = stdin;
      state.stdout = stdout;
      state.stderr = stderr;
      return await builtin(rest, opts, state);
    });
  }
  function makeSubshellAction(ast, opts, state) {
    return (stdio) => {
      const stdin = new import_stream3.PassThrough();
      const promise = executeShellLine(ast, opts, cloneState(state, {stdin}));
      return {stdin, promise};
    };
  }
  function makeGroupAction(ast, opts, state) {
    return (stdio) => {
      const stdin = new import_stream3.PassThrough();
      const promise = executeShellLine(ast, opts, state);
      return {stdin, promise};
    };
  }
  function makeActionFromProcedure(procedure, args, opts, activeState) {
    if (args.length === 0) {
      return procedure;
    } else {
      let key;
      do {
        key = String(Math.random());
      } while (Object.prototype.hasOwnProperty.call(activeState.procedures, key));
      activeState.procedures = {...activeState.procedures};
      activeState.procedures[key] = procedure;
      return makeCommandAction([...args, `__ysh_run_procedure`, key], opts, activeState);
    }
  }
  async function executeCommandChain(node, opts, state) {
    let current = node;
    let pipeType = null;
    let execution = null;
    while (current) {
      const activeState = current.then ? {...state} : state;
      let action;
      switch (current.type) {
        case `command`:
          {
            const args = await interpolateArguments(current.args, opts, state);
            const environment = await applyEnvVariables(current.envs, opts, state);
            action = current.envs.length ? makeCommandAction(args, opts, cloneState(activeState, {environment})) : makeCommandAction(args, opts, activeState);
          }
          break;
        case `subshell`:
          {
            const args = await interpolateArguments(current.args, opts, state);
            const procedure = makeSubshellAction(current.subshell, opts, activeState);
            action = makeActionFromProcedure(procedure, args, opts, activeState);
          }
          break;
        case `group`:
          {
            const args = await interpolateArguments(current.args, opts, state);
            const procedure = makeGroupAction(current.group, opts, activeState);
            action = makeActionFromProcedure(procedure, args, opts, activeState);
          }
          break;
        case `envs`:
          {
            const environment = await applyEnvVariables(current.envs, opts, state);
            activeState.environment = {...activeState.environment, ...environment};
            action = makeCommandAction([`true`], opts, activeState);
          }
          break;
      }
      if (typeof action === `undefined`)
        throw new Error(`Assertion failed: An action should have been generated`);
      if (pipeType === null) {
        execution = start(action, {
          stdin: new ProtectedStream(activeState.stdin),
          stdout: new ProtectedStream(activeState.stdout),
          stderr: new ProtectedStream(activeState.stderr)
        });
      } else {
        if (execution === null)
          throw new Error(`Assertion failed: The execution pipeline should have been setup`);
        switch (pipeType) {
          case `|`:
            {
              execution = execution.pipeTo(action, Pipe.STDOUT);
            }
            break;
          case `|&`:
            {
              execution = execution.pipeTo(action, Pipe.STDOUT | Pipe.STDERR);
            }
            break;
        }
      }
      if (current.then) {
        pipeType = current.then.type;
        current = current.then.chain;
      } else {
        current = null;
      }
    }
    if (execution === null)
      throw new Error(`Assertion failed: The execution pipeline should have been setup`);
    return await execution.run();
  }
  async function executeCommandLine(node, opts, state) {
    let code;
    const setCode = (newCode) => {
      code = newCode;
      state.variables[`?`] = String(newCode);
    };
    const executeChain = async (chain) => {
      try {
        return await executeCommandChain(chain, opts, state);
      } catch (error) {
        if (!(error instanceof ShellError))
          throw error;
        state.stderr.write(`${error.message}
`);
        return 1;
      }
    };
    setCode(await executeChain(node.chain));
    while (node.then) {
      if (state.exitCode !== null)
        return state.exitCode;
      switch (node.then.type) {
        case `&&`:
          {
            if (code === 0) {
              setCode(await executeChain(node.then.line.chain));
            }
          }
          break;
        case `||`:
          {
            if (code !== 0) {
              setCode(await executeChain(node.then.line.chain));
            }
          }
          break;
        default:
          {
            throw new Error(`Assertion failed: Unsupported command type: "${node.then.type}"`);
          }
          break;
      }
      node = node.then.line;
    }
    return code;
  }
  async function executeShellLine(node, opts, state) {
    let rightMostExitCode = 0;
    for (const command of node) {
      rightMostExitCode = await executeCommandLine(command, opts, state);
      if (state.exitCode !== null)
        return state.exitCode;
      state.variables[`?`] = String(rightMostExitCode);
    }
    return rightMostExitCode;
  }
  function locateArgsVariableInSegment(segment) {
    switch (segment.type) {
      case `variable`:
        {
          return segment.name === `@` || segment.name === `#` || segment.name === `*` || Number.isFinite(parseInt(segment.name, 10)) || `defaultValue` in segment && !!segment.defaultValue && segment.defaultValue.some((arg) => locateArgsVariableInArgument(arg));
        }
        break;
      case `arithmetic`:
        {
          return locateArgsVariableInArithmetic(segment.arithmetic);
        }
        break;
      case `shell`:
        {
          return locateArgsVariable(segment.shell);
        }
        break;
      default:
        {
          return false;
        }
        break;
    }
  }
  function locateArgsVariableInArgument(arg) {
    switch (arg.type) {
      case `redirection`:
        {
          return arg.args.some((arg2) => locateArgsVariableInArgument(arg2));
        }
        break;
      case `argument`:
        {
          return arg.segments.some((segment) => locateArgsVariableInSegment(segment));
        }
        break;
      default:
        throw new Error(`Assertion failed: Unsupported argument type: "${arg.type}"`);
    }
  }
  function locateArgsVariableInArithmetic(arg) {
    switch (arg.type) {
      case `variable`:
        {
          return locateArgsVariableInSegment(arg);
        }
        break;
      case `number`:
        {
          return false;
        }
        break;
      default:
        return locateArgsVariableInArithmetic(arg.left) || locateArgsVariableInArithmetic(arg.right);
    }
  }
  function locateArgsVariable(node) {
    return node.some((command) => {
      while (command) {
        let chain = command.chain;
        while (chain) {
          let hasArgs;
          switch (chain.type) {
            case `subshell`:
              {
                hasArgs = locateArgsVariable(chain.subshell);
              }
              break;
            case `command`:
              {
                hasArgs = chain.envs.some((env) => env.args.some((arg) => {
                  return locateArgsVariableInArgument(arg);
                })) || chain.args.some((arg) => {
                  return locateArgsVariableInArgument(arg);
                });
              }
              break;
          }
          if (hasArgs)
            return true;
          if (!chain.then)
            break;
          chain = chain.then.chain;
        }
        if (!command.then)
          break;
        command = command.then.line;
      }
      return false;
    });
  }
  async function execute2(command, args = [], {
    baseFs = new NodeFS(),
    builtins = {},
    cwd = npath.toPortablePath(process.cwd()),
    env = process.env,
    stdin = process.stdin,
    stdout = process.stdout,
    stderr = process.stderr,
    variables = {},
    glob = globUtils_exports
  } = {}) {
    const normalizedEnv = {};
    for (const [key, value] of Object.entries(env))
      if (typeof value !== `undefined`)
        normalizedEnv[key] = value;
    const normalizedBuiltins = new Map(BUILTINS);
    for (const [key, builtin] of Object.entries(builtins))
      normalizedBuiltins.set(key, builtin);
    if (stdin === null) {
      stdin = new import_stream3.PassThrough();
      stdin.end();
    }
    const ast = parseShell(command, glob);
    if (!locateArgsVariable(ast) && ast.length > 0 && args.length > 0) {
      let command2 = ast[ast.length - 1];
      while (command2.then)
        command2 = command2.then.line;
      let chain = command2.chain;
      while (chain.then)
        chain = chain.then.chain;
      if (chain.type === `command`) {
        chain.args = chain.args.concat(args.map((arg) => {
          return {
            type: `argument`,
            segments: [{
              type: `text`,
              text: arg
            }]
          };
        }));
      }
    }
    return await executeShellLine(ast, {
      args,
      baseFs,
      builtins: normalizedBuiltins,
      initialStdin: stdin,
      initialStdout: stdout,
      initialStderr: stderr,
      glob
    }, {
      cwd,
      environment: normalizedEnv,
      exitCode: null,
      procedures: {},
      stdin,
      stdout,
      stderr,
      variables: Object.assign({}, variables, {
        [`?`]: 0
      })
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\scriptUtils.ts
  var import_capitalize = __toModule(require_capitalize());
  var import_p_limit = __toModule(require_p_limit());
  var import_stream5 = __toModule(require("stream"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Manifest.ts
  var import_semver4 = __toModule(require_semver2());
  var miscUtils3 = __toModule(require_miscUtils());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\semverUtils.ts
  var semverUtils_exports = {};
  __export(semverUtils_exports, {
    SemVer: () => import_semver3.SemVer,
    satisfiesWithPrereleases: () => satisfiesWithPrereleases,
    validRange: () => validRange
  });
  var import_semver2 = __toModule(require_semver2());
  var import_semver3 = __toModule(require_semver2());
  function satisfiesWithPrereleases(version, range, loose = false) {
    let semverRange;
    try {
      semverRange = new import_semver2.default.Range(range, {includePrerelease: true, loose});
    } catch (err) {
      return false;
    }
    if (!version)
      return false;
    let semverVersion;
    try {
      semverVersion = new import_semver2.default.SemVer(version, semverRange);
      if (semverVersion.prerelease) {
        semverVersion.prerelease = [];
      }
    } catch (err) {
      return false;
    }
    return semverRange.set.some((comparatorSet) => {
      for (const comparator of comparatorSet)
        if (comparator.semver.prerelease)
          comparator.semver.prerelease = [];
      return comparatorSet.every((comparator) => {
        return comparator.test(semverVersion);
      });
    });
  }
  var rangesCache = new Map();
  function validRange(potentialRange) {
    if (potentialRange.indexOf(`:`) !== -1)
      return null;
    let range = rangesCache.get(potentialRange);
    if (typeof range !== `undefined`)
      return range;
    try {
      range = new import_semver2.default.Range(potentialRange);
    } catch {
      range = null;
    }
    rangesCache.set(potentialRange, range);
    return range;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Manifest.ts
  var _a;
  var Manifest2 = class {
    constructor() {
      this.indent = `  `;
      this.name = null;
      this.version = null;
      this.os = null;
      this.cpu = null;
      this.type = null;
      this[_a] = false;
      this.license = null;
      this.main = null;
      this.module = null;
      this.browser = null;
      this.languageName = null;
      this.bin = new Map();
      this.scripts = new Map();
      this.dependencies = new Map();
      this.devDependencies = new Map();
      this.peerDependencies = new Map();
      this.workspaceDefinitions = [];
      this.dependenciesMeta = new Map();
      this.peerDependenciesMeta = new Map();
      this.resolutions = [];
      this.files = null;
      this.publishConfig = null;
      this.installConfig = null;
      this.preferUnplugged = null;
      this.raw = {};
      this.errors = [];
    }
    static async tryFind(path6, {baseFs = new NodeFS()} = {}) {
      const manifestPath = ppath.join(path6, `package.json`);
      if (!await baseFs.existsPromise(manifestPath))
        return null;
      return await Manifest2.fromFile(manifestPath, {baseFs});
    }
    static async find(path6, {baseFs} = {}) {
      const manifest = await Manifest2.tryFind(path6, {baseFs});
      if (manifest === null)
        throw new Error(`Manifest not found`);
      return manifest;
    }
    static async fromFile(path6, {baseFs = new NodeFS()} = {}) {
      const manifest = new Manifest2();
      await manifest.loadFile(path6, {baseFs});
      return manifest;
    }
    static fromText(text) {
      const manifest = new Manifest2();
      manifest.loadFromText(text);
      return manifest;
    }
    static isManifestFieldCompatible(rules, actual) {
      if (rules === null)
        return true;
      let isNotOnAllowlist = true;
      let isOnDenylist = false;
      for (const rule of rules) {
        if (rule[0] === `!`) {
          isOnDenylist = true;
          if (actual === rule.slice(1)) {
            return false;
          }
        } else {
          isNotOnAllowlist = false;
          if (rule === actual) {
            return true;
          }
        }
      }
      return isOnDenylist && isNotOnAllowlist;
    }
    loadFromText(text) {
      let data;
      try {
        data = JSON.parse(stripBOM(text) || `{}`);
      } catch (error) {
        error.message += ` (when parsing ${text})`;
        throw error;
      }
      this.load(data);
      this.indent = getIndent(text);
    }
    async loadFile(path6, {baseFs = new NodeFS()}) {
      const content = await baseFs.readFilePromise(path6, `utf8`);
      let data;
      try {
        data = JSON.parse(stripBOM(content) || `{}`);
      } catch (error) {
        error.message += ` (when parsing ${path6})`;
        throw error;
      }
      this.load(data);
      this.indent = getIndent(content);
    }
    load(data, {yamlCompatibilityMode = false} = {}) {
      if (typeof data !== `object` || data === null)
        throw new Error(`Utterly invalid manifest data (${data})`);
      this.raw = data;
      const errors4 = [];
      this.name = null;
      if (typeof data.name === `string`) {
        try {
          this.name = parseIdent(data.name);
        } catch (error) {
          errors4.push(new Error(`Parsing failed for the 'name' field`));
        }
      }
      if (typeof data.version === `string`)
        this.version = data.version;
      else
        this.version = null;
      if (Array.isArray(data.os)) {
        const os2 = [];
        this.os = os2;
        for (const item of data.os) {
          if (typeof item !== `string`) {
            errors4.push(new Error(`Parsing failed for the 'os' field`));
          } else {
            os2.push(item);
          }
        }
      } else {
        this.os = null;
      }
      if (Array.isArray(data.cpu)) {
        const cpu = [];
        this.cpu = cpu;
        for (const item of data.cpu) {
          if (typeof item !== `string`) {
            errors4.push(new Error(`Parsing failed for the 'cpu' field`));
          } else {
            cpu.push(item);
          }
        }
      } else {
        this.cpu = null;
      }
      if (typeof data.type === `string`)
        this.type = data.type;
      else
        this.type = null;
      if (typeof data.private === `boolean`)
        this.private = data.private;
      else
        this.private = false;
      if (typeof data.license === `string`)
        this.license = data.license;
      else
        this.license = null;
      if (typeof data.languageName === `string`)
        this.languageName = data.languageName;
      else
        this.languageName = null;
      if (typeof data.main === `string`)
        this.main = normalizeSlashes(data.main);
      else
        this.main = null;
      if (typeof data.module === `string`)
        this.module = normalizeSlashes(data.module);
      else
        this.module = null;
      if (data.browser != null) {
        if (typeof data.browser === `string`) {
          this.browser = normalizeSlashes(data.browser);
        } else {
          this.browser = new Map();
          for (const [key, value] of Object.entries(data.browser)) {
            this.browser.set(normalizeSlashes(key), typeof value === `string` ? normalizeSlashes(value) : value);
          }
        }
      } else {
        this.browser = null;
      }
      this.bin = new Map();
      if (typeof data.bin === `string`) {
        if (this.name !== null) {
          this.bin.set(this.name.name, normalizeSlashes(data.bin));
        } else {
          errors4.push(new Error(`String bin field, but no attached package name`));
        }
      } else if (typeof data.bin === `object` && data.bin !== null) {
        for (const [key, value] of Object.entries(data.bin)) {
          if (typeof value !== `string`) {
            errors4.push(new Error(`Invalid bin definition for '${key}'`));
            continue;
          }
          this.bin.set(key, normalizeSlashes(value));
        }
      }
      this.scripts = new Map();
      if (typeof data.scripts === `object` && data.scripts !== null) {
        for (const [key, value] of Object.entries(data.scripts)) {
          if (typeof value !== `string`) {
            errors4.push(new Error(`Invalid script definition for '${key}'`));
            continue;
          }
          this.scripts.set(key, value);
        }
      }
      this.dependencies = new Map();
      if (typeof data.dependencies === `object` && data.dependencies !== null) {
        for (const [name, range] of Object.entries(data.dependencies)) {
          if (typeof range !== `string`) {
            errors4.push(new Error(`Invalid dependency range for '${name}'`));
            continue;
          }
          let ident;
          try {
            ident = parseIdent(name);
          } catch (error) {
            errors4.push(new Error(`Parsing failed for the dependency name '${name}'`));
            continue;
          }
          const descriptor = makeDescriptor(ident, range);
          this.dependencies.set(descriptor.identHash, descriptor);
        }
      }
      this.devDependencies = new Map();
      if (typeof data.devDependencies === `object` && data.devDependencies !== null) {
        for (const [name, range] of Object.entries(data.devDependencies)) {
          if (typeof range !== `string`) {
            errors4.push(new Error(`Invalid dependency range for '${name}'`));
            continue;
          }
          let ident;
          try {
            ident = parseIdent(name);
          } catch (error) {
            errors4.push(new Error(`Parsing failed for the dependency name '${name}'`));
            continue;
          }
          const descriptor = makeDescriptor(ident, range);
          this.devDependencies.set(descriptor.identHash, descriptor);
        }
      }
      this.peerDependencies = new Map();
      if (typeof data.peerDependencies === `object` && data.peerDependencies !== null) {
        for (let [name, range] of Object.entries(data.peerDependencies)) {
          let ident;
          try {
            ident = parseIdent(name);
          } catch (error) {
            errors4.push(new Error(`Parsing failed for the dependency name '${name}'`));
            continue;
          }
          if (typeof range !== `string` || !validRange(range)) {
            errors4.push(new Error(`Invalid dependency range for '${name}'`));
            range = `*`;
          }
          const descriptor = makeDescriptor(ident, range);
          this.peerDependencies.set(descriptor.identHash, descriptor);
        }
      }
      if (typeof data.workspaces === `object` && data.workspaces.nohoist)
        errors4.push(new Error(`'nohoist' is deprecated, please use 'installConfig.hoistingLimits' instead`));
      const workspaces = Array.isArray(data.workspaces) ? data.workspaces : typeof data.workspaces === `object` && data.workspaces !== null && Array.isArray(data.workspaces.packages) ? data.workspaces.packages : [];
      this.workspaceDefinitions = [];
      for (const entry of workspaces) {
        if (typeof entry !== `string`) {
          errors4.push(new Error(`Invalid workspace definition for '${entry}'`));
          continue;
        }
        this.workspaceDefinitions.push({
          pattern: entry
        });
      }
      this.dependenciesMeta = new Map();
      if (typeof data.dependenciesMeta === `object` && data.dependenciesMeta !== null) {
        for (const [pattern, meta] of Object.entries(data.dependenciesMeta)) {
          if (typeof meta !== `object` || meta === null) {
            errors4.push(new Error(`Invalid meta field for '${pattern}`));
            continue;
          }
          const descriptor = parseDescriptor(pattern);
          const dependencyMeta = this.ensureDependencyMeta(descriptor);
          const built = tryParseOptionalBoolean3(meta.built, {yamlCompatibilityMode});
          if (built === null) {
            errors4.push(new Error(`Invalid built meta field for '${pattern}'`));
            continue;
          }
          const optional = tryParseOptionalBoolean3(meta.optional, {yamlCompatibilityMode});
          if (optional === null) {
            errors4.push(new Error(`Invalid optional meta field for '${pattern}'`));
            continue;
          }
          const unplugged = tryParseOptionalBoolean3(meta.unplugged, {yamlCompatibilityMode});
          if (unplugged === null) {
            errors4.push(new Error(`Invalid unplugged meta field for '${pattern}'`));
            continue;
          }
          Object.assign(dependencyMeta, {built, optional, unplugged});
        }
      }
      this.peerDependenciesMeta = new Map();
      if (typeof data.peerDependenciesMeta === `object` && data.peerDependenciesMeta !== null) {
        for (const [pattern, meta] of Object.entries(data.peerDependenciesMeta)) {
          if (typeof meta !== `object` || meta === null) {
            errors4.push(new Error(`Invalid meta field for '${pattern}'`));
            continue;
          }
          const descriptor = parseDescriptor(pattern);
          const peerDependencyMeta = this.ensurePeerDependencyMeta(descriptor);
          const optional = tryParseOptionalBoolean3(meta.optional, {yamlCompatibilityMode});
          if (optional === null) {
            errors4.push(new Error(`Invalid optional meta field for '${pattern}'`));
            continue;
          }
          Object.assign(peerDependencyMeta, {optional});
        }
      }
      this.resolutions = [];
      if (typeof data.resolutions === `object` && data.resolutions !== null) {
        for (const [pattern, reference] of Object.entries(data.resolutions)) {
          if (typeof reference !== `string`) {
            errors4.push(new Error(`Invalid resolution entry for '${pattern}'`));
            continue;
          }
          try {
            this.resolutions.push({pattern: parseResolution(pattern), reference});
          } catch (error) {
            errors4.push(error);
            continue;
          }
        }
      }
      if (Array.isArray(data.files)) {
        this.files = new Set();
        for (const filename of data.files) {
          if (typeof filename !== `string`) {
            errors4.push(new Error(`Invalid files entry for '${filename}'`));
            continue;
          }
          this.files.add(filename);
        }
      } else {
        this.files = null;
      }
      if (typeof data.publishConfig === `object` && data.publishConfig !== null) {
        this.publishConfig = {};
        if (typeof data.publishConfig.access === `string`)
          this.publishConfig.access = data.publishConfig.access;
        if (typeof data.publishConfig.main === `string`)
          this.publishConfig.main = normalizeSlashes(data.publishConfig.main);
        if (typeof data.publishConfig.module === `string`)
          this.publishConfig.module = normalizeSlashes(data.publishConfig.module);
        if (data.publishConfig.browser != null) {
          if (typeof data.publishConfig.browser === `string`) {
            this.publishConfig.browser = normalizeSlashes(data.publishConfig.browser);
          } else {
            this.publishConfig.browser = new Map();
            for (const [key, value] of Object.entries(data.publishConfig.browser)) {
              this.publishConfig.browser.set(normalizeSlashes(key), typeof value === `string` ? normalizeSlashes(value) : value);
            }
          }
        }
        if (typeof data.publishConfig.registry === `string`)
          this.publishConfig.registry = data.publishConfig.registry;
        if (typeof data.publishConfig.bin === `string`) {
          if (this.name !== null) {
            this.publishConfig.bin = new Map([[this.name.name, normalizeSlashes(data.publishConfig.bin)]]);
          } else {
            errors4.push(new Error(`String bin field, but no attached package name`));
          }
        } else if (typeof data.publishConfig.bin === `object` && data.publishConfig.bin !== null) {
          this.publishConfig.bin = new Map();
          for (const [key, value] of Object.entries(data.publishConfig.bin)) {
            if (typeof value !== `string`) {
              errors4.push(new Error(`Invalid bin definition for '${key}'`));
              continue;
            }
            this.publishConfig.bin.set(key, normalizeSlashes(value));
          }
        }
        if (Array.isArray(data.publishConfig.executableFiles)) {
          this.publishConfig.executableFiles = new Set();
          for (const value of data.publishConfig.executableFiles) {
            if (typeof value !== `string`) {
              errors4.push(new Error(`Invalid executable file definition`));
              continue;
            }
            this.publishConfig.executableFiles.add(normalizeSlashes(value));
          }
        }
      } else {
        this.publishConfig = null;
      }
      if (typeof data.installConfig === `object` && data.installConfig !== null) {
        this.installConfig = {};
        for (const key of Object.keys(data.installConfig)) {
          if (key === `hoistingLimits`) {
            if (typeof data.installConfig.hoistingLimits === `string`) {
              this.installConfig.hoistingLimits = data.installConfig.hoistingLimits;
            } else {
              errors4.push(new Error(`Invalid hoisting limits definition`));
            }
          } else {
            errors4.push(new Error(`Unrecognized installConfig key: ${key}`));
          }
        }
      } else {
        this.installConfig = null;
      }
      if (typeof data.optionalDependencies === `object` && data.optionalDependencies !== null) {
        for (const [name, range] of Object.entries(data.optionalDependencies)) {
          if (typeof range !== `string`) {
            errors4.push(new Error(`Invalid dependency range for '${name}'`));
            continue;
          }
          let ident;
          try {
            ident = parseIdent(name);
          } catch (error) {
            errors4.push(new Error(`Parsing failed for the dependency name '${name}'`));
            continue;
          }
          const realDescriptor = makeDescriptor(ident, range);
          this.dependencies.set(realDescriptor.identHash, realDescriptor);
          const identDescriptor = makeDescriptor(ident, `unknown`);
          const dependencyMeta = this.ensureDependencyMeta(identDescriptor);
          Object.assign(dependencyMeta, {optional: true});
        }
      }
      if (typeof data.preferUnplugged === `boolean`)
        this.preferUnplugged = data.preferUnplugged;
      else
        this.preferUnplugged = null;
      this.errors = errors4;
    }
    getForScope(type) {
      switch (type) {
        case `dependencies`:
          return this.dependencies;
        case `devDependencies`:
          return this.devDependencies;
        case `peerDependencies`:
          return this.peerDependencies;
        default: {
          throw new Error(`Unsupported value ("${type}")`);
        }
      }
    }
    hasConsumerDependency(ident) {
      if (this.dependencies.has(ident.identHash))
        return true;
      if (this.peerDependencies.has(ident.identHash))
        return true;
      return false;
    }
    hasHardDependency(ident) {
      if (this.dependencies.has(ident.identHash))
        return true;
      if (this.devDependencies.has(ident.identHash))
        return true;
      return false;
    }
    hasSoftDependency(ident) {
      if (this.peerDependencies.has(ident.identHash))
        return true;
      return false;
    }
    hasDependency(ident) {
      if (this.hasHardDependency(ident))
        return true;
      if (this.hasSoftDependency(ident))
        return true;
      return false;
    }
    isCompatibleWithOS(os2) {
      return Manifest2.isManifestFieldCompatible(this.os, os2);
    }
    isCompatibleWithCPU(cpu) {
      return Manifest2.isManifestFieldCompatible(this.cpu, cpu);
    }
    ensureDependencyMeta(descriptor) {
      if (descriptor.range !== `unknown` && !import_semver4.default.valid(descriptor.range))
        throw new Error(`Invalid meta field range for '${stringifyDescriptor(descriptor)}'`);
      const identString = stringifyIdent(descriptor);
      const range = descriptor.range !== `unknown` ? descriptor.range : null;
      let dependencyMetaSet = this.dependenciesMeta.get(identString);
      if (!dependencyMetaSet)
        this.dependenciesMeta.set(identString, dependencyMetaSet = new Map());
      let dependencyMeta = dependencyMetaSet.get(range);
      if (!dependencyMeta)
        dependencyMetaSet.set(range, dependencyMeta = {});
      return dependencyMeta;
    }
    ensurePeerDependencyMeta(descriptor) {
      if (descriptor.range !== `unknown`)
        throw new Error(`Invalid meta field range for '${stringifyDescriptor(descriptor)}'`);
      const identString = stringifyIdent(descriptor);
      let peerDependencyMeta = this.peerDependenciesMeta.get(identString);
      if (!peerDependencyMeta)
        this.peerDependenciesMeta.set(identString, peerDependencyMeta = {});
      return peerDependencyMeta;
    }
    setRawField(name, value, {after = []} = {}) {
      const afterSet = new Set(after.filter((key) => {
        return Object.prototype.hasOwnProperty.call(this.raw, key);
      }));
      if (afterSet.size === 0 || Object.prototype.hasOwnProperty.call(this.raw, name)) {
        this.raw[name] = value;
      } else {
        const oldRaw = this.raw;
        const newRaw = this.raw = {};
        let inserted = false;
        for (const key of Object.keys(oldRaw)) {
          newRaw[key] = oldRaw[key];
          if (!inserted) {
            afterSet.delete(key);
            if (afterSet.size === 0) {
              newRaw[name] = value;
              inserted = true;
            }
          }
        }
      }
    }
    exportTo(data, {compatibilityMode = true} = {}) {
      Object.assign(data, this.raw);
      if (this.name !== null)
        data.name = stringifyIdent(this.name);
      else
        delete data.name;
      if (this.version !== null)
        data.version = this.version;
      else
        delete data.version;
      if (this.os !== null)
        data.os = this.os;
      else
        delete data.os;
      if (this.cpu !== null)
        data.cpu = this.cpu;
      else
        delete data.cpu;
      if (this.type !== null)
        data.type = this.type;
      else
        delete data.type;
      if (this.private)
        data.private = true;
      else
        delete data.private;
      if (this.license !== null)
        data.license = this.license;
      else
        delete data.license;
      if (this.languageName !== null)
        data.languageName = this.languageName;
      else
        delete data.languageName;
      if (this.main !== null)
        data.main = this.main;
      else
        delete data.main;
      if (this.module !== null)
        data.module = this.module;
      else
        delete data.module;
      if (this.browser !== null) {
        const browser = this.browser;
        if (typeof browser === `string`) {
          data.browser = browser;
        } else if (browser instanceof Map) {
          data.browser = Object.assign({}, ...Array.from(browser.keys()).sort().map((name) => {
            return {[name]: browser.get(name)};
          }));
        }
      } else {
        delete data.browser;
      }
      if (this.bin.size === 1 && this.name !== null && this.bin.has(this.name.name)) {
        data.bin = this.bin.get(this.name.name);
      } else if (this.bin.size > 0) {
        data.bin = Object.assign({}, ...Array.from(this.bin.keys()).sort().map((name) => {
          return {[name]: this.bin.get(name)};
        }));
      } else {
        delete data.bin;
      }
      if (this.workspaceDefinitions.length > 0) {
        if (this.raw.workspaces && !Array.isArray(this.raw.workspaces)) {
          data.workspaces = {...this.raw.workspaces, packages: this.workspaceDefinitions.map(({pattern}) => pattern)};
        } else {
          data.workspaces = this.workspaceDefinitions.map(({pattern}) => pattern);
        }
      } else if (this.raw.workspaces && !Array.isArray(this.raw.workspaces) && Object.keys(this.raw.workspaces).length > 0) {
        data.workspaces = this.raw.workspaces;
      } else {
        delete data.workspaces;
      }
      const regularDependencies = [];
      const optionalDependencies = [];
      for (const dependency of this.dependencies.values()) {
        const dependencyMetaSet = this.dependenciesMeta.get(stringifyIdent(dependency));
        let isOptionallyBuilt = false;
        if (compatibilityMode) {
          if (dependencyMetaSet) {
            const meta = dependencyMetaSet.get(null);
            if (meta && meta.optional) {
              isOptionallyBuilt = true;
            }
          }
        }
        if (isOptionallyBuilt) {
          optionalDependencies.push(dependency);
        } else {
          regularDependencies.push(dependency);
        }
      }
      if (regularDependencies.length > 0) {
        data.dependencies = Object.assign({}, ...sortDescriptors(regularDependencies).map((dependency) => {
          return {[stringifyIdent(dependency)]: dependency.range};
        }));
      } else {
        delete data.dependencies;
      }
      if (optionalDependencies.length > 0) {
        data.optionalDependencies = Object.assign({}, ...sortDescriptors(optionalDependencies).map((dependency) => {
          return {[stringifyIdent(dependency)]: dependency.range};
        }));
      } else {
        delete data.optionalDependencies;
      }
      if (this.devDependencies.size > 0) {
        data.devDependencies = Object.assign({}, ...sortDescriptors(this.devDependencies.values()).map((dependency) => {
          return {[stringifyIdent(dependency)]: dependency.range};
        }));
      } else {
        delete data.devDependencies;
      }
      if (this.peerDependencies.size > 0) {
        data.peerDependencies = Object.assign({}, ...sortDescriptors(this.peerDependencies.values()).map((dependency) => {
          return {[stringifyIdent(dependency)]: dependency.range};
        }));
      } else {
        delete data.peerDependencies;
      }
      data.dependenciesMeta = {};
      for (const [identString, dependencyMetaSet] of miscUtils3.sortMap(this.dependenciesMeta.entries(), ([identString2, dependencyMetaSet2]) => identString2)) {
        for (const [range, meta] of miscUtils3.sortMap(dependencyMetaSet.entries(), ([range2, meta2]) => range2 !== null ? `0${range2}` : `1`)) {
          const key = range !== null ? stringifyDescriptor(makeDescriptor(parseIdent(identString), range)) : identString;
          const metaCopy = {...meta};
          if (compatibilityMode && range === null)
            delete metaCopy.optional;
          if (Object.keys(metaCopy).length === 0)
            continue;
          data.dependenciesMeta[key] = metaCopy;
        }
      }
      if (Object.keys(data.dependenciesMeta).length === 0)
        delete data.dependenciesMeta;
      if (this.peerDependenciesMeta.size > 0) {
        data.peerDependenciesMeta = Object.assign({}, ...miscUtils3.sortMap(this.peerDependenciesMeta.entries(), ([identString, meta]) => identString).map(([identString, meta]) => {
          return {[identString]: meta};
        }));
      } else {
        delete data.peerDependenciesMeta;
      }
      if (this.resolutions.length > 0) {
        data.resolutions = Object.assign({}, ...this.resolutions.map(({pattern, reference}) => {
          return {[stringifyResolution(pattern)]: reference};
        }));
      } else {
        delete data.resolutions;
      }
      if (this.files !== null)
        data.files = Array.from(this.files);
      else
        delete data.files;
      if (this.preferUnplugged !== null)
        data.preferUnplugged = this.preferUnplugged;
      else
        delete data.preferUnplugged;
      return data;
    }
  };
  var Manifest = Manifest2;
  _a = "private";
  Manifest.fileName = `package.json`;
  Manifest.allDependencies = [`dependencies`, `devDependencies`, `peerDependencies`];
  Manifest.hardDependencies = [`dependencies`, `devDependencies`];
  function getIndent(content) {
    const indentMatch = content.match(/^[ \t]+/m);
    if (indentMatch) {
      return indentMatch[0];
    } else {
      return `  `;
    }
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      return content.slice(1);
    } else {
      return content;
    }
  }
  function normalizeSlashes(str) {
    return str.replace(/\\/g, `/`);
  }
  function tryParseOptionalBoolean3(value, {yamlCompatibilityMode}) {
    if (yamlCompatibilityMode)
      return miscUtils3.tryParseOptionalBoolean(value);
    if (typeof value === `undefined` || typeof value === `boolean`)
      return value;
    return null;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Report.ts
  var import_stream4 = __toModule(require("stream"));
  var import_string_decoder = __toModule(require("string_decoder"));
  var ReportError = class extends Error {
    constructor(code, message, reportExtra) {
      super(message);
      this.reportExtra = reportExtra;
      this.reportCode = code;
    }
  };
  function isReportError(error) {
    return typeof error.reportCode !== `undefined`;
  }
  var Report = class {
    constructor() {
      this.reportedInfos = new Set();
      this.reportedWarnings = new Set();
      this.reportedErrors = new Set();
    }
    static progressViaCounter(max) {
      let current = 0;
      let unlock;
      let lock = new Promise((resolve) => {
        unlock = resolve;
      });
      const set = (n) => {
        const thisUnlock = unlock;
        lock = new Promise((resolve) => {
          unlock = resolve;
        });
        current = n;
        thisUnlock();
      };
      const tick = (n = 0) => {
        set(current + 1);
      };
      const gen = async function* () {
        while (current < max) {
          await lock;
          yield {
            progress: current / max
          };
        }
      }();
      return {
        [Symbol.asyncIterator]() {
          return gen;
        },
        set,
        tick
      };
    }
    reportInfoOnce(name, text, opts) {
      const key = opts && opts.key ? opts.key : text;
      if (!this.reportedInfos.has(key)) {
        this.reportedInfos.add(key);
        this.reportInfo(name, text);
      }
    }
    reportWarningOnce(name, text, opts) {
      const key = opts && opts.key ? opts.key : text;
      if (!this.reportedWarnings.has(key)) {
        this.reportedWarnings.add(key);
        this.reportWarning(name, text);
      }
    }
    reportErrorOnce(name, text, opts) {
      var _a2;
      const key = opts && opts.key ? opts.key : text;
      if (!this.reportedErrors.has(key)) {
        this.reportedErrors.add(key);
        this.reportError(name, text);
        (_a2 = opts == null ? void 0 : opts.reportExtra) == null ? void 0 : _a2.call(opts, this);
      }
    }
    reportExceptionOnce(error) {
      if (isReportError(error)) {
        this.reportErrorOnce(error.reportCode, error.message, {key: error, reportExtra: error.reportExtra});
      } else {
        this.reportErrorOnce(MessageName.EXCEPTION, error.stack || error.message, {key: error});
      }
    }
    createStreamReporter(prefix = null) {
      const stream = new import_stream4.PassThrough();
      const decoder = new import_string_decoder.StringDecoder();
      let buffer = ``;
      stream.on(`data`, (chunk) => {
        let chunkStr = decoder.write(chunk);
        let lineIndex;
        do {
          lineIndex = chunkStr.indexOf(`
`);
          if (lineIndex !== -1) {
            const line = buffer + chunkStr.substr(0, lineIndex);
            chunkStr = chunkStr.substr(lineIndex + 1);
            buffer = ``;
            if (prefix !== null) {
              this.reportInfo(null, `${prefix} ${line}`);
            } else {
              this.reportInfo(null, line);
            }
          }
        } while (lineIndex !== -1);
        buffer += chunkStr;
      });
      stream.on(`end`, () => {
        const last = decoder.end();
        if (last !== ``) {
          if (prefix !== null) {
            this.reportInfo(null, `${prefix} ${last}`);
          } else {
            this.reportInfo(null, last);
          }
        }
      });
      return stream;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\StreamReport.ts
  var import_slice_ansi = __toModule(require_slice_ansi());
  var PROGRESS_FRAMES = [`\u280B`, `\u2819`, `\u2839`, `\u2838`, `\u283C`, `\u2834`, `\u2826`, `\u2827`, `\u2807`, `\u280F`];
  var PROGRESS_INTERVAL = 80;
  var BASE_FORGETTABLE_NAMES = new Set([MessageName.FETCH_NOT_CACHED, MessageName.UNUSED_CACHE_ENTRY]);
  var BASE_FORGETTABLE_BUFFER_SIZE = 5;
  var GROUP = process.env.GITHUB_ACTIONS ? {start: (what) => `::group::${what}
`, end: (what) => `::endgroup::
`} : process.env.TRAVIS ? {start: (what) => `travis_fold:start:${what}
`, end: (what) => `travis_fold:end:${what}
`} : process.env.GITLAB_CI ? {start: (what) => `section_start:${Math.floor(Date.now() / 1e3)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r[0K${what}
`, end: (what) => `section_end:${Math.floor(Date.now() / 1e3)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r[0K`} : null;
  var now = new Date();
  var supportsEmojis = [`iTerm.app`, `Apple_Terminal`].includes(process.env.TERM_PROGRAM) || !!process.env.WT_SESSION;
  var makeRecord = (obj) => obj;
  var PROGRESS_STYLES = makeRecord({
    patrick: {
      date: [17, 3],
      chars: [`\u{1F340}`, `\u{1F331}`],
      size: 40
    },
    simba: {
      date: [19, 7],
      chars: [`\u{1F981}`, `\u{1F334}`],
      size: 40
    },
    jack: {
      date: [31, 10],
      chars: [`\u{1F383}`, `\u{1F987}`],
      size: 40
    },
    hogsfather: {
      date: [31, 12],
      chars: [`\u{1F389}`, `\u{1F384}`],
      size: 40
    },
    default: {
      chars: [`=`, `-`],
      size: 80
    }
  });
  var defaultStyle = supportsEmojis && Object.keys(PROGRESS_STYLES).find((name) => {
    const style = PROGRESS_STYLES[name];
    if (style.date && (style.date[0] !== now.getDate() || style.date[1] !== now.getMonth() + 1))
      return false;
    return true;
  }) || `default`;
  function formatName(name, {configuration, json: json2}) {
    const num = name === null ? 0 : name;
    const label = stringifyMessageName(num);
    if (!json2 && name === null) {
      return pretty(configuration, label, `grey`);
    } else {
      return label;
    }
  }
  function formatNameWithHyperlink(name, {configuration, json: json2}) {
    const code = formatName(name, {configuration, json: json2});
    if (!configuration.get(`enableHyperlinks`))
      return code;
    if (name === null || name === MessageName.UNNAMED)
      return code;
    const desc = MessageName[name];
    const href = `https://yarnpkg.com/advanced/error-codes#${code}---${desc}`.toLowerCase();
    return `]8;;${href}\x07${code}]8;;\x07`;
  }
  var StreamReport = class extends Report {
    constructor({
      configuration,
      stdout,
      json: json2 = false,
      includeFooter = true,
      includeLogs = !json2,
      includeInfos = includeLogs,
      includeWarnings = includeLogs,
      forgettableBufferSize = BASE_FORGETTABLE_BUFFER_SIZE,
      forgettableNames = new Set()
    }) {
      super();
      this.uncommitted = new Set();
      this.cacheHitCount = 0;
      this.cacheMissCount = 0;
      this.warningCount = 0;
      this.errorCount = 0;
      this.startTime = Date.now();
      this.indent = 0;
      this.progress = new Map();
      this.progressTime = 0;
      this.progressFrame = 0;
      this.progressTimeout = null;
      this.forgettableLines = [];
      addLogFilterSupport(this, {configuration});
      this.configuration = configuration;
      this.forgettableBufferSize = forgettableBufferSize;
      this.forgettableNames = new Set([...forgettableNames, ...BASE_FORGETTABLE_NAMES]);
      this.includeFooter = includeFooter;
      this.includeInfos = includeInfos;
      this.includeWarnings = includeWarnings;
      this.json = json2;
      this.stdout = stdout;
      const styleName = this.configuration.get(`progressBarStyle`) || defaultStyle;
      if (!Object.prototype.hasOwnProperty.call(PROGRESS_STYLES, styleName))
        throw new Error(`Assertion failed: Invalid progress bar style`);
      this.progressStyle = PROGRESS_STYLES[styleName];
      const PAD_LEFT = `\u27A4 YN0000: \u250C `.length;
      const maxWidth = Math.max(0, Math.min(process.stdout.columns - PAD_LEFT, 80));
      this.progressMaxScaledSize = Math.floor(this.progressStyle.size * maxWidth / 80);
    }
    static async start(opts, cb) {
      const report = new this(opts);
      const emitWarning = process.emitWarning;
      process.emitWarning = (message, name) => {
        if (typeof message !== `string`) {
          const error = message;
          message = error.message;
          name = name != null ? name : error.name;
        }
        const fullMessage = typeof name !== `undefined` ? `${name}: ${message}` : message;
        report.reportWarning(MessageName.UNNAMED, fullMessage);
      };
      try {
        await cb(report);
      } catch (error) {
        report.reportExceptionOnce(error);
      } finally {
        await report.finalize();
        process.emitWarning = emitWarning;
      }
      return report;
    }
    hasErrors() {
      return this.errorCount > 0;
    }
    exitCode() {
      return this.hasErrors() ? 1 : 0;
    }
    reportCacheHit(locator) {
      this.cacheHitCount += 1;
    }
    reportCacheMiss(locator, message) {
      this.cacheMissCount += 1;
      if (typeof message !== `undefined` && !this.configuration.get(`preferAggregateCacheInfo`)) {
        this.reportInfo(MessageName.FETCH_NOT_CACHED, message);
      }
    }
    startTimerSync(what, opts, cb) {
      const realOpts = typeof opts === `function` ? {} : opts;
      const realCb = typeof opts === `function` ? opts : cb;
      const mark2 = {committed: false, action: () => {
        this.reportInfo(null, `\u250C ${what}`);
        this.indent += 1;
        if (GROUP !== null) {
          this.stdout.write(GROUP.start(what));
        }
      }};
      if (realOpts.skipIfEmpty) {
        this.uncommitted.add(mark2);
      } else {
        mark2.action();
        mark2.committed = true;
      }
      const before = Date.now();
      try {
        return realCb();
      } catch (error) {
        this.reportExceptionOnce(error);
        throw error;
      } finally {
        const after = Date.now();
        this.uncommitted.delete(mark2);
        if (mark2.committed) {
          this.indent -= 1;
          if (GROUP !== null)
            this.stdout.write(GROUP.end(what));
          if (this.configuration.get(`enableTimers`) && after - before > 200) {
            this.reportInfo(null, `\u2514 Completed in ${pretty(this.configuration, after - before, Type.DURATION)}`);
          } else {
            this.reportInfo(null, `\u2514 Completed`);
          }
        }
      }
    }
    async startTimerPromise(what, opts, cb) {
      const realOpts = typeof opts === `function` ? {} : opts;
      const realCb = typeof opts === `function` ? opts : cb;
      const mark2 = {committed: false, action: () => {
        this.reportInfo(null, `\u250C ${what}`);
        this.indent += 1;
        if (GROUP !== null) {
          this.stdout.write(GROUP.start(what));
        }
      }};
      if (realOpts.skipIfEmpty) {
        this.uncommitted.add(mark2);
      } else {
        mark2.action();
        mark2.committed = true;
      }
      const before = Date.now();
      try {
        return await realCb();
      } catch (error) {
        this.reportExceptionOnce(error);
        throw error;
      } finally {
        const after = Date.now();
        this.uncommitted.delete(mark2);
        if (mark2.committed) {
          this.indent -= 1;
          if (GROUP !== null)
            this.stdout.write(GROUP.end(what));
          if (this.configuration.get(`enableTimers`) && after - before > 200) {
            this.reportInfo(null, `\u2514 Completed in ${pretty(this.configuration, after - before, Type.DURATION)}`);
          } else {
            this.reportInfo(null, `\u2514 Completed`);
          }
        }
      }
    }
    async startCacheReport(cb) {
      const cacheInfo = this.configuration.get(`preferAggregateCacheInfo`) ? {cacheHitCount: this.cacheHitCount, cacheMissCount: this.cacheMissCount} : null;
      try {
        return await cb();
      } catch (error) {
        this.reportExceptionOnce(error);
        throw error;
      } finally {
        if (cacheInfo !== null) {
          this.reportCacheChanges(cacheInfo);
        }
      }
    }
    reportSeparator() {
      if (this.indent === 0) {
        this.writeLineWithForgettableReset(``);
      } else {
        this.reportInfo(null, ``);
      }
    }
    reportInfo(name, text) {
      if (!this.includeInfos)
        return;
      this.commit();
      const message = `${pretty(this.configuration, `\u27A4`, `blueBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`;
      if (!this.json) {
        if (this.forgettableNames.has(name)) {
          this.forgettableLines.push(message);
          if (this.forgettableLines.length > this.forgettableBufferSize) {
            while (this.forgettableLines.length > this.forgettableBufferSize)
              this.forgettableLines.shift();
            this.writeLines(this.forgettableLines, {truncate: true});
          } else {
            this.writeLine(message, {truncate: true});
          }
        } else {
          this.writeLineWithForgettableReset(message);
        }
      } else {
        this.reportJson({type: `info`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text});
      }
    }
    reportWarning(name, text) {
      this.warningCount += 1;
      if (!this.includeWarnings)
        return;
      this.commit();
      if (!this.json) {
        this.writeLineWithForgettableReset(`${pretty(this.configuration, `\u27A4`, `yellowBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`);
      } else {
        this.reportJson({type: `warning`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text});
      }
    }
    reportError(name, text) {
      this.errorCount += 1;
      this.commit();
      if (!this.json) {
        this.writeLineWithForgettableReset(`${pretty(this.configuration, `\u27A4`, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`, {truncate: false});
      } else {
        this.reportJson({type: `error`, name, displayName: this.formatName(name), indent: this.formatIndent(), data: text});
      }
    }
    reportProgress(progressIt) {
      let stopped = false;
      const promise = Promise.resolve().then(async () => {
        const progressDefinition = {
          progress: 0,
          title: void 0
        };
        this.progress.set(progressIt, {
          definition: progressDefinition,
          lastScaledSize: -1
        });
        this.refreshProgress(-1);
        for await (const {progress, title} of progressIt) {
          if (stopped)
            continue;
          if (progressDefinition.progress === progress && progressDefinition.title === title)
            continue;
          progressDefinition.progress = progress;
          progressDefinition.title = title;
          this.refreshProgress();
        }
        stop();
      });
      const stop = () => {
        if (stopped)
          return;
        stopped = true;
        this.progress.delete(progressIt);
        this.refreshProgress(1);
      };
      return {...promise, stop};
    }
    reportJson(data) {
      if (this.json) {
        this.writeLineWithForgettableReset(`${JSON.stringify(data)}`);
      }
    }
    async finalize() {
      if (!this.includeFooter)
        return;
      let installStatus = ``;
      if (this.errorCount > 0)
        installStatus = `Failed with errors`;
      else if (this.warningCount > 0)
        installStatus = `Done with warnings`;
      else
        installStatus = `Done`;
      const timing = pretty(this.configuration, Date.now() - this.startTime, Type.DURATION);
      const message = this.configuration.get(`enableTimers`) ? `${installStatus} in ${timing}` : installStatus;
      if (this.errorCount > 0) {
        this.reportError(MessageName.UNNAMED, message);
      } else if (this.warningCount > 0) {
        this.reportWarning(MessageName.UNNAMED, message);
      } else {
        this.reportInfo(MessageName.UNNAMED, message);
      }
    }
    writeLine(str, {truncate} = {}) {
      this.clearProgress({clear: true});
      this.stdout.write(`${this.truncate(str, {truncate})}
`);
      this.writeProgress();
    }
    writeLineWithForgettableReset(str, {truncate} = {}) {
      this.forgettableLines = [];
      this.writeLine(str, {truncate});
    }
    writeLines(lines, {truncate} = {}) {
      this.clearProgress({delta: lines.length});
      for (const line of lines)
        this.stdout.write(`${this.truncate(line, {truncate})}
`);
      this.writeProgress();
    }
    reportCacheChanges({cacheHitCount, cacheMissCount}) {
      const cacheHitDelta = this.cacheHitCount - cacheHitCount;
      const cacheMissDelta = this.cacheMissCount - cacheMissCount;
      if (cacheHitDelta === 0 && cacheMissDelta === 0)
        return;
      let fetchStatus = ``;
      if (this.cacheHitCount > 1)
        fetchStatus += `${this.cacheHitCount} packages were already cached`;
      else if (this.cacheHitCount === 1)
        fetchStatus += ` - one package was already cached`;
      else
        fetchStatus += `No packages were cached`;
      if (this.cacheHitCount > 0) {
        if (this.cacheMissCount > 1) {
          fetchStatus += `, ${this.cacheMissCount} had to be fetched`;
        } else if (this.cacheMissCount === 1) {
          fetchStatus += `, one had to be fetched`;
        }
      } else {
        if (this.cacheMissCount > 1) {
          fetchStatus += ` - ${this.cacheMissCount} packages had to be fetched`;
        } else if (this.cacheMissCount === 1) {
          fetchStatus += ` - one package had to be fetched`;
        }
      }
      this.reportInfo(MessageName.FETCH_NOT_CACHED, fetchStatus);
    }
    commit() {
      const marks = this.uncommitted;
      this.uncommitted = new Set();
      for (const mark2 of marks) {
        mark2.committed = true;
        mark2.action();
      }
    }
    clearProgress({delta = 0, clear = false}) {
      if (!this.configuration.get(`enableProgressBars`) || this.json)
        return;
      if (this.progress.size + delta > 0) {
        this.stdout.write(`[${this.progress.size + delta}A`);
        if (delta > 0 || clear) {
          this.stdout.write(`[0J`);
        }
      }
    }
    writeProgress() {
      if (!this.configuration.get(`enableProgressBars`) || this.json)
        return;
      if (this.progressTimeout !== null)
        clearTimeout(this.progressTimeout);
      this.progressTimeout = null;
      if (this.progress.size === 0)
        return;
      const now2 = Date.now();
      if (now2 - this.progressTime > PROGRESS_INTERVAL) {
        this.progressFrame = (this.progressFrame + 1) % PROGRESS_FRAMES.length;
        this.progressTime = now2;
      }
      const spinner = PROGRESS_FRAMES[this.progressFrame];
      for (const progress of this.progress.values()) {
        const ok = this.progressStyle.chars[0].repeat(progress.lastScaledSize);
        const ko = this.progressStyle.chars[1].repeat(this.progressMaxScaledSize - progress.lastScaledSize);
        this.stdout.write(`${pretty(this.configuration, `\u27A4`, `blueBright`)} ${this.formatName(null)}: ${spinner} ${ok}${ko}
`);
      }
      this.progressTimeout = setTimeout(() => {
        this.refreshProgress();
      }, PROGRESS_INTERVAL);
    }
    refreshProgress(delta = 0) {
      let needsUpdate = false;
      if (this.progress.size === 0) {
        needsUpdate = true;
      } else {
        for (const progress of this.progress.values()) {
          const refreshedScaledSize = Math.trunc(this.progressMaxScaledSize * progress.definition.progress);
          const previousScaledSize = progress.lastScaledSize;
          progress.lastScaledSize = refreshedScaledSize;
          if (refreshedScaledSize !== previousScaledSize) {
            needsUpdate = true;
            break;
          }
        }
      }
      if (needsUpdate) {
        this.clearProgress({delta});
        this.writeProgress();
      }
    }
    truncate(str, {truncate} = {}) {
      if (!this.configuration.get(`enableProgressBars`))
        truncate = false;
      if (typeof truncate === `undefined`)
        truncate = this.configuration.get(`preferTruncatedLines`);
      if (truncate)
        str = import_slice_ansi.default(str, 0, process.stdout.columns - 1);
      return str;
    }
    formatName(name) {
      return formatName(name, {
        configuration: this.configuration,
        json: this.json
      });
    }
    formatNameWithHyperlink(name) {
      return formatNameWithHyperlink(name, {
        configuration: this.configuration,
        json: this.json
      });
    }
    formatIndent() {
      return `\u2502 `.repeat(this.indent);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\YarnVersion.ts
  var YarnVersion = true ? "2.4.0-git.20210130.hash-b5b9abf4" : null;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\scriptUtils.ts
  var miscUtils4 = __toModule(require_miscUtils());
  var PackageManager;
  (function(PackageManager2) {
    PackageManager2["Yarn1"] = `Yarn Classic`;
    PackageManager2["Yarn2"] = `Yarn`;
    PackageManager2["Npm"] = `npm`;
    PackageManager2["Pnpm"] = `pnpm`;
  })(PackageManager || (PackageManager = {}));
  async function makePathWrapper(location, name, argv0, args = []) {
    if (process.platform === `win32`) {
      const cmdScript = `@goto #_undefined_# 2>NUL || @title %COMSPEC% & @"${argv0}" ${args.map((arg) => `"${arg.replace(`"`, `""`)}"`).join(` `)} %*`;
      await xfs.writeFilePromise(ppath.format({dir: location, name, ext: `.cmd`}), cmdScript);
    }
    await xfs.writeFilePromise(ppath.join(location, name), `#!/bin/sh
exec "${argv0}" ${args.map((arg) => `'${arg.replace(/'/g, `'"'"'`)}'`).join(` `)} "$@"
`);
    await xfs.chmodPromise(ppath.join(location, name), 493);
  }
  async function detectPackageManager(location) {
    let yarnLock = null;
    try {
      yarnLock = await xfs.readFilePromise(ppath.join(location, Filename.lockfile), `utf8`);
    } catch {
    }
    if (yarnLock !== null) {
      if (yarnLock.match(/^__metadata:$/m)) {
        return PackageManager.Yarn2;
      } else {
        return PackageManager.Yarn1;
      }
    }
    if (xfs.existsSync(ppath.join(location, `package-lock.json`)))
      return PackageManager.Npm;
    if (xfs.existsSync(ppath.join(location, `pnpm-lock.yaml`)))
      return PackageManager.Pnpm;
    return null;
  }
  async function makeScriptEnv({project, binFolder, lifecycleScript}) {
    const scriptEnv = {};
    for (const [key, value] of Object.entries(process.env))
      if (typeof value !== `undefined`)
        scriptEnv[key.toLowerCase() !== `path` ? key : `PATH`] = value;
    const nBinFolder = npath.fromPortablePath(binFolder);
    scriptEnv.BERRY_BIN_FOLDER = npath.fromPortablePath(nBinFolder);
    await makePathWrapper(binFolder, `node`, process.execPath);
    if (YarnVersion !== null) {
      await makePathWrapper(binFolder, `run`, process.execPath, [process.argv[1], `run`]);
      await makePathWrapper(binFolder, `yarn`, process.execPath, [process.argv[1]]);
      await makePathWrapper(binFolder, `yarnpkg`, process.execPath, [process.argv[1]]);
      await makePathWrapper(binFolder, `node-gyp`, process.execPath, [process.argv[1], `run`, `--top-level`, `node-gyp`]);
    }
    if (project) {
      scriptEnv.INIT_CWD = npath.fromPortablePath(project.configuration.startingCwd);
      scriptEnv.PROJECT_CWD = npath.fromPortablePath(project.cwd);
    }
    scriptEnv.PATH = scriptEnv.PATH ? `${nBinFolder}${npath.delimiter}${scriptEnv.PATH}` : `${nBinFolder}`;
    scriptEnv.npm_execpath = `${nBinFolder}${npath.sep}yarn`;
    scriptEnv.npm_node_execpath = `${nBinFolder}${npath.sep}node`;
    const version = YarnVersion !== null ? `yarn/${YarnVersion}` : `yarn/${miscUtils4.dynamicRequire(`@yarnpkg/core`).version}-core`;
    scriptEnv.npm_config_user_agent = `${version} npm/? node/${process.versions.node} ${process.platform} ${process.arch}`;
    if (lifecycleScript)
      scriptEnv.npm_lifecycle_event = lifecycleScript;
    if (project) {
      await project.configuration.triggerHook((hook) => hook.setupScriptEnvironment, project, scriptEnv, async (name, argv0, args) => {
        return await makePathWrapper(binFolder, toFilename(name), argv0, args);
      });
    }
    return scriptEnv;
  }
  var MAX_PREPARE_CONCURRENCY = 2;
  var prepareLimit = import_p_limit.default(MAX_PREPARE_CONCURRENCY);
  async function prepareExternalProject(cwd, outputPath, {configuration, report, workspace = null}) {
    await prepareLimit(async () => {
      await xfs.mktempPromise(async (logDir) => {
        const logFile = ppath.join(logDir, `pack.log`);
        const stdin = null;
        const {stdout, stderr} = configuration.getSubprocessStreams(logFile, {prefix: cwd, report});
        const packageManager = await detectPackageManager(cwd);
        let effectivePackageManager;
        if (packageManager !== null) {
          stdout.write(`Installing the project using ${packageManager}

`);
          effectivePackageManager = packageManager;
        } else {
          stdout.write(`No package manager detected; defaulting to Yarn

`);
          effectivePackageManager = PackageManager.Yarn2;
        }
        await xfs.mktempPromise(async (binFolder) => {
          const env = await makeScriptEnv({binFolder});
          const workflows = new Map([
            [PackageManager.Yarn1, async () => {
              const workspaceCli = workspace !== null ? [`workspace`, workspace] : [];
              const version = await pipevp(`yarn`, [`set`, `version`, `classic`, `--only-if-needed`], {cwd, env, stdin, stdout, stderr, end: EndStrategy.ErrorCode});
              if (version.code !== 0)
                return version.code;
              await xfs.appendFilePromise(ppath.join(cwd, `.npmignore`), `/.yarn
`);
              stdout.write(`
`);
              const install = await pipevp(`yarn`, [`install`], {cwd, env, stdin, stdout, stderr, end: EndStrategy.ErrorCode});
              if (install.code !== 0)
                return install.code;
              stdout.write(`
`);
              const pack = await pipevp(`yarn`, [...workspaceCli, `pack`, `--filename`, npath.fromPortablePath(outputPath)], {cwd, env, stdin, stdout, stderr});
              if (pack.code !== 0)
                return pack.code;
              return 0;
            }],
            [PackageManager.Yarn2, async () => {
              const workspaceCli = workspace !== null ? [`workspace`, workspace] : [];
              env.YARN_ENABLE_INLINE_BUILDS = `1`;
              const lockfilePath = ppath.join(cwd, Filename.lockfile);
              if (!await xfs.existsPromise(lockfilePath))
                await xfs.writeFilePromise(lockfilePath, ``);
              const pack = await pipevp(`yarn`, [...workspaceCli, `pack`, `--install-if-needed`, `--filename`, npath.fromPortablePath(outputPath)], {cwd, env, stdin, stdout, stderr});
              if (pack.code !== 0)
                return pack.code;
              return 0;
            }],
            [PackageManager.Npm, async () => {
              if (workspace !== null)
                throw new Error(`Workspaces aren't supported by npm, which has been detected as the primary package manager for ${cwd}`);
              delete env.npm_config_user_agent;
              const install = await pipevp(`npm`, [`install`], {cwd, env, stdin, stdout, stderr, end: EndStrategy.ErrorCode});
              if (install.code !== 0)
                return install.code;
              const packStream = new import_stream5.PassThrough();
              const packPromise = miscUtils4.bufferStream(packStream);
              packStream.pipe(stdout);
              const pack = await pipevp(`npm`, [`pack`, `--silent`], {cwd, env, stdin, stdout: packStream, stderr});
              if (pack.code !== 0)
                return pack.code;
              const packOutput = (await packPromise).toString().trim();
              const packTarget = ppath.resolve(cwd, npath.toPortablePath(packOutput));
              await xfs.renamePromise(packTarget, outputPath);
              return 0;
            }]
          ]);
          const workflow = workflows.get(effectivePackageManager);
          if (typeof workflow === `undefined`)
            throw new Error(`Assertion failed: Unsupported workflow`);
          const code = await workflow();
          if (code === 0 || typeof code === `undefined`)
            return;
          xfs.detachTemp(logDir);
          throw new ReportError(MessageName.PACKAGE_PREPARATION_FAILED, `Packing the package failed (exit code ${code}, logs can be found here: ${logFile})`);
        });
      });
    });
  }
  async function hasPackageScript(locator, scriptName, {project}) {
    const pkg = project.storedPackages.get(locator.locatorHash);
    if (!pkg)
      throw new Error(`Package for ${prettyLocator(project.configuration, locator)} not found in the project`);
    return await ZipOpenFS.openPromise(async (zipOpenFs) => {
      const configuration = project.configuration;
      const linkers = project.configuration.getLinkers();
      const linkerOptions = {project, report: new StreamReport({stdout: new import_stream5.PassThrough(), configuration})};
      const linker = linkers.find((linker2) => linker2.supportsPackage(pkg, linkerOptions));
      if (!linker)
        throw new Error(`The package ${prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
      const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
      const packageFs = new CwdFS(packageLocation, {baseFs: zipOpenFs});
      const manifest = await Manifest.find(PortablePath2.dot, {baseFs: packageFs});
      return manifest.scripts.has(scriptName);
    }, {
      libzip: await getLibzipPromise()
    });
  }
  async function executePackageScript(locator, scriptName, args, {cwd, project, stdin, stdout, stderr}) {
    return await xfs.mktempPromise(async (binFolder) => {
      const {manifest, env, cwd: realCwd} = await initializePackageEnvironment(locator, {project, binFolder, cwd, lifecycleScript: scriptName});
      const script = manifest.scripts.get(scriptName);
      if (typeof script === `undefined`)
        return 1;
      const realExecutor = async () => {
        return await execute2(script, args, {cwd: realCwd, env, stdin, stdout, stderr});
      };
      const executor = await project.configuration.reduceHook((hooks) => {
        return hooks.wrapScriptExecution;
      }, realExecutor, project, locator, scriptName, {
        script,
        args,
        cwd: realCwd,
        env,
        stdin,
        stdout,
        stderr
      });
      return await executor();
    });
  }
  async function executePackageShellcode(locator, command, args, {cwd, project, stdin, stdout, stderr}) {
    return await xfs.mktempPromise(async (binFolder) => {
      const {env, cwd: realCwd} = await initializePackageEnvironment(locator, {project, binFolder, cwd});
      return await execute2(command, args, {cwd: realCwd, env, stdin, stdout, stderr});
    });
  }
  async function initializePackageEnvironment(locator, {project, binFolder, cwd, lifecycleScript}) {
    const pkg = project.storedPackages.get(locator.locatorHash);
    if (!pkg)
      throw new Error(`Package for ${prettyLocator(project.configuration, locator)} not found in the project`);
    return await ZipOpenFS.openPromise(async (zipOpenFs) => {
      const configuration = project.configuration;
      const linkers = project.configuration.getLinkers();
      const linkerOptions = {project, report: new StreamReport({stdout: new import_stream5.PassThrough(), configuration})};
      const linker = linkers.find((linker2) => linker2.supportsPackage(pkg, linkerOptions));
      if (!linker)
        throw new Error(`The package ${prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
      const env = await makeScriptEnv({project, binFolder, lifecycleScript});
      await Promise.all(Array.from(await getPackageAccessibleBinaries(locator, {project}), ([binaryName, [, binaryPath]]) => makePathWrapper(binFolder, toFilename(binaryName), process.execPath, [binaryPath])));
      const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
      const packageFs = new CwdFS(packageLocation, {baseFs: zipOpenFs});
      const manifest = await Manifest.find(PortablePath2.dot, {baseFs: packageFs});
      if (typeof cwd === `undefined`)
        cwd = packageLocation;
      return {manifest, binFolder, env, cwd};
    }, {
      libzip: await getLibzipPromise()
    });
  }
  async function executeWorkspaceScript(workspace, scriptName, args, {cwd, stdin, stdout, stderr}) {
    return await executePackageScript(workspace.anchoredLocator, scriptName, args, {cwd, project: workspace.project, stdin, stdout, stderr});
  }
  function hasWorkspaceScript(workspace, scriptName) {
    return workspace.manifest.scripts.has(scriptName);
  }
  async function executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, {cwd, report}) {
    const {configuration} = workspace.project;
    const stdin = null;
    await xfs.mktempPromise(async (logDir) => {
      const logFile = ppath.join(logDir, `${lifecycleScriptName}.log`);
      const header = `# This file contains the result of Yarn calling the "${lifecycleScriptName}" lifecycle script inside a workspace ("${workspace.cwd}")
`;
      const {stdout, stderr} = configuration.getSubprocessStreams(logFile, {
        report,
        prefix: prettyLocator(configuration, workspace.anchoredLocator),
        header
      });
      report.reportInfo(MessageName.LIFECYCLE_SCRIPT, `Calling the "${lifecycleScriptName}" lifecycle script`);
      const exitCode = await executeWorkspaceScript(workspace, lifecycleScriptName, [], {cwd, stdin, stdout, stderr});
      stdout.end();
      stderr.end();
      if (exitCode !== 0) {
        xfs.detachTemp(logDir);
        throw new ReportError(MessageName.LIFECYCLE_SCRIPT, `${import_capitalize.default(lifecycleScriptName)} script failed (exit code ${pretty(configuration, exitCode, Type.NUMBER)}, logs can be found here: ${pretty(configuration, logFile, Type.PATH)}); run ${pretty(configuration, `yarn ${lifecycleScriptName}`, Type.CODE)} to investigate`);
      }
    });
  }
  async function maybeExecuteWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts) {
    if (hasWorkspaceScript(workspace, lifecycleScriptName)) {
      await executeWorkspaceLifecycleScript(workspace, lifecycleScriptName, opts);
    }
  }
  async function getPackageAccessibleBinaries(locator, {project}) {
    const configuration = project.configuration;
    const binaries = new Map();
    const pkg = project.storedPackages.get(locator.locatorHash);
    if (!pkg)
      throw new Error(`Package for ${prettyLocator(configuration, locator)} not found in the project`);
    const stdout = new import_stream5.Writable();
    const linkers = configuration.getLinkers();
    const linkerOptions = {project, report: new StreamReport({configuration, stdout})};
    const visibleLocators = new Set([locator.locatorHash]);
    for (const descriptor of pkg.dependencies.values()) {
      const resolution = project.storedResolutions.get(descriptor.descriptorHash);
      if (!resolution)
        throw new Error(`Assertion failed: The resolution (${prettyDescriptor(configuration, descriptor)}) should have been registered`);
      visibleLocators.add(resolution);
    }
    for (const locatorHash of visibleLocators) {
      const dependency = project.storedPackages.get(locatorHash);
      if (!dependency)
        throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
      if (dependency.bin.size === 0)
        continue;
      const linker = linkers.find((linker2) => linker2.supportsPackage(dependency, linkerOptions));
      if (!linker)
        continue;
      let packageLocation = null;
      try {
        packageLocation = await linker.findPackageLocation(dependency, linkerOptions);
      } catch (err) {
        if (err.code === `LOCATOR_NOT_INSTALLED`) {
          continue;
        } else {
          throw err;
        }
      }
      for (const [name, target] of dependency.bin) {
        binaries.set(name, [dependency, npath.fromPortablePath(ppath.resolve(packageLocation, target))]);
      }
    }
    return binaries;
  }
  async function getWorkspaceAccessibleBinaries(workspace) {
    return await getPackageAccessibleBinaries(workspace.anchoredLocator, {project: workspace.project});
  }
  async function executePackageAccessibleBinary(locator, binaryName, args, {cwd, project, stdin, stdout, stderr, nodeArgs = []}) {
    const packageAccessibleBinaries = await getPackageAccessibleBinaries(locator, {project});
    const binary = packageAccessibleBinaries.get(binaryName);
    if (!binary)
      throw new Error(`Binary not found (${binaryName}) for ${prettyLocator(project.configuration, locator)}`);
    return await xfs.mktempPromise(async (binFolder) => {
      const [, binaryPath] = binary;
      const env = await makeScriptEnv({project, binFolder});
      await Promise.all(Array.from(packageAccessibleBinaries, ([binaryName2, [, binaryPath2]]) => makePathWrapper(env.BERRY_BIN_FOLDER, toFilename(binaryName2), process.execPath, [binaryPath2])));
      let result;
      try {
        result = await pipevp(process.execPath, [...nodeArgs, binaryPath, ...args], {cwd, env, stdin, stdout, stderr});
      } finally {
        await xfs.removePromise(env.BERRY_BIN_FOLDER);
      }
      return result.code;
    });
  }
  async function executeWorkspaceAccessibleBinary(workspace, binaryName, args, {cwd, stdin, stdout, stderr}) {
    return await executePackageAccessibleBinary(workspace.anchoredLocator, binaryName, args, {project: workspace.project, cwd, stdin, stdout, stderr});
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\tgzUtils.ts
  var tgzUtils_exports = {};
  __export(tgzUtils_exports, {
    convertToZip: () => convertToZip,
    extractArchiveTo: () => extractArchiveTo,
    makeArchiveFromDirectory: () => makeArchiveFromDirectory
  });
  var import_stream6 = __toModule(require("stream"));
  var import_tar = __toModule(require_tar());
  var miscUtils5 = __toModule(require_miscUtils());
  async function makeArchiveFromDirectory(source, {baseFs = new NodeFS(), prefixPath = PortablePath2.root, compressionLevel, inMemory = false} = {}) {
    const libzip = await getLibzipPromise();
    let zipFs;
    if (inMemory) {
      zipFs = new ZipFS(null, {libzip, level: compressionLevel});
    } else {
      const tmpFolder = await xfs.mktempPromise();
      const tmpFile = ppath.join(tmpFolder, `archive.zip`);
      zipFs = new ZipFS(tmpFile, {create: true, libzip, level: compressionLevel});
    }
    const target = ppath.resolve(PortablePath2.root, prefixPath);
    await zipFs.copyPromise(target, source, {baseFs, stableTime: true, stableSort: true});
    return zipFs;
  }
  async function convertToZip(tgz, opts) {
    const tmpFolder = await xfs.mktempPromise();
    const tmpFile = ppath.join(tmpFolder, `archive.zip`);
    const {compressionLevel, ...bufferOpts} = opts;
    return await extractArchiveTo(tgz, new ZipFS(tmpFile, {create: true, libzip: await getLibzipPromise(), level: compressionLevel}), bufferOpts);
  }
  async function* parseTar(tgz) {
    const parser = new import_tar.default.Parse();
    const passthrough = new import_stream6.PassThrough({objectMode: true, autoDestroy: true, emitClose: true});
    parser.on(`entry`, (entry) => {
      passthrough.write(entry);
    });
    parser.on(`error`, (error) => {
      passthrough.destroy(error);
    });
    parser.on(`close`, () => {
      passthrough.destroy();
    });
    parser.end(tgz);
    for await (const entry of passthrough) {
      const it = entry;
      yield it;
      it.resume();
    }
  }
  async function extractArchiveTo(tgz, targetFs, {stripComponents = 0, prefixPath = PortablePath2.dot} = {}) {
    var _a2, _b;
    const defaultTime2 = 315532800;
    function ignore(entry) {
      if (entry.path[0] === `/`)
        return true;
      const parts = entry.path.split(/\//g);
      if (parts.some((part) => part === `..`))
        return true;
      if (parts.length <= stripComponents)
        return true;
      return false;
    }
    for await (const entry of parseTar(tgz)) {
      if (ignore(entry))
        continue;
      const parts = ppath.normalize(npath.toPortablePath(entry.path)).replace(/\/$/, ``).split(/\//g);
      if (parts.length <= stripComponents)
        continue;
      const slicePath = parts.slice(stripComponents).join(`/`);
      const mappedPath = ppath.join(prefixPath, slicePath);
      let mode = 420;
      if (entry.type === `Directory` || (((_a2 = entry.mode) != null ? _a2 : 0) & 73) !== 0)
        mode |= 73;
      switch (entry.type) {
        case `Directory`:
          {
            targetFs.mkdirpSync(ppath.dirname(mappedPath), {chmod: 493, utimes: [defaultTime2, defaultTime2]});
            targetFs.mkdirSync(mappedPath);
            targetFs.chmodSync(mappedPath, mode);
            targetFs.utimesSync(mappedPath, defaultTime2, defaultTime2);
          }
          break;
        case `OldFile`:
        case `File`:
          {
            targetFs.mkdirpSync(ppath.dirname(mappedPath), {chmod: 493, utimes: [defaultTime2, defaultTime2]});
            targetFs.writeFileSync(mappedPath, await miscUtils5.bufferStream(entry));
            targetFs.chmodSync(mappedPath, mode);
            targetFs.utimesSync(mappedPath, defaultTime2, defaultTime2);
          }
          break;
        case `SymbolicLink`:
          {
            targetFs.mkdirpSync(ppath.dirname(mappedPath), {chmod: 493, utimes: [defaultTime2, defaultTime2]});
            targetFs.symlinkSync(entry.linkpath, mappedPath);
            (_b = targetFs.lutimesSync) == null ? void 0 : _b.call(targetFs, mappedPath, defaultTime2, defaultTime2);
          }
          break;
      }
    }
    return targetFs;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\treeUtils.ts
  var treeUtils_exports = {};
  __export(treeUtils_exports, {
    emitList: () => emitList,
    emitTree: () => emitTree,
    treeNodeToJson: () => treeNodeToJson,
    treeNodeToTreeify: () => treeNodeToTreeify
  });
  var import_treeify = __toModule(require_treeify());
  function treeNodeToTreeify(printTree, {configuration}) {
    const target = {};
    const copyTree = (printNode, targetNode) => {
      const iterator = Array.isArray(printNode) ? printNode.entries() : Object.entries(printNode);
      for (const [key, {label, value, children}] of iterator) {
        const finalParts = [];
        if (typeof label !== `undefined`)
          finalParts.push(applyStyle(configuration, label, Style.BOLD));
        if (typeof value !== `undefined`)
          finalParts.push(pretty(configuration, value[0], value[1]));
        if (finalParts.length === 0)
          finalParts.push(applyStyle(configuration, `${key}`, Style.BOLD));
        const finalLabel = finalParts.join(`: `);
        const createdNode = targetNode[finalLabel] = {};
        if (typeof children !== `undefined`) {
          copyTree(children, createdNode);
        }
      }
    };
    if (typeof printTree.children === `undefined`)
      throw new Error(`The root node must only contain children`);
    copyTree(printTree.children, target);
    return target;
  }
  function treeNodeToJson(printTree) {
    const copyTree = (printNode) => {
      var _a2;
      if (typeof printNode.children === `undefined`) {
        if (typeof printNode.value === `undefined`)
          throw new Error(`Assertion failed: Expected a value to be set if the children are missing`);
        return json(printNode.value[0], printNode.value[1]);
      }
      const iterator = Array.isArray(printNode.children) ? printNode.children.entries() : Object.entries((_a2 = printNode.children) != null ? _a2 : {});
      const targetChildren = Array.isArray(printNode.children) ? [] : {};
      for (const [key, child] of iterator)
        targetChildren[key] = copyTree(child);
      if (typeof printNode.value === `undefined`)
        return targetChildren;
      return {
        value: json(printNode.value[0], printNode.value[1]),
        children: targetChildren
      };
    };
    return copyTree(printTree);
  }
  function emitList(values, {configuration, stdout, json: json2}) {
    const children = values.map((value) => ({value}));
    emitTree({children}, {configuration, stdout, json: json2});
  }
  function emitTree(tree, {configuration, stdout, json: json2, separators = 0}) {
    var _a2;
    if (json2) {
      const iterator = Array.isArray(tree.children) ? tree.children.values() : Object.values((_a2 = tree.children) != null ? _a2 : {});
      for (const child of iterator)
        stdout.write(`${JSON.stringify(treeNodeToJson(child))}
`);
      return;
    }
    let treeOutput = import_treeify.asTree(treeNodeToTreeify(tree, {configuration}), false, false);
    if (separators >= 1)
      treeOutput = treeOutput.replace(/^([├└]─)/gm, `\u2502
$1`).replace(/^│\n/, ``);
    if (separators >= 2)
      for (let t7 = 0; t7 < 2; ++t7)
        treeOutput = treeOutput.replace(/^([│ ].{2}[├│ ].{2}[^\n]+\n)(([│ ]).{2}[├└].{2}[^\n]*\n[│ ].{2}[│ ].{2}[├└]─)/gm, `$1$3  \u2502
$2`).replace(/^│\n/, ``);
    if (separators >= 3)
      throw new Error(`Only the first two levels are accepted by treeUtils.emitTree`);
    stdout.write(treeOutput);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Cache.ts
  var import_fs6 = __toModule(require("fs"));
  var miscUtils6 = __toModule(require_miscUtils());
  var CACHE_VERSION = 7;
  var Cache = class {
    constructor(cacheCwd, {configuration, immutable = configuration.get(`enableImmutableCache`), check = false}) {
      this.markedFiles = new Set();
      this.mutexes = new Map();
      this.configuration = configuration;
      this.cwd = cacheCwd;
      this.immutable = immutable;
      this.check = check;
      const cacheKeyOverride = configuration.get(`cacheKeyOverride`);
      if (cacheKeyOverride !== null) {
        this.cacheKey = `${cacheKeyOverride}`;
      } else {
        const compressionLevel = configuration.get(`compressionLevel`);
        const compressionKey = compressionLevel !== DEFAULT_COMPRESSION_LEVEL ? `c${compressionLevel}` : ``;
        this.cacheKey = [
          CACHE_VERSION,
          compressionKey
        ].join(``);
      }
    }
    static async find(configuration, {immutable, check} = {}) {
      const cache2 = new Cache(configuration.get(`cacheFolder`), {configuration, immutable, check});
      await cache2.setup();
      return cache2;
    }
    get mirrorCwd() {
      if (!this.configuration.get(`enableMirror`))
        return null;
      const mirrorCwd = `${this.configuration.get(`globalFolder`)}/cache`;
      return mirrorCwd !== this.cwd ? mirrorCwd : null;
    }
    getVersionFilename(locator) {
      return `${slugifyLocator(locator)}-${this.cacheKey}.zip`;
    }
    getChecksumFilename(locator, checksum) {
      const contentChecksum = getHashComponent(checksum);
      const significantChecksum = contentChecksum.slice(0, 10);
      return `${slugifyLocator(locator)}-${significantChecksum}.zip`;
    }
    getLocatorPath(locator, expectedChecksum) {
      if (this.mirrorCwd === null)
        return ppath.resolve(this.cwd, this.getVersionFilename(locator));
      if (expectedChecksum === null)
        return null;
      const cacheKey = getCacheKeyComponent(expectedChecksum);
      if (cacheKey !== this.cacheKey)
        return null;
      return ppath.resolve(this.cwd, this.getChecksumFilename(locator, expectedChecksum));
    }
    getLocatorMirrorPath(locator) {
      const mirrorCwd = this.mirrorCwd;
      return mirrorCwd !== null ? ppath.resolve(mirrorCwd, this.getVersionFilename(locator)) : null;
    }
    async setup() {
      if (!this.configuration.get(`enableGlobalCache`)) {
        await xfs.mkdirPromise(this.cwd, {recursive: true});
        const gitignorePath = ppath.resolve(this.cwd, `.gitignore`);
        await xfs.changeFilePromise(gitignorePath, `/.gitignore
*.flock
`);
      }
      await xfs.mkdirPromise(this.mirrorCwd || this.cwd, {recursive: true});
    }
    async fetchPackageFromCache(locator, expectedChecksum, {onHit, onMiss, loader, skipIntegrityCheck}) {
      const mirrorPath = this.getLocatorMirrorPath(locator);
      const baseFs = new NodeFS();
      const validateFile = async (path6, refetchPath = null) => {
        const actualChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await checksumFile(path6)}` : expectedChecksum;
        if (refetchPath !== null) {
          const previousChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await checksumFile(refetchPath)}` : expectedChecksum;
          if (actualChecksum !== previousChecksum) {
            throw new ReportError(MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the local checksum - has the local cache been corrupted?`);
          }
        }
        if (expectedChecksum !== null && actualChecksum !== expectedChecksum) {
          let checksumBehavior;
          if (this.check)
            checksumBehavior = `throw`;
          else if (getCacheKeyComponent(expectedChecksum) !== getCacheKeyComponent(actualChecksum))
            checksumBehavior = `update`;
          else
            checksumBehavior = this.configuration.get(`checksumBehavior`);
          switch (checksumBehavior) {
            case `ignore`:
              return expectedChecksum;
            case `update`:
              return actualChecksum;
            default:
            case `throw`: {
              throw new ReportError(MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the expected checksum`);
            }
          }
        }
        return actualChecksum;
      };
      const validateFileAgainstRemote = async (cachePath2) => {
        if (!loader)
          throw new Error(`Cache check required but no loader configured for ${prettyLocator(this.configuration, locator)}`);
        const zipFs2 = await loader();
        const refetchPath = zipFs2.getRealPath();
        zipFs2.saveAndClose();
        await xfs.chmodPromise(refetchPath, 420);
        return await validateFile(cachePath2, refetchPath);
      };
      const loadPackageThroughMirror = async () => {
        if (mirrorPath === null || !await xfs.existsPromise(mirrorPath)) {
          const zipFs2 = await loader();
          const realPath = zipFs2.getRealPath();
          zipFs2.saveAndClose();
          return realPath;
        }
        const tempDir = await xfs.mktempPromise();
        const tempPath = ppath.join(tempDir, this.getVersionFilename(locator));
        await xfs.copyFilePromise(mirrorPath, tempPath, import_fs6.default.constants.COPYFILE_FICLONE);
        return tempPath;
      };
      const loadPackage = async () => {
        if (!loader)
          throw new Error(`Cache entry required but missing for ${prettyLocator(this.configuration, locator)}`);
        if (this.immutable)
          throw new ReportError(MessageName.IMMUTABLE_CACHE, `Cache entry required but missing for ${prettyLocator(this.configuration, locator)}`);
        const originalPath = await loadPackageThroughMirror();
        await xfs.chmodPromise(originalPath, 420);
        const checksum2 = await validateFile(originalPath);
        const cachePath2 = this.getLocatorPath(locator, checksum2);
        if (!cachePath2)
          throw new Error(`Assertion failed: Expected the cache path to be available`);
        return await this.writeFileWithLock(cachePath2, async () => {
          return await this.writeFileWithLock(mirrorPath, async () => {
            await xfs.movePromise(originalPath, cachePath2);
            if (mirrorPath !== null)
              await xfs.copyFilePromise(cachePath2, mirrorPath, import_fs6.default.constants.COPYFILE_FICLONE);
            return [cachePath2, checksum2];
          });
        });
      };
      const loadPackageThroughMutex = async () => {
        const mutexedLoad = async () => {
          const tentativeCachePath = this.getLocatorPath(locator, expectedChecksum);
          const cacheExists = tentativeCachePath !== null ? await baseFs.existsPromise(tentativeCachePath) : false;
          const action = cacheExists ? onHit : onMiss;
          if (action)
            action();
          if (!cacheExists) {
            return loadPackage();
          } else {
            let checksum2 = null;
            const cachePath2 = tentativeCachePath;
            if (this.check)
              checksum2 = await validateFileAgainstRemote(cachePath2);
            else
              checksum2 = await validateFile(cachePath2);
            return [cachePath2, checksum2];
          }
        };
        const mutex = mutexedLoad();
        this.mutexes.set(locator.locatorHash, mutex);
        try {
          return await mutex;
        } finally {
          this.mutexes.delete(locator.locatorHash);
        }
      };
      for (let mutex; mutex = this.mutexes.get(locator.locatorHash); )
        await mutex;
      const [cachePath, checksum] = await loadPackageThroughMutex();
      this.markedFiles.add(cachePath);
      let zipFs = null;
      const libzip = await getLibzipPromise();
      const lazyFs = new LazyFS(() => miscUtils6.prettifySyncErrors(() => {
        return zipFs = new ZipFS(cachePath, {baseFs, libzip, readOnly: true});
      }, (message) => {
        return `Failed to open the cache entry for ${prettyLocator(this.configuration, locator)}: ${message}`;
      }), ppath);
      const aliasFs = new AliasFS(cachePath, {baseFs: lazyFs, pathUtils: ppath});
      const releaseFs = () => {
        if (zipFs !== null) {
          zipFs.discardAndClose();
        }
      };
      return [aliasFs, releaseFs, checksum];
    }
    async writeFileWithLock(file, generator) {
      if (file === null)
        return await generator();
      return await xfs.lockPromise(file, async () => {
        return await generator();
      });
    }
  };
  function getCacheKeyComponent(checksum) {
    const split2 = checksum.indexOf(`/`);
    return split2 !== -1 ? checksum.slice(0, split2) : null;
  }
  function getHashComponent(checksum) {
    const split2 = checksum.indexOf(`/`);
    return split2 !== -1 ? checksum.slice(split2 + 1) : checksum;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Configuration.ts
  var import_camelcase = __toModule(require_camelcase());
  var import_ci_info = __toModule(require_ci_info());
  var import_p_limit2 = __toModule(require_p_limit());
  var import_semver6 = __toModule(require_semver2());
  var import_stream7 = __toModule(require("stream"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\CorePlugin.ts
  var CorePlugin = {
    hooks: {
      reduceDependency: (dependency, project, locator, initialDependency, {resolver, resolveOptions}) => {
        for (const {pattern, reference} of project.topLevelWorkspace.manifest.resolutions) {
          if (pattern.from && pattern.from.fullName !== stringifyIdent(locator))
            continue;
          if (pattern.from && pattern.from.description && pattern.from.description !== locator.reference)
            continue;
          if (pattern.descriptor.fullName !== stringifyIdent(dependency))
            continue;
          if (pattern.descriptor.description && pattern.descriptor.description !== dependency.range)
            continue;
          const alias = resolver.bindDescriptor(makeDescriptor(dependency, reference), project.topLevelWorkspace.anchoredLocator, resolveOptions);
          return alias;
        }
        return dependency;
      },
      validateProject: async (project, report) => {
        for (const workspace of project.workspaces) {
          const workspaceName = prettyWorkspace(project.configuration, workspace);
          await project.configuration.triggerHook((hooks) => {
            return hooks.validateWorkspace;
          }, workspace, {
            reportWarning: (name, text) => report.reportWarning(name, `${workspaceName}: ${text}`),
            reportError: (name, text) => report.reportError(name, `${workspaceName}: ${text}`)
          });
        }
      },
      validateWorkspace: async (workspace, report) => {
        const {manifest} = workspace;
        if (manifest.resolutions.length && workspace.cwd !== workspace.project.cwd)
          manifest.errors.push(new Error(`Resolutions field will be ignored`));
        for (const manifestError of manifest.errors) {
          report.reportWarning(MessageName.INVALID_MANIFEST, manifestError.message);
        }
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\MultiFetcher.ts
  var MultiFetcher = class {
    constructor(fetchers) {
      this.fetchers = fetchers;
    }
    supports(locator, opts) {
      if (!this.tryFetcher(locator, opts))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      const fetcher = this.getFetcher(locator, opts);
      return fetcher.getLocalPath(locator, opts);
    }
    async fetch(locator, opts) {
      const fetcher = this.getFetcher(locator, opts);
      return await fetcher.fetch(locator, opts);
    }
    tryFetcher(locator, opts) {
      const fetcher = this.fetchers.find((fetcher2) => fetcher2.supports(locator, opts));
      if (!fetcher)
        return null;
      return fetcher;
    }
    getFetcher(locator, opts) {
      const fetcher = this.fetchers.find((fetcher2) => fetcher2.supports(locator, opts));
      if (!fetcher)
        throw new ReportError(MessageName.FETCHER_NOT_FOUND, `${prettyLocator(opts.project.configuration, locator)} isn't supported by any available fetcher`);
      return fetcher;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\MultiResolver.ts
  var MultiResolver = class {
    constructor(resolvers) {
      this.resolvers = resolvers.filter((resolver) => resolver);
    }
    supportsDescriptor(descriptor, opts) {
      const resolver = this.tryResolverByDescriptor(descriptor, opts);
      return !!resolver;
    }
    supportsLocator(locator, opts) {
      const resolver = this.tryResolverByLocator(locator, opts);
      return !!resolver;
    }
    shouldPersistResolution(locator, opts) {
      const resolver = this.getResolverByLocator(locator, opts);
      return resolver.shouldPersistResolution(locator, opts);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      const resolver = this.getResolverByDescriptor(descriptor, opts);
      return resolver.bindDescriptor(descriptor, fromLocator, opts);
    }
    getResolutionDependencies(descriptor, opts) {
      const resolver = this.getResolverByDescriptor(descriptor, opts);
      return resolver.getResolutionDependencies(descriptor, opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
      const resolver = this.getResolverByDescriptor(descriptor, opts);
      return await resolver.getCandidates(descriptor, dependencies, opts);
    }
    async getSatisfying(descriptor, references, opts) {
      const resolver = this.getResolverByDescriptor(descriptor, opts);
      return resolver.getSatisfying(descriptor, references, opts);
    }
    async resolve(locator, opts) {
      const resolver = this.getResolverByLocator(locator, opts);
      return await resolver.resolve(locator, opts);
    }
    tryResolverByDescriptor(descriptor, opts) {
      const resolver = this.resolvers.find((resolver2) => resolver2.supportsDescriptor(descriptor, opts));
      if (!resolver)
        return null;
      return resolver;
    }
    getResolverByDescriptor(descriptor, opts) {
      const resolver = this.resolvers.find((resolver2) => resolver2.supportsDescriptor(descriptor, opts));
      if (!resolver)
        throw new Error(`${prettyDescriptor(opts.project.configuration, descriptor)} isn't supported by any available resolver`);
      return resolver;
    }
    tryResolverByLocator(locator, opts) {
      const resolver = this.resolvers.find((resolver2) => resolver2.supportsLocator(locator, opts));
      if (!resolver)
        return null;
      return resolver;
    }
    getResolverByLocator(locator, opts) {
      const resolver = this.resolvers.find((resolver2) => resolver2.supportsLocator(locator, opts));
      if (!resolver)
        throw new Error(`${prettyLocator(opts.project.configuration, locator)} isn't supported by any available resolver`);
      return resolver;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\ProtocolResolver.ts
  var import_semver5 = __toModule(require_semver2());
  var TAG_REGEXP = /^(?!v)[a-z0-9-.]+$/i;
  var ProtocolResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (validRange(descriptor.range))
        return true;
      if (TAG_REGEXP.test(descriptor.range))
        return true;
      return false;
    }
    supportsLocator(locator, opts) {
      if (import_semver5.default.valid(locator.reference))
        return true;
      if (TAG_REGEXP.test(locator.reference))
        return true;
      return false;
    }
    shouldPersistResolution(locator, opts) {
      return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
    }
    getResolutionDependencies(descriptor, opts) {
      return opts.resolver.getResolutionDependencies(this.forwardDescriptor(descriptor, opts), opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
      return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), dependencies, opts);
    }
    async getSatisfying(descriptor, references, opts) {
      return await opts.resolver.getSatisfying(this.forwardDescriptor(descriptor, opts), references, opts);
    }
    async resolve(locator, opts) {
      const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
      return renamePackage(pkg, locator);
    }
    forwardDescriptor(descriptor, opts) {
      return makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
    }
    forwardLocator(locator, opts) {
      return makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\VirtualFetcher.ts
  var VirtualFetcher = class {
    supports(locator) {
      if (!locator.reference.startsWith(`virtual:`))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      const splitPoint = locator.reference.indexOf(`#`);
      if (splitPoint === -1)
        throw new Error(`Invalid virtual package reference`);
      const nextReference = locator.reference.slice(splitPoint + 1);
      const nextLocator = makeLocator(locator, nextReference);
      return opts.fetcher.getLocalPath(nextLocator, opts);
    }
    async fetch(locator, opts) {
      const splitPoint = locator.reference.indexOf(`#`);
      if (splitPoint === -1)
        throw new Error(`Invalid virtual package reference`);
      const nextReference = locator.reference.slice(splitPoint + 1);
      const nextLocator = makeLocator(locator, nextReference);
      const parentFetch = await opts.fetcher.fetch(nextLocator, opts);
      return await this.ensureVirtualLink(locator, parentFetch, opts);
    }
    getLocatorFilename(locator) {
      return slugifyLocator(locator);
    }
    async ensureVirtualLink(locator, sourceFetch, opts) {
      const to = sourceFetch.packageFs.getRealPath();
      const virtualFolder = opts.project.configuration.get(`virtualFolder`);
      const virtualName = this.getLocatorFilename(locator);
      const virtualPath = VirtualFS.makeVirtualPath(virtualFolder, virtualName, to);
      const aliasFs = new AliasFS(virtualPath, {baseFs: sourceFetch.packageFs, pathUtils: ppath});
      return {...sourceFetch, packageFs: aliasFs};
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\VirtualResolver.ts
  var VirtualResolver2 = class {
    static isVirtualDescriptor(descriptor) {
      if (!descriptor.range.startsWith(VirtualResolver2.protocol))
        return false;
      return true;
    }
    static isVirtualLocator(locator) {
      if (!locator.reference.startsWith(VirtualResolver2.protocol))
        return false;
      return true;
    }
    supportsDescriptor(descriptor, opts) {
      return VirtualResolver2.isVirtualDescriptor(descriptor);
    }
    supportsLocator(locator, opts) {
      return VirtualResolver2.isVirtualLocator(locator);
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, locator, opts) {
      throw new Error(`Assertion failed: calling "bindDescriptor" on a virtual descriptor is unsupported`);
    }
    getResolutionDependencies(descriptor, opts) {
      throw new Error(`Assertion failed: calling "getResolutionDependencies" on a virtual descriptor is unsupported`);
    }
    async getCandidates(descriptor, dependencies, opts) {
      throw new Error(`Assertion failed: calling "getCandidates" on a virtual descriptor is unsupported`);
    }
    async getSatisfying(descriptor, candidates, opts) {
      throw new Error(`Assertion failed: calling "getSatisfying" on a virtual descriptor is unsupported`);
    }
    async resolve(locator, opts) {
      throw new Error(`Assertion failed: calling "resolve" on a virtual locator is unsupported`);
    }
  };
  var VirtualResolver = VirtualResolver2;
  VirtualResolver.protocol = `virtual:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\WorkspaceResolver.ts
  var WorkspaceResolver2 = class {
    supportsDescriptor(descriptor, opts) {
      if (descriptor.range.startsWith(WorkspaceResolver2.protocol))
        return true;
      const workspace = opts.project.tryWorkspaceByDescriptor(descriptor);
      if (workspace !== null)
        return true;
      return false;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(WorkspaceResolver2.protocol))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const workspace = opts.project.getWorkspaceByDescriptor(descriptor);
      return [workspace.anchoredLocator];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      const workspace = opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver2.protocol.length));
      return {
        ...locator,
        version: workspace.manifest.version || `0.0.0`,
        languageName: `unknown`,
        linkType: LinkType.SOFT,
        dependencies: new Map([...workspace.manifest.dependencies, ...workspace.manifest.devDependencies]),
        peerDependencies: new Map([...workspace.manifest.peerDependencies]),
        dependenciesMeta: workspace.manifest.dependenciesMeta,
        peerDependenciesMeta: workspace.manifest.peerDependenciesMeta,
        bin: workspace.manifest.bin
      };
    }
  };
  var WorkspaceResolver = WorkspaceResolver2;
  WorkspaceResolver.protocol = `workspace:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\WorkspaceFetcher.ts
  var WorkspaceFetcher = class {
    supports(locator) {
      if (!locator.reference.startsWith(WorkspaceResolver.protocol))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return this.getWorkspace(locator, opts).cwd;
    }
    async fetch(locator, opts) {
      const sourcePath = this.getWorkspace(locator, opts).cwd;
      return {packageFs: new CwdFS(sourcePath), prefixPath: PortablePath2.dot, localPath: sourcePath};
    }
    getWorkspace(locator, opts) {
      return opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver.protocol.length));
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Configuration.ts
  var miscUtils7 = __toModule(require_miscUtils());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\nodeUtils.ts
  var import_module = __toModule(require("module"));
  function builtinModules() {
    return new Set(import_module.default.builtinModules || Object.keys(process.binding(`natives`)));
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Configuration.ts
  var IGNORED_ENV_VARIABLES = new Set([
    `binFolder`,
    `version`,
    `flags`,
    `profile`,
    `gpg`,
    `ignoreNode`,
    `wrapOutput`
  ]);
  var ENVIRONMENT_PREFIX = `yarn_`;
  var DEFAULT_RC_FILENAME = `.yarnrc.yml`;
  var DEFAULT_LOCK_FILENAME = `yarn.lock`;
  var SECRET = `********`;
  var SettingsType;
  (function(SettingsType2) {
    SettingsType2["ANY"] = `ANY`;
    SettingsType2["BOOLEAN"] = `BOOLEAN`;
    SettingsType2["ABSOLUTE_PATH"] = `ABSOLUTE_PATH`;
    SettingsType2["LOCATOR"] = `LOCATOR`;
    SettingsType2["LOCATOR_LOOSE"] = `LOCATOR_LOOSE`;
    SettingsType2["NUMBER"] = `NUMBER`;
    SettingsType2["STRING"] = `STRING`;
    SettingsType2["SECRET"] = `SECRET`;
    SettingsType2["SHAPE"] = `SHAPE`;
    SettingsType2["MAP"] = `MAP`;
  })(SettingsType || (SettingsType = {}));
  var FormatType = Type;
  var coreDefinitions = {
    lastUpdateCheck: {
      description: `Last timestamp we checked whether new Yarn versions were available`,
      type: SettingsType.STRING,
      default: null
    },
    yarnPath: {
      description: `Path to the local executable that must be used over the global one`,
      type: SettingsType.ABSOLUTE_PATH,
      default: null
    },
    ignorePath: {
      description: `If true, the local executable will be ignored when using the global one`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    ignoreCwd: {
      description: `If true, the \`--cwd\` flag will be ignored`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    cacheKeyOverride: {
      description: `A global cache key override; used only for test purposes`,
      type: SettingsType.STRING,
      default: null
    },
    globalFolder: {
      description: `Folder where are stored the system-wide settings`,
      type: SettingsType.ABSOLUTE_PATH,
      default: getDefaultGlobalFolder()
    },
    cacheFolder: {
      description: `Folder where the cache files must be written`,
      type: SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/cache`
    },
    compressionLevel: {
      description: `Zip files compression level, from 0 to 9 or mixed (a variant of 9, which stores some files uncompressed, when compression doesn't yield good results)`,
      type: SettingsType.NUMBER,
      values: [`mixed`, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      default: DEFAULT_COMPRESSION_LEVEL
    },
    virtualFolder: {
      description: `Folder where the virtual packages (cf doc) will be mapped on the disk (must be named $$virtual)`,
      type: SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/$$virtual`
    },
    bstatePath: {
      description: `Path of the file where the current state of the built packages must be stored`,
      type: SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/build-state.yml`
    },
    lockfileFilename: {
      description: `Name of the files where the Yarn dependency tree entries must be stored`,
      type: SettingsType.STRING,
      default: DEFAULT_LOCK_FILENAME
    },
    installStatePath: {
      description: `Path of the file where the install state will be persisted`,
      type: SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/install-state.gz`
    },
    immutablePatterns: {
      description: `Array of glob patterns; files matching them won't be allowed to change during immutable installs`,
      type: SettingsType.STRING,
      default: [],
      isArray: true
    },
    rcFilename: {
      description: `Name of the files where the configuration can be found`,
      type: SettingsType.STRING,
      default: getRcFilename()
    },
    enableGlobalCache: {
      description: `If true, the system-wide cache folder will be used regardless of \`cache-folder\``,
      type: SettingsType.BOOLEAN,
      default: false
    },
    enableAbsoluteVirtuals: {
      description: `If true, the virtual symlinks will use absolute paths if required [non portable!!]`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    enableColors: {
      description: `If true, the CLI is allowed to use colors in its output`,
      type: SettingsType.BOOLEAN,
      default: supportsColor,
      defaultText: `<dynamic>`
    },
    enableHyperlinks: {
      description: `If true, the CLI is allowed to use hyperlinks in its output`,
      type: SettingsType.BOOLEAN,
      default: supportsHyperlinks,
      defaultText: `<dynamic>`
    },
    enableInlineBuilds: {
      description: `If true, the CLI will print the build output on the command line`,
      type: SettingsType.BOOLEAN,
      default: import_ci_info.isCI,
      defaultText: `<dynamic>`
    },
    enableProgressBars: {
      description: `If true, the CLI is allowed to show a progress bar for long-running events`,
      type: SettingsType.BOOLEAN,
      default: !import_ci_info.isCI && process.stdout.isTTY && process.stdout.columns > 22,
      defaultText: `<dynamic>`
    },
    enableTimers: {
      description: `If true, the CLI is allowed to print the time spent executing commands`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    preferAggregateCacheInfo: {
      description: `If true, the CLI will only print a one-line report of any cache changes`,
      type: SettingsType.BOOLEAN,
      default: import_ci_info.isCI
    },
    preferInteractive: {
      description: `If true, the CLI will automatically use the interactive mode when called from a TTY`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    preferTruncatedLines: {
      description: `If true, the CLI will truncate lines that would go beyond the size of the terminal`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    progressBarStyle: {
      description: `Which style of progress bar should be used (only when progress bars are enabled)`,
      type: SettingsType.STRING,
      default: void 0,
      defaultText: `<dynamic>`
    },
    defaultLanguageName: {
      description: `Default language mode that should be used when a package doesn't offer any insight`,
      type: SettingsType.STRING,
      default: `node`
    },
    defaultProtocol: {
      description: `Default resolution protocol used when resolving pure semver and tag ranges`,
      type: SettingsType.STRING,
      default: `npm:`
    },
    enableTransparentWorkspaces: {
      description: `If false, Yarn won't automatically resolve workspace dependencies unless they use the \`workspace:\` protocol`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    enableMirror: {
      description: `If true, the downloaded packages will be retrieved and stored in both the local and global folders`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    enableNetwork: {
      description: `If false, the package manager will refuse to use the network if required to`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    httpProxy: {
      description: `URL of the http proxy that must be used for outgoing http requests`,
      type: SettingsType.STRING,
      default: null
    },
    httpsProxy: {
      description: `URL of the http proxy that must be used for outgoing https requests`,
      type: SettingsType.STRING,
      default: null
    },
    unsafeHttpWhitelist: {
      description: `List of the hostnames for which http queries are allowed (glob patterns are supported)`,
      type: SettingsType.STRING,
      default: [],
      isArray: true
    },
    httpTimeout: {
      description: `Timeout of each http request in milliseconds`,
      type: SettingsType.NUMBER,
      default: 6e4
    },
    httpRetry: {
      description: `Retry times on http failure`,
      type: SettingsType.NUMBER,
      default: 3
    },
    networkConcurrency: {
      description: `Maximal number of concurrent requests`,
      type: SettingsType.NUMBER,
      default: Infinity
    },
    networkSettings: {
      description: `Network settings per hostname (glob patterns are supported)`,
      type: SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: SettingsType.SHAPE,
        properties: {
          caFilePath: {
            description: `Path to file containing one or multiple Certificate Authority signing certificates`,
            type: SettingsType.ABSOLUTE_PATH,
            default: null
          },
          enableNetwork: {
            description: `If false, the package manager will refuse to use the network if required to`,
            type: SettingsType.BOOLEAN,
            default: null
          },
          httpProxy: {
            description: `URL of the http proxy that must be used for outgoing http requests`,
            type: SettingsType.STRING,
            default: null
          },
          httpsProxy: {
            description: `URL of the http proxy that must be used for outgoing https requests`,
            type: SettingsType.STRING,
            default: null
          }
        }
      }
    },
    caFilePath: {
      description: `A path to a file containing one or multiple Certificate Authority signing certificates`,
      type: SettingsType.ABSOLUTE_PATH,
      default: null
    },
    enableStrictSsl: {
      description: `If false, SSL certificate errors will be ignored`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    logFilters: {
      description: `Overrides for log levels`,
      type: SettingsType.SHAPE,
      isArray: true,
      concatenateValues: true,
      properties: {
        code: {
          description: `Code of the messages covered by this override`,
          type: SettingsType.STRING,
          default: void 0
        },
        text: {
          description: `Code of the texts covered by this override`,
          type: SettingsType.STRING,
          default: void 0
        },
        level: {
          description: `Log level override, set to null to remove override`,
          type: SettingsType.STRING,
          values: Object.values(LogLevel),
          isNullable: true,
          default: void 0
        }
      }
    },
    enableTelemetry: {
      description: `If true, telemetry will be periodically sent, following the rules in https://yarnpkg.com/advanced/telemetry`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    telemetryInterval: {
      description: `Minimal amount of time between two telemetry uploads, in days`,
      type: SettingsType.NUMBER,
      default: 7
    },
    telemetryUserId: {
      description: `If you desire to tell us which project you are, you can set this field. Completely optional and opt-in.`,
      type: SettingsType.STRING,
      default: null
    },
    enableScripts: {
      description: `If true, packages are allowed to have install scripts by default`,
      type: SettingsType.BOOLEAN,
      default: true
    },
    enableImmutableCache: {
      description: `If true, the cache is reputed immutable and actions that would modify it will throw`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    checksumBehavior: {
      description: `Enumeration defining what to do when a checksum doesn't match expectations`,
      type: SettingsType.STRING,
      default: `throw`
    },
    packageExtensions: {
      description: `Map of package corrections to apply on the dependency tree`,
      type: SettingsType.MAP,
      valueDefinition: {
        description: `The extension that will be applied to any package whose version matches the specified range`,
        type: SettingsType.SHAPE,
        properties: {
          dependencies: {
            description: `The set of dependencies that must be made available to the current package in order for it to work properly`,
            type: SettingsType.MAP,
            valueDefinition: {
              description: `A range`,
              type: SettingsType.STRING
            }
          },
          peerDependencies: {
            description: `Inherited dependencies - the consumer of the package will be tasked to provide them`,
            type: SettingsType.MAP,
            valueDefinition: {
              description: `A semver range`,
              type: SettingsType.STRING
            }
          },
          peerDependenciesMeta: {
            description: `Extra information related to the dependencies listed in the peerDependencies field`,
            type: SettingsType.MAP,
            valueDefinition: {
              description: `The peerDependency meta`,
              type: SettingsType.SHAPE,
              properties: {
                optional: {
                  description: `If true, the selected peer dependency will be marked as optional by the package manager and the consumer omitting it won't be reported as an error`,
                  type: SettingsType.BOOLEAN,
                  default: false
                }
              }
            }
          }
        }
      }
    }
  };
  function parseValue(configuration, path6, value, definition, folder) {
    if (definition.isArray || definition.type === SettingsType.ANY && Array.isArray(value)) {
      if (!Array.isArray(value)) {
        return String(value).split(/,/).map((segment) => {
          return parseSingleValue(configuration, path6, segment, definition, folder);
        });
      } else {
        return value.map((sub, i) => parseSingleValue(configuration, `${path6}[${i}]`, sub, definition, folder));
      }
    } else {
      if (Array.isArray(value)) {
        throw new Error(`Non-array configuration settings "${path6}" cannot be an array`);
      } else {
        return parseSingleValue(configuration, path6, value, definition, folder);
      }
    }
  }
  function parseSingleValue(configuration, path6, value, definition, folder) {
    var _a2;
    switch (definition.type) {
      case SettingsType.ANY:
        return value;
      case SettingsType.SHAPE:
        return parseShape(configuration, path6, value, definition, folder);
      case SettingsType.MAP:
        return parseMap(configuration, path6, value, definition, folder);
    }
    if (value === null && !definition.isNullable && definition.default !== null)
      throw new Error(`Non-nullable configuration settings "${path6}" cannot be set to null`);
    if ((_a2 = definition.values) == null ? void 0 : _a2.includes(value))
      return value;
    const interpretValue = () => {
      if (definition.type === SettingsType.BOOLEAN)
        return miscUtils7.parseBoolean(value);
      if (typeof value !== `string`)
        throw new Error(`Expected value (${value}) to be a string`);
      const valueWithReplacedVariables = miscUtils7.replaceEnvVariables(value, {
        env: process.env
      });
      switch (definition.type) {
        case SettingsType.ABSOLUTE_PATH:
          return ppath.resolve(folder, npath.toPortablePath(valueWithReplacedVariables));
        case SettingsType.LOCATOR_LOOSE:
          return parseLocator(valueWithReplacedVariables, false);
        case SettingsType.NUMBER:
          return parseInt(valueWithReplacedVariables);
        case SettingsType.LOCATOR:
          return parseLocator(valueWithReplacedVariables);
        default:
          return valueWithReplacedVariables;
      }
    };
    const interpreted = interpretValue();
    if (definition.values && !definition.values.includes(interpreted))
      throw new Error(`Invalid value, expected one of ${definition.values.join(`, `)}`);
    return interpreted;
  }
  function parseShape(configuration, path6, value, definition, folder) {
    if (typeof value !== `object` || Array.isArray(value))
      throw new UsageError(`Object configuration settings "${path6}" must be an object`);
    const result = getDefaultValue(configuration, definition, {
      ignoreArrays: true
    });
    if (value === null)
      return result;
    for (const [propKey, propValue] of Object.entries(value)) {
      const subPath = `${path6}.${propKey}`;
      const subDefinition = definition.properties[propKey];
      if (!subDefinition)
        throw new UsageError(`Unrecognized configuration settings found: ${path6}.${propKey} - run "yarn config -v" to see the list of settings supported in Yarn`);
      result.set(propKey, parseValue(configuration, subPath, propValue, definition.properties[propKey], folder));
    }
    return result;
  }
  function parseMap(configuration, path6, value, definition, folder) {
    const result = new Map();
    if (typeof value !== `object` || Array.isArray(value))
      throw new UsageError(`Map configuration settings "${path6}" must be an object`);
    if (value === null)
      return result;
    for (const [propKey, propValue] of Object.entries(value)) {
      const normalizedKey = definition.normalizeKeys ? definition.normalizeKeys(propKey) : propKey;
      const subPath = `${path6}['${normalizedKey}']`;
      const valueDefinition = definition.valueDefinition;
      result.set(normalizedKey, parseValue(configuration, subPath, propValue, valueDefinition, folder));
    }
    return result;
  }
  function getDefaultValue(configuration, definition, {ignoreArrays = false} = {}) {
    switch (definition.type) {
      case SettingsType.SHAPE:
        {
          if (definition.isArray && !ignoreArrays)
            return [];
          const result = new Map();
          for (const [propKey, propDefinition] of Object.entries(definition.properties))
            result.set(propKey, getDefaultValue(configuration, propDefinition));
          return result;
        }
        break;
      case SettingsType.MAP:
        {
          if (definition.isArray && !ignoreArrays)
            return [];
          return new Map();
        }
        break;
      case SettingsType.ABSOLUTE_PATH:
        {
          if (definition.default === null)
            return null;
          if (configuration.projectCwd === null) {
            if (ppath.isAbsolute(definition.default)) {
              return ppath.normalize(definition.default);
            } else if (definition.isNullable) {
              return null;
            } else {
              return void 0;
            }
          } else {
            if (Array.isArray(definition.default)) {
              return definition.default.map((entry) => ppath.resolve(configuration.projectCwd, entry));
            } else {
              return ppath.resolve(configuration.projectCwd, definition.default);
            }
          }
        }
        break;
      default:
        {
          return definition.default;
        }
        break;
    }
  }
  function transformConfiguration(rawValue, definition, transforms2) {
    if (definition.type === SettingsType.SECRET && typeof rawValue === `string` && transforms2.hideSecrets)
      return SECRET;
    if (definition.type === SettingsType.ABSOLUTE_PATH && typeof rawValue === `string` && transforms2.getNativePaths)
      return npath.fromPortablePath(rawValue);
    if (definition.isArray && Array.isArray(rawValue)) {
      const newValue = [];
      for (const value of rawValue)
        newValue.push(transformConfiguration(value, definition, transforms2));
      return newValue;
    }
    if (definition.type === SettingsType.MAP && rawValue instanceof Map) {
      const newValue = new Map();
      for (const [key, value] of rawValue.entries())
        newValue.set(key, transformConfiguration(value, definition.valueDefinition, transforms2));
      return newValue;
    }
    if (definition.type === SettingsType.SHAPE && rawValue instanceof Map) {
      const newValue = new Map();
      for (const [key, value] of rawValue.entries()) {
        const propertyDefinition = definition.properties[key];
        newValue.set(key, transformConfiguration(value, propertyDefinition, transforms2));
      }
      return newValue;
    }
    return rawValue;
  }
  function getEnvironmentSettings() {
    const environmentSettings = {};
    for (let [key, value] of Object.entries(process.env)) {
      key = key.toLowerCase();
      if (!key.startsWith(ENVIRONMENT_PREFIX))
        continue;
      key = import_camelcase.default(key.slice(ENVIRONMENT_PREFIX.length));
      environmentSettings[key] = value;
    }
    return environmentSettings;
  }
  function getRcFilename() {
    const rcKey = `${ENVIRONMENT_PREFIX}rc_filename`;
    for (const [key, value] of Object.entries(process.env))
      if (key.toLowerCase() === rcKey && typeof value === `string`)
        return value;
    return DEFAULT_RC_FILENAME;
  }
  var ProjectLookup;
  (function(ProjectLookup2) {
    ProjectLookup2[ProjectLookup2["LOCKFILE"] = 0] = "LOCKFILE";
    ProjectLookup2[ProjectLookup2["MANIFEST"] = 1] = "MANIFEST";
    ProjectLookup2[ProjectLookup2["NONE"] = 2] = "NONE";
  })(ProjectLookup || (ProjectLookup = {}));
  var Configuration2 = class {
    constructor(startingCwd) {
      this.projectCwd = null;
      this.plugins = new Map();
      this.settings = new Map();
      this.values = new Map();
      this.sources = new Map();
      this.invalid = new Map();
      this.packageExtensions = new Map();
      this.limits = new Map();
      this.startingCwd = startingCwd;
    }
    static create(startingCwd, projectCwdOrPlugins, maybePlugins) {
      const configuration = new Configuration2(startingCwd);
      if (typeof projectCwdOrPlugins !== `undefined` && !(projectCwdOrPlugins instanceof Map))
        configuration.projectCwd = projectCwdOrPlugins;
      configuration.importSettings(coreDefinitions);
      const plugins = typeof maybePlugins !== `undefined` ? maybePlugins : projectCwdOrPlugins instanceof Map ? projectCwdOrPlugins : new Map();
      for (const [name, plugin23] of plugins)
        configuration.activatePlugin(name, plugin23);
      return configuration;
    }
    static async find(startingCwd, pluginConfiguration, {lookup = 0, strict = true, usePath = false, useRc = true} = {}) {
      const environmentSettings = getEnvironmentSettings();
      delete environmentSettings.rcFilename;
      const rcFiles = await Configuration2.findRcFiles(startingCwd);
      const homeRcFile = await Configuration2.findHomeRcFile();
      const pickCoreFields = ({ignoreCwd, yarnPath, ignorePath, lockfileFilename: lockfileFilename2}) => ({ignoreCwd, yarnPath, ignorePath, lockfileFilename: lockfileFilename2});
      const excludeCoreFields = ({ignoreCwd, yarnPath, ignorePath, lockfileFilename: lockfileFilename2, ...rest}) => rest;
      const configuration = new Configuration2(startingCwd);
      configuration.importSettings(pickCoreFields(coreDefinitions));
      configuration.useWithSource(`<environment>`, pickCoreFields(environmentSettings), startingCwd, {strict: false});
      for (const {path: path6, cwd, data} of rcFiles)
        configuration.useWithSource(path6, pickCoreFields(data), cwd, {strict: false});
      if (homeRcFile)
        configuration.useWithSource(homeRcFile.path, pickCoreFields(homeRcFile.data), homeRcFile.cwd, {strict: false});
      if (usePath) {
        const yarnPath = configuration.get(`yarnPath`);
        const ignorePath = configuration.get(`ignorePath`);
        if (yarnPath !== null && !ignorePath) {
          return configuration;
        }
      }
      const lockfileFilename = configuration.get(`lockfileFilename`);
      let projectCwd;
      switch (lookup) {
        case 0:
          {
            projectCwd = await Configuration2.findProjectCwd(startingCwd, lockfileFilename);
          }
          break;
        case 1:
          {
            projectCwd = await Configuration2.findProjectCwd(startingCwd, null);
          }
          break;
        case 2:
          {
            if (xfs.existsSync(ppath.join(startingCwd, `package.json`))) {
              projectCwd = ppath.resolve(startingCwd);
            } else {
              projectCwd = null;
            }
          }
          break;
      }
      configuration.startingCwd = startingCwd;
      configuration.projectCwd = projectCwd;
      configuration.importSettings(excludeCoreFields(coreDefinitions));
      const plugins = new Map([
        [`@@core`, CorePlugin]
      ]);
      const interop = (obj) => obj.__esModule ? obj.default : obj;
      if (pluginConfiguration !== null) {
        for (const request2 of pluginConfiguration.plugins.keys())
          plugins.set(request2, interop(pluginConfiguration.modules.get(request2)));
        const requireEntries = new Map();
        for (const request2 of builtinModules())
          requireEntries.set(request2, () => miscUtils7.dynamicRequire(request2));
        for (const [request2, embedModule] of pluginConfiguration.modules)
          requireEntries.set(request2, () => embedModule);
        const dynamicPlugins = new Set();
        const getDefault = (object) => {
          return object.default || object;
        };
        const importPlugin = (pluginPath, source) => {
          const {factory, name} = miscUtils7.dynamicRequire(npath.fromPortablePath(pluginPath));
          if (dynamicPlugins.has(name))
            return;
          const pluginRequireEntries = new Map(requireEntries);
          const pluginRequire = (request2) => {
            if (pluginRequireEntries.has(request2)) {
              return pluginRequireEntries.get(request2)();
            } else {
              throw new UsageError(`This plugin cannot access the package referenced via ${request2} which is neither a builtin, nor an exposed entry`);
            }
          };
          const plugin23 = miscUtils7.prettifySyncErrors(() => {
            return getDefault(factory(pluginRequire));
          }, (message) => {
            return `${message} (when initializing ${name}, defined in ${source})`;
          });
          requireEntries.set(name, () => plugin23);
          dynamicPlugins.add(name);
          plugins.set(name, plugin23);
        };
        if (environmentSettings.plugins) {
          for (const userProvidedPath of environmentSettings.plugins.split(`;`)) {
            const pluginPath = ppath.resolve(startingCwd, npath.toPortablePath(userProvidedPath));
            importPlugin(pluginPath, `<environment>`);
          }
        }
        for (const {path: path6, cwd, data} of rcFiles) {
          if (!useRc)
            continue;
          if (!Array.isArray(data.plugins))
            continue;
          for (const userPluginEntry of data.plugins) {
            const userProvidedPath = typeof userPluginEntry !== `string` ? userPluginEntry.path : userPluginEntry;
            const pluginPath = ppath.resolve(cwd, npath.toPortablePath(userProvidedPath));
            importPlugin(pluginPath, path6);
          }
        }
      }
      for (const [name, plugin23] of plugins)
        configuration.activatePlugin(name, plugin23);
      configuration.useWithSource(`<environment>`, excludeCoreFields(environmentSettings), startingCwd, {strict});
      for (const {path: path6, cwd, data} of rcFiles)
        configuration.useWithSource(path6, excludeCoreFields(data), cwd, {strict});
      if (homeRcFile)
        configuration.useWithSource(homeRcFile.path, excludeCoreFields(homeRcFile.data), homeRcFile.cwd, {strict: false});
      if (configuration.get(`enableGlobalCache`)) {
        configuration.values.set(`cacheFolder`, `${configuration.get(`globalFolder`)}/cache`);
        configuration.sources.set(`cacheFolder`, `<internal>`);
      }
      await configuration.refreshPackageExtensions();
      return configuration;
    }
    static async findRcFiles(startingCwd) {
      const rcFilename = getRcFilename();
      const rcFiles = [];
      let nextCwd = startingCwd;
      let currentCwd = null;
      while (nextCwd !== currentCwd) {
        currentCwd = nextCwd;
        const rcPath = ppath.join(currentCwd, rcFilename);
        if (xfs.existsSync(rcPath)) {
          const content = await xfs.readFilePromise(rcPath, `utf8`);
          let data;
          try {
            data = parseSyml(content);
          } catch (error) {
            let tip = ``;
            if (content.match(/^\s+(?!-)[^:]+\s+\S+/m))
              tip = ` (in particular, make sure you list the colons after each key name)`;
            throw new UsageError(`Parse error when loading ${rcPath}; please check it's proper Yaml${tip}`);
          }
          rcFiles.push({path: rcPath, cwd: currentCwd, data});
        }
        nextCwd = ppath.dirname(currentCwd);
      }
      return rcFiles;
    }
    static async findHomeRcFile() {
      const rcFilename = getRcFilename();
      const homeFolder = getHomeFolder();
      const homeRcFilePath = ppath.join(homeFolder, rcFilename);
      if (xfs.existsSync(homeRcFilePath)) {
        const content = await xfs.readFilePromise(homeRcFilePath, `utf8`);
        const data = parseSyml(content);
        return {path: homeRcFilePath, cwd: homeFolder, data};
      }
      return null;
    }
    static async findProjectCwd(startingCwd, lockfileFilename) {
      let projectCwd = null;
      let nextCwd = startingCwd;
      let currentCwd = null;
      while (nextCwd !== currentCwd) {
        currentCwd = nextCwd;
        if (xfs.existsSync(ppath.join(currentCwd, `package.json`)))
          projectCwd = currentCwd;
        if (lockfileFilename !== null) {
          if (xfs.existsSync(ppath.join(currentCwd, lockfileFilename))) {
            projectCwd = currentCwd;
            break;
          }
        } else {
          if (projectCwd !== null) {
            break;
          }
        }
        nextCwd = ppath.dirname(currentCwd);
      }
      return projectCwd;
    }
    static async updateConfiguration(cwd, patch7) {
      const rcFilename = getRcFilename();
      const configurationPath = ppath.join(cwd, rcFilename);
      const current = xfs.existsSync(configurationPath) ? parseSyml(await xfs.readFilePromise(configurationPath, `utf8`)) : {};
      let patched = false;
      let replacement;
      if (typeof patch7 === `function`) {
        try {
          replacement = patch7(current);
        } catch {
          replacement = patch7({});
        }
        if (replacement === current) {
          return;
        }
      } else {
        replacement = current;
        for (const key of Object.keys(patch7)) {
          const currentValue = current[key];
          const patchField = patch7[key];
          let nextValue;
          if (typeof patchField === `function`) {
            try {
              nextValue = patchField(currentValue);
            } catch {
              nextValue = patchField(void 0);
            }
          } else {
            nextValue = patchField;
          }
          if (currentValue === nextValue)
            continue;
          replacement[key] = nextValue;
          patched = true;
        }
        if (!patched) {
          return;
        }
      }
      await xfs.changeFilePromise(configurationPath, stringifySyml(replacement), {
        automaticNewlines: true
      });
    }
    static async updateHomeConfiguration(patch7) {
      const homeFolder = getHomeFolder();
      return await Configuration2.updateConfiguration(homeFolder, patch7);
    }
    activatePlugin(name, plugin23) {
      this.plugins.set(name, plugin23);
      if (typeof plugin23.configuration !== `undefined`) {
        this.importSettings(plugin23.configuration);
      }
    }
    importSettings(definitions) {
      for (const [name, definition] of Object.entries(definitions)) {
        if (definition == null)
          continue;
        if (this.settings.has(name))
          throw new Error(`Cannot redefine settings "${name}"`);
        this.settings.set(name, definition);
        this.values.set(name, getDefaultValue(this, definition));
      }
    }
    useWithSource(source, data, folder, opts) {
      try {
        this.use(source, data, folder, opts);
      } catch (error) {
        error.message += ` (in ${pretty(this, source, Type.PATH)})`;
        throw error;
      }
    }
    use(source, data, folder, {strict = true, overwrite = false} = {}) {
      for (const key of Object.keys(data)) {
        const value = data[key];
        if (typeof value === `undefined`)
          continue;
        if (key === `plugins`)
          continue;
        if (source === `<environment>` && IGNORED_ENV_VARIABLES.has(key))
          continue;
        if (key === `rcFilename`)
          throw new UsageError(`The rcFilename settings can only be set via ${`${ENVIRONMENT_PREFIX}RC_FILENAME`.toUpperCase()}, not via a rc file`);
        const definition = this.settings.get(key);
        if (!definition) {
          if (strict) {
            throw new UsageError(`Unrecognized or legacy configuration settings found: ${key} - run "yarn config -v" to see the list of settings supported in Yarn`);
          } else {
            this.invalid.set(key, source);
            continue;
          }
        }
        if (this.sources.has(key) && !(overwrite || definition.type === SettingsType.MAP || definition.isArray && definition.concatenateValues))
          continue;
        let parsed;
        try {
          parsed = parseValue(this, key, data[key], definition, folder);
        } catch (error) {
          error.message += ` in ${pretty(this, source, Type.PATH)}`;
          throw error;
        }
        if (definition.type === SettingsType.MAP) {
          const previousValue = this.values.get(key);
          this.values.set(key, new Map(overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]));
          this.sources.set(key, `${this.sources.get(key)}, ${source}`);
        } else if (definition.isArray && definition.concatenateValues) {
          const previousValue = this.values.get(key);
          this.values.set(key, overwrite ? [...previousValue, ...parsed] : [...parsed, ...previousValue]);
          this.sources.set(key, `${this.sources.get(key)}, ${source}`);
        } else {
          this.values.set(key, parsed);
          this.sources.set(key, source);
        }
      }
    }
    get(key) {
      if (!this.values.has(key))
        throw new Error(`Invalid configuration key "${key}"`);
      return this.values.get(key);
    }
    getSpecial(key, {hideSecrets = false, getNativePaths = false}) {
      const rawValue = this.get(key);
      const definition = this.settings.get(key);
      if (typeof definition === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${key}"`);
      return transformConfiguration(rawValue, definition, {
        hideSecrets,
        getNativePaths
      });
    }
    getSubprocessStreams(logFile, {header, prefix, report}) {
      let stdout;
      let stderr;
      const logStream = xfs.createWriteStream(logFile);
      if (this.get(`enableInlineBuilds`)) {
        const stdoutLineReporter = report.createStreamReporter(`${prefix} ${pretty(this, `STDOUT`, `green`)}`);
        const stderrLineReporter = report.createStreamReporter(`${prefix} ${pretty(this, `STDERR`, `red`)}`);
        stdout = new import_stream7.PassThrough();
        stdout.pipe(stdoutLineReporter);
        stdout.pipe(logStream);
        stderr = new import_stream7.PassThrough();
        stderr.pipe(stderrLineReporter);
        stderr.pipe(logStream);
      } else {
        stdout = logStream;
        stderr = logStream;
        if (typeof header !== `undefined`) {
          stdout.write(`${header}
`);
        }
      }
      return {stdout, stderr};
    }
    makeResolver() {
      const pluginResolvers = [];
      for (const plugin23 of this.plugins.values())
        for (const resolver of plugin23.resolvers || [])
          pluginResolvers.push(new resolver());
      return new MultiResolver([
        new VirtualResolver(),
        new WorkspaceResolver(),
        new ProtocolResolver(),
        ...pluginResolvers
      ]);
    }
    makeFetcher() {
      const pluginFetchers = [];
      for (const plugin23 of this.plugins.values())
        for (const fetcher of plugin23.fetchers || [])
          pluginFetchers.push(new fetcher());
      return new MultiFetcher([
        new VirtualFetcher(),
        new WorkspaceFetcher(),
        ...pluginFetchers
      ]);
    }
    getLinkers() {
      const linkers = [];
      for (const plugin23 of this.plugins.values())
        for (const linker of plugin23.linkers || [])
          linkers.push(new linker());
      return linkers;
    }
    async refreshPackageExtensions() {
      this.packageExtensions = new Map();
      const packageExtensions3 = this.packageExtensions;
      const registerPackageExtension = (descriptor, extensionData, {userProvided = false} = {}) => {
        if (!import_semver6.default.validRange(descriptor.range))
          throw new Error(`Only semver ranges are allowed as keys for the lockfileExtensions setting`);
        const extension = new Manifest();
        extension.load(extensionData, {yamlCompatibilityMode: true});
        const extensionsPerIdent = miscUtils7.getArrayWithDefault(packageExtensions3, descriptor.identHash);
        const extensionsPerRange = [];
        extensionsPerIdent.push([descriptor.range, extensionsPerRange]);
        const baseExtension = {
          status: PackageExtensionStatus.Inactive,
          userProvided,
          parentDescriptor: descriptor
        };
        for (const dependency of extension.dependencies.values())
          extensionsPerRange.push({...baseExtension, type: PackageExtensionType.Dependency, descriptor: dependency});
        for (const peerDependency of extension.peerDependencies.values())
          extensionsPerRange.push({...baseExtension, type: PackageExtensionType.PeerDependency, descriptor: peerDependency});
        for (const [selector, meta] of extension.peerDependenciesMeta) {
          for (const [key, value] of Object.entries(meta)) {
            extensionsPerRange.push({...baseExtension, type: PackageExtensionType.PeerDependencyMeta, selector, key, value});
          }
        }
      };
      await this.triggerHook((hooks) => {
        return hooks.registerPackageExtensions;
      }, this, registerPackageExtension);
      for (const [descriptorString, extensionData] of this.get(`packageExtensions`)) {
        registerPackageExtension(parseDescriptor(descriptorString, true), miscUtils7.convertMapsToIndexableObjects(extensionData), {userProvided: true});
      }
    }
    normalizePackage(original) {
      const pkg = copyPackage(original);
      if (this.packageExtensions == null)
        throw new Error(`refreshPackageExtensions has to be called before normalizing packages`);
      const extensionsPerIdent = this.packageExtensions.get(original.identHash);
      if (typeof extensionsPerIdent !== `undefined`) {
        const version = original.version;
        if (version !== null) {
          for (const [range, extensionsPerRange] of extensionsPerIdent) {
            if (!satisfiesWithPrereleases(version, range))
              continue;
            for (const extension of extensionsPerRange) {
              if (extension.status === PackageExtensionStatus.Inactive)
                extension.status = PackageExtensionStatus.Redundant;
              switch (extension.type) {
                case PackageExtensionType.Dependency:
                  {
                    const currentDependency = pkg.dependencies.get(extension.descriptor.identHash);
                    if (typeof currentDependency === `undefined`) {
                      extension.status = PackageExtensionStatus.Active;
                      pkg.dependencies.set(extension.descriptor.identHash, extension.descriptor);
                    }
                  }
                  break;
                case PackageExtensionType.PeerDependency:
                  {
                    const currentPeerDependency = pkg.peerDependencies.get(extension.descriptor.identHash);
                    if (typeof currentPeerDependency === `undefined`) {
                      extension.status = PackageExtensionStatus.Active;
                      pkg.peerDependencies.set(extension.descriptor.identHash, extension.descriptor);
                    }
                  }
                  break;
                case PackageExtensionType.PeerDependencyMeta:
                  {
                    const currentPeerDependencyMeta = pkg.peerDependenciesMeta.get(extension.selector);
                    if (typeof currentPeerDependencyMeta === `undefined` || !Object.prototype.hasOwnProperty.call(currentPeerDependencyMeta, extension.key) || currentPeerDependencyMeta[extension.key] !== extension.value) {
                      extension.status = PackageExtensionStatus.Active;
                      miscUtils7.getFactoryWithDefault(pkg.peerDependenciesMeta, extension.selector, () => ({}))[extension.key] = extension.value;
                    }
                  }
                  break;
                default:
                  {
                    miscUtils7.assertNever(extension);
                  }
                  break;
              }
            }
          }
        }
      }
      const getTypesName = (descriptor) => {
        return descriptor.scope ? `${descriptor.scope}__${descriptor.name}` : `${descriptor.name}`;
      };
      for (const descriptor of pkg.peerDependencies.values()) {
        if (descriptor.scope === `types`)
          continue;
        const typesName = getTypesName(descriptor);
        const typesIdent = makeIdent(`types`, typesName);
        const stringifiedTypesIdent = stringifyIdent(typesIdent);
        if (pkg.peerDependencies.has(typesIdent.identHash) || pkg.peerDependenciesMeta.has(stringifiedTypesIdent))
          continue;
        pkg.peerDependenciesMeta.set(stringifiedTypesIdent, {
          optional: true
        });
      }
      for (const identString of pkg.peerDependenciesMeta.keys()) {
        const ident = parseIdent(identString);
        if (!pkg.peerDependencies.has(ident.identHash)) {
          pkg.peerDependencies.set(ident.identHash, makeDescriptor(ident, `*`));
        }
      }
      pkg.dependencies = new Map(miscUtils7.sortMap(pkg.dependencies, ([, descriptor]) => stringifyDescriptor(descriptor)));
      pkg.peerDependencies = new Map(miscUtils7.sortMap(pkg.peerDependencies, ([, descriptor]) => stringifyDescriptor(descriptor)));
      return pkg;
    }
    getLimit(key) {
      return miscUtils7.getFactoryWithDefault(this.limits, key, () => {
        return import_p_limit2.default(this.get(key));
      });
    }
    async triggerHook(get4, ...args) {
      for (const plugin23 of this.plugins.values()) {
        const hooks = plugin23.hooks;
        if (!hooks)
          continue;
        const hook = get4(hooks);
        if (!hook)
          continue;
        await hook(...args);
      }
    }
    async triggerMultipleHooks(get4, argsList) {
      for (const args of argsList) {
        await this.triggerHook(get4, ...args);
      }
    }
    async reduceHook(get4, initialValue, ...args) {
      let value = initialValue;
      for (const plugin23 of this.plugins.values()) {
        const hooks = plugin23.hooks;
        if (!hooks)
          continue;
        const hook = get4(hooks);
        if (!hook)
          continue;
        value = await hook(value, ...args);
      }
      return value;
    }
    async firstHook(get4, ...args) {
      for (const plugin23 of this.plugins.values()) {
        const hooks = plugin23.hooks;
        if (!hooks)
          continue;
        const hook = get4(hooks);
        if (!hook)
          continue;
        const ret = await hook(...args);
        if (typeof ret !== `undefined`) {
          return ret;
        }
      }
      return null;
    }
  };
  var Configuration = Configuration2;
  Configuration.telemetry = null;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Installer.ts
  var BuildType;
  (function(BuildType2) {
    BuildType2[BuildType2["SCRIPT"] = 0] = "SCRIPT";
    BuildType2[BuildType2["SHELLCODE"] = 1] = "SHELLCODE";
  })(BuildType || (BuildType = {}));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\LightReport.ts
  var LightReport = class extends Report {
    constructor({configuration, stdout, suggestInstall = true}) {
      super();
      this.errorCount = 0;
      addLogFilterSupport(this, {configuration});
      this.configuration = configuration;
      this.stdout = stdout;
      this.suggestInstall = suggestInstall;
    }
    static async start(opts, cb) {
      const report = new this(opts);
      try {
        await cb(report);
      } catch (error) {
        report.reportExceptionOnce(error);
      } finally {
        await report.finalize();
      }
      return report;
    }
    hasErrors() {
      return this.errorCount > 0;
    }
    exitCode() {
      return this.hasErrors() ? 1 : 0;
    }
    reportCacheHit(locator) {
    }
    reportCacheMiss(locator) {
    }
    startTimerSync(what, opts, cb) {
      const realCb = typeof opts === `function` ? opts : cb;
      return realCb();
    }
    async startTimerPromise(what, opts, cb) {
      const realCb = typeof opts === `function` ? opts : cb;
      return await realCb();
    }
    async startCacheReport(cb) {
      return await cb();
    }
    reportSeparator() {
    }
    reportInfo(name, text) {
    }
    reportWarning(name, text) {
    }
    reportError(name, text) {
      this.errorCount += 1;
      this.stdout.write(`${pretty(this.configuration, `\u27A4`, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${text}
`);
    }
    reportProgress(progress) {
      const promise = Promise.resolve().then(async () => {
        for await (const {} of progress) {
        }
      });
      const stop = () => {
      };
      return {...promise, stop};
    }
    reportJson(data) {
    }
    async finalize() {
      if (this.errorCount > 0) {
        this.stdout.write(`${pretty(this.configuration, `\u27A4`, `redBright`)} Errors happened when preparing the environment required to run this command.
`);
        if (this.suggestInstall) {
          this.stdout.write(`${pretty(this.configuration, `\u27A4`, `redBright`)} This might be caused by packages being missing from the lockfile, in which case running "yarn install" might help.
`);
        }
      }
    }
    formatNameWithHyperlink(name) {
      return formatNameWithHyperlink(name, {
        configuration: this.configuration,
        json: false
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Project.ts
  var import_crypto2 = __toModule(require("crypto"));
  var import_diff = __toModule(require_lib2());
  var import_pick = __toModule(require_pick());
  var import_p_limit3 = __toModule(require_p_limit());
  var import_semver9 = __toModule(require_semver2());
  var import_util3 = __toModule(require("util"));
  var import_v8 = __toModule(require("v8"));
  var import_zlib2 = __toModule(require("zlib"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\LegacyMigrationResolver.ts
  var import_semver7 = __toModule(require_semver2());
  var IMPORTED_PATTERNS = [
    [/^(git(?:\+(?:https|ssh))?:\/\/.*(?:\.git)?)#(.*)$/, (version, $0, $1, $2) => `${$1}#commit=${$2}`],
    [/^https:\/\/((?:[^/]+?)@)?codeload\.github\.com\/([^/]+\/[^/]+)\/tar\.gz\/([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`],
    [/^https:\/\/((?:[^/]+?)@)?github\.com\/([^/]+\/[^/]+?)(?:\.git)?#([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit=${$3}`],
    [/^https?:\/\/[^/]+\/(?:[^/]+\/)*(?:@[^/]+\/)?([^/]+)\/(?:-|download)\/\1-[^/]+\.tgz(?:#|$)/, (version) => `npm:${version}`],
    [/^https:\/\/npm\.pkg\.github\.com\/download\/(?:@[^/]+)\/(?:[^/]+)\/(?:[^/]+)\/(?:[0-9a-f]+)$/, (version) => `npm:${version}`],
    [/^https:\/\/npm\.fontawesome\.com\/(?:@[^/]+)\/([^/]+)\/-\/([^/]+)\/\1-\2.tgz(?:#|$)/, (version) => `npm:${version}`],
    [/^https?:\/\/(?:[^\\.]+)\.jfrog\.io\/.*\/(@[^/]+)\/([^/]+)\/-\/\1\/\2-(?:[.\d\w-]+)\.tgz(?:#|$)/, (version) => `npm:${version}`],
    [/^[^/]+\.tgz#[0-9a-f]+$/, (version) => `npm:${version}`]
  ];
  var LegacyMigrationResolver = class {
    constructor() {
      this.resolutions = null;
    }
    async setup(project, {report}) {
      const lockfilePath = ppath.join(project.cwd, project.configuration.get(`lockfileFilename`));
      if (!xfs.existsSync(lockfilePath))
        return;
      const content = await xfs.readFilePromise(lockfilePath, `utf8`);
      const parsed = parseSyml(content);
      if (Object.prototype.hasOwnProperty.call(parsed, `__metadata`))
        return;
      const resolutions = this.resolutions = new Map();
      for (const key of Object.keys(parsed)) {
        let descriptor = tryParseDescriptor(key);
        if (!descriptor) {
          report.reportWarning(MessageName.YARN_IMPORT_FAILED, `Failed to parse the string "${key}" into a proper descriptor`);
          continue;
        }
        if (import_semver7.default.validRange(descriptor.range))
          descriptor = makeDescriptor(descriptor, `npm:${descriptor.range}`);
        const {version, resolved} = parsed[key];
        if (!resolved)
          continue;
        let reference;
        for (const [pattern, matcher] of IMPORTED_PATTERNS) {
          const match2 = resolved.match(pattern);
          if (match2) {
            reference = matcher(version, ...match2);
            break;
          }
        }
        if (!reference) {
          report.reportWarning(MessageName.YARN_IMPORT_FAILED, `${prettyDescriptor(project.configuration, descriptor)}: Only some patterns can be imported from legacy lockfiles (not "${resolved}")`);
          continue;
        }
        const resolution = makeLocator(descriptor, reference);
        resolutions.set(descriptor.descriptorHash, resolution);
      }
    }
    supportsDescriptor(descriptor, opts) {
      if (!this.resolutions)
        return false;
      return this.resolutions.has(descriptor.descriptorHash);
    }
    supportsLocator(locator, opts) {
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      if (!this.resolutions)
        throw new Error(`Assertion failed: The resolution store should have been setup`);
      const resolution = this.resolutions.get(descriptor.descriptorHash);
      if (!resolution)
        throw new Error(`Assertion failed: The resolution should have been registered`);
      return [resolution];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\LockfileResolver.ts
  var LockfileResolver = class {
    supportsDescriptor(descriptor, opts) {
      const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
      if (resolution)
        return true;
      if (opts.project.originalPackages.has(convertDescriptorToLocator(descriptor).locatorHash))
        return true;
      return false;
    }
    supportsLocator(locator, opts) {
      if (opts.project.originalPackages.has(locator.locatorHash))
        return true;
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      let pkg = opts.project.originalPackages.get(convertDescriptorToLocator(descriptor).locatorHash);
      if (pkg)
        return [pkg];
      const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
      if (!resolution)
        throw new Error(`Expected the resolution to have been successful - resolution not found`);
      pkg = opts.project.originalPackages.get(resolution);
      if (!pkg)
        throw new Error(`Expected the resolution to have been successful - package not found`);
      return [pkg];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      const pkg = opts.project.originalPackages.get(locator.locatorHash);
      if (!pkg)
        throw new Error(`The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache`);
      return pkg;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\RunInstallPleaseResolver.ts
  var RunInstallPleaseResolver = class {
    constructor(resolver) {
      this.resolver = resolver;
    }
    supportsDescriptor(descriptor, opts) {
      return this.resolver.supportsDescriptor(descriptor, opts);
    }
    supportsLocator(locator, opts) {
      return this.resolver.supportsLocator(locator, opts);
    }
    shouldPersistResolution(locator, opts) {
      return this.resolver.shouldPersistResolution(locator, opts);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return this.resolver.bindDescriptor(descriptor, fromLocator, opts);
    }
    getResolutionDependencies(descriptor, opts) {
      return this.resolver.getResolutionDependencies(descriptor, opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
      throw new ReportError(MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; run "yarn install" to update the lockfile`);
    }
    async getSatisfying(descriptor, references, opts) {
      throw new ReportError(MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; run "yarn install" to update the lockfile`);
    }
    async resolve(locator, opts) {
      throw new ReportError(MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; run "yarn install" to update the lockfile`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\ThrowReport.ts
  var ThrowReport = class extends Report {
    reportCacheHit(locator) {
    }
    reportCacheMiss(locator) {
    }
    startTimerSync(what, opts, cb) {
      const realCb = typeof opts === `function` ? opts : cb;
      return realCb();
    }
    async startTimerPromise(what, opts, cb) {
      const realCb = typeof opts === `function` ? opts : cb;
      return await realCb();
    }
    async startCacheReport(cb) {
      return await cb();
    }
    reportSeparator() {
    }
    reportInfo(name, text) {
    }
    reportWarning(name, text) {
    }
    reportError(name, text) {
    }
    reportProgress(progress) {
      const promise = Promise.resolve().then(async () => {
        for await (const {} of progress) {
        }
      });
      const stop = () => {
      };
      return {...promise, stop};
    }
    reportJson(data) {
    }
    async finalize() {
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Workspace.ts
  var import_globby2 = __toModule(require_globby());
  var import_semver8 = __toModule(require_semver2());
  var Workspace = class {
    constructor(workspaceCwd, {project}) {
      this.workspacesCwds = new Set();
      this.dependencies = new Map();
      this.project = project;
      this.cwd = workspaceCwd;
    }
    async setup() {
      this.manifest = xfs.existsSync(ppath.join(this.cwd, Manifest.fileName)) ? await Manifest.find(this.cwd) : new Manifest();
      this.relativeCwd = ppath.relative(this.project.cwd, this.cwd) || PortablePath2.dot;
      const ident = this.manifest.name ? this.manifest.name : makeIdent(null, `${this.computeCandidateName()}-${makeHash(this.relativeCwd).substr(0, 6)}`);
      const reference = this.manifest.version ? this.manifest.version : `0.0.0`;
      this.locator = makeLocator(ident, reference);
      this.anchoredDescriptor = makeDescriptor(this.locator, `${WorkspaceResolver.protocol}${this.relativeCwd}`);
      this.anchoredLocator = makeLocator(this.locator, `${WorkspaceResolver.protocol}${this.relativeCwd}`);
      const patterns = this.manifest.workspaceDefinitions.map(({pattern}) => pattern);
      const relativeCwds = await import_globby2.default(patterns, {
        absolute: true,
        cwd: npath.fromPortablePath(this.cwd),
        expandDirectories: false,
        onlyDirectories: true,
        onlyFiles: false,
        ignore: [`**/node_modules`, `**/.git`, `**/.yarn`]
      });
      relativeCwds.sort();
      for (const relativeCwd of relativeCwds) {
        const candidateCwd = ppath.resolve(this.cwd, npath.toPortablePath(relativeCwd));
        if (xfs.existsSync(ppath.join(candidateCwd, `package.json`))) {
          this.workspacesCwds.add(candidateCwd);
        }
      }
    }
    accepts(range) {
      const protocolIndex = range.indexOf(`:`);
      const protocol = protocolIndex !== -1 ? range.slice(0, protocolIndex + 1) : null;
      const pathname = protocolIndex !== -1 ? range.slice(protocolIndex + 1) : range;
      if (protocol === WorkspaceResolver.protocol && ppath.normalize(pathname) === this.relativeCwd)
        return true;
      if (protocol === WorkspaceResolver.protocol && pathname === `*`)
        return true;
      if (!import_semver8.default.validRange(pathname))
        return false;
      if (protocol === WorkspaceResolver.protocol)
        return import_semver8.default.satisfies(this.manifest.version !== null ? this.manifest.version : `0.0.0`, pathname);
      if (!this.project.configuration.get(`enableTransparentWorkspaces`))
        return false;
      if (this.manifest.version !== null)
        return import_semver8.default.satisfies(this.manifest.version, pathname);
      return false;
    }
    computeCandidateName() {
      if (this.cwd === this.project.cwd) {
        return `root-workspace`;
      } else {
        return `${ppath.basename(this.cwd)}` || `unnamed-workspace`;
      }
    }
    async persistManifest() {
      const data = {};
      this.manifest.exportTo(data);
      const path6 = ppath.join(this.cwd, Manifest.fileName);
      const content = `${JSON.stringify(data, null, this.manifest.indent)}
`;
      await xfs.changeFilePromise(path6, content, {
        automaticNewlines: true
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\Project.ts
  var miscUtils8 = __toModule(require_miscUtils());
  var LOCKFILE_VERSION = 4;
  var INSTALL_STATE_VERSION = 1;
  var MULTIPLE_KEYS_REGEXP = / *, */g;
  var TRAILING_SLASH_REGEXP = /\/$/;
  var FETCHER_CONCURRENCY = 32;
  var gzip = import_util3.promisify(import_zlib2.default.gzip);
  var gunzip = import_util3.promisify(import_zlib2.default.gunzip);
  var INSTALL_STATE_FIELDS = {
    restoreInstallersCustomData: [
      `installersCustomData`
    ],
    restoreResolutions: [
      `accessibleLocators`,
      `optionalBuilds`,
      `storedDescriptors`,
      `storedResolutions`,
      `storedPackages`,
      `lockFileChecksum`
    ]
  };
  var Project = class {
    constructor(projectCwd, {configuration}) {
      this.resolutionAliases = new Map();
      this.workspaces = [];
      this.workspacesByCwd = new Map();
      this.workspacesByIdent = new Map();
      this.storedResolutions = new Map();
      this.storedDescriptors = new Map();
      this.storedPackages = new Map();
      this.storedChecksums = new Map();
      this.accessibleLocators = new Set();
      this.originalPackages = new Map();
      this.optionalBuilds = new Set();
      this.peerRequirements = new Map();
      this.installersCustomData = new Map();
      this.lockFileChecksum = null;
      this.configuration = configuration;
      this.cwd = projectCwd;
    }
    static async find(configuration, startingCwd) {
      var _a2, _b, _c;
      if (!configuration.projectCwd)
        throw new UsageError(`No project found in ${startingCwd}`);
      let packageCwd = configuration.projectCwd;
      let nextCwd = startingCwd;
      let currentCwd = null;
      while (currentCwd !== configuration.projectCwd) {
        currentCwd = nextCwd;
        if (xfs.existsSync(ppath.join(currentCwd, Filename.manifest))) {
          packageCwd = currentCwd;
          break;
        }
        nextCwd = ppath.dirname(currentCwd);
      }
      const project = new Project(configuration.projectCwd, {configuration});
      (_a2 = Configuration.telemetry) == null ? void 0 : _a2.reportProject(project.cwd);
      await project.setupResolutions();
      await project.setupWorkspaces();
      (_b = Configuration.telemetry) == null ? void 0 : _b.reportWorkspaceCount(project.workspaces.length);
      (_c = Configuration.telemetry) == null ? void 0 : _c.reportDependencyCount(project.workspaces.reduce((sum, workspace2) => sum + workspace2.manifest.dependencies.size + workspace2.manifest.devDependencies.size, 0));
      const workspace = project.tryWorkspaceByCwd(packageCwd);
      if (workspace)
        return {project, workspace, locator: workspace.anchoredLocator};
      const locator = await project.findLocatorForLocation(`${packageCwd}/`, {strict: true});
      if (locator)
        return {project, locator, workspace: null};
      throw new UsageError(`The nearest package directory (${pretty(configuration, packageCwd, Type.PATH)}) doesn't seem to be part of the project declared in ${pretty(configuration, project.cwd, Type.PATH)}.

- If the project directory is right, it might be that you forgot to list ${pretty(configuration, ppath.relative(project.cwd, packageCwd), Type.PATH)} as a workspace.
- If it isn't, it's likely because you have a yarn.lock or package.json file there, confusing the project root detection.`);
    }
    static generateBuildStateFile(buildState, locatorStore) {
      let bstateFile = `# Warning: This file is automatically generated. Removing it is fine, but will
# cause all your builds to become invalidated.
`;
      const bstateData = [...buildState].map(([locatorHash, hash]) => {
        const locator = locatorStore.get(locatorHash);
        if (typeof locator === `undefined`)
          throw new Error(`Assertion failed: The locator should have been registered`);
        return [stringifyLocator(locator), locator.locatorHash, hash];
      });
      for (const [locatorString, locatorHash, buildHash] of miscUtils8.sortMap(bstateData, [(d) => d[0], (d) => d[1]])) {
        bstateFile += `
`;
        bstateFile += `# ${locatorString}
`;
        bstateFile += `${JSON.stringify(locatorHash)}:
`;
        bstateFile += `  ${buildHash}
`;
      }
      return bstateFile;
    }
    async setupResolutions() {
      this.storedResolutions = new Map();
      this.storedDescriptors = new Map();
      this.storedPackages = new Map();
      this.lockFileChecksum = null;
      const lockfilePath = ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
      const defaultLanguageName = this.configuration.get(`defaultLanguageName`);
      if (xfs.existsSync(lockfilePath)) {
        const content = await xfs.readFilePromise(lockfilePath, `utf8`);
        this.lockFileChecksum = makeHash(`${INSTALL_STATE_VERSION}`, content);
        const parsed = parseSyml(content);
        if (parsed.__metadata) {
          const lockfileVersion = parsed.__metadata.version;
          const cacheKey = parsed.__metadata.cacheKey;
          for (const key of Object.keys(parsed)) {
            if (key === `__metadata`)
              continue;
            const data = parsed[key];
            if (typeof data.resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the lockfile entry to have a resolution field (${key})`);
            const locator = parseLocator(data.resolution, true);
            const manifest = new Manifest();
            manifest.load(data, {yamlCompatibilityMode: true});
            const version = manifest.version;
            const languageName = manifest.languageName || defaultLanguageName;
            const linkType = data.linkType.toUpperCase();
            const dependencies = manifest.dependencies;
            const peerDependencies = manifest.peerDependencies;
            const dependenciesMeta = manifest.dependenciesMeta;
            const peerDependenciesMeta = manifest.peerDependenciesMeta;
            const bin = manifest.bin;
            if (data.checksum != null) {
              const checksum = typeof cacheKey !== `undefined` && !data.checksum.includes(`/`) ? `${cacheKey}/${data.checksum}` : data.checksum;
              this.storedChecksums.set(locator.locatorHash, checksum);
            }
            if (lockfileVersion >= LOCKFILE_VERSION) {
              const pkg = {...locator, version, languageName, linkType, dependencies, peerDependencies, dependenciesMeta, peerDependenciesMeta, bin};
              this.originalPackages.set(pkg.locatorHash, pkg);
            }
            for (const entry of key.split(MULTIPLE_KEYS_REGEXP)) {
              const descriptor = parseDescriptor(entry);
              this.storedDescriptors.set(descriptor.descriptorHash, descriptor);
              if (lockfileVersion >= LOCKFILE_VERSION) {
                this.storedResolutions.set(descriptor.descriptorHash, locator.locatorHash);
              } else {
                const resolutionDescriptor = convertLocatorToDescriptor(locator);
                if (resolutionDescriptor.descriptorHash !== descriptor.descriptorHash) {
                  this.storedDescriptors.set(resolutionDescriptor.descriptorHash, resolutionDescriptor);
                  this.resolutionAliases.set(descriptor.descriptorHash, resolutionDescriptor.descriptorHash);
                }
              }
            }
          }
        }
      }
    }
    async setupWorkspaces() {
      this.workspaces = [];
      this.workspacesByCwd = new Map();
      this.workspacesByIdent = new Map();
      let workspaceCwds = [this.cwd];
      while (workspaceCwds.length > 0) {
        const passCwds = workspaceCwds;
        workspaceCwds = [];
        for (const workspaceCwd of passCwds) {
          if (this.workspacesByCwd.has(workspaceCwd))
            continue;
          const workspace = await this.addWorkspace(workspaceCwd);
          const workspacePkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
          if (workspacePkg)
            workspace.dependencies = workspacePkg.dependencies;
          for (const workspaceCwd2 of workspace.workspacesCwds) {
            workspaceCwds.push(workspaceCwd2);
          }
        }
      }
    }
    async addWorkspace(workspaceCwd) {
      const workspace = new Workspace(workspaceCwd, {project: this});
      await workspace.setup();
      const dup = this.workspacesByIdent.get(workspace.locator.identHash);
      if (typeof dup !== `undefined`)
        throw new Error(`Duplicate workspace name ${prettyIdent(this.configuration, workspace.locator)}: ${workspaceCwd} conflicts with ${dup.cwd}`);
      this.workspaces.push(workspace);
      this.workspacesByCwd.set(workspaceCwd, workspace);
      this.workspacesByIdent.set(workspace.locator.identHash, workspace);
      return workspace;
    }
    get topLevelWorkspace() {
      return this.getWorkspaceByCwd(this.cwd);
    }
    tryWorkspaceByCwd(workspaceCwd) {
      if (!ppath.isAbsolute(workspaceCwd))
        workspaceCwd = ppath.resolve(this.cwd, workspaceCwd);
      workspaceCwd = ppath.normalize(workspaceCwd).replace(/\/+$/, ``);
      const workspace = this.workspacesByCwd.get(workspaceCwd);
      if (!workspace)
        return null;
      return workspace;
    }
    getWorkspaceByCwd(workspaceCwd) {
      const workspace = this.tryWorkspaceByCwd(workspaceCwd);
      if (!workspace)
        throw new Error(`Workspace not found (${workspaceCwd})`);
      return workspace;
    }
    tryWorkspaceByFilePath(filePath) {
      let bestWorkspace = null;
      for (const workspace of this.workspaces) {
        const rel = ppath.relative(workspace.cwd, filePath);
        if (rel.startsWith(`../`))
          continue;
        if (bestWorkspace && bestWorkspace.cwd.length >= workspace.cwd.length)
          continue;
        bestWorkspace = workspace;
      }
      if (!bestWorkspace)
        return null;
      return bestWorkspace;
    }
    getWorkspaceByFilePath(filePath) {
      const workspace = this.tryWorkspaceByFilePath(filePath);
      if (!workspace)
        throw new Error(`Workspace not found (${filePath})`);
      return workspace;
    }
    tryWorkspaceByIdent(ident) {
      const workspace = this.workspacesByIdent.get(ident.identHash);
      if (typeof workspace === `undefined`)
        return null;
      return workspace;
    }
    getWorkspaceByIdent(ident) {
      const workspace = this.tryWorkspaceByIdent(ident);
      if (!workspace)
        throw new Error(`Workspace not found (${prettyIdent(this.configuration, ident)})`);
      return workspace;
    }
    tryWorkspaceByDescriptor(descriptor) {
      const workspace = this.tryWorkspaceByIdent(descriptor);
      if (workspace === null || !workspace.accepts(descriptor.range))
        return null;
      return workspace;
    }
    getWorkspaceByDescriptor(descriptor) {
      const workspace = this.tryWorkspaceByDescriptor(descriptor);
      if (workspace === null)
        throw new Error(`Workspace not found (${prettyDescriptor(this.configuration, descriptor)})`);
      return workspace;
    }
    tryWorkspaceByLocator(locator) {
      if (isVirtualLocator(locator))
        locator = devirtualizeLocator(locator);
      const workspace = this.tryWorkspaceByIdent(locator);
      if (workspace === null || workspace.locator.locatorHash !== locator.locatorHash && workspace.anchoredLocator.locatorHash !== locator.locatorHash)
        return null;
      return workspace;
    }
    getWorkspaceByLocator(locator) {
      const workspace = this.tryWorkspaceByLocator(locator);
      if (!workspace)
        throw new Error(`Workspace not found (${prettyLocator(this.configuration, locator)})`);
      return workspace;
    }
    refreshWorkspaceDependencies() {
      for (const workspace of this.workspaces) {
        const pkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (!pkg)
          throw new Error(`Assertion failed: Expected workspace to have been resolved`);
        workspace.dependencies = new Map(pkg.dependencies);
      }
    }
    forgetResolution(dataStructure) {
      const deleteDescriptor = (descriptorHash) => {
        this.storedResolutions.delete(descriptorHash);
        this.storedDescriptors.delete(descriptorHash);
      };
      const deleteLocator = (locatorHash) => {
        this.originalPackages.delete(locatorHash);
        this.storedPackages.delete(locatorHash);
        this.accessibleLocators.delete(locatorHash);
      };
      if (`descriptorHash` in dataStructure) {
        const locatorHash = this.storedResolutions.get(dataStructure.descriptorHash);
        deleteDescriptor(dataStructure.descriptorHash);
        const remainingResolutions = new Set(this.storedResolutions.values());
        if (typeof locatorHash !== `undefined` && !remainingResolutions.has(locatorHash)) {
          deleteLocator(locatorHash);
        }
      }
      if (`locatorHash` in dataStructure) {
        deleteLocator(dataStructure.locatorHash);
        for (const [descriptorHash, locatorHash] of this.storedResolutions) {
          if (locatorHash === dataStructure.locatorHash) {
            deleteDescriptor(descriptorHash);
          }
        }
      }
    }
    forgetTransientResolutions() {
      const resolver = this.configuration.makeResolver();
      for (const pkg of this.originalPackages.values()) {
        let shouldPersistResolution;
        try {
          shouldPersistResolution = resolver.shouldPersistResolution(pkg, {project: this, resolver});
        } catch {
          shouldPersistResolution = false;
        }
        if (!shouldPersistResolution) {
          this.forgetResolution(pkg);
        }
      }
    }
    forgetVirtualResolutions() {
      for (const pkg of this.storedPackages.values()) {
        for (const [dependencyHash, dependency] of pkg.dependencies) {
          if (isVirtualDescriptor(dependency)) {
            pkg.dependencies.set(dependencyHash, devirtualizeDescriptor(dependency));
          }
        }
      }
    }
    getDependencyMeta(ident, version) {
      const dependencyMeta = {};
      const dependenciesMeta = this.topLevelWorkspace.manifest.dependenciesMeta;
      const dependencyMetaSet = dependenciesMeta.get(stringifyIdent(ident));
      if (!dependencyMetaSet)
        return dependencyMeta;
      const defaultMeta = dependencyMetaSet.get(null);
      if (defaultMeta)
        Object.assign(dependencyMeta, defaultMeta);
      if (version === null || !import_semver9.default.valid(version))
        return dependencyMeta;
      for (const [range, meta] of dependencyMetaSet)
        if (range !== null && range === version)
          Object.assign(dependencyMeta, meta);
      return dependencyMeta;
    }
    async findLocatorForLocation(cwd, {strict = false} = {}) {
      const report = new ThrowReport();
      const linkers = this.configuration.getLinkers();
      const linkerOptions = {project: this, report};
      for (const linker of linkers) {
        const locator = await linker.findPackageLocator(cwd, linkerOptions);
        if (locator) {
          if (strict) {
            const location = await linker.findPackageLocation(locator, linkerOptions);
            if (location.replace(TRAILING_SLASH_REGEXP, ``) !== cwd.replace(TRAILING_SLASH_REGEXP, ``)) {
              continue;
            }
          }
          return locator;
        }
      }
      return null;
    }
    async resolveEverything(opts) {
      if (!this.workspacesByCwd || !this.workspacesByIdent)
        throw new Error(`Workspaces must have been setup before calling this function`);
      this.forgetVirtualResolutions();
      if (!opts.lockfileOnly)
        this.forgetTransientResolutions();
      const realResolver = opts.resolver || this.configuration.makeResolver();
      const legacyMigrationResolver = new LegacyMigrationResolver();
      await legacyMigrationResolver.setup(this, {report: opts.report});
      const resolver = opts.lockfileOnly ? new MultiResolver([new LockfileResolver(), new RunInstallPleaseResolver(realResolver)]) : new MultiResolver([new LockfileResolver(), legacyMigrationResolver, realResolver]);
      const fetcher = this.configuration.makeFetcher();
      const resolveOptions = opts.lockfileOnly ? {project: this, report: opts.report, resolver} : {project: this, report: opts.report, resolver, fetchOptions: {project: this, cache: opts.cache, checksums: this.storedChecksums, report: opts.report, fetcher}};
      const allDescriptors = new Map();
      const allPackages = new Map();
      const allResolutions = new Map();
      const originalPackages = new Map();
      const packageResolutionPromises = new Map();
      const descriptorResolutionPromises = new Map();
      const resolutionQueue = [];
      const startPackageResolution = async (locator) => {
        const originalPkg = await miscUtils8.prettifyAsyncErrors(async () => {
          return await resolver.resolve(locator, resolveOptions);
        }, (message) => {
          return `${prettyLocator(this.configuration, locator)}: ${message}`;
        });
        if (!areLocatorsEqual(locator, originalPkg))
          throw new Error(`Assertion failed: The locator cannot be changed by the resolver (went from ${prettyLocator(this.configuration, locator)} to ${prettyLocator(this.configuration, originalPkg)})`);
        originalPackages.set(originalPkg.locatorHash, originalPkg);
        const pkg = this.configuration.normalizePackage(originalPkg);
        for (const [identHash, descriptor] of pkg.dependencies) {
          const dependency = await this.configuration.reduceHook((hooks) => {
            return hooks.reduceDependency;
          }, descriptor, this, pkg, descriptor, {
            resolver,
            resolveOptions
          });
          if (!areIdentsEqual(descriptor, dependency))
            throw new Error(`Assertion failed: The descriptor ident cannot be changed through aliases`);
          const bound = resolver.bindDescriptor(dependency, locator, resolveOptions);
          pkg.dependencies.set(identHash, bound);
        }
        resolutionQueue.push(Promise.all([...pkg.dependencies.values()].map((descriptor) => {
          return scheduleDescriptorResolution(descriptor);
        })));
        allPackages.set(pkg.locatorHash, pkg);
        return pkg;
      };
      const schedulePackageResolution = async (locator) => {
        const promise = packageResolutionPromises.get(locator.locatorHash);
        if (typeof promise !== `undefined`)
          return promise;
        const newPromise = Promise.resolve().then(() => startPackageResolution(locator));
        packageResolutionPromises.set(locator.locatorHash, newPromise);
        return newPromise;
      };
      const startDescriptorAliasing = async (descriptor, alias) => {
        const resolution = await scheduleDescriptorResolution(alias);
        allDescriptors.set(descriptor.descriptorHash, descriptor);
        allResolutions.set(descriptor.descriptorHash, resolution.locatorHash);
        return resolution;
      };
      const startDescriptorResolution = async (descriptor) => {
        const alias = this.resolutionAliases.get(descriptor.descriptorHash);
        if (typeof alias !== `undefined`)
          return startDescriptorAliasing(descriptor, this.storedDescriptors.get(alias));
        const resolutionDependencies = resolver.getResolutionDependencies(descriptor, resolveOptions);
        const resolvedDependencies = new Map(await Promise.all(resolutionDependencies.map(async (dependency) => {
          return [dependency.descriptorHash, await scheduleDescriptorResolution(dependency)];
        })));
        const candidateResolutions = await miscUtils8.prettifyAsyncErrors(async () => {
          return await resolver.getCandidates(descriptor, resolvedDependencies, resolveOptions);
        }, (message) => {
          return `${prettyDescriptor(this.configuration, descriptor)}: ${message}`;
        });
        const finalResolution = candidateResolutions[0];
        if (typeof finalResolution === `undefined`)
          throw new Error(`${prettyDescriptor(this.configuration, descriptor)}: No candidates found`);
        allDescriptors.set(descriptor.descriptorHash, descriptor);
        allResolutions.set(descriptor.descriptorHash, finalResolution.locatorHash);
        return schedulePackageResolution(finalResolution);
      };
      const scheduleDescriptorResolution = (descriptor) => {
        const promise = descriptorResolutionPromises.get(descriptor.descriptorHash);
        if (typeof promise !== `undefined`)
          return promise;
        allDescriptors.set(descriptor.descriptorHash, descriptor);
        const newPromise = Promise.resolve().then(() => startDescriptorResolution(descriptor));
        descriptorResolutionPromises.set(descriptor.descriptorHash, newPromise);
        return newPromise;
      };
      for (const workspace of this.workspaces) {
        const workspaceDescriptor = workspace.anchoredDescriptor;
        resolutionQueue.push(scheduleDescriptorResolution(workspaceDescriptor));
      }
      while (resolutionQueue.length > 0) {
        const copy = [...resolutionQueue];
        resolutionQueue.length = 0;
        await Promise.all(copy);
      }
      const volatileDescriptors = new Set(this.resolutionAliases.values());
      const optionalBuilds = new Set(allPackages.keys());
      const accessibleLocators = new Set();
      const peerRequirements = new Map();
      applyVirtualResolutionMutations({
        project: this,
        report: opts.report,
        accessibleLocators,
        volatileDescriptors,
        optionalBuilds,
        peerRequirements,
        allDescriptors,
        allResolutions,
        allPackages
      });
      for (const descriptorHash of volatileDescriptors) {
        allDescriptors.delete(descriptorHash);
        allResolutions.delete(descriptorHash);
      }
      this.storedResolutions = allResolutions;
      this.storedDescriptors = allDescriptors;
      this.storedPackages = allPackages;
      this.accessibleLocators = accessibleLocators;
      this.originalPackages = originalPackages;
      this.optionalBuilds = optionalBuilds;
      this.peerRequirements = peerRequirements;
      this.refreshWorkspaceDependencies();
    }
    async fetchEverything({cache: cache2, report, fetcher: userFetcher}) {
      const fetcher = userFetcher || this.configuration.makeFetcher();
      const fetcherOptions = {checksums: this.storedChecksums, project: this, cache: cache2, fetcher, report};
      const locatorHashes = Array.from(new Set(miscUtils8.sortMap(this.storedResolutions.values(), [
        (locatorHash) => {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg)
            throw new Error(`Assertion failed: The locator should have been registered`);
          return stringifyLocator(pkg);
        }
      ])));
      let firstError = false;
      const progress = Report.progressViaCounter(locatorHashes.length);
      report.reportProgress(progress);
      const limit = import_p_limit3.default(FETCHER_CONCURRENCY);
      await report.startCacheReport(async () => {
        await Promise.all(locatorHashes.map((locatorHash) => limit(async () => {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg)
            throw new Error(`Assertion failed: The locator should have been registered`);
          if (isVirtualLocator(pkg))
            return;
          let fetchResult;
          try {
            fetchResult = await fetcher.fetch(pkg, fetcherOptions);
          } catch (error) {
            error.message = `${prettyLocator(this.configuration, pkg)}: ${error.message}`;
            report.reportExceptionOnce(error);
            firstError = error;
            return;
          }
          if (fetchResult.checksum)
            this.storedChecksums.set(pkg.locatorHash, fetchResult.checksum);
          else
            this.storedChecksums.delete(pkg.locatorHash);
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }).finally(() => {
          progress.tick();
        })));
      });
      if (firstError) {
        throw firstError;
      }
    }
    async linkEverything({cache: cache2, report, fetcher: optFetcher, skipBuild}) {
      var _a2;
      const fetcher = optFetcher || this.configuration.makeFetcher();
      const fetcherOptions = {checksums: this.storedChecksums, project: this, cache: cache2, fetcher, report, skipIntegrityCheck: true};
      const linkers = this.configuration.getLinkers();
      const linkerOptions = {project: this, report};
      const installers = new Map(linkers.map((linker) => {
        const installer = linker.makeInstaller(linkerOptions);
        const customDataKey = installer.getCustomDataKey();
        const customData = this.installersCustomData.get(customDataKey);
        if (typeof customData !== `undefined`)
          installer.attachCustomData(customData);
        return [linker, installer];
      }));
      const packageLinkers = new Map();
      const packageLocations = new Map();
      const packageBuildDirectives = new Map();
      const fetchResultsPerPackage = new Map(await Promise.all([...this.accessibleLocators].map(async (locatorHash) => {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg)
          throw new Error(`Assertion failed: The locator should have been registered`);
        return [locatorHash, await fetcher.fetch(pkg, fetcherOptions)];
      })));
      for (const locatorHash of this.accessibleLocators) {
        const pkg = this.storedPackages.get(locatorHash);
        if (typeof pkg === `undefined`)
          throw new Error(`Assertion failed: The locator should have been registered`);
        const fetchResult = fetchResultsPerPackage.get(pkg.locatorHash);
        if (typeof fetchResult === `undefined`)
          throw new Error(`Assertion failed: The fetch result should have been registered`);
        const workspace = this.tryWorkspaceByLocator(pkg);
        if (workspace !== null) {
          const buildScripts = [];
          const {scripts} = workspace.manifest;
          for (const scriptName of [`preinstall`, `install`, `postinstall`])
            if (scripts.has(scriptName))
              buildScripts.push([BuildType.SCRIPT, scriptName]);
          try {
            for (const installer of installers.values()) {
              const result = await installer.installPackage(pkg, fetchResult);
              if (result.buildDirective !== null) {
                throw new Error(`Assertion failed: Linkers can't return build directives for workspaces; this responsibility befalls to the Yarn core`);
              }
            }
          } finally {
            if (fetchResult.releaseFs) {
              fetchResult.releaseFs();
            }
          }
          const location = ppath.join(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
          packageLocations.set(pkg.locatorHash, location);
          if (buildScripts.length > 0) {
            packageBuildDirectives.set(pkg.locatorHash, {
              directives: buildScripts,
              buildLocations: [location]
            });
          }
        } else {
          const linker = linkers.find((linker2) => linker2.supportsPackage(pkg, linkerOptions));
          if (!linker)
            throw new ReportError(MessageName.LINKER_NOT_FOUND, `${prettyLocator(this.configuration, pkg)} isn't supported by any available linker`);
          const installer = installers.get(linker);
          if (!installer)
            throw new Error(`Assertion failed: The installer should have been registered`);
          let installStatus;
          try {
            installStatus = await installer.installPackage(pkg, fetchResult);
          } finally {
            if (fetchResult.releaseFs) {
              fetchResult.releaseFs();
            }
          }
          packageLinkers.set(pkg.locatorHash, linker);
          packageLocations.set(pkg.locatorHash, installStatus.packageLocation);
          if (installStatus.buildDirective && installStatus.packageLocation) {
            packageBuildDirectives.set(pkg.locatorHash, {
              directives: installStatus.buildDirective,
              buildLocations: [installStatus.packageLocation]
            });
          }
        }
      }
      const externalDependents = new Map();
      for (const locatorHash of this.accessibleLocators) {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg)
          throw new Error(`Assertion failed: The locator should have been registered`);
        const isWorkspace = this.tryWorkspaceByLocator(pkg) !== null;
        const linkPackage = async (packageLinker, installer) => {
          const packageLocation = packageLocations.get(pkg.locatorHash);
          if (typeof packageLocation === `undefined`)
            throw new Error(`Assertion failed: The package (${prettyLocator(this.configuration, pkg)}) should have been registered`);
          const internalDependencies = [];
          for (const descriptor of pkg.dependencies.values()) {
            const resolution = this.storedResolutions.get(descriptor.descriptorHash);
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: The resolution (${prettyDescriptor(this.configuration, descriptor)}, from ${prettyLocator(this.configuration, pkg)})should have been registered`);
            const dependency = this.storedPackages.get(resolution);
            if (typeof dependency === `undefined`)
              throw new Error(`Assertion failed: The package (${resolution}, resolved from ${prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
            const dependencyLinker = this.tryWorkspaceByLocator(dependency) === null ? packageLinkers.get(resolution) : null;
            if (typeof dependencyLinker === `undefined`)
              throw new Error(`Assertion failed: The package (${resolution}, resolved from ${prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
            const isWorkspaceDependency = dependencyLinker === null;
            if (dependencyLinker === packageLinker || isWorkspace || isWorkspaceDependency) {
              if (packageLocations.get(dependency.locatorHash) !== null) {
                internalDependencies.push([descriptor, dependency]);
              }
            } else if (packageLocation !== null) {
              const externalEntry = miscUtils8.getArrayWithDefault(externalDependents, resolution);
              externalEntry.push(packageLocation);
            }
          }
          if (packageLocation !== null) {
            await installer.attachInternalDependencies(pkg, internalDependencies);
          }
        };
        if (isWorkspace) {
          for (const [packageLinker, installer] of installers) {
            await linkPackage(packageLinker, installer);
          }
        } else {
          const packageLinker = packageLinkers.get(pkg.locatorHash);
          if (!packageLinker)
            throw new Error(`Assertion failed: The linker should have been found`);
          const installer = installers.get(packageLinker);
          if (!installer)
            throw new Error(`Assertion failed: The installer should have been registered`);
          await linkPackage(packageLinker, installer);
        }
      }
      for (const [locatorHash, dependentPaths] of externalDependents) {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        const packageLinker = packageLinkers.get(pkg.locatorHash);
        if (!packageLinker)
          throw new Error(`Assertion failed: The linker should have been found`);
        const installer = installers.get(packageLinker);
        if (!installer)
          throw new Error(`Assertion failed: The installer should have been registered`);
        await installer.attachExternalDependents(pkg, dependentPaths);
      }
      const installersCustomData = new Map();
      for (const installer of installers.values()) {
        const finalizeInstallData = await installer.finalizeInstall();
        for (const installStatus of (_a2 = finalizeInstallData == null ? void 0 : finalizeInstallData.records) != null ? _a2 : []) {
          packageBuildDirectives.set(installStatus.locatorHash, {
            directives: installStatus.buildDirective,
            buildLocations: installStatus.buildLocations
          });
        }
        if (typeof (finalizeInstallData == null ? void 0 : finalizeInstallData.customData) !== `undefined`) {
          installersCustomData.set(installer.getCustomDataKey(), finalizeInstallData.customData);
        }
      }
      this.installersCustomData = installersCustomData;
      await this.persistInstallStateFile();
      if (skipBuild)
        return;
      const readyPackages = new Set(this.storedPackages.keys());
      const buildablePackages = new Set(packageBuildDirectives.keys());
      for (const locatorHash of buildablePackages)
        readyPackages.delete(locatorHash);
      const globalHashGenerator = import_crypto2.createHash(`sha512`);
      globalHashGenerator.update(process.versions.node);
      this.configuration.triggerHook((hooks) => {
        return hooks.globalHashGeneration;
      }, this, (data) => {
        globalHashGenerator.update(`\0`);
        globalHashGenerator.update(data);
      });
      const globalHash = globalHashGenerator.digest(`hex`);
      const packageHashMap = new Map();
      const getBaseHash = (locator) => {
        let hash = packageHashMap.get(locator.locatorHash);
        if (typeof hash !== `undefined`)
          return hash;
        const pkg = this.storedPackages.get(locator.locatorHash);
        if (typeof pkg === `undefined`)
          throw new Error(`Assertion failed: The package should have been registered`);
        const builder = import_crypto2.createHash(`sha512`);
        builder.update(locator.locatorHash);
        packageHashMap.set(locator.locatorHash, `<recursive>`);
        for (const descriptor of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`)
            throw new Error(`Assertion failed: The resolution (${prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const dependency = this.storedPackages.get(resolution);
          if (typeof dependency === `undefined`)
            throw new Error(`Assertion failed: The package should have been registered`);
          builder.update(getBaseHash(dependency));
        }
        hash = builder.digest(`hex`);
        packageHashMap.set(locator.locatorHash, hash);
        return hash;
      };
      const getBuildHash = (locator, buildLocations) => {
        const builder = import_crypto2.createHash(`sha512`);
        builder.update(globalHash);
        builder.update(getBaseHash(locator));
        for (const location of buildLocations)
          builder.update(location);
        return builder.digest(`hex`);
      };
      const bstatePath = this.configuration.get(`bstatePath`);
      const bstate = xfs.existsSync(bstatePath) ? parseSyml(await xfs.readFilePromise(bstatePath, `utf8`)) : {};
      const nextBState = new Map();
      while (buildablePackages.size > 0) {
        const savedSize = buildablePackages.size;
        const buildPromises = [];
        for (const locatorHash of buildablePackages) {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg)
            throw new Error(`Assertion failed: The package should have been registered`);
          let isBuildable = true;
          for (const dependency of pkg.dependencies.values()) {
            const resolution = this.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
              throw new Error(`Assertion failed: The resolution (${prettyDescriptor(this.configuration, dependency)}) should have been registered`);
            if (buildablePackages.has(resolution)) {
              isBuildable = false;
              break;
            }
          }
          if (!isBuildable)
            continue;
          buildablePackages.delete(locatorHash);
          const buildInfo = packageBuildDirectives.get(pkg.locatorHash);
          if (!buildInfo)
            throw new Error(`Assertion failed: The build directive should have been registered`);
          const buildHash = getBuildHash(pkg, buildInfo.buildLocations);
          if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash) && bstate[pkg.locatorHash] === buildHash) {
            nextBState.set(pkg.locatorHash, buildHash);
            continue;
          }
          if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash))
            report.reportInfo(MessageName.MUST_REBUILD, `${prettyLocator(this.configuration, pkg)} must be rebuilt because its dependency tree changed`);
          else
            report.reportInfo(MessageName.MUST_BUILD, `${prettyLocator(this.configuration, pkg)} must be built because it never did before or the last one failed`);
          for (const location of buildInfo.buildLocations) {
            if (!ppath.isAbsolute(location))
              throw new Error(`Assertion failed: Expected the build location to be absolute (not ${location})`);
            buildPromises.push((async () => {
              for (const [buildType, scriptName] of buildInfo.directives) {
                let header = `# This file contains the result of Yarn building a package (${stringifyLocator(pkg)})
`;
                switch (buildType) {
                  case BuildType.SCRIPT:
                    {
                      header += `# Script name: ${scriptName}
`;
                    }
                    break;
                  case BuildType.SHELLCODE:
                    {
                      header += `# Script code: ${scriptName}
`;
                    }
                    break;
                }
                const stdin = null;
                await xfs.mktempPromise(async (logDir) => {
                  const logFile = ppath.join(logDir, `build.log`);
                  const {stdout, stderr} = this.configuration.getSubprocessStreams(logFile, {
                    header,
                    prefix: prettyLocator(this.configuration, pkg),
                    report
                  });
                  let exitCode;
                  try {
                    switch (buildType) {
                      case BuildType.SCRIPT:
                        {
                          exitCode = await executePackageScript(pkg, scriptName, [], {cwd: location, project: this, stdin, stdout, stderr});
                        }
                        break;
                      case BuildType.SHELLCODE:
                        {
                          exitCode = await executePackageShellcode(pkg, scriptName, [], {cwd: location, project: this, stdin, stdout, stderr});
                        }
                        break;
                    }
                  } catch (error) {
                    stderr.write(error.stack);
                    exitCode = 1;
                  }
                  stdout.end();
                  stderr.end();
                  if (exitCode === 0) {
                    nextBState.set(pkg.locatorHash, buildHash);
                    return true;
                  }
                  xfs.detachTemp(logDir);
                  const buildMessage = `${prettyLocator(this.configuration, pkg)} couldn't be built successfully (exit code ${pretty(this.configuration, exitCode, Type.NUMBER)}, logs can be found here: ${pretty(this.configuration, logFile, Type.PATH)})`;
                  report.reportInfo(MessageName.BUILD_FAILED, buildMessage);
                  if (this.optionalBuilds.has(pkg.locatorHash)) {
                    nextBState.set(pkg.locatorHash, buildHash);
                    return true;
                  }
                  report.reportError(MessageName.BUILD_FAILED, buildMessage);
                  return false;
                });
              }
            })());
          }
        }
        await Promise.all(buildPromises);
        if (savedSize === buildablePackages.size) {
          const prettyLocators = Array.from(buildablePackages).map((locatorHash) => {
            const pkg = this.storedPackages.get(locatorHash);
            if (!pkg)
              throw new Error(`Assertion failed: The package should have been registered`);
            return prettyLocator(this.configuration, pkg);
          }).join(`, `);
          report.reportError(MessageName.CYCLIC_DEPENDENCIES, `Some packages have circular dependencies that make their build order unsatisfiable - as a result they won't be built (affected packages are: ${prettyLocators})`);
          break;
        }
      }
      if (nextBState.size > 0) {
        const bstatePath2 = this.configuration.get(`bstatePath`);
        const bstateFile = Project.generateBuildStateFile(nextBState, this.storedPackages);
        await xfs.mkdirPromise(ppath.dirname(bstatePath2), {recursive: true});
        await xfs.changeFilePromise(bstatePath2, bstateFile, {
          automaticNewlines: true
        });
      } else {
        await xfs.removePromise(bstatePath);
      }
    }
    async install(opts) {
      var _a2, _b;
      const nodeLinker = this.configuration.get(`nodeLinker`);
      (_a2 = Configuration.telemetry) == null ? void 0 : _a2.reportInstall(nodeLinker);
      await opts.report.startTimerPromise(`Project validation`, {
        skipIfEmpty: true
      }, async () => {
        await this.configuration.triggerHook((hooks) => {
          return hooks.validateProject;
        }, this, {
          reportWarning: opts.report.reportWarning.bind(opts.report),
          reportError: opts.report.reportError.bind(opts.report)
        });
      });
      for (const extensionsByIdent of this.configuration.packageExtensions.values())
        for (const [, extensionsByRange] of extensionsByIdent)
          for (const extension of extensionsByRange)
            extension.status = PackageExtensionStatus.Inactive;
      const lockfilePath = ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
      let initialLockfile = null;
      if (opts.immutable) {
        try {
          initialLockfile = await xfs.readFilePromise(lockfilePath, `utf8`);
        } catch (error) {
          if (error.code === `ENOENT`) {
            throw new ReportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been created by this install, which is explicitly forbidden.`);
          } else {
            throw error;
          }
        }
      }
      await opts.report.startTimerPromise(`Resolution step`, async () => {
        await this.resolveEverything(opts);
      });
      await opts.report.startTimerPromise(`Post-resolution validation`, {
        skipIfEmpty: true
      }, async () => {
        for (const [, extensionsPerRange] of this.configuration.packageExtensions) {
          for (const [, extensions] of extensionsPerRange) {
            for (const extension of extensions) {
              if (extension.userProvided) {
                const prettyPackageExtension = pretty(this.configuration, extension, Type.PACKAGE_EXTENSION);
                switch (extension.status) {
                  case PackageExtensionStatus.Inactive:
                    {
                      opts.report.reportWarning(MessageName.UNUSED_PACKAGE_EXTENSION, `${prettyPackageExtension}: No matching package in the dependency tree; you may not need this rule anymore.`);
                    }
                    break;
                  case PackageExtensionStatus.Redundant:
                    {
                      opts.report.reportWarning(MessageName.REDUNDANT_PACKAGE_EXTENSION, `${prettyPackageExtension}: This rule seems redundant when applied on the original package; the extension may have been applied upstream.`);
                    }
                    break;
                }
              }
            }
          }
        }
        if (initialLockfile !== null) {
          const newLockfile = normalizeLineEndings(initialLockfile, this.generateLockfile());
          if (newLockfile !== initialLockfile) {
            const diff = import_diff.structuredPatch(lockfilePath, lockfilePath, initialLockfile, newLockfile);
            opts.report.reportSeparator();
            for (const hunk of diff.hunks) {
              opts.report.reportInfo(null, `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`);
              for (const line of hunk.lines) {
                if (line.startsWith(`+`)) {
                  opts.report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, pretty(this.configuration, line, Type.ADDED));
                } else if (line.startsWith(`-`)) {
                  opts.report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, pretty(this.configuration, line, Type.REMOVED));
                } else {
                  opts.report.reportInfo(null, pretty(this.configuration, line, `grey`));
                }
              }
            }
            opts.report.reportSeparator();
            throw new ReportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been modified by this install, which is explicitly forbidden.`);
          }
        }
      });
      for (const extensionsByIdent of this.configuration.packageExtensions.values())
        for (const [, extensionsByRange] of extensionsByIdent)
          for (const extension of extensionsByRange)
            if (extension.userProvided && extension.status === PackageExtensionStatus.Active)
              (_b = Configuration.telemetry) == null ? void 0 : _b.reportPackageExtension(json(extension, Type.PACKAGE_EXTENSION));
      await opts.report.startTimerPromise(`Fetch step`, async () => {
        await this.fetchEverything(opts);
        if (typeof opts.persistProject === `undefined` || opts.persistProject) {
          await this.cacheCleanup(opts);
        }
      });
      if (typeof opts.persistProject === `undefined` || opts.persistProject)
        await this.persist();
      await opts.report.startTimerPromise(`Link step`, async () => {
        const immutablePatterns = opts.immutable ? [...new Set(this.configuration.get(`immutablePatterns`))].sort() : [];
        const before = await Promise.all(immutablePatterns.map(async (pattern) => {
          return checksumPattern(pattern, {cwd: this.cwd});
        }));
        await this.linkEverything(opts);
        const after = await Promise.all(immutablePatterns.map(async (pattern) => {
          return checksumPattern(pattern, {cwd: this.cwd});
        }));
        for (let t7 = 0; t7 < immutablePatterns.length; ++t7) {
          if (before[t7] !== after[t7]) {
            opts.report.reportError(MessageName.FROZEN_ARTIFACT_EXCEPTION, `The checksum for ${immutablePatterns[t7]} has been modified by this install, which is explicitly forbidden.`);
          }
        }
      });
      await this.persistInstallStateFile();
      await this.configuration.triggerHook((hooks) => {
        return hooks.afterAllInstalled;
      }, this, opts);
    }
    generateLockfile() {
      const reverseLookup = new Map();
      for (const [descriptorHash, locatorHash] of this.storedResolutions.entries()) {
        let descriptorHashes = reverseLookup.get(locatorHash);
        if (!descriptorHashes)
          reverseLookup.set(locatorHash, descriptorHashes = new Set());
        descriptorHashes.add(descriptorHash);
      }
      const optimizedLockfile = {};
      optimizedLockfile.__metadata = {
        version: LOCKFILE_VERSION
      };
      for (const [locatorHash, descriptorHashes] of reverseLookup.entries()) {
        const pkg = this.originalPackages.get(locatorHash);
        if (!pkg)
          continue;
        const descriptors = [];
        for (const descriptorHash of descriptorHashes) {
          const descriptor = this.storedDescriptors.get(descriptorHash);
          if (!descriptor)
            throw new Error(`Assertion failed: The descriptor should have been registered`);
          descriptors.push(descriptor);
        }
        const key = descriptors.map((descriptor) => {
          return stringifyDescriptor(descriptor);
        }).sort().join(`, `);
        const manifest = new Manifest();
        manifest.version = pkg.linkType === LinkType.HARD ? pkg.version : `0.0.0-use.local`;
        manifest.languageName = pkg.languageName;
        manifest.dependencies = new Map(pkg.dependencies);
        manifest.peerDependencies = new Map(pkg.peerDependencies);
        manifest.dependenciesMeta = new Map(pkg.dependenciesMeta);
        manifest.peerDependenciesMeta = new Map(pkg.peerDependenciesMeta);
        manifest.bin = new Map(pkg.bin);
        let entryChecksum;
        const checksum = this.storedChecksums.get(pkg.locatorHash);
        if (typeof checksum !== `undefined`) {
          const cacheKeyIndex = checksum.indexOf(`/`);
          if (cacheKeyIndex === -1)
            throw new Error(`Assertion failed: Expecte the checksum to reference its cache key`);
          const cacheKey = checksum.slice(0, cacheKeyIndex);
          const hash = checksum.slice(cacheKeyIndex + 1);
          if (typeof optimizedLockfile.__metadata.cacheKey === `undefined`)
            optimizedLockfile.__metadata.cacheKey = cacheKey;
          if (cacheKey === optimizedLockfile.__metadata.cacheKey) {
            entryChecksum = hash;
          } else {
            entryChecksum = checksum;
          }
        }
        optimizedLockfile[key] = {
          ...manifest.exportTo({}, {
            compatibilityMode: false
          }),
          linkType: pkg.linkType.toLowerCase(),
          resolution: stringifyLocator(pkg),
          checksum: entryChecksum
        };
      }
      const header = `${[
        `# This file is generated by running "yarn install" inside your project.
`,
        `# Manual changes might be lost - proceed with caution!
`
      ].join(``)}
`;
      return header + stringifySyml(optimizedLockfile);
    }
    async persistLockfile() {
      const lockfilePath = ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
      const lockfileContent = this.generateLockfile();
      await xfs.changeFilePromise(lockfilePath, lockfileContent, {
        automaticNewlines: true
      });
    }
    async persistInstallStateFile() {
      const fields = [];
      for (const category of Object.values(INSTALL_STATE_FIELDS))
        fields.push(...category);
      const installState = import_pick.default(this, fields);
      const serializedState = await gzip(import_v8.default.serialize(installState));
      const installStatePath = this.configuration.get(`installStatePath`);
      await xfs.mkdirPromise(ppath.dirname(installStatePath), {recursive: true});
      await xfs.changeFilePromise(installStatePath, serializedState);
    }
    async restoreInstallState({restoreInstallersCustomData = true, restoreResolutions = true} = {}) {
      const installStatePath = this.configuration.get(`installStatePath`);
      if (!xfs.existsSync(installStatePath)) {
        if (restoreResolutions)
          await this.applyLightResolution();
        return;
      }
      const serializedState = await xfs.readFilePromise(installStatePath);
      const installState = import_v8.default.deserialize(await gunzip(serializedState));
      if (restoreInstallersCustomData) {
        if (typeof installState.installersCustomData !== `undefined`)
          this.installersCustomData = installState.installersCustomData;
      }
      if (restoreResolutions) {
        if (installState.lockFileChecksum === this.lockFileChecksum) {
          Object.assign(this, import_pick.default(installState, INSTALL_STATE_FIELDS.restoreResolutions));
          this.refreshWorkspaceDependencies();
        } else {
          await this.applyLightResolution();
        }
      }
    }
    async applyLightResolution() {
      await this.resolveEverything({
        lockfileOnly: true,
        report: new ThrowReport()
      });
      await this.persistInstallStateFile();
    }
    async persist() {
      await this.persistLockfile();
      for (const workspace of this.workspacesByCwd.values()) {
        await workspace.persistManifest();
      }
    }
    async cacheCleanup({cache: cache2, report}) {
      const PRESERVED_FILES = new Set([
        `.gitignore`
      ]);
      if (!xfs.existsSync(cache2.cwd))
        return;
      if (!isFolderInside(cache2.cwd, this.cwd))
        return;
      for (const entry of await xfs.readdirPromise(cache2.cwd)) {
        if (PRESERVED_FILES.has(entry))
          continue;
        const entryPath = ppath.resolve(cache2.cwd, entry);
        if (cache2.markedFiles.has(entryPath))
          continue;
        if (cache2.immutable) {
          report.reportError(MessageName.IMMUTABLE_CACHE, `${pretty(this.configuration, ppath.basename(entryPath), `magenta`)} appears to be unused and would marked for deletion, but the cache is immutable`);
        } else {
          report.reportInfo(MessageName.UNUSED_CACHE_ENTRY, `${pretty(this.configuration, ppath.basename(entryPath), `magenta`)} appears to be unused - removing`);
          await xfs.removePromise(entryPath);
        }
      }
      cache2.markedFiles.clear();
    }
  };
  function applyVirtualResolutionMutations({
    project,
    allDescriptors,
    allResolutions,
    allPackages,
    accessibleLocators = new Set(),
    optionalBuilds = new Set(),
    volatileDescriptors = new Set(),
    peerRequirements = new Map(),
    report,
    tolerateMissingPackages = false
  }) {
    var _a2;
    const virtualStack = new Map();
    const resolutionStack = [];
    const allIdents = new Map();
    const allVirtualInstances = new Map();
    const allVirtualDependents = new Map();
    const peerDependencyLinks = new Map();
    const peerDependencyDependents = new Map();
    const originalWorkspaceDefinitions = new Map(project.workspaces.map((workspace) => {
      const locatorHash = workspace.anchoredLocator.locatorHash;
      const pkg = allPackages.get(locatorHash);
      if (typeof pkg === `undefined`) {
        if (tolerateMissingPackages) {
          return [locatorHash, null];
        } else {
          throw new Error(`Assertion failed: The workspace should have an associated package`);
        }
      }
      return [locatorHash, copyPackage(pkg)];
    }));
    const reportStackOverflow = () => {
      const logDir = xfs.mktempSync();
      const logFile = ppath.join(logDir, `stacktrace.log`);
      const maxSize = String(resolutionStack.length + 1).length;
      const content = resolutionStack.map((locator, index) => {
        const prefix = `${index + 1}.`.padStart(maxSize, ` `);
        return `${prefix} ${stringifyLocator(locator)}
`;
      }).join(``);
      xfs.writeFileSync(logFile, content);
      xfs.detachTemp(logDir);
      throw new ReportError(MessageName.STACK_OVERFLOW_RESOLUTION, `Encountered a stack overflow when resolving peer dependencies; cf ${npath.fromPortablePath(logFile)}`);
    };
    const getPackageFromDescriptor = (descriptor) => {
      const resolution = allResolutions.get(descriptor.descriptorHash);
      if (typeof resolution === `undefined`)
        throw new Error(`Assertion failed: The resolution should have been registered`);
      const pkg = allPackages.get(resolution);
      if (!pkg)
        throw new Error(`Assertion failed: The package could not be found`);
      return pkg;
    };
    const resolvePeerDependencies = (parentLocator, peerSlots, {first, optional}) => {
      if (resolutionStack.length > 1e3)
        reportStackOverflow();
      resolutionStack.push(parentLocator);
      const result = resolvePeerDependenciesImpl(parentLocator, peerSlots, {first, optional});
      resolutionStack.pop();
      return result;
    };
    const resolvePeerDependenciesImpl = (parentLocator, peerSlots, {first, optional}) => {
      if (accessibleLocators.has(parentLocator.locatorHash))
        return;
      accessibleLocators.add(parentLocator.locatorHash);
      if (!optional)
        optionalBuilds.delete(parentLocator.locatorHash);
      const parentPackage = allPackages.get(parentLocator.locatorHash);
      if (!parentPackage) {
        if (tolerateMissingPackages) {
          return;
        } else {
          throw new Error(`Assertion failed: The package (${prettyLocator(project.configuration, parentLocator)}) should have been registered`);
        }
      }
      const newVirtualInstances = [];
      const firstPass = [];
      const secondPass = [];
      const thirdPass = [];
      const fourthPass = [];
      for (const descriptor of Array.from(parentPackage.dependencies.values())) {
        if (parentPackage.peerDependencies.has(descriptor.identHash) && !first)
          continue;
        if (isVirtualDescriptor(descriptor))
          throw new Error(`Assertion failed: Virtual packages shouldn't be encountered when virtualizing a branch`);
        volatileDescriptors.delete(descriptor.descriptorHash);
        let isOptional = optional;
        if (!isOptional) {
          const dependencyMetaSet = parentPackage.dependenciesMeta.get(stringifyIdent(descriptor));
          if (typeof dependencyMetaSet !== `undefined`) {
            const dependencyMeta = dependencyMetaSet.get(null);
            if (typeof dependencyMeta !== `undefined` && dependencyMeta.optional) {
              isOptional = true;
            }
          }
        }
        const resolution = allResolutions.get(descriptor.descriptorHash);
        if (!resolution) {
          if (tolerateMissingPackages) {
            continue;
          } else {
            throw new Error(`Assertion failed: The resolution (${prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
          }
        }
        const pkg = originalWorkspaceDefinitions.get(resolution) || allPackages.get(resolution);
        if (!pkg)
          throw new Error(`Assertion failed: The package (${resolution}, resolved from ${prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
        if (pkg.peerDependencies.size === 0) {
          resolvePeerDependencies(pkg, new Map(), {first: false, optional: isOptional});
          continue;
        }
        const stackDepth = virtualStack.get(pkg.locatorHash);
        if (typeof stackDepth === `number` && stackDepth >= 2)
          reportStackOverflow();
        let virtualizedDescriptor;
        let virtualizedPackage;
        const missingPeerDependencies = new Set();
        let nextPeerSlots;
        firstPass.push(() => {
          virtualizedDescriptor = virtualizeDescriptor(descriptor, parentLocator.locatorHash);
          virtualizedPackage = virtualizePackage(pkg, parentLocator.locatorHash);
          parentPackage.dependencies.delete(descriptor.identHash);
          parentPackage.dependencies.set(virtualizedDescriptor.identHash, virtualizedDescriptor);
          allResolutions.set(virtualizedDescriptor.descriptorHash, virtualizedPackage.locatorHash);
          allDescriptors.set(virtualizedDescriptor.descriptorHash, virtualizedDescriptor);
          allPackages.set(virtualizedPackage.locatorHash, virtualizedPackage);
          newVirtualInstances.push([pkg, virtualizedDescriptor, virtualizedPackage]);
        });
        secondPass.push(() => {
          var _a3;
          nextPeerSlots = new Map();
          for (const peerRequest of virtualizedPackage.peerDependencies.values()) {
            let peerDescriptor = parentPackage.dependencies.get(peerRequest.identHash);
            if (!peerDescriptor && areIdentsEqual(parentLocator, peerRequest)) {
              peerDescriptor = convertLocatorToDescriptor(parentLocator);
              allDescriptors.set(peerDescriptor.descriptorHash, peerDescriptor);
              allResolutions.set(peerDescriptor.descriptorHash, parentLocator.locatorHash);
              volatileDescriptors.delete(peerDescriptor.descriptorHash);
            }
            if (!peerDescriptor && virtualizedPackage.dependencies.has(peerRequest.identHash)) {
              virtualizedPackage.peerDependencies.delete(peerRequest.identHash);
              continue;
            }
            if (!peerDescriptor)
              peerDescriptor = makeDescriptor(peerRequest, `missing:`);
            virtualizedPackage.dependencies.set(peerDescriptor.identHash, peerDescriptor);
            if (isVirtualDescriptor(peerDescriptor)) {
              const dependents = miscUtils8.getSetWithDefault(allVirtualDependents, peerDescriptor.descriptorHash);
              dependents.add(virtualizedPackage.locatorHash);
            }
            allIdents.set(peerDescriptor.identHash, peerDescriptor);
            if (peerDescriptor.range === `missing:`)
              missingPeerDependencies.add(peerDescriptor.identHash);
            nextPeerSlots.set(peerRequest.identHash, (_a3 = peerSlots.get(peerRequest.identHash)) != null ? _a3 : virtualizedPackage.locatorHash);
          }
          virtualizedPackage.dependencies = new Map(miscUtils8.sortMap(virtualizedPackage.dependencies, ([identHash, descriptor2]) => {
            return stringifyIdent(descriptor2);
          }));
        });
        thirdPass.push(() => {
          if (!allPackages.has(virtualizedPackage.locatorHash))
            return;
          const current = virtualStack.get(pkg.locatorHash);
          const next = typeof current !== `undefined` ? current + 1 : 1;
          virtualStack.set(pkg.locatorHash, next);
          resolvePeerDependencies(virtualizedPackage, nextPeerSlots, {first: false, optional: isOptional});
          virtualStack.set(pkg.locatorHash, next - 1);
        });
        fourthPass.push(() => {
          const finalDescriptor = parentPackage.dependencies.get(descriptor.identHash);
          if (typeof finalDescriptor === `undefined`)
            throw new Error(`Assertion failed: Expected the peer dependency to have been turned into a dependency`);
          const finalResolution = allResolutions.get(finalDescriptor.descriptorHash);
          if (typeof finalResolution === `undefined`)
            throw new Error(`Assertion failed: Expected the descriptor to be registered`);
          miscUtils8.getSetWithDefault(peerDependencyDependents, finalResolution).add(parentLocator.locatorHash);
          if (!allPackages.has(virtualizedPackage.locatorHash))
            return;
          for (const descriptor2 of virtualizedPackage.peerDependencies.values()) {
            const root = nextPeerSlots.get(descriptor2.identHash);
            if (typeof root === `undefined`)
              throw new Error(`Assertion failed: Expected the peer dependency ident to be registered`);
            miscUtils8.getArrayWithDefault(miscUtils8.getMapWithDefault(peerDependencyLinks, root), stringifyIdent(descriptor2)).push(virtualizedPackage.locatorHash);
          }
          for (const missingPeerDependency of missingPeerDependencies) {
            virtualizedPackage.dependencies.delete(missingPeerDependency);
          }
        });
      }
      for (const fn of [...firstPass, ...secondPass])
        fn();
      let stable;
      do {
        stable = true;
        for (const [physicalLocator, virtualDescriptor, virtualPackage] of newVirtualInstances) {
          if (!allPackages.has(virtualPackage.locatorHash))
            continue;
          const otherVirtualInstances = miscUtils8.getMapWithDefault(allVirtualInstances, physicalLocator.locatorHash);
          const dependencyHash = makeHash(...[...virtualPackage.dependencies.values()].map((descriptor) => {
            const resolution = descriptor.range !== `missing:` ? allResolutions.get(descriptor.descriptorHash) : `missing:`;
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the resolution for ${prettyDescriptor(project.configuration, descriptor)} to have been registered`);
            return resolution;
          }), virtualDescriptor.identHash);
          const masterDescriptor = otherVirtualInstances.get(dependencyHash);
          if (typeof masterDescriptor === `undefined`) {
            otherVirtualInstances.set(dependencyHash, virtualDescriptor);
            continue;
          }
          if (masterDescriptor === virtualDescriptor)
            continue;
          stable = false;
          allPackages.delete(virtualPackage.locatorHash);
          allDescriptors.delete(virtualDescriptor.descriptorHash);
          allResolutions.delete(virtualDescriptor.descriptorHash);
          accessibleLocators.delete(virtualPackage.locatorHash);
          const dependents = allVirtualDependents.get(virtualDescriptor.descriptorHash) || [];
          const allDependents = [parentPackage.locatorHash, ...dependents];
          allVirtualDependents.delete(virtualDescriptor.descriptorHash);
          for (const dependent of allDependents) {
            const pkg = allPackages.get(dependent);
            if (typeof pkg === `undefined`)
              continue;
            pkg.dependencies.set(virtualDescriptor.identHash, masterDescriptor);
          }
        }
      } while (!stable);
      for (const fn of [...thirdPass, ...fourthPass]) {
        fn();
      }
    };
    for (const workspace of project.workspaces) {
      volatileDescriptors.delete(workspace.anchoredDescriptor.descriptorHash);
      resolvePeerDependencies(workspace.anchoredLocator, new Map(), {first: true, optional: false});
    }
    var WarningType;
    (function(WarningType2) {
      WarningType2[WarningType2["NotProvided"] = 0] = "NotProvided";
      WarningType2[WarningType2["NotCompatible"] = 1] = "NotCompatible";
    })(WarningType || (WarningType = {}));
    const warnings = [];
    for (const [rootHash, dependents] of peerDependencyDependents) {
      const root = allPackages.get(rootHash);
      if (typeof root === `undefined`)
        throw new Error(`Assertion failed: Expected the root to be registered`);
      const rootLinks = peerDependencyLinks.get(rootHash);
      if (typeof rootLinks === `undefined`)
        continue;
      for (const dependentHash of dependents) {
        const dependent = allPackages.get(dependentHash);
        if (typeof dependent === `undefined`)
          continue;
        for (const [identStr, linkHashes] of rootLinks) {
          const ident = parseIdent(identStr);
          if (dependent.peerDependencies.has(ident.identHash))
            continue;
          const hash = `p${makeHash(dependentHash, identStr, rootHash).slice(0, 5)}`;
          peerRequirements.set(hash, {
            subject: dependentHash,
            requested: ident,
            rootRequester: rootHash,
            allRequesters: linkHashes
          });
          const resolvedDescriptor = root.dependencies.get(ident.identHash);
          if (typeof resolvedDescriptor !== `undefined`) {
            const peerResolution = getPackageFromDescriptor(resolvedDescriptor);
            const peerVersion = (_a2 = peerResolution.version) != null ? _a2 : `0.0.0`;
            const ranges = new Set();
            for (const linkHash of linkHashes) {
              const link = allPackages.get(linkHash);
              if (typeof link === `undefined`)
                throw new Error(`Assertion failed: Expected the link to be registered`);
              const peerDependency = link.peerDependencies.get(ident.identHash);
              if (typeof peerDependency === `undefined`)
                throw new Error(`Assertion failed: Expected the ident to be registered`);
              ranges.add(peerDependency.range);
            }
            const satisfiesAll = [...ranges].every((range) => {
              return satisfiesWithPrereleases(peerVersion, range);
            });
            if (!satisfiesAll) {
              warnings.push({
                type: 1,
                subject: dependent,
                requested: ident,
                requester: root,
                version: peerVersion,
                hash,
                requirementCount: linkHashes.length
              });
            }
          } else {
            const peerDependencyMeta = root.peerDependenciesMeta.get(identStr);
            if (!(peerDependencyMeta == null ? void 0 : peerDependencyMeta.optional)) {
              warnings.push({
                type: 0,
                subject: dependent,
                requested: ident,
                requester: root,
                hash
              });
            }
          }
        }
      }
    }
    const warningSortCriterias = [
      (warning) => prettyLocatorNoColors(warning.subject),
      (warning) => stringifyIdent(warning.requested),
      (warning) => `${warning.type}`
    ];
    for (const warning of miscUtils8.sortMap(warnings, warningSortCriterias)) {
      switch (warning.type) {
        case 0:
          {
            report == null ? void 0 : report.reportWarning(MessageName.MISSING_PEER_DEPENDENCY, `${prettyLocator(project.configuration, warning.subject)} doesn't provide ${prettyIdent(project.configuration, warning.requested)} (${pretty(project.configuration, warning.hash, Type.CODE)}), requested by ${prettyIdent(project.configuration, warning.requester)}`);
          }
          break;
        case 1:
          {
            const andDescendants = warning.requirementCount > 1 ? `and some of its descendants request` : `requests`;
            report == null ? void 0 : report.reportWarning(MessageName.INCOMPATIBLE_PEER_DEPENDENCY, `${prettyLocator(project.configuration, warning.subject)} provides ${prettyIdent(project.configuration, warning.requested)} (${pretty(project.configuration, warning.hash, Type.CODE)}) with version ${prettyReference(project.configuration, warning.version)}, which doesn't satisfy what ${prettyIdent(project.configuration, warning.requester)} ${andDescendants}`);
          }
          break;
      }
    }
    if (warnings.length > 0) {
      report == null ? void 0 : report.reportWarning(MessageName.UNNAMED, `Some peer dependencies are incorrectly met; run ${pretty(project.configuration, `yarn explain peer-requirements <hash>`, Type.CODE)} for details, where ${pretty(project.configuration, `<hash>`, Type.CODE)} is the six-letter p-prefixed code`);
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-core\sources\TelemetryManager.ts
  var miscUtils9 = __toModule(require_miscUtils());
  var MetricName;
  (function(MetricName2) {
    MetricName2["VERSION"] = `version`;
    MetricName2["COMMAND_NAME"] = `commandName`;
    MetricName2["PLUGIN_NAME"] = `pluginName`;
    MetricName2["INSTALL_COUNT"] = `installCount`;
    MetricName2["PROJECT_COUNT"] = `projectCount`;
    MetricName2["WORKSPACE_COUNT"] = `workspaceCount`;
    MetricName2["DEPENDENCY_COUNT"] = `dependencyCount`;
    MetricName2["EXTENSION"] = `packageExtension`;
  })(MetricName || (MetricName = {}));
  var TelemetryManager = class {
    constructor(configuration, accountId) {
      this.values = new Map();
      this.hits = new Map();
      this.enumerators = new Map();
      this.configuration = configuration;
      const registryFile = this.getRegistryPath();
      this.isNew = !xfs.existsSync(registryFile);
      this.sendReport(accountId);
      this.startBuffer();
    }
    reportVersion(value) {
      this.reportValue(MetricName.VERSION, value);
    }
    reportCommandName(value) {
      this.reportValue(MetricName.COMMAND_NAME, value || `<none>`);
    }
    reportPluginName(value) {
      this.reportValue(MetricName.PLUGIN_NAME, value);
    }
    reportProject(cwd) {
      this.reportEnumerator(MetricName.PROJECT_COUNT, cwd);
    }
    reportInstall(nodeLinker) {
      this.reportHit(MetricName.INSTALL_COUNT, nodeLinker);
    }
    reportPackageExtension(value) {
      this.reportValue(MetricName.EXTENSION, value);
    }
    reportWorkspaceCount(count) {
      this.reportValue(MetricName.WORKSPACE_COUNT, String(count));
    }
    reportDependencyCount(count) {
      this.reportValue(MetricName.DEPENDENCY_COUNT, String(count));
    }
    reportValue(metric, value) {
      miscUtils9.getSetWithDefault(this.values, metric).add(value);
    }
    reportEnumerator(metric, value) {
      miscUtils9.getSetWithDefault(this.enumerators, metric).add(value);
    }
    reportHit(metric, extra = `*`) {
      const ns = miscUtils9.getMapWithDefault(this.hits, metric);
      const current = miscUtils9.getFactoryWithDefault(ns, extra, () => 0);
      ns.set(extra, current + 1);
    }
    getRegistryPath() {
      const registryFile = this.configuration.get(`globalFolder`);
      return ppath.join(registryFile, `telemetry.json`);
    }
    sendReport(accountId) {
      var _a2, _b, _c;
      const registryFile = this.getRegistryPath();
      let content;
      try {
        content = xfs.readJsonSync(registryFile);
      } catch {
        content = {};
      }
      const now2 = Date.now();
      const interval = this.configuration.get(`telemetryInterval`) * 24 * 60 * 60 * 1e3;
      const lastUpdate = (_a2 = content.lastUpdate) != null ? _a2 : now2 + interval + Math.floor(interval * Math.random());
      const nextUpdate = lastUpdate + interval;
      if (nextUpdate > now2 && content.lastUpdate != null)
        return;
      try {
        xfs.mkdirSync(ppath.dirname(registryFile), {recursive: true});
        xfs.writeJsonSync(registryFile, {lastUpdate: now2});
      } catch {
        return;
      }
      if (nextUpdate > now2)
        return;
      if (!content.blocks)
        return;
      for (const [userId, block] of Object.entries((_b = content.blocks) != null ? _b : {})) {
        if (Object.keys(block).length === 0)
          continue;
        const upload = block;
        upload.userId = userId;
        for (const key of Object.keys((_c = upload.enumerators) != null ? _c : {}))
          upload.enumerators[key] = upload.enumerators[key].length;
        const rawUrl = `https://browser-http-intake.logs.datadoghq.eu/v1/input/${accountId}?ddsource=yarn`;
        post(rawUrl, upload, {
          configuration: this.configuration
        }).catch(() => {
        });
      }
    }
    applyChanges() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
      const registryFile = this.getRegistryPath();
      let content;
      try {
        content = xfs.readJsonSync(registryFile);
      } catch {
        content = {};
      }
      const userId = (_a2 = this.configuration.get(`telemetryUserId`)) != null ? _a2 : `*`;
      const blocks = content.blocks = (_b = content.blocks) != null ? _b : {};
      const block = blocks[userId] = (_c = blocks[userId]) != null ? _c : {};
      for (const key of this.hits.keys()) {
        const store = block.hits = (_d = block.hits) != null ? _d : {};
        const ns = store[key] = (_e = store[key]) != null ? _e : {};
        for (const [extra, value] of this.hits.get(key)) {
          ns[extra] = ((_f = ns[extra]) != null ? _f : 0) + value;
        }
      }
      for (const field of [`values`, `enumerators`]) {
        for (const key of this[field].keys()) {
          const store = block[field] = (_g = block[field]) != null ? _g : {};
          store[key] = [...new Set([
            ...(_h = store[key]) != null ? _h : [],
            ...(_i = this[field].get(key)) != null ? _i : []
          ])];
        }
      }
      xfs.mkdirSync(ppath.dirname(registryFile), {recursive: true});
      xfs.writeJsonSync(registryFile, content);
    }
    startBuffer() {
      process.on(`exit`, () => {
        try {
          this.applyChanges();
        } catch {
        }
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\main.ts
  var import_child_process = __toModule(require("child_process"));
  var import_ci_info2 = __toModule(require_ci_info());
  var import_fs7 = __toModule(require("fs"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\pluginCommands.ts
  var pluginCommands = new Map([
    [`constraints`, [
      [`constraints`, `query`],
      [`constraints`, `source`],
      [`constraints`]
    ]],
    [`exec`, []],
    [`interactive-tools`, [
      [`search`],
      [`upgrade-interactive`]
    ]],
    [`stage`, [
      [`stage`]
    ]],
    [`typescript`, []],
    [`version`, [
      [`version`, `apply`],
      [`version`, `check`],
      [`version`]
    ]],
    [`workspace-tools`, [
      [`workspaces`, `focus`],
      [`workspaces`, `foreach`]
    ]]
  ]);

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\BaseCommand.ts
  var BaseCommand = class extends Command {
    constructor() {
      super(...arguments);
      this.cwd = options_exports.String(`--cwd`, {hidden: true});
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\WelcomeCommand.ts
  var getMessage = (configuration) => `
${formatUtils_exports.pretty(configuration, `Welcome on Yarn 2!`, `bold`)} \u{1F389} Thanks for helping us shape our vision of how projects
should be managed going forward.

Being still in RC, Yarn 2 isn't completely stable yet. Some features might be
missing, and some behaviors may have received major overhaul. In case of doubt,
use the following URLs to get some insight:

  - The changelog:
    ${formatUtils_exports.pretty(configuration, `https://github.com/yarnpkg/berry/tree/CHANGELOG.md`, `cyan`)}

  - Our issue tracker:
    ${formatUtils_exports.pretty(configuration, `https://github.com/yarnpkg/berry`, `cyan`)}

  - Our Discord server:
    ${formatUtils_exports.pretty(configuration, `https://discord.gg/yarnpkg`, `cyan`)}

We're hoping you will enjoy the experience. For now, a good start is to run
the two following commands:

  ${formatUtils_exports.pretty(configuration, `find . -name node_modules -prune -exec rm -r {} \\;`, `magenta`)}
  ${formatUtils_exports.pretty(configuration, `yarn install`, `magenta`)}

One last trick! If you need at some point to upgrade Yarn to a nightly build,
the following command will install the CLI straight from master:

  ${formatUtils_exports.pretty(configuration, `yarn set version from sources`, `magenta`)}

See you later \u{1F44B}
`;
  var WelcomeCommand = class extends BaseCommand {
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      this.context.stdout.write(`${getMessage(configuration).trim()}
`);
    }
  };
  WelcomeCommand.paths = [
    [`--welcome`]
  ];

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\main.ts
  function runBinary(path6) {
    const physicalPath = npath.fromPortablePath(path6);
    process.on(`SIGINT`, () => {
    });
    if (physicalPath) {
      import_child_process.execFileSync(process.execPath, [physicalPath, ...process.argv.slice(2)], {
        stdio: `inherit`,
        env: {
          ...process.env,
          YARN_IGNORE_PATH: `1`,
          YARN_IGNORE_CWD: `1`
        }
      });
    } else {
      import_child_process.execFileSync(physicalPath, process.argv.slice(2), {
        stdio: `inherit`,
        env: {
          ...process.env,
          YARN_IGNORE_PATH: `1`,
          YARN_IGNORE_CWD: `1`
        }
      });
    }
  }
  async function main({binaryVersion, pluginConfiguration}) {
    async function run() {
      const cli = new Cli({
        binaryLabel: `Yarn Package Manager`,
        binaryName: `yarn`,
        binaryVersion
      });
      cli.register(WelcomeCommand);
      try {
        await exec(cli);
      } catch (error) {
        process.stdout.write(cli.error(error));
        process.exitCode = 1;
      }
    }
    async function exec(cli) {
      var _a2, _b, _c, _d, _e;
      const version = process.versions.node;
      const range = `>=12 <14 || 14.2 - 14.9 || >14.10.0`;
      if (process.env.YARN_IGNORE_NODE !== `1` && !semverUtils_exports.satisfiesWithPrereleases(version, range))
        throw new UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`);
      const configuration = await Configuration.find(npath.toPortablePath(process.cwd()), pluginConfiguration, {
        usePath: true,
        strict: false
      });
      const yarnPath = configuration.get(`yarnPath`);
      const ignorePath = configuration.get(`ignorePath`);
      const ignoreCwd = configuration.get(`ignoreCwd`);
      if (!ignorePath && !ignoreCwd && yarnPath === npath.toPortablePath(npath.resolve(process.argv[1]))) {
        process.env.YARN_IGNORE_PATH = `1`;
        process.env.YARN_IGNORE_CWD = `1`;
        await exec(cli);
        return;
      } else if (yarnPath !== null && !ignorePath) {
        if (!xfs.existsSync(yarnPath)) {
          process.stdout.write(cli.error(new Error(`The "yarn-path" option has been set (in ${configuration.sources.get(`yarnPath`)}), but the specified location doesn't exist (${yarnPath}).`)));
          process.exitCode = 1;
        } else {
          try {
            runBinary(yarnPath);
          } catch (error) {
            process.exitCode = error.code || 1;
          }
        }
      } else {
        if (ignorePath)
          delete process.env.YARN_IGNORE_PATH;
        const isTelemetryEnabled = configuration.get(`enableTelemetry`);
        if (isTelemetryEnabled && !import_ci_info2.isCI && process.stdout.isTTY)
          Configuration.telemetry = new TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
        (_a2 = Configuration.telemetry) == null ? void 0 : _a2.reportVersion(binaryVersion);
        for (const [name, plugin23] of configuration.plugins.entries()) {
          if (pluginCommands.has((_c = (_b = name.match(/^@yarnpkg\/plugin-(.*)$/)) == null ? void 0 : _b[1]) != null ? _c : ``))
            (_d = Configuration.telemetry) == null ? void 0 : _d.reportPluginName(name);
          for (const command2 of plugin23.commands || []) {
            cli.register(command2);
          }
        }
        const command = cli.process(process.argv.slice(2));
        if (!command.help)
          (_e = Configuration.telemetry) == null ? void 0 : _e.reportCommandName(command.path.join(` `));
        const cwd = command.cwd;
        if (typeof cwd !== `undefined` && !ignoreCwd) {
          const iAmHere = import_fs7.realpathSync(process.cwd());
          const iShouldBeHere = import_fs7.realpathSync(cwd);
          if (iAmHere !== iShouldBeHere) {
            process.chdir(cwd);
            await run();
            return;
          }
        }
        await cli.runExit(command, {
          cwd: npath.toPortablePath(process.cwd()),
          plugins: pluginConfiguration,
          quiet: false,
          stdin: process.stdin,
          stdout: process.stdout,
          stderr: process.stderr
        });
      }
    }
    return run().catch((error) => {
      process.stdout.write(error.stack || error.message);
      process.exitCode = 1;
    }).finally(() => xfs.rmtempPromise());
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\index.ts
  var sources_exports5 = {};
  __export(sources_exports5, {
    BaseCommand: () => BaseCommand,
    WorkspaceRequiredError: () => WorkspaceRequiredError,
    getDynamicLibs: () => getDynamicLibs,
    getPluginConfiguration: () => getPluginConfiguration,
    main: () => main,
    openWorkspace: () => openWorkspace,
    pluginCommands: () => pluginCommands
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\WorkspaceRequiredError.ts
  var WorkspaceRequiredError = class extends UsageError {
    constructor(projectCwd, cwd) {
      const relativePath = ppath.relative(projectCwd, cwd);
      const manifestPath = ppath.join(projectCwd, Manifest.fileName);
      super(`This command can only be run from within a workspace of your project (${relativePath} isn't a workspace of ${manifestPath}).`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\getDynamicLibs.ts
  var semver9 = __toModule(require_semver2());
  var typanion = __toModule(require_lib());
  var getDynamicLibs = () => new Map([
    [`@yarnpkg/cli`, sources_exports5],
    [`@yarnpkg/core`, sources_exports4],
    [`@yarnpkg/fslib`, sources_exports],
    [`@yarnpkg/libzip`, sync_exports],
    [`@yarnpkg/parsers`, sources_exports2],
    [`@yarnpkg/shell`, sources_exports3],
    [`clipanion`, advanced_exports],
    [`semver`, semver9],
    [`typanion`, typanion]
  ]);

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\openWorkspace.ts
  async function openWorkspace(configuration, cwd) {
    const {project, workspace} = await Project.find(configuration, cwd);
    if (!workspace)
      throw new WorkspaceRequiredError(project.cwd, cwd);
    return workspace;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\getPluginConfiguration.ts
  var _72 = __toModule(require_semver2());
  var _82 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\index.ts
  var sources_exports6 = {};
  __export(sources_exports6, {
    dedupeUtils: () => suggestUtils_exports,
    default: () => sources_default3,
    suggestUtils: () => suggestUtils_exports
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\add.ts
  var import_enquirer = __toModule(require_enquirer());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\suggestUtils.ts
  var suggestUtils_exports = {};
  __export(suggestUtils_exports, {
    Modifier: () => Modifier,
    Strategy: () => Strategy,
    Target: () => Target,
    applyModifier: () => applyModifier,
    extractDescriptorFromPath: () => extractDescriptorFromPath,
    extractRangeModifier: () => extractRangeModifier,
    fetchDescriptorFrom: () => fetchDescriptorFrom,
    findProjectDescriptors: () => findProjectDescriptors,
    getModifier: () => getModifier,
    getSuggestedDescriptors: () => getSuggestedDescriptors
  });
  var import_semver10 = __toModule(require_semver2());
  var Target;
  (function(Target3) {
    Target3["REGULAR"] = `dependencies`;
    Target3["DEVELOPMENT"] = `devDependencies`;
    Target3["PEER"] = `peerDependencies`;
  })(Target || (Target = {}));
  var Modifier;
  (function(Modifier3) {
    Modifier3["CARET"] = `^`;
    Modifier3["TILDE"] = `~`;
    Modifier3["EXACT"] = ``;
  })(Modifier || (Modifier = {}));
  var Strategy;
  (function(Strategy5) {
    Strategy5["KEEP"] = `keep`;
    Strategy5["REUSE"] = `reuse`;
    Strategy5["PROJECT"] = `project`;
    Strategy5["LATEST"] = `latest`;
    Strategy5["CACHE"] = `cache`;
  })(Strategy || (Strategy = {}));
  function getModifier(flags, project) {
    if (flags.exact)
      return Modifier.EXACT;
    if (flags.caret)
      return Modifier.CARET;
    if (flags.tilde)
      return Modifier.TILDE;
    return project.configuration.get(`defaultSemverRangePrefix`);
  }
  var SIMPLE_SEMVER = /^([\^~]?)[0-9]+(?:\.[0-9]+){0,2}(?:-\S+)?$/;
  function extractRangeModifier(range, {project}) {
    const match2 = range.match(SIMPLE_SEMVER);
    return match2 ? match2[1] : project.configuration.get(`defaultSemverRangePrefix`);
  }
  function applyModifier(descriptor, modifier) {
    let {protocol, source, params, selector} = structUtils_exports.parseRange(descriptor.range);
    if (import_semver10.default.valid(selector))
      selector = `${modifier}${descriptor.range}`;
    return structUtils_exports.makeDescriptor(descriptor, structUtils_exports.makeRange({protocol, source, params, selector}));
  }
  async function findProjectDescriptors(ident, {project, target}) {
    const matches = new Map();
    const getDescriptorEntry = (descriptor) => {
      let entry = matches.get(descriptor.descriptorHash);
      if (!entry) {
        matches.set(descriptor.descriptorHash, entry = {
          descriptor,
          locators: []
        });
      }
      return entry;
    };
    for (const workspace of project.workspaces) {
      if (target === Target.PEER) {
        const peerDescriptor = workspace.manifest.peerDependencies.get(ident.identHash);
        if (peerDescriptor !== void 0) {
          getDescriptorEntry(peerDescriptor).locators.push(workspace.locator);
        }
      } else {
        const regularDescriptor = workspace.manifest.dependencies.get(ident.identHash);
        const developmentDescriptor = workspace.manifest.devDependencies.get(ident.identHash);
        if (target === Target.DEVELOPMENT) {
          if (developmentDescriptor !== void 0) {
            getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
          } else if (regularDescriptor !== void 0) {
            getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
          }
        } else {
          if (regularDescriptor !== void 0) {
            getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
          } else if (developmentDescriptor !== void 0) {
            getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
          }
        }
      }
    }
    return matches;
  }
  async function extractDescriptorFromPath(path6, {cwd, workspace}) {
    return await makeTemporaryCache(async (cache2) => {
      if (!ppath.isAbsolute(path6)) {
        path6 = ppath.relative(workspace.cwd, ppath.resolve(cwd, path6));
        if (!path6.match(/^\.{0,2}\//)) {
          path6 = `./${path6}`;
        }
      }
      const {project} = workspace;
      const descriptor = await fetchDescriptorFrom(structUtils_exports.makeIdent(null, `archive`), path6, {project: workspace.project, cache: cache2, workspace});
      if (!descriptor)
        throw new Error(`Assertion failed: The descriptor should have been found`);
      const report = new ThrowReport();
      const resolver = project.configuration.makeResolver();
      const fetcher = project.configuration.makeFetcher();
      const resolverOptions = {checksums: project.storedChecksums, project, cache: cache2, fetcher, report, resolver};
      const boundDescriptor = resolver.bindDescriptor(descriptor, workspace.anchoredLocator, resolverOptions);
      const locator = structUtils_exports.convertDescriptorToLocator(boundDescriptor);
      const fetchResult = await fetcher.fetch(locator, resolverOptions);
      const manifest = await Manifest.find(fetchResult.prefixPath, {baseFs: fetchResult.packageFs});
      if (!manifest.name)
        throw new Error(`Target path doesn't have a name`);
      return structUtils_exports.makeDescriptor(manifest.name, path6);
    });
  }
  async function getSuggestedDescriptors(request2, {project, workspace, cache: cache2, target, modifier, strategies, maxResults = Infinity}) {
    if (!(maxResults >= 0))
      throw new Error(`Invalid maxResults (${maxResults})`);
    if (request2.range !== `unknown`) {
      return {
        suggestions: [{
          descriptor: request2,
          name: `Use ${structUtils_exports.prettyDescriptor(project.configuration, request2)}`,
          reason: `(unambiguous explicit request)`
        }],
        rejections: []
      };
    }
    const existing = typeof workspace !== `undefined` && workspace !== null ? workspace.manifest[target].get(request2.identHash) || null : null;
    const suggested = [];
    const rejected = [];
    const trySuggest = async (cb) => {
      try {
        await cb();
      } catch (e) {
        rejected.push(e);
      }
    };
    for (const strategy of strategies) {
      if (suggested.length >= maxResults)
        break;
      switch (strategy) {
        case Strategy.KEEP:
          {
            await trySuggest(async () => {
              if (existing) {
                suggested.push({
                  descriptor: existing,
                  name: `Keep ${structUtils_exports.prettyDescriptor(project.configuration, existing)}`,
                  reason: `(no changes)`
                });
              }
            });
          }
          break;
        case Strategy.REUSE:
          {
            await trySuggest(async () => {
              for (const {descriptor, locators} of (await findProjectDescriptors(request2, {project, target})).values()) {
                if (locators.length === 1 && locators[0].locatorHash === workspace.anchoredLocator.locatorHash) {
                  if (strategies.includes(Strategy.KEEP))
                    continue;
                }
                let reason = `(originally used by ${structUtils_exports.prettyLocator(project.configuration, locators[0])}`;
                reason += locators.length > 1 ? ` and ${locators.length - 1} other${locators.length > 2 ? `s` : ``})` : `)`;
                suggested.push({
                  descriptor,
                  name: `Reuse ${structUtils_exports.prettyDescriptor(project.configuration, descriptor)}`,
                  reason
                });
              }
            });
          }
          break;
        case Strategy.CACHE:
          {
            await trySuggest(async () => {
              for (const descriptor of project.storedDescriptors.values()) {
                if (descriptor.identHash === request2.identHash) {
                  suggested.push({
                    descriptor,
                    name: `Reuse ${structUtils_exports.prettyDescriptor(project.configuration, descriptor)}`,
                    reason: `(already used somewhere in the lockfile)`
                  });
                }
              }
            });
          }
          break;
        case Strategy.PROJECT:
          {
            await trySuggest(async () => {
              if (workspace.manifest.name !== null && request2.identHash === workspace.manifest.name.identHash)
                return;
              const candidateWorkspace = project.tryWorkspaceByIdent(request2);
              if (candidateWorkspace === null)
                return;
              suggested.push({
                descriptor: candidateWorkspace.anchoredDescriptor,
                name: `Attach ${structUtils_exports.prettyWorkspace(project.configuration, candidateWorkspace)}`,
                reason: `(local workspace at ${candidateWorkspace.cwd})`
              });
            });
          }
          break;
        case Strategy.LATEST:
          {
            await trySuggest(async () => {
              if (request2.range !== `unknown`) {
                suggested.push({
                  descriptor: request2,
                  name: `Use ${structUtils_exports.prettyRange(project.configuration, request2.range)}`,
                  reason: `(explicit range requested)`
                });
              } else if (target === Target.PEER) {
                suggested.push({
                  descriptor: structUtils_exports.makeDescriptor(request2, `*`),
                  name: `Use *`,
                  reason: `(catch-all peer dependency pattern)`
                });
              } else if (!project.configuration.get(`enableNetwork`)) {
                suggested.push({
                  descriptor: null,
                  name: `Resolve from latest`,
                  reason: formatUtils_exports.pretty(project.configuration, `(unavailable because enableNetwork is toggled off)`, `grey`)
                });
              } else {
                let latest = await fetchDescriptorFrom(request2, `latest`, {project, cache: cache2, workspace, preserveModifier: false});
                if (latest) {
                  latest = applyModifier(latest, modifier);
                  suggested.push({
                    descriptor: latest,
                    name: `Use ${structUtils_exports.prettyDescriptor(project.configuration, latest)}`,
                    reason: `(resolved from latest)`
                  });
                }
              }
            });
          }
          break;
      }
    }
    return {
      suggestions: suggested.slice(0, maxResults),
      rejections: rejected.slice(0, maxResults)
    };
  }
  async function fetchDescriptorFrom(ident, range, {project, cache: cache2, workspace, preserveModifier = true}) {
    const latestDescriptor = structUtils_exports.makeDescriptor(ident, range);
    const report = new ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const resolver = project.configuration.makeResolver();
    const fetchOptions = {project, fetcher, cache: cache2, checksums: project.storedChecksums, report, skipIntegrityCheck: true};
    const resolveOptions = {...fetchOptions, resolver, fetchOptions};
    const boundDescriptor = resolver.bindDescriptor(latestDescriptor, workspace.anchoredLocator, resolveOptions);
    const candidateLocators = await resolver.getCandidates(boundDescriptor, new Map(), resolveOptions);
    if (candidateLocators.length === 0)
      return null;
    const bestLocator = candidateLocators[0];
    let {protocol, source, params, selector} = structUtils_exports.parseRange(structUtils_exports.convertToManifestRange(bestLocator.reference));
    if (protocol === project.configuration.get(`defaultProtocol`))
      protocol = null;
    if (import_semver10.default.valid(selector) && preserveModifier !== false) {
      const referenceRange = typeof preserveModifier === `string` ? preserveModifier : latestDescriptor.range;
      const modifier = extractRangeModifier(referenceRange, {project});
      selector = modifier + selector;
    }
    return structUtils_exports.makeDescriptor(bestLocator, structUtils_exports.makeRange({protocol, source, params, selector}));
  }
  async function makeTemporaryCache(cb) {
    return await xfs.mktempPromise(async (cacheDir) => {
      const configuration = Configuration.create(cacheDir);
      configuration.useWithSource(cacheDir, {
        enableMirror: false,
        compressionLevel: 0
      }, cacheDir, {overwrite: true});
      return await cb(new Cache(cacheDir, {configuration, check: false, immutable: false}));
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\add.ts
  var AddCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.exact = options_exports.Boolean(`-E,--exact`, false, {
        description: `Don't use any semver modifier on the resolved range`
      });
      this.tilde = options_exports.Boolean(`-T,--tilde`, false, {
        description: `Use the \`~\` semver modifier on the resolved range`
      });
      this.caret = options_exports.Boolean(`-C,--caret`, false, {
        description: `Use the \`^\` semver modifier on the resolved range`
      });
      this.dev = options_exports.Boolean(`-D,--dev`, false, {
        description: `Add a package as a dev dependency`
      });
      this.peer = options_exports.Boolean(`-P,--peer`, false, {
        description: `Add a package as a peer dependency`
      });
      this.optional = options_exports.Boolean(`-O,--optional`, false, {
        description: `Add / upgrade a package to an optional regular / peer dependency`
      });
      this.preferDev = options_exports.Boolean(`--prefer-dev`, false, {
        description: `Add / upgrade a package to a dev dependency`
      });
      this.interactive = options_exports.Boolean(`-i,--interactive`, false, {
        description: `Reuse the specified package from other workspaces in the project`
      });
      this.cached = options_exports.Boolean(`--cached`, false, {
        description: `Reuse the highest version already used somewhere within the project`
      });
      this.packages = options_exports.Rest();
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const interactive = (_a2 = this.interactive) != null ? _a2 : configuration.get(`preferInteractive`);
      const modifier = getModifier(this, project);
      const strategies = [
        ...interactive ? [
          Strategy.REUSE
        ] : [],
        Strategy.PROJECT,
        ...this.cached ? [
          Strategy.CACHE
        ] : [],
        Strategy.LATEST
      ];
      const maxResults = interactive ? Infinity : 1;
      const allSuggestions = await Promise.all(this.packages.map(async (pseudoDescriptor) => {
        const request2 = pseudoDescriptor.match(/^\.{0,2}\//) ? await extractDescriptorFromPath(pseudoDescriptor, {cwd: this.context.cwd, workspace}) : structUtils_exports.parseDescriptor(pseudoDescriptor);
        const target = suggestTarget(workspace, request2, {
          dev: this.dev,
          peer: this.peer,
          preferDev: this.preferDev,
          optional: this.optional
        });
        const suggestions = await getSuggestedDescriptors(request2, {project, workspace, cache: cache2, target, modifier, strategies, maxResults});
        return [request2, suggestions, target];
      }));
      const checkReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout,
        suggestInstall: false
      }, async (report) => {
        for (const [request2, {suggestions, rejections}] of allSuggestions) {
          const nonNullSuggestions = suggestions.filter((suggestion) => {
            return suggestion.descriptor !== null;
          });
          if (nonNullSuggestions.length === 0) {
            const [firstError] = rejections;
            if (typeof firstError === `undefined`)
              throw new Error(`Assertion failed: Expected an error to have been set`);
            const prettyError = this.cli.error(firstError);
            if (!project.configuration.get(`enableNetwork`)) {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, request2)} can't be resolved to a satisfying range (note: network resolution has been disabled):

${prettyError}`);
            } else {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, request2)} can't be resolved to a satisfying range:

${prettyError}`);
            }
          }
        }
      });
      if (checkReport.hasErrors())
        return checkReport.exitCode();
      let askedQuestions = false;
      const afterWorkspaceDependencyAdditionList = [];
      const afterWorkspaceDependencyReplacementList = [];
      for (const [, {suggestions}, target] of allSuggestions) {
        let selected;
        const nonNullSuggestions = suggestions.filter((suggestion) => {
          return suggestion.descriptor !== null;
        });
        const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
        const areAllTheSame = nonNullSuggestions.every((suggestion) => structUtils_exports.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
        if (nonNullSuggestions.length === 1 || areAllTheSame) {
          selected = firstSuggestedDescriptor;
        } else {
          askedQuestions = true;
          ({answer: selected} = await import_enquirer.prompt({
            type: `select`,
            name: `answer`,
            message: `Which range do you want to use?`,
            choices: suggestions.map(({descriptor, name, reason}) => descriptor ? {
              name,
              hint: reason,
              descriptor
            } : {
              name,
              hint: reason,
              disabled: true
            }),
            onCancel: () => process.exit(130),
            result(name) {
              return this.find(name, `descriptor`);
            },
            stdin: this.context.stdin,
            stdout: this.context.stdout
          }));
        }
        const current = workspace.manifest[target].get(selected.identHash);
        if (typeof current === `undefined` || current.descriptorHash !== selected.descriptorHash) {
          workspace.manifest[target].set(selected.identHash, selected);
          if (this.optional) {
            if (target === `dependencies`) {
              workspace.manifest.ensureDependencyMeta({
                ...selected,
                range: `unknown`
              }).optional = true;
            } else if (target === `peerDependencies`) {
              workspace.manifest.ensurePeerDependencyMeta({
                ...selected,
                range: `unknown`
              }).optional = true;
            }
          }
          if (typeof current === `undefined`) {
            afterWorkspaceDependencyAdditionList.push([
              workspace,
              target,
              selected,
              strategies
            ]);
          } else {
            afterWorkspaceDependencyReplacementList.push([
              workspace,
              target,
              current,
              selected
            ]);
          }
        }
      }
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyAddition, afterWorkspaceDependencyAdditionList);
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
      if (askedQuestions)
        this.context.stdout.write(`
`);
      const installReport = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeLogs: !this.context.quiet
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  AddCommand.paths = [
    [`add`]
  ];
  AddCommand.usage = Command.Usage({
    description: `add dependencies to the project`,
    details: `
      This command adds a package to the package.json for the nearest workspace.

      - If it didn't exist before, the package will by default be added to the regular \`dependencies\` field, but this behavior can be overriden thanks to the \`-D,--dev\` flag (which will cause the dependency to be added to the \`devDependencies\` field instead) and the \`-P,--peer\` flag (which will do the same but for \`peerDependencies\`).

      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your \`dependencies\` or \`devDependencies\` (it won't ever update \`peerDependencies\`, though).

      - If set, the \`--prefer-dev\` flag will operate as a more flexible \`-D,--dev\` in that it will add the package to your \`devDependencies\` if it isn't already listed in either \`dependencies\` or \`devDependencies\`, but it will also happily upgrade your \`dependencies\` if that's what you already use (whereas \`-D,--dev\` would throw an exception).

      - If set, the \`-O,--optional\` flag will add the package to the \`optionalDependencies\` field and, in combination with the \`-P,--peer\` flag, it will add the package as an optional peer dependency. If the package was already listed in your \`dependencies\`, it will be upgraded to \`optionalDependencies\`. If the package was already listed in your \`peerDependencies\`, in combination with the \`-P,--peer\` flag, it will be upgraded to an optional peer dependency: \`"peerDependenciesMeta": { "<package>": { "optional": true } }\`

      - If the added package doesn't specify a range at all its \`latest\` tag will be resolved and the returned version will be used to generate a new semver range (using the \`^\` modifier by default unless otherwise configured via the \`defaultSemverRangePrefix\` configuration, or the \`~\` modifier if \`-T,--tilde\` is specified, or no modifier at all if \`-E,--exact\` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use \`-P,--peer\` the default range will be \`*\` and won't be resolved at all.

      - If the added package specifies a range (such as \`^1.0.0\`, \`latest\`, or \`rc\`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as \`rc\` will be encoded as-is rather than being converted into a semver range).

      If the \`--cached\` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.

      If the \`-i,--interactive\` option is used (or if the \`preferInteractive\` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.

      For a compilation of all the supported protocols, please consult the dedicated page from our website: https://yarnpkg.com/features/protocols.
    `,
    examples: [[
      `Add a regular package to the current workspace`,
      `$0 add lodash`
    ], [
      `Add a specific version for a package to the current workspace`,
      `$0 add lodash@1.2.3`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using a URL`,
      `$0 add lodash@https://github.com/lodash/lodash`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol`,
      `$0 add lodash@github:lodash/lodash`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)`,
      `$0 add lodash@lodash/lodash`
    ], [
      `Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)`,
      `$0 add lodash-es@lodash/lodash#es`
    ]]
  });
  var add_default = AddCommand;
  function suggestTarget(workspace, ident, {dev, peer, preferDev, optional}) {
    const hasRegular = workspace.manifest[Target.REGULAR].has(ident.identHash);
    const hasDev = workspace.manifest[Target.DEVELOPMENT].has(ident.identHash);
    const hasPeer = workspace.manifest[Target.PEER].has(ident.identHash);
    if ((dev || peer) && hasRegular)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);
    if (!dev && !peer && hasPeer)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);
    if (optional && hasDev)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);
    if (optional && !peer && hasPeer)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);
    if ((dev || preferDev) && optional)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" cannot simultaneously be a dev dependency and an optional dependency`);
    if (peer)
      return Target.PEER;
    if (dev || preferDev)
      return Target.DEVELOPMENT;
    if (hasRegular)
      return Target.REGULAR;
    if (hasDev)
      return Target.DEVELOPMENT;
    return Target.REGULAR;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\bin.ts
  var BinCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Print both the binary name and the locator of the package that provides the binary`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.name = options_exports.String({required: false});
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, locator} = await Project.find(configuration, this.context.cwd);
      await project.restoreInstallState();
      if (this.name) {
        const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(locator, {project});
        const binary = binaries.get(this.name);
        if (!binary)
          throw new UsageError(`Couldn't find a binary named "${this.name}" for package "${structUtils_exports.prettyLocator(configuration, locator)}"`);
        const [, binaryFile] = binary;
        this.context.stdout.write(`${binaryFile}
`);
        return 0;
      }
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(locator, {project});
        const keys = Array.from(binaries.keys());
        const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
        for (const [name, [pkg, binaryFile]] of binaries) {
          report2.reportJson({
            name,
            source: structUtils_exports.stringifyIdent(pkg),
            path: binaryFile
          });
        }
        if (this.verbose) {
          for (const [name, [pkg]] of binaries) {
            report2.reportInfo(null, `${name.padEnd(maxKeyLength, ` `)}   ${structUtils_exports.prettyLocator(configuration, pkg)}`);
          }
        } else {
          for (const name of binaries.keys()) {
            report2.reportInfo(null, name);
          }
        }
      });
      return report.exitCode();
    }
  };
  BinCommand.paths = [
    [`bin`]
  ];
  BinCommand.usage = Command.Usage({
    description: `get the path to a binary script`,
    details: `
      When used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the \`-v,--verbose\` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.

      When an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.
    `,
    examples: [[
      `List all the available binaries`,
      `$0 bin`
    ], [
      `Print the path to a specific binary`,
      `$0 bin eslint`
    ]]
  });
  var bin_default = BinCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\cache\clean.ts
  var CacheCleanCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.mirror = options_exports.Boolean(`--mirror`, false, {
        description: `Remove the global cache files instead of the local cache files`
      });
      this.all = options_exports.Boolean(`--all`, false, {
        description: `Remove both the global cache files and the local cache files of the current project`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const cache2 = await Cache.find(configuration);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async () => {
        const cleanMirror = (this.all || this.mirror) && cache2.mirrorCwd !== null;
        const cleanCache = !this.mirror;
        if (cleanMirror)
          await xfs.removePromise(cache2.mirrorCwd);
        if (cleanCache) {
          await xfs.removePromise(cache2.cwd);
        }
      });
      return report.exitCode();
    }
  };
  CacheCleanCommand.paths = [
    [`cache`, `clean`],
    [`cache`, `clear`]
  ];
  CacheCleanCommand.usage = Command.Usage({
    description: `remove the shared cache files`,
    details: `
      This command will remove all the files from the cache.
    `,
    examples: [[
      `Remove all the local archives`,
      `$0 cache clean`
    ], [
      `Remove all the archives stored in the ~/.yarn directory`,
      `$0 cache clean --mirror`
    ]]
  });
  var clean_default = CacheCleanCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\config\get.ts
  var import_get = __toModule(require_get());
  var import_util4 = __toModule(require("util"));
  var ConfigGetCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.unsafe = options_exports.Boolean(`--no-redacted`, false, {
        description: `Don't redact secrets (such as tokens) from the output`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const displayedValue = configuration.getSpecial(name, {
        hideSecrets: !this.unsafe,
        getNativePaths: true
      });
      const asObject = miscUtils10.convertMapsToIndexableObjects(displayedValue);
      const requestedObject = path6 ? import_get.default(asObject, path6) : asObject;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportJson(requestedObject);
      });
      if (!this.json) {
        if (typeof requestedObject === `string`) {
          this.context.stdout.write(`${requestedObject}
`);
          return report.exitCode();
        }
        import_util4.inspect.styles.name = `cyan`;
        this.context.stdout.write(`${import_util4.inspect(requestedObject, {
          depth: Infinity,
          colors: configuration.get(`enableColors`),
          compact: false
        })}
`);
      }
      return report.exitCode();
    }
  };
  ConfigGetCommand.paths = [
    [`config`, `get`]
  ];
  ConfigGetCommand.usage = Command.Usage({
    description: `read a configuration settings`,
    details: `
      This command will print a configuration setting.

      Secrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the \`--no-redacted\` to get the untransformed value.
    `,
    examples: [[
      `Print a simple configuration setting`,
      `yarn config get yarnPath`
    ], [
      `Print a complex configuration setting`,
      `yarn config get packageExtensions`
    ], [
      `Print a nested field from the configuration`,
      `yarn config get 'npmScopes["my-company"].npmRegistryServer'`
    ], [
      `Print a token from the configuration`,
      `yarn config get npmAuthToken --no-redacted`
    ], [
      `Print a configuration setting as JSON`,
      `yarn config get packageExtensions --json`
    ]]
  });
  var get_default = ConfigGetCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\config\set.ts
  var import_cloneDeep = __toModule(require_cloneDeep());
  var import_get2 = __toModule(require_get());
  var import_set = __toModule(require_set2());
  var import_util5 = __toModule(require("util"));
  var ConfigSetCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Set complex configuration settings to JSON values`
      });
      this.home = options_exports.Boolean(`-H,--home`, false, {
        description: `Update the home configuration instead of the project configuration`
      });
      this.name = options_exports.String();
      this.value = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (!configuration.projectCwd)
        throw new UsageError(`This command must be run from within a project folder`);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*\.?/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const value = this.json ? JSON.parse(this.value) : this.value;
      const updateConfiguration = this.home ? (patch7) => Configuration.updateHomeConfiguration(patch7) : (patch7) => Configuration.updateConfiguration(configuration.projectCwd, patch7);
      await updateConfiguration((current) => {
        if (path6) {
          const clone2 = import_cloneDeep.default(current);
          import_set.default(clone2, this.name, value);
          return clone2;
        } else {
          return {
            ...current,
            [name]: value
          };
        }
      });
      const updatedConfiguration = await Configuration.find(this.context.cwd, this.context.plugins);
      const displayedValue = updatedConfiguration.getSpecial(name, {
        hideSecrets: true,
        getNativePaths: true
      });
      const asObject = miscUtils10.convertMapsToIndexableObjects(displayedValue);
      const requestedObject = path6 ? import_get2.default(asObject, path6) : asObject;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout
      }, async (report2) => {
        import_util5.inspect.styles.name = `cyan`;
        report2.reportInfo(MessageName.UNNAMED, `Successfully set ${this.name} to ${import_util5.inspect(requestedObject, {
          depth: Infinity,
          colors: configuration.get(`enableColors`),
          compact: false
        })}`);
      });
      return report.exitCode();
    }
  };
  ConfigSetCommand.paths = [
    [`config`, `set`]
  ];
  ConfigSetCommand.usage = Command.Usage({
    description: `change a configuration settings`,
    details: `
      This command will set a configuration setting.

      When used without the \`--json\` flag, it can only set a simple configuration setting (a string, a number, or a boolean).

      When used with the \`--json\` flag, it can set both simple and complex configuration settings, including Arrays and Objects.
    `,
    examples: [[
      `Set a simple configuration setting (a string, a number, or a boolean)`,
      `yarn config set initScope myScope`
    ], [
      `Set a simple configuration setting (a string, a number, or a boolean) using the \`--json\` flag`,
      `yarn config set initScope --json \\"myScope\\"`
    ], [
      `Set a complex configuration setting (an Array) using the \`--json\` flag`,
      `yarn config set unsafeHttpWhitelist --json '["*.example.com", "example.com"]'`
    ], [
      `Set a complex configuration setting (an Object) using the \`--json\` flag`,
      `yarn config set packageExtensions --json '{ "@babel/parser@*": { "dependencies": { "@babel/types": "*" } } }'`
    ], [
      `Set a nested configuration setting`,
      `yarn config set npmScopes.company.npmRegistryServer "https://npm.example.com"`
    ], [
      `Set a nested configuration setting using indexed access for non-simple keys`,
      `yarn config set 'npmRegistries["//npm.example.com"].npmAuthToken' "ffffffff-ffff-ffff-ffff-ffffffffffff"`
    ]]
  });
  var set_default = ConfigSetCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\config\unset.ts
  var import_cloneDeep2 = __toModule(require_cloneDeep());
  var import_unset = __toModule(require_unset());
  var ConfigUnsetCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.home = options_exports.Boolean(`-H,--home`, false, {
        description: `Update the home configuration instead of the project configuration`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (!configuration.projectCwd)
        throw new UsageError(`This command must be run from within a project folder`);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*\.?/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const updateConfiguration = this.home ? (patch7) => Configuration.updateHomeConfiguration(patch7) : (patch7) => Configuration.updateConfiguration(configuration.projectCwd, patch7);
      await updateConfiguration((current) => {
        if (path6) {
          const clone2 = import_cloneDeep2.default(current);
          import_unset.default(clone2, this.name);
          return clone2;
        } else {
          const next = import_unset.default({...current}, name);
          return next;
        }
      });
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportInfo(MessageName.UNNAMED, `Successfully unset ${this.name}`);
      });
      return report.exitCode();
    }
  };
  ConfigUnsetCommand.paths = [
    [`config`, `unset`]
  ];
  ConfigUnsetCommand.usage = Command.Usage({
    description: `unset a configuration setting`,
    details: `
      This command will unset a configuration setting.
    `,
    examples: [[
      `Unset a simple configuration setting`,
      `yarn config unset initScope`
    ], [
      `Unset a complex configuration setting`,
      `yarn config unset packageExtensions`
    ], [
      `Unset a nested configuration setting`,
      `yarn config unset npmScopes.company.npmRegistryServer`
    ]]
  });
  var unset_default = ConfigUnsetCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\config.ts
  var import_util6 = __toModule(require("util"));
  var ConfigCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Print the setting description on top of the regular key/value information`
      });
      this.why = options_exports.Boolean(`--why`, false, {
        description: `Print the reason why a setting is set a particular way`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins, {
        strict: false
      });
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        if (configuration.invalid.size > 0 && !this.json) {
          for (const [key, source] of configuration.invalid)
            report2.reportError(MessageName.INVALID_CONFIGURATION_KEY, `Invalid configuration key "${key}" in ${source}`);
          report2.reportSeparator();
        }
        if (this.json) {
          const keys = miscUtils10.sortMap(configuration.settings.keys(), (key) => key);
          for (const key of keys) {
            const data = configuration.settings.get(key);
            const effective = configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            });
            const source = configuration.sources.get(key);
            if (this.verbose) {
              report2.reportJson({key, effective, source});
            } else {
              report2.reportJson({key, effective, source, ...data});
            }
          }
        } else {
          const keys = miscUtils10.sortMap(configuration.settings.keys(), (key) => key);
          const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
          const inspectConfig = {
            breakLength: Infinity,
            colors: configuration.get(`enableColors`),
            maxArrayLength: 2
          };
          if (this.why || this.verbose) {
            const keysAndDescriptions = keys.map((key) => {
              const setting = configuration.settings.get(key);
              if (!setting)
                throw new Error(`Assertion failed: This settings ("${key}") should have been registered`);
              const description = this.why ? configuration.sources.get(key) || `<default>` : setting.description;
              return [key, description];
            });
            const maxDescriptionLength = keysAndDescriptions.reduce((max, [, description]) => {
              return Math.max(max, description.length);
            }, 0);
            for (const [key, description] of keysAndDescriptions) {
              report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${description.padEnd(maxDescriptionLength, ` `)}   ${import_util6.inspect(configuration.getSpecial(key, {hideSecrets: true, getNativePaths: true}), inspectConfig)}`);
            }
          } else {
            for (const key of keys) {
              report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${import_util6.inspect(configuration.getSpecial(key, {hideSecrets: true, getNativePaths: true}), inspectConfig)}`);
            }
          }
        }
      });
      return report.exitCode();
    }
  };
  ConfigCommand.paths = [
    [`config`]
  ];
  ConfigCommand.usage = Command.Usage({
    description: `display the current configuration`,
    details: `
      This command prints the current active configuration settings.
    `,
    examples: [[
      `Print the active configuration settings`,
      `$0 config`
    ]]
  });
  var config_default = ConfigCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\dedupe.ts
  var t = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\dedupeUtils.ts
  var import_micromatch3 = __toModule(require_micromatch());
  var Strategy2;
  (function(Strategy5) {
    Strategy5["HIGHEST"] = `highest`;
  })(Strategy2 || (Strategy2 = {}));
  var acceptedStrategies = new Set(Object.values(Strategy2));
  var DEDUPE_ALGORITHMS = {
    highest: async (project, patterns, {resolver, fetcher, resolveOptions, fetchOptions}) => {
      const locatorsByIdent = new Map();
      for (const [descriptorHash, locatorHash] of project.storedResolutions) {
        const descriptor = project.storedDescriptors.get(descriptorHash);
        if (typeof descriptor === `undefined`)
          throw new Error(`Assertion failed: The descriptor (${descriptorHash}) should have been registered`);
        miscUtils10.getSetWithDefault(locatorsByIdent, descriptor.identHash).add(locatorHash);
      }
      return Array.from(project.storedDescriptors.values(), async (descriptor) => {
        if (patterns.length && !import_micromatch3.default.isMatch(structUtils_exports.stringifyIdent(descriptor), patterns))
          return null;
        const currentResolution = project.storedResolutions.get(descriptor.descriptorHash);
        if (typeof currentResolution === `undefined`)
          throw new Error(`Assertion failed: The resolution (${descriptor.descriptorHash}) should have been registered`);
        const currentPackage = project.originalPackages.get(currentResolution);
        if (typeof currentPackage === `undefined`)
          return null;
        if (!resolver.shouldPersistResolution(currentPackage, resolveOptions))
          return null;
        const locators = locatorsByIdent.get(descriptor.identHash);
        if (typeof locators === `undefined`)
          throw new Error(`Assertion failed: The resolutions (${descriptor.identHash}) should have been registered`);
        if (locators.size === 1)
          return null;
        const references = [...locators].map((locatorHash) => {
          const pkg = project.originalPackages.get(locatorHash);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
          return pkg.reference;
        });
        const candidates = await resolver.getSatisfying(descriptor, references, resolveOptions);
        const bestCandidate = candidates == null ? void 0 : candidates[0];
        if (typeof bestCandidate === `undefined`)
          return null;
        const updatedResolution = bestCandidate.locatorHash;
        const updatedPackage = project.originalPackages.get(updatedResolution);
        if (typeof updatedPackage === `undefined`)
          throw new Error(`Assertion failed: The package (${updatedResolution}) should have been registered`);
        if (updatedResolution === currentResolution)
          return null;
        return {descriptor, currentPackage, updatedPackage};
      });
    }
  };
  async function dedupe(project, {strategy, patterns, cache: cache2, report}) {
    const {configuration} = project;
    const throwReport = new ThrowReport();
    const resolver = configuration.makeResolver();
    const fetcher = configuration.makeFetcher();
    const fetchOptions = {
      cache: cache2,
      checksums: project.storedChecksums,
      fetcher,
      project,
      report: throwReport,
      skipIntegrityCheck: true
    };
    const resolveOptions = {
      project,
      resolver,
      report: throwReport,
      fetchOptions
    };
    return await report.startTimerPromise(`Deduplication step`, async () => {
      const algorithm = DEDUPE_ALGORITHMS[strategy];
      const dedupePromises = await algorithm(project, patterns, {resolver, resolveOptions, fetcher, fetchOptions});
      const progress = Report.progressViaCounter(dedupePromises.length);
      report.reportProgress(progress);
      let dedupedPackageCount = 0;
      await Promise.all(dedupePromises.map((dedupePromise) => dedupePromise.then((dedupe3) => {
        if (dedupe3 === null)
          return;
        dedupedPackageCount++;
        const {descriptor, currentPackage, updatedPackage} = dedupe3;
        report.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyDescriptor(configuration, descriptor)} can be deduped from ${structUtils_exports.prettyLocator(configuration, currentPackage)} to ${structUtils_exports.prettyLocator(configuration, updatedPackage)}`);
        report.reportJson({
          descriptor: structUtils_exports.stringifyDescriptor(descriptor),
          currentResolution: structUtils_exports.stringifyLocator(currentPackage),
          updatedResolution: structUtils_exports.stringifyLocator(updatedPackage)
        });
        project.storedResolutions.set(descriptor.descriptorHash, updatedPackage.locatorHash);
      }).finally(() => progress.tick())));
      let packages;
      switch (dedupedPackageCount) {
        case 0:
          {
            packages = `No packages`;
          }
          break;
        case 1:
          {
            packages = `One package`;
          }
          break;
        default: {
          packages = `${dedupedPackageCount} packages`;
        }
      }
      const prettyStrategy = formatUtils_exports.pretty(configuration, strategy, formatUtils_exports.Type.CODE);
      report.reportInfo(MessageName.UNNAMED, `${packages} can be deduped using the ${prettyStrategy} strategy`);
      return dedupedPackageCount;
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\dedupe.ts
  var DedupeCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.strategy = options_exports.String(`-s,--strategy`, Strategy2.HIGHEST, {
        description: `The strategy to use when deduping dependencies`,
        validator: t.isEnum(Strategy2)
      });
      this.check = options_exports.Boolean(`-c,--check`, false, {
        description: `Exit with exit code 1 when duplicates are found, without persisting the dependency tree`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      let dedupedPackageCount = 0;
      const dedupeReport = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout,
        json: this.json
      }, async (report) => {
        dedupedPackageCount = await dedupe(project, {strategy: this.strategy, patterns: this.patterns, cache: cache2, report});
      });
      if (dedupeReport.hasErrors())
        return dedupeReport.exitCode();
      if (this.check) {
        return dedupedPackageCount ? 1 : 0;
      } else {
        const installReport = await StreamReport.start({
          configuration,
          stdout: this.context.stdout,
          json: this.json
        }, async (report) => {
          await project.install({cache: cache2, report});
        });
        return installReport.exitCode();
      }
    }
  };
  DedupeCommand.paths = [
    [`dedupe`]
  ];
  DedupeCommand.usage = Command.Usage({
    description: `deduplicate dependencies with overlapping ranges`,
    details: `
      Duplicates are defined as descriptors with overlapping ranges being resolved and locked to different locators. They are a natural consequence of Yarn's deterministic installs, but they can sometimes pile up and unnecessarily increase the size of your project.

      This command dedupes dependencies in the current project using different strategies (only one is implemented at the moment):

      - \`highest\`: Reuses (where possible) the locators with the highest versions. This means that dependencies can only be upgraded, never downgraded. It's also guaranteed that it never takes more than a single pass to dedupe the entire dependency tree.

      **Note:** Even though it never produces a wrong dependency tree, this command should be used with caution, as it modifies the dependency tree, which can sometimes cause problems when packages don't strictly follow semver recommendations. Because of this, it is recommended to also review the changes manually.

      If set, the \`-c,--check\` flag will only report the found duplicates, without persisting the modified dependency tree. If changes are found, the command will exit with a non-zero exit code, making it suitable for CI purposes.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      ### In-depth explanation:

      Yarn doesn't deduplicate dependencies by default, otherwise installs wouldn't be deterministic and the lockfile would be useless. What it actually does is that it tries to not duplicate dependencies in the first place.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@*\`will cause Yarn to reuse \`foo@2.3.4\`, even if the latest \`foo\` is actually \`foo@2.10.14\`, thus preventing unnecessary duplication.

      Duplication happens when Yarn can't unlock dependencies that have already been locked inside the lockfile.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@2.10.14\` will cause Yarn to install \`foo@2.10.14\` because the existing resolution doesn't satisfy the range \`2.10.14\`. This behavior can lead to (sometimes) unwanted duplication, since now the lockfile contains 2 separate resolutions for the 2 \`foo\` descriptors, even though they have overlapping ranges, which means that the lockfile can be simplified so that both descriptors resolve to \`foo@2.10.14\`.
    `,
    examples: [[
      `Dedupe all packages`,
      `$0 dedupe`
    ], [
      `Dedupe all packages using a specific strategy`,
      `$0 dedupe --strategy highest`
    ], [
      `Dedupe a specific package`,
      `$0 dedupe lodash`
    ], [
      `Dedupe all packages with the \`@babel/*\` scope`,
      `$0 dedupe '@babel/*'`
    ], [
      `Check for duplicates (can be used as a CI step)`,
      `$0 dedupe --check`
    ]]
  });
  var dedupe_default = DedupeCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\entries\clipanion.ts
  var ClipanionCommand = class extends Command {
    async execute() {
      const {plugins} = await Configuration.find(this.context.cwd, this.context.plugins);
      const pluginDefinitions = [];
      for (const plugin23 of plugins) {
        const {commands} = plugin23[1];
        if (commands) {
          const cli = Cli.from(commands);
          const definitions = cli.definitions();
          pluginDefinitions.push([plugin23[0], definitions]);
        }
      }
      const clipanionDefinitions = this.cli.definitions();
      const arePathsEqual = (path1, path22) => path1.split(` `).slice(1).join() === path22.split(` `).slice(1).join();
      const defaultPlugins = require_package()[`@yarnpkg/builder`].bundles.standard;
      for (const pluginDefinition of pluginDefinitions) {
        const definitions = pluginDefinition[1];
        for (const definition of definitions) {
          clipanionDefinitions.find((clipanionDefinition) => arePathsEqual(clipanionDefinition.path, definition.path)).plugin = {
            name: pluginDefinition[0],
            isDefault: defaultPlugins.includes(pluginDefinition[0])
          };
        }
      }
      this.context.stdout.write(`${JSON.stringify({
        commands: clipanionDefinitions
      }, null, 2)}
`);
    }
  };
  ClipanionCommand.paths = [
    [`--clipanion=definitions`]
  ];
  var clipanion_default = ClipanionCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\entries\help.ts
  var HelpCommand3 = class extends Command {
    async execute() {
      this.context.stdout.write(this.cli.usage(null));
    }
  };
  HelpCommand3.paths = [
    [`help`],
    [`--help`],
    [`-h`]
  ];
  var help_default = HelpCommand3;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\entries\run.ts
  var EntryCommand = class extends Command {
    constructor() {
      super(...arguments);
      this.leadingArgument = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      if (this.leadingArgument.match(/[\\/]/) && !structUtils_exports.tryParseIdent(this.leadingArgument)) {
        const newCwd = ppath.resolve(this.context.cwd, npath.toPortablePath(this.leadingArgument));
        return await this.cli.run(this.args, {cwd: newCwd});
      } else {
        return await this.cli.run([`run`, this.leadingArgument, ...this.args]);
      }
    }
  };
  var run_default = EntryCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\entries\version.ts
  var VersionCommand2 = class extends Command {
    async execute() {
      this.context.stdout.write(`${YarnVersion || `<unknown>`}
`);
    }
  };
  VersionCommand2.paths = [
    [`-v`],
    [`--version`]
  ];
  var version_default = VersionCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\exec.ts
  var ExecCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.commandName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      return await xfs.mktempPromise(async (binFolder) => {
        const {code} = await execUtils_exports.pipevp(this.commandName, this.args, {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr,
          env: await scriptUtils_exports.makeScriptEnv({project, binFolder})
        });
        return code;
      });
    }
  };
  ExecCommand.paths = [
    [`exec`]
  ];
  ExecCommand.usage = Command.Usage({
    description: `execute a shell command`,
    details: `
      This command simply executes a shell binary within the context of the root directory of the active workspace.

      It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).
    `,
    examples: [[
      `Execute a shell command`,
      `$0 exec echo Hello World`
    ]]
  });
  var exec_default = ExecCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\explain\peerRequirements.ts
  var t2 = __toModule(require_lib());
  var ExplainPeerRequirementsCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.hash = options_exports.String({
        required: false,
        validator: t2.applyCascade(t2.isString(), [
          t2.matchesRegExp(/^p[0-9a-f]{5}$/)
        ])
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      await project.applyLightResolution();
      if (typeof this.hash !== `undefined`) {
        return await explainPeerRequirements(this.hash, project, {
          stdout: this.context.stdout
        });
      }
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeFooter: false
      }, async (report2) => {
        var _a2;
        const sortCriterias = [
          ([, requirement]) => structUtils_exports.stringifyLocator(project.storedPackages.get(requirement.subject)),
          ([, requirement]) => structUtils_exports.stringifyIdent(requirement.requested)
        ];
        for (const [hash, requirement] of miscUtils10.sortMap(project.peerRequirements, sortCriterias)) {
          const subject = project.storedPackages.get(requirement.subject);
          if (typeof subject === `undefined`)
            throw new Error(`Assertion failed: Expected the subject package to have been registered`);
          const rootRequester = project.storedPackages.get(requirement.rootRequester);
          if (typeof rootRequester === `undefined`)
            throw new Error(`Assertion failed: Expected the root package to have been registered`);
          const providedDescriptor = (_a2 = subject.dependencies.get(requirement.requested.identHash)) != null ? _a2 : null;
          const prettyHash = formatUtils_exports.pretty(configuration, hash, formatUtils_exports.Type.CODE);
          const prettySubject = structUtils_exports.prettyLocator(configuration, subject);
          const prettyIdent2 = structUtils_exports.prettyIdent(configuration, requirement.requested);
          const prettyRoot = structUtils_exports.prettyIdent(configuration, rootRequester);
          const descendantCount = requirement.allRequesters.length - 1;
          const pluralized = `descendant${descendantCount === 1 ? `` : `s`}`;
          const maybeDescendants = descendantCount > 0 ? ` and ${descendantCount} ${pluralized}` : ``;
          const provides = providedDescriptor !== null ? `provides` : `doesn't provide`;
          report2.reportInfo(null, `${prettyHash} \u2192 ${prettySubject} ${provides} ${prettyIdent2} to ${prettyRoot}${maybeDescendants}`);
        }
      });
      return report.exitCode();
    }
  };
  ExplainPeerRequirementsCommand.paths = [
    [`explain`, `peer-requirements`]
  ];
  ExplainPeerRequirementsCommand.usage = Command.Usage({
    description: `explain a set of peer requirements`,
    details: `
      A set of peer requirements represents all peer requirements that a dependent must satisfy when providing a given peer request to a requester and its descendants.

      When the hash argument is specified, this command prints a detailed explanation of all requirements of the set corresponding to the hash and whether they're satisfied or not.

      When used without arguments, this command lists all sets of peer requirements and the corresponding hash that can be used to get detailed information about a given set.

      **Note:** A hash is a six-letter p-prefixed code that can be obtained from peer dependency warnings or from the list of all peer requirements (\`yarn explain peer-requirements\`).
    `,
    examples: [[
      `Explain the corresponding set of peer requirements for a hash`,
      `$0 explain peer-requirements p1a4ed`
    ], [
      `List all sets of peer requirements`,
      `$0 explain peer-requirements`
    ]]
  });
  var peerRequirements_default = ExplainPeerRequirementsCommand;
  async function explainPeerRequirements(peerRequirementsHash, project, opts) {
    const {configuration} = project;
    const requirement = project.peerRequirements.get(peerRequirementsHash);
    if (typeof requirement === `undefined`)
      throw new Error(`No peerDependency requirements found for hash: "${peerRequirementsHash}"`);
    const report = await StreamReport.start({
      configuration,
      stdout: opts.stdout,
      includeFooter: false
    }, async (report2) => {
      var _a2, _b;
      const subject = project.storedPackages.get(requirement.subject);
      if (typeof subject === `undefined`)
        throw new Error(`Assertion failed: Expected the subject package to have been registered`);
      const rootRequester = project.storedPackages.get(requirement.rootRequester);
      if (typeof rootRequester === `undefined`)
        throw new Error(`Assertion failed: Expected the root package to have been registered`);
      const providedDescriptor = (_a2 = subject.dependencies.get(requirement.requested.identHash)) != null ? _a2 : null;
      const providedResolution = providedDescriptor !== null ? project.storedResolutions.get(providedDescriptor.descriptorHash) : null;
      if (typeof providedResolution === `undefined`)
        throw new Error(`Assertion failed: Expected the resolution to have been registered`);
      const provided = providedResolution !== null ? project.storedPackages.get(providedResolution) : null;
      if (typeof provided === `undefined`)
        throw new Error(`Assertion failed: Expected the provided package to have been registered`);
      const allRequesters = [...requirement.allRequesters.values()].map((requesterHash) => {
        const pkg = project.storedPackages.get(requesterHash);
        if (typeof pkg === `undefined`)
          throw new Error(`Assertion failed: Expected the package to be registered`);
        const devirtualizedLocator = structUtils_exports.devirtualizeLocator(pkg);
        const devirtualizedPkg = project.storedPackages.get(devirtualizedLocator.locatorHash);
        if (typeof devirtualizedPkg === `undefined`)
          throw new Error(`Assertion failed: Expected the package to be registered`);
        const peerDependency = devirtualizedPkg.peerDependencies.get(requirement.requested.identHash);
        if (typeof peerDependency === `undefined`)
          throw new Error(`Assertion failed: Expected the peer dependency to be registered`);
        return {pkg, peerDependency};
      });
      if (provided !== null) {
        const satisfiesAllRanges = allRequesters.every(({peerDependency}) => {
          return semverUtils_exports.satisfiesWithPrereleases(provided.version, peerDependency.range);
        });
        report2.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyLocator(configuration, subject)} provides ${structUtils_exports.prettyLocator(configuration, provided)} with version ${structUtils_exports.prettyReference(configuration, (_b = provided.version) != null ? _b : `<missing>`)}, which ${satisfiesAllRanges ? `satisfies` : `doesn't satisfy`} the following requirements:`);
      } else {
        report2.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyLocator(configuration, subject)} doesn't provide ${structUtils_exports.prettyIdent(configuration, requirement.requested)}, breaking the following requirements:`);
      }
      report2.reportSeparator();
      const Mark = formatUtils_exports.mark(configuration);
      const requirements = [];
      for (const {pkg, peerDependency} of miscUtils10.sortMap(allRequesters, (requester) => structUtils_exports.stringifyLocator(requester.pkg))) {
        const isSatisfied = provided !== null ? semverUtils_exports.satisfiesWithPrereleases(provided.version, peerDependency.range) : false;
        const mark2 = isSatisfied ? Mark.Check : Mark.Cross;
        requirements.push({
          stringifiedLocator: structUtils_exports.stringifyLocator(pkg),
          prettyLocator: structUtils_exports.prettyLocator(configuration, pkg),
          prettyRange: structUtils_exports.prettyRange(configuration, peerDependency.range),
          mark: mark2
        });
      }
      const maxStringifiedLocatorLength = Math.max(...requirements.map(({stringifiedLocator}) => stringifiedLocator.length));
      const maxPrettyRangeLength = Math.max(...requirements.map(({prettyRange: prettyRange2}) => prettyRange2.length));
      for (const {stringifiedLocator, prettyLocator: prettyLocator2, prettyRange: prettyRange2, mark: mark2} of miscUtils10.sortMap(requirements, ({stringifiedLocator: stringifiedLocator2}) => stringifiedLocator2)) {
        report2.reportInfo(null, `${prettyLocator2.padEnd(maxStringifiedLocatorLength + (prettyLocator2.length - stringifiedLocator.length), ` `)} \u2192 ${prettyRange2.padEnd(maxPrettyRangeLength, ` `)} ${mark2}`);
      }
      if (requirements.length > 1) {
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Note: these requirements start with ${structUtils_exports.prettyLocator(project.configuration, rootRequester)}`);
      }
    });
    return report.exitCode();
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\info.ts
  var import_micromatch4 = __toModule(require_micromatch());
  var InfoCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Print versions of a package from the whole project`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Print information for all packages, including transitive dependencies`
      });
      this.extra = options_exports.Array(`-X,--extra`, [], {
        description: `An array of requests of extra data provided by plugins`
      });
      this.cache = options_exports.Boolean(`--cache`, false, {
        description: `Print information about the cache entry of a package (path, size, checksum)`
      });
      this.dependents = options_exports.Boolean(`--dependents`, false, {
        description: `Print all dependents for each matching package`
      });
      this.manifest = options_exports.Boolean(`--manifest`, false, {
        description: `Print data obtained by looking at the package archive (license, homepage, ...)`
      });
      this.nameOnly = options_exports.Boolean(`--name-only`, false, {
        description: `Only print the name for the matching packages`
      });
      this.virtuals = options_exports.Boolean(`--virtuals`, false, {
        description: `Print each instance of the virtual packages`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace && !this.all)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const extraSet = new Set(this.extra);
      if (this.cache)
        extraSet.add(`cache`);
      if (this.dependents)
        extraSet.add(`dependents`);
      if (this.manifest)
        extraSet.add(`manifest`);
      const traverseWorkspace = (workspace2, {recursive}) => {
        const initialHash = workspace2.anchoredLocator.locatorHash;
        const seen = new Map();
        const pass = [initialHash];
        while (pass.length > 0) {
          const hash = pass.shift();
          if (seen.has(hash))
            continue;
          const pkg = project.storedPackages.get(hash);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: Expected the package to be registered`);
          seen.set(hash, pkg);
          if (structUtils_exports.isVirtualLocator(pkg))
            pass.push(structUtils_exports.devirtualizeLocator(pkg).locatorHash);
          if (!recursive && hash !== initialHash)
            continue;
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the resolution to be registered`);
            pass.push(resolution);
          }
        }
        return seen.values();
      };
      const traverseAllWorkspaces = ({recursive}) => {
        const aggregate = new Map();
        for (const workspace2 of project.workspaces)
          for (const pkg of traverseWorkspace(workspace2, {recursive}))
            aggregate.set(pkg.locatorHash, pkg);
        return aggregate.values();
      };
      const getLookupSet = ({all, recursive}) => {
        if (all && recursive)
          return project.storedPackages.values();
        if (all) {
          return traverseAllWorkspaces({recursive});
        } else {
          return traverseWorkspace(workspace, {recursive});
        }
      };
      const findSelectedSet = ({all, recursive}) => {
        const lookupSet = getLookupSet({all, recursive});
        const matchers = this.patterns.map((pattern) => {
          const patternLocator = structUtils_exports.parseLocator(pattern);
          const identRegex = import_micromatch4.default.makeRe(structUtils_exports.stringifyIdent(patternLocator));
          const patternIsVirtual = structUtils_exports.isVirtualLocator(patternLocator);
          const uvPatternLocator = patternIsVirtual ? structUtils_exports.devirtualizeLocator(patternLocator) : patternLocator;
          return (pkg) => {
            const stringifiedIdent = structUtils_exports.stringifyIdent(pkg);
            if (!identRegex.test(stringifiedIdent))
              return false;
            if (patternLocator.reference === `unknown`)
              return true;
            const pkgIsVirtual = structUtils_exports.isVirtualLocator(pkg);
            const uvPkgLocator = pkgIsVirtual ? structUtils_exports.devirtualizeLocator(pkg) : pkg;
            if (patternIsVirtual && pkgIsVirtual && patternLocator.reference !== pkg.reference)
              return false;
            if (uvPatternLocator.reference !== uvPkgLocator.reference)
              return false;
            return true;
          };
        });
        const sortedLookup2 = miscUtils10.sortMap([...lookupSet], (pkg) => {
          return structUtils_exports.stringifyLocator(pkg);
        });
        const selection2 = sortedLookup2.filter((pkg) => {
          return matchers.length === 0 || matchers.some((matcher) => matcher(pkg));
        });
        return {selection: selection2, sortedLookup: sortedLookup2};
      };
      const {selection, sortedLookup} = findSelectedSet({
        all: this.all,
        recursive: this.recursive
      });
      if (selection.length === 0)
        throw new UsageError(`No package matched your request`);
      const dependentMap = new Map();
      if (this.dependents) {
        for (const pkg of sortedLookup) {
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the resolution to be registered`);
            miscUtils10.getArrayWithDefault(dependentMap, resolution).push(pkg);
          }
        }
      }
      const allInstances = new Map();
      for (const pkg of sortedLookup) {
        if (!structUtils_exports.isVirtualLocator(pkg))
          continue;
        const base = structUtils_exports.devirtualizeLocator(pkg);
        miscUtils10.getArrayWithDefault(allInstances, base.locatorHash).push(pkg);
      }
      const infoTreeChildren = {};
      const infoTree = {children: infoTreeChildren};
      const fetcher = configuration.makeFetcher();
      const fetcherOptions = {project, fetcher, cache: cache2, checksums: project.storedChecksums, report: new ThrowReport(), skipIntegrityCheck: true};
      const builtinInfoBuilders = [
        async (pkg, extra, registerData) => {
          var _a2, _b;
          if (!extra.has(`manifest`))
            return;
          const fetchResult = await fetcher.fetch(pkg, fetcherOptions);
          let manifest;
          try {
            manifest = await Manifest.find(fetchResult.prefixPath, {baseFs: fetchResult.packageFs});
          } finally {
            (_a2 = fetchResult.releaseFs) == null ? void 0 : _a2.call(fetchResult);
          }
          registerData(`Manifest`, {
            [`License`]: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, manifest.license),
            [`Homepage`]: formatUtils_exports.tuple(formatUtils_exports.Type.URL, (_b = manifest.raw.homepage) != null ? _b : null)
          });
        },
        async (pkg, extra, registerData) => {
          var _a2;
          if (!extra.has(`cache`))
            return;
          const checksum = (_a2 = project.storedChecksums.get(pkg.locatorHash)) != null ? _a2 : null;
          const cachePath = cache2.getLocatorPath(pkg, checksum);
          let stat;
          if (cachePath !== null) {
            try {
              stat = xfs.statSync(cachePath);
            } catch {
            }
          }
          const size = typeof stat !== `undefined` ? [stat.size, formatUtils_exports.Type.SIZE] : void 0;
          registerData(`Cache`, {
            [`Checksum`]: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, checksum),
            [`Path`]: formatUtils_exports.tuple(formatUtils_exports.Type.PATH, cachePath),
            [`Size`]: size
          });
        }
      ];
      for (const pkg of selection) {
        const isVirtual = structUtils_exports.isVirtualLocator(pkg);
        if (!this.virtuals && isVirtual)
          continue;
        const nodeChildren = {};
        const node = {
          value: [pkg, formatUtils_exports.Type.LOCATOR],
          children: nodeChildren
        };
        infoTreeChildren[structUtils_exports.stringifyLocator(pkg)] = node;
        if (this.nameOnly) {
          delete node.children;
          continue;
        }
        const instances = allInstances.get(pkg.locatorHash);
        if (typeof instances !== `undefined`) {
          nodeChildren.Instances = {
            label: `Instances`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NUMBER, instances.length)
          };
        }
        nodeChildren.Version = {
          label: `Version`,
          value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, pkg.version)
        };
        const registerData = (namespace, info) => {
          const namespaceNode = {};
          nodeChildren[namespace] = namespaceNode;
          if (Array.isArray(info)) {
            namespaceNode.children = info.map((value) => ({value}));
          } else {
            const namespaceChildren = {};
            namespaceNode.children = namespaceChildren;
            for (const [key, value] of Object.entries(info)) {
              if (typeof value === `undefined`)
                continue;
              namespaceChildren[key] = {
                label: key,
                value
              };
            }
          }
        };
        if (!isVirtual) {
          for (const infoBuilder of builtinInfoBuilders)
            await infoBuilder(pkg, extraSet, registerData);
          await configuration.triggerHook((hooks) => {
            return hooks.fetchPackageInfo;
          }, pkg, extraSet, registerData);
        }
        if (pkg.bin.size > 0 && !isVirtual) {
          registerData(`Exported Binaries`, [...pkg.bin.keys()].map((name) => {
            return formatUtils_exports.tuple(formatUtils_exports.Type.PATH, name);
          }));
        }
        const dependents = dependentMap.get(pkg.locatorHash);
        if (typeof dependents !== `undefined` && dependents.length > 0) {
          registerData(`Dependents`, dependents.map((dependent) => {
            return formatUtils_exports.tuple(formatUtils_exports.Type.LOCATOR, dependent);
          }));
        }
        if (pkg.dependencies.size > 0 && !isVirtual) {
          registerData(`Dependencies`, [...pkg.dependencies.values()].map((dependency) => {
            var _a2;
            const resolutionHash = project.storedResolutions.get(dependency.descriptorHash);
            const resolution = typeof resolutionHash !== `undefined` ? (_a2 = project.storedPackages.get(resolutionHash)) != null ? _a2 : null : null;
            return formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
              descriptor: dependency,
              locator: resolution
            });
          }));
        }
        if (pkg.peerDependencies.size > 0 && isVirtual) {
          registerData(`Peer dependencies`, [...pkg.peerDependencies.values()].map((peerDependency) => {
            var _a2, _b;
            const dependency = pkg.dependencies.get(peerDependency.identHash);
            const resolutionHash = typeof dependency !== `undefined` ? (_a2 = project.storedResolutions.get(dependency.descriptorHash)) != null ? _a2 : null : null;
            const resolution = resolutionHash !== null ? (_b = project.storedPackages.get(resolutionHash)) != null ? _b : null : null;
            return formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
              descriptor: peerDependency,
              locator: resolution
            });
          }));
        }
      }
      treeUtils_exports.emitTree(infoTree, {
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        separators: this.nameOnly ? 0 : 2
      });
    }
  };
  InfoCommand.paths = [
    [`info`]
  ];
  InfoCommand.usage = Command.Usage({
    description: `see information related to packages`,
    details: `
      This command prints various information related to the specified packages, accepting glob patterns.

      By default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the \`-A,--all\` flag. Adding the \`-R,--recursive\` flag will also report transitive dependencies.

      Some fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (\`--dependents\`, \`--manifest\`, \`--virtuals\`, ...) described in the option descriptions.

      Note that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use \`yarn why\` which will do just that (it also provides a \`-R,--recursive\` flag that may be of some help).
    `,
    examples: [[
      `Show information about Lodash`,
      `$0 info lodash`
    ]]
  });
  var info_default = InfoCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\install.ts
  var import_ci_info3 = __toModule(require_ci_info());
  var YarnCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.immutable = options_exports.Boolean(`--immutable`, {
        description: `Abort with an error exit code if the lockfile was to be modified`
      });
      this.immutableCache = options_exports.Boolean(`--immutable-cache`, {
        description: `Abort with an error exit code if the cache folder was to be modified`
      });
      this.checkCache = options_exports.Boolean(`--check-cache`, false, {
        description: `Always refetch the packages and ensure that their checksums are consistent`
      });
      this.inlineBuilds = options_exports.Boolean(`--inline-builds`, {
        description: `Verbosely print the output of the build steps of dependencies`
      });
      this.skipBuilds = options_exports.Boolean(`--skip-builds`, false, {
        description: `Skip the build step altogether`
      });
      this.cacheFolder = options_exports.String(`--cache-folder`, {hidden: true});
      this.frozenLockfile = options_exports.Boolean(`--frozen-lockfile`, {hidden: true});
      this.ignoreEngines = options_exports.Boolean(`--ignore-engines`, {hidden: true});
      this.nonInteractive = options_exports.Boolean(`--non-interactive`, {hidden: true});
      this.preferOffline = options_exports.Boolean(`--prefer-offline`, {hidden: true});
      this.production = options_exports.Boolean(`--production`, {hidden: true});
      this.registry = options_exports.String(`--registry`, {hidden: true});
      this.silent = options_exports.Boolean(`--silent`, {hidden: true});
    }
    async execute() {
      var _a2, _b, _c;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (typeof this.inlineBuilds !== `undefined`)
        configuration.useWithSource(`<cli>`, {enableInlineBuilds: this.inlineBuilds}, configuration.startingCwd, {overwrite: true});
      const isZeitNow = !!process.env.NOW_BUILDER;
      const isNetlify = !!process.env.NETLIFY;
      const isGCP = !!process.env.FUNCTION_TARGET || !!process.env.GOOGLE_RUNTIME;
      const reportDeprecation = async (message, {error}) => {
        const deprecationReport = await StreamReport.start({
          configuration,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          if (error) {
            report2.reportError(MessageName.DEPRECATED_CLI_SETTINGS, message);
          } else {
            report2.reportWarning(MessageName.DEPRECATED_CLI_SETTINGS, message);
          }
        });
        if (deprecationReport.hasErrors()) {
          return deprecationReport.exitCode();
        } else {
          return null;
        }
      };
      if (typeof this.ignoreEngines !== `undefined`) {
        const exitCode = await reportDeprecation(`The --ignore-engines option is deprecated; engine checking isn't a core feature anymore`, {
          error: !isZeitNow
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.registry !== `undefined`) {
        const exitCode = await reportDeprecation(`The --registry option is deprecated; prefer setting npmRegistryServer in your .yarnrc.yml file`, {
          error: false
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.preferOffline !== `undefined`) {
        const exitCode = await reportDeprecation(`The --prefer-offline flag is deprecated; use the --cached flag with 'yarn add' instead`, {
          error: !isZeitNow
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.production !== `undefined`) {
        const exitCode = await reportDeprecation(`The --production option is deprecated on 'install'; use 'yarn workspaces focus' instead`, {
          error: true
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.nonInteractive !== `undefined`) {
        const exitCode = await reportDeprecation(`The --non-interactive option is deprecated`, {
          error: !isGCP
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.frozenLockfile !== `undefined`) {
        const exitCode = await reportDeprecation(`The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead`, {
          error: !isGCP && !import_ci_info3.TRAVIS
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.cacheFolder !== `undefined`) {
        const exitCode = await reportDeprecation(`The cache-folder option has been deprecated; use rc settings instead`, {
          error: !isNetlify
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      const immutable = typeof this.immutable === `undefined` && typeof this.frozenLockfile === `undefined` ? (_a2 = configuration.get(`enableImmutableInstalls`)) != null ? _a2 : false : (_c = (_b = this.immutable) != null ? _b : this.frozenLockfile) != null ? _c : false;
      if (configuration.projectCwd !== null) {
        const fixReport = await StreamReport.start({
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          if (await autofixMergeConflicts(configuration, immutable)) {
            report2.reportInfo(MessageName.AUTOMERGE_SUCCESS, `Automatically fixed merge conflicts \u{1F44D}`);
            report2.reportSeparator();
          }
        });
        if (fixReport.hasErrors()) {
          return fixReport.exitCode();
        }
      }
      if (configuration.projectCwd !== null) {
        const telemetryReport = await StreamReport.start({
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          var _a3;
          if ((_a3 = Configuration.telemetry) == null ? void 0 : _a3.isNew) {
            report2.reportInfo(MessageName.TELEMETRY_NOTICE, `Yarn will periodically gather anonymous telemetry: https://yarnpkg.com/advanced/telemetry`);
            report2.reportInfo(MessageName.TELEMETRY_NOTICE, `Run ${formatUtils_exports.pretty(configuration, `yarn config set --home enableTelemetry 0`, formatUtils_exports.Type.CODE)} to disable`);
            report2.reportSeparator();
          }
        });
        if (telemetryReport.hasErrors()) {
          return telemetryReport.exitCode();
        }
      }
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration, {immutable: this.immutableCache, check: this.checkCache});
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeLogs: true
      }, async (report2) => {
        await project.install({cache: cache2, report: report2, immutable, skipBuild: this.skipBuilds});
      });
      return report.exitCode();
    }
  };
  YarnCommand.paths = [
    [`install`],
    Command.Default
  ];
  YarnCommand.usage = Command.Usage({
    description: `install the project dependencies`,
    details: `
      This command setup your project if needed. The installation is splitted in four different steps that each have their own characteristics:

      - **Resolution:** First the package manager will resolve your dependencies. The exact way a dependency version is privileged over another isn't standardized outside of the regular semver guarantees. If a package doesn't resolve to what you would expect, check that all dependencies are correctly declared (also check our website for more information: ).

      - **Fetch:** Then we download all the dependencies if needed, and make sure that they're all stored within our cache (check the value of \`cacheFolder\` in \`yarn config\` to see where are stored the cache files).

      - **Link:** Then we send the dependency tree information to internal plugins tasked from writing them on the disk in some form (for example by generating the .pnp.cjs file you might know).

      - **Build:** Once the dependency tree has been written on the disk, the package manager will now be free to run the build scripts for all packages that might need it, in a topological order compatible with the way they depend on one another.

      Note that running this command is not part of the recommended workflow. Yarn supports zero-installs, which means that as long as you store your cache and your .pnp.cjs file inside your repository, everything will work without requiring any install right after cloning your repository or switching branches.

      If the \`--immutable\` option is set, Yarn will abort with an error exit code if the lockfile was to be modified (other paths can be added using the \`immutablePatterns\` configuration setting). For backward compatibility we offer an alias under the name of \`--frozen-lockfile\`, but it will be removed in a later release.

      If the \`--immutable-cache\` option is set, Yarn will abort with an error exit code if the cache folder was to be modified (either because files would be added, or because they'd be removed).

      If the \`--check-cache\` option is set, Yarn will always refetch the packages and will ensure that their checksum matches what's 1/ described in the lockfile 2/ inside the existing cache files (if present). This is recommended as part of your CI workflow if you're both following the Zero-Installs model and accepting PRs from third-parties, as they'd otherwise have the ability to alter the checked-in packages before submitting them.

      If the \`--inline-builds\` option is set, Yarn will verbosely print the output of the build steps of your dependencies (instead of writing them into individual files). This is likely useful mostly for debug purposes only when using Docker-like environments.

      If the \`--skip-builds\` option is set, Yarn will not run the build scripts at all. Note that this is different from setting \`enableScripts\` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.
    `,
    examples: [[
      `Install the project`,
      `$0 install`
    ], [
      `Validate a project when using Zero-Installs`,
      `$0 install --immutable --immutable-cache`
    ], [
      `Validate a project when using Zero-Installs (slightly safer if you accept external PRs)`,
      `$0 install --immutable --immutable-cache --check-cache`
    ]]
  });
  var install_default = YarnCommand;
  var MERGE_CONFLICT_ANCESTOR = `|||||||`;
  var MERGE_CONFLICT_END = `>>>>>>>`;
  var MERGE_CONFLICT_SEP = `=======`;
  var MERGE_CONFLICT_START = `<<<<<<<`;
  async function autofixMergeConflicts(configuration, immutable) {
    if (!configuration.projectCwd)
      return false;
    const lockfilePath = ppath.join(configuration.projectCwd, configuration.get(`lockfileFilename`));
    if (!await xfs.existsPromise(lockfilePath))
      return false;
    const file = await xfs.readFilePromise(lockfilePath, `utf8`);
    if (!file.includes(MERGE_CONFLICT_START))
      return false;
    if (immutable)
      throw new ReportError(MessageName.AUTOMERGE_IMMUTABLE, `Cannot autofix a lockfile when running an immutable install`);
    const [left, right] = getVariants(file);
    let parsedLeft;
    let parsedRight;
    try {
      parsedLeft = parseSyml(left);
      parsedRight = parseSyml(right);
    } catch (error) {
      throw new ReportError(MessageName.AUTOMERGE_FAILED_TO_PARSE, `The individual variants of the lockfile failed to parse`);
    }
    const merged = {
      ...parsedLeft,
      ...parsedRight
    };
    for (const [key, value] of Object.entries(merged))
      if (typeof value === `string`)
        delete merged[key];
    await xfs.changeFilePromise(lockfilePath, stringifySyml(merged), {
      automaticNewlines: true
    });
    return true;
  }
  function getVariants(file) {
    const variants = [[], []];
    const lines = file.split(/\r?\n/g);
    let skip = false;
    while (lines.length > 0) {
      const line = lines.shift();
      if (typeof line === `undefined`)
        throw new Error(`Assertion failed: Some lines should remain`);
      if (line.startsWith(MERGE_CONFLICT_START)) {
        while (lines.length > 0) {
          const conflictLine = lines.shift();
          if (typeof conflictLine === `undefined`)
            throw new Error(`Assertion failed: Some lines should remain`);
          if (conflictLine === MERGE_CONFLICT_SEP) {
            skip = false;
            break;
          } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {
            skip = true;
            continue;
          } else {
            variants[0].push(conflictLine);
          }
        }
        while (lines.length > 0) {
          const conflictLine = lines.shift();
          if (typeof conflictLine === `undefined`)
            throw new Error(`Assertion failed: Some lines should remain`);
          if (conflictLine.startsWith(MERGE_CONFLICT_END)) {
            break;
          } else {
            variants[1].push(conflictLine);
          }
        }
      } else {
        variants[0].push(line);
        variants[1].push(line);
      }
    }
    return [
      variants[0].join(`
`),
      variants[1].join(`
`)
    ];
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\link.ts
  var LinkCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Link all workspaces belonging to the target project to the current one`
      });
      this.private = options_exports.Boolean(`-p,--private`, false, {
        description: `Also link private workspaces belonging to the target project to the current one`
      });
      this.relative = options_exports.Boolean(`-r,--relative`, false, {
        description: `Link workspaces using relative paths instead of absolute paths`
      });
      this.destination = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const absoluteDestination = ppath.resolve(this.context.cwd, npath.toPortablePath(this.destination));
      const configuration2 = await Configuration.find(absoluteDestination, this.context.plugins);
      const {project: project2, workspace: workspace2} = await Project.find(configuration2, absoluteDestination);
      if (!workspace2)
        throw new WorkspaceRequiredError(project2.cwd, absoluteDestination);
      const topLevelWorkspace = project.topLevelWorkspace;
      const linkedWorkspaces = [];
      if (this.all) {
        for (const workspace3 of project2.workspaces)
          if (workspace3.manifest.name && (!workspace3.manifest.private || this.private))
            linkedWorkspaces.push(workspace3);
        if (linkedWorkspaces.length === 0) {
          throw new UsageError(`No workspace found to be linked in the target project`);
        }
      } else {
        if (!workspace2.manifest.name)
          throw new UsageError(`The target workspace doesn't have a name and thus cannot be linked`);
        if (workspace2.manifest.private && !this.private)
          throw new UsageError(`The target workspace is marked private - use the --private flag to link it anyway`);
        linkedWorkspaces.push(workspace2);
      }
      for (const workspace3 of linkedWorkspaces) {
        const fullName = structUtils_exports.stringifyIdent(workspace3.locator);
        const target = this.relative ? ppath.relative(project.cwd, workspace3.cwd) : workspace3.cwd;
        topLevelWorkspace.manifest.resolutions.push({
          pattern: {descriptor: {fullName}},
          reference: `portal:${target}`
        });
      }
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  LinkCommand.paths = [
    [`link`]
  ];
  LinkCommand.usage = Command.Usage({
    description: `connect the local project to another one`,
    details: `
      This command will set a new \`resolutions\` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).

      There is no \`yarn unlink\` command. To unlink the workspaces from the current project one must revert the changes made to the \`resolutions\` field.
    `,
    examples: [[
      `Register a remote workspace for use in the current project`,
      `$0 link ~/ts-loader`
    ], [
      `Register all workspaces from a remote project for use in the current project`,
      `$0 link ~/jest --all`
    ]]
  });
  var link_default = LinkCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\node.ts
  var NodeCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.args = options_exports.Proxy();
    }
    async execute() {
      return this.cli.run([`exec`, `node`, ...this.args]);
    }
  };
  NodeCommand.paths = [
    [`node`]
  ];
  NodeCommand.usage = Command.Usage({
    description: `run node with the hook already setup`,
    details: `
      This command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).

      The Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.
    `,
    examples: [[
      `Run a Node script`,
      `$0 node ./my-script.js`
    ]]
  });
  var node_default = NodeCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\import\sources.ts
  var import_os6 = __toModule(require("os"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\set\version\sources.ts
  var import_os5 = __toModule(require("os"));
  var import_path16 = __toModule(require("path"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\set\version.ts
  var import_semver11 = __toModule(require_semver2());
  var SetVersionCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.onlyIfNeeded = options_exports.Boolean(`--only-if-needed`, false, {
        description: `Only lock the Yarn version if it isn't already locked`
      });
      this.version = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (configuration.get(`yarnPath`) && this.onlyIfNeeded)
        return 0;
      let bundleUrl;
      if (this.version === `latest` || this.version === `berry`)
        bundleUrl = `https://github.com/yarnpkg/berry/raw/master/packages/yarnpkg-cli/bin/yarn.js`;
      else if (this.version === `classic`)
        bundleUrl = `https://nightly.yarnpkg.com/latest.js`;
      else if (semverUtils_exports.satisfiesWithPrereleases(this.version, `>=2.0.0`))
        bundleUrl = `https://github.com/yarnpkg/berry/raw/%40yarnpkg/cli/${this.version}/packages/yarnpkg-cli/bin/yarn.js`;
      else if (semverUtils_exports.satisfiesWithPrereleases(this.version, `^0.x || ^1.x`))
        bundleUrl = `https://github.com/yarnpkg/yarn/releases/download/v${this.version}/yarn-${this.version}.js`;
      else if (import_semver11.default.validRange(this.version))
        throw new UsageError(`Support for ranges got removed - please use the exact version you want to install, or 'latest' to get the latest build available`);
      else
        throw new UsageError(`Invalid version descriptor "${this.version}"`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportInfo(MessageName.UNNAMED, `Downloading ${formatUtils_exports.pretty(configuration, bundleUrl, `green`)}`);
        const bundleBuffer = await httpUtils_exports.get(bundleUrl, {configuration});
        await setVersion(configuration, null, bundleBuffer, {report: report2});
      });
      return report.exitCode();
    }
  };
  SetVersionCommand.paths = [
    [`set`, `version`]
  ];
  SetVersionCommand.usage = Command.Usage({
    description: `lock the Yarn version used by the project`,
    details: `
      This command will download a specific release of Yarn directly from the Yarn GitHub repository, will store it inside your project, and will change the \`yarnPath\` settings from your project \`.yarnrc.yml\` file to point to the new file.

      A very good use case for this command is to enforce the version of Yarn used by the any single member of your team inside a same project - by doing this you ensure that you have control on Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting a different behavior than you.
    `,
    examples: [[
      `Download the latest release from the Yarn repository`,
      `$0 set version latest`
    ], [
      `Download the latest classic release from the Yarn repository`,
      `$0 set version classic`
    ], [
      `Download a specific Yarn 2 build`,
      `$0 set version 2.0.0-rc.30`
    ], [
      `Switch back to a specific Yarn 1 release`,
      `$0 set version 1.22.1`
    ]]
  });
  var version_default2 = SetVersionCommand;
  async function setVersion(configuration, bundleVersion, bundleBuffer, {report}) {
    const projectCwd = configuration.projectCwd ? configuration.projectCwd : configuration.startingCwd;
    if (bundleVersion === null) {
      await xfs.mktempPromise(async (tmpDir) => {
        const temporaryPath = ppath.join(tmpDir, `yarn.cjs`);
        await xfs.writeFilePromise(temporaryPath, bundleBuffer);
        const {stdout} = await execUtils_exports.execvp(process.execPath, [npath.fromPortablePath(temporaryPath), `--version`], {
          cwd: projectCwd,
          env: {...process.env, YARN_IGNORE_PATH: `1`}
        });
        bundleVersion = stdout.trim();
        if (!import_semver11.default.valid(bundleVersion)) {
          throw new Error(`Invalid semver version`);
        }
      });
    }
    const releaseFolder = ppath.resolve(projectCwd, `.yarn/releases`);
    const absolutePath = ppath.resolve(releaseFolder, `yarn-${bundleVersion}.cjs`);
    const displayPath = ppath.relative(configuration.startingCwd, absolutePath);
    const projectPath = ppath.relative(projectCwd, absolutePath);
    const yarnPath = configuration.get(`yarnPath`);
    const updateConfig = yarnPath === null || yarnPath.startsWith(`${releaseFolder}/`);
    report.reportInfo(MessageName.UNNAMED, `Saving the new release in ${formatUtils_exports.pretty(configuration, displayPath, `magenta`)}`);
    await xfs.removePromise(ppath.dirname(absolutePath));
    await xfs.mkdirPromise(ppath.dirname(absolutePath), {recursive: true});
    await xfs.writeFilePromise(absolutePath, bundleBuffer);
    await xfs.chmodPromise(absolutePath, 493);
    if (updateConfig) {
      await Configuration.updateConfiguration(projectCwd, {
        yarnPath: projectPath
      });
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\set\version\sources.ts
  var PR_REGEXP = /^[0-9]+$/;
  function getBranchRef(branch) {
    if (PR_REGEXP.test(branch)) {
      return `pull/${branch}/head`;
    } else {
      return branch;
    }
  }
  var cloneWorkflow = ({repository, branch}, target) => [
    [`git`, `init`, npath.fromPortablePath(target)],
    [`git`, `remote`, `add`, `origin`, repository],
    [`git`, `fetch`, `origin`, getBranchRef(branch)],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`]
  ];
  var updateWorkflow = ({branch}) => [
    [`git`, `fetch`, `origin`, getBranchRef(branch), `--force`],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
    [`git`, `clean`, `-dfx`]
  ];
  var buildWorkflow = ({plugins, noMinify}, target) => [
    [`yarn`, `build:cli`, ...new Array().concat(...plugins.map((plugin23) => [`--plugin`, import_path16.default.resolve(target, plugin23)])), ...noMinify ? [`--no-minify`] : [], `|`]
  ];
  var SetVersionSourcesCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.installPath = options_exports.String(`--path`, {
        description: `The path where the repository should be cloned to`
      });
      this.repository = options_exports.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
        description: `The repository that should be cloned`
      });
      this.branch = options_exports.String(`--branch`, `master`, {
        description: `The branch of the repository that should be cloned`
      });
      this.plugins = options_exports.Array(`--plugin`, [], {
        description: `An array of additional plugins that should be included in the bundle`
      });
      this.noMinify = options_exports.Boolean(`--no-minify`, false, {
        description: `Build a bundle for development (debugging) - non-minified and non-mangled`
      });
      this.force = options_exports.Boolean(`-f,--force`, false, {
        description: `Always clone the repository instead of trying to fetch the latest commits`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const target = typeof this.installPath !== `undefined` ? ppath.resolve(this.context.cwd, npath.toPortablePath(this.installPath)) : ppath.resolve(npath.toPortablePath(import_os5.tmpdir()), `yarnpkg-sources`, hashUtils_exports.makeHash(this.repository).slice(0, 6));
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await prepareRepo(this, {configuration, report: report2, target});
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Building a fresh bundle`);
        report2.reportSeparator();
        await runWorkflow(buildWorkflow(this, target), {configuration, context: this.context, target});
        report2.reportSeparator();
        const bundlePath = ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
        const bundleBuffer = await xfs.readFilePromise(bundlePath);
        await setVersion(configuration, `sources`, bundleBuffer, {
          report: report2
        });
      });
      return report.exitCode();
    }
  };
  SetVersionSourcesCommand.paths = [
    [`set`, `version`, `from`, `sources`]
  ];
  SetVersionSourcesCommand.usage = Command.Usage({
    description: `build Yarn from master`,
    details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.
    `,
    examples: [[
      `Build Yarn from master`,
      `$0 set version from sources`
    ]]
  });
  var sources_default = SetVersionSourcesCommand;
  async function runWorkflow(workflow, {configuration, context, target}) {
    for (const [fileName, ...args] of workflow) {
      const usePipe = args[args.length - 1] === `|`;
      if (usePipe)
        args.pop();
      if (usePipe) {
        await execUtils_exports.pipevp(fileName, args, {
          cwd: target,
          stdin: context.stdin,
          stdout: context.stdout,
          stderr: context.stderr,
          strict: true
        });
      } else {
        context.stdout.write(`${formatUtils_exports.pretty(configuration, `  $ ${[fileName, ...args].join(` `)}`, `grey`)}
`);
        try {
          await execUtils_exports.execvp(fileName, args, {
            cwd: target,
            strict: true
          });
        } catch (error) {
          context.stdout.write(error.stdout || error.stack);
          throw error;
        }
      }
    }
  }
  async function prepareRepo(spec, {configuration, report, target}) {
    let ready = false;
    if (!spec.force && xfs.existsSync(ppath.join(target, `.git`))) {
      report.reportInfo(MessageName.UNNAMED, `Fetching the latest commits`);
      report.reportSeparator();
      try {
        await runWorkflow(updateWorkflow(spec), {configuration, context: spec.context, target});
        ready = true;
      } catch (error) {
        report.reportSeparator();
        report.reportWarning(MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
      }
    }
    if (!ready) {
      report.reportInfo(MessageName.UNNAMED, `Cloning the remote repository`);
      report.reportSeparator();
      await xfs.removePromise(target);
      await xfs.mkdirPromise(target, {recursive: true});
      await runWorkflow(cloneWorkflow(spec, target), {configuration, context: spec.context, target});
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\import.ts
  var import_url3 = __toModule(require("url"));
  var import_vm = __toModule(require("vm"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\list.ts
  var REMOTE_REGISTRY = `https://raw.githubusercontent.com/yarnpkg/berry/master/plugins.yml`;
  async function getAvailablePlugins(configuration) {
    const raw = await httpUtils_exports.get(REMOTE_REGISTRY, {configuration});
    const data = parseSyml(raw.toString());
    return data;
  }
  var PluginDlCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        const data = await getAvailablePlugins(configuration);
        for (const [name, {experimental, ...rest}] of Object.entries(data)) {
          let label = name;
          if (experimental)
            label += ` [experimental]`;
          report2.reportJson({name, experimental, ...rest});
          report2.reportInfo(null, label);
        }
      });
      return report.exitCode();
    }
  };
  PluginDlCommand.paths = [
    [`plugin`, `list`]
  ];
  PluginDlCommand.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `list the available official plugins`,
    details: `
      This command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in \`yarn plugin import\`.
    `,
    examples: [[
      `List the official plugins`,
      `$0 plugin list`
    ]]
  });
  var list_default = PluginDlCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\import.ts
  var PluginDlCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const {project} = await Project.find(configuration, this.context.cwd);
        let pluginSpec;
        let pluginBuffer;
        if (this.name.match(/^\.{0,2}[\\/]/) || npath.isAbsolute(this.name)) {
          const candidatePath = ppath.resolve(this.context.cwd, npath.toPortablePath(this.name));
          report2.reportInfo(MessageName.UNNAMED, `Reading ${formatUtils_exports.pretty(configuration, candidatePath, formatUtils_exports.Type.PATH)}`);
          pluginSpec = ppath.relative(project.cwd, candidatePath);
          pluginBuffer = await xfs.readFilePromise(candidatePath);
        } else {
          let pluginUrl;
          if (this.name.match(/^https?:/)) {
            try {
              new import_url3.URL(this.name);
            } catch {
              throw new ReportError(MessageName.INVALID_PLUGIN_REFERENCE, `Plugin specifier "${this.name}" is neither a plugin name nor a valid url`);
            }
            pluginSpec = this.name;
            pluginUrl = this.name;
          } else {
            const ident = structUtils_exports.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
            const identStr = structUtils_exports.stringifyIdent(ident);
            const data = await getAvailablePlugins(configuration);
            if (!Object.prototype.hasOwnProperty.call(data, identStr))
              throw new ReportError(MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be referenced by their name; any other plugin will have to be referenced through its public url (for example https://github.com/yarnpkg/berry/raw/master/packages/plugin-typescript/bin/%40yarnpkg/plugin-typescript.js).`);
            pluginSpec = identStr;
            pluginUrl = data[identStr].url;
          }
          report2.reportInfo(MessageName.UNNAMED, `Downloading ${formatUtils_exports.pretty(configuration, pluginUrl, `green`)}`);
          pluginBuffer = await httpUtils_exports.get(pluginUrl, {configuration});
        }
        await savePlugin(pluginSpec, pluginBuffer, {project, report: report2});
      });
      return report.exitCode();
    }
  };
  PluginDlCommand2.paths = [
    [`plugin`, `import`]
  ];
  PluginDlCommand2.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `download a plugin`,
    details: `
      This command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.

      Three types of plugin references are accepted:

      - If the plugin is stored within the Yarn repository, it can be referenced by name.
      - Third-party plugins can be referenced directly through their public urls.
      - Local plugins can be referenced by their path on the disk.

      Plugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the \`@yarnpkg/builder\` package).
    `,
    examples: [[
      `Download and activate the "@yarnpkg/plugin-exec" plugin`,
      `$0 plugin import @yarnpkg/plugin-exec`
    ], [
      `Download and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
      `$0 plugin import exec`
    ], [
      `Download and activate a community plugin`,
      `$0 plugin import https://example.org/path/to/plugin.js`
    ], [
      `Activate a local plugin`,
      `$0 plugin import ./path/to/plugin.js`
    ]]
  });
  var import_default = PluginDlCommand2;
  async function savePlugin(pluginSpec, pluginBuffer, {project, report}) {
    const {configuration} = project;
    const vmExports = {};
    const vmModule = {exports: vmExports};
    import_vm.runInNewContext(pluginBuffer.toString(), {
      module: vmModule,
      exports: vmExports
    });
    const pluginName = vmModule.exports.name;
    const relativePath = `.yarn/plugins/${pluginName}.cjs`;
    const absolutePath = ppath.resolve(project.cwd, relativePath);
    report.reportInfo(MessageName.UNNAMED, `Saving the new plugin in ${formatUtils_exports.pretty(configuration, relativePath, `magenta`)}`);
    await xfs.mkdirPromise(ppath.dirname(absolutePath), {recursive: true});
    await xfs.writeFilePromise(absolutePath, pluginBuffer);
    const pluginMeta = {
      path: relativePath,
      spec: pluginSpec
    };
    await Configuration.updateConfiguration(project.cwd, (current) => {
      const plugins = [];
      let hasBeenReplaced = false;
      for (const entry of current.plugins || []) {
        const userProvidedPath = typeof entry !== `string` ? entry.path : entry;
        const pluginPath = ppath.resolve(project.cwd, npath.toPortablePath(userProvidedPath));
        const {name} = miscUtils10.dynamicRequire(npath.fromPortablePath(pluginPath));
        if (name !== pluginName) {
          plugins.push(entry);
        } else {
          plugins.push(pluginMeta);
          hasBeenReplaced = true;
        }
      }
      if (!hasBeenReplaced)
        plugins.push(pluginMeta);
      return {...current, plugins};
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\import\sources.ts
  var buildWorkflow2 = ({pluginName, noMinify}, target) => [
    [`yarn`, `build:${pluginName}`, ...noMinify ? [`--no-minify`] : [], `|`]
  ];
  var PluginDlSourcesCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.installPath = options_exports.String(`--path`, {
        description: `The path where the repository should be cloned to`
      });
      this.repository = options_exports.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
        description: `The repository that should be cloned`
      });
      this.branch = options_exports.String(`--branch`, `master`, {
        description: `The branch of the repository that should be cloned`
      });
      this.noMinify = options_exports.Boolean(`--no-minify`, false, {
        description: `Build a plugin for development (debugging) - non-minified and non-mangled`
      });
      this.force = options_exports.Boolean(`-f,--force`, false, {
        description: `Always clone the repository instead of trying to fetch the latest commits`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const target = typeof this.installPath !== `undefined` ? ppath.resolve(this.context.cwd, npath.toPortablePath(this.installPath)) : ppath.resolve(npath.toPortablePath(import_os6.tmpdir()), `yarnpkg-sources`, hashUtils_exports.makeHash(this.repository).slice(0, 6));
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const {project} = await Project.find(configuration, this.context.cwd);
        const ident = structUtils_exports.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
        const identStr = structUtils_exports.stringifyIdent(ident);
        const data = await getAvailablePlugins(configuration);
        if (!Object.prototype.hasOwnProperty.call(data, identStr))
          throw new ReportError(MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be built and imported from sources.`);
        const pluginSpec = identStr;
        const pluginName = pluginSpec.replace(/@yarnpkg\//, ``);
        await prepareRepo(this, {configuration, report: report2, target});
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Building a fresh ${pluginName}`);
        report2.reportSeparator();
        await runWorkflow(buildWorkflow2({
          pluginName,
          noMinify: this.noMinify
        }, target), {configuration, context: this.context, target});
        report2.reportSeparator();
        const pluginPath = ppath.resolve(target, `packages/${pluginName}/bundles/${pluginSpec}.js`);
        const pluginBuffer = await xfs.readFilePromise(pluginPath);
        await savePlugin(pluginSpec, pluginBuffer, {project, report: report2});
      });
      return report.exitCode();
    }
  };
  PluginDlSourcesCommand.paths = [
    [`plugin`, `import`, `from`, `sources`]
  ];
  PluginDlSourcesCommand.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `build a plugin from sources`,
    details: `
      This command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.

      The plugins can be referenced by their short name if sourced from the official Yarn repository.
    `,
    examples: [[
      `Build and activate the "@yarnpkg/plugin-exec" plugin`,
      `$0 plugin import from sources @yarnpkg/plugin-exec`
    ], [
      `Build and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
      `$0 plugin import from sources exec`
    ]]
  });
  var sources_default2 = PluginDlSourcesCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\remove.ts
  var PluginRemoveCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const pluginName = this.name;
        const pluginIdent = structUtils_exports.parseIdent(pluginName);
        if (!configuration.plugins.has(pluginName))
          throw new UsageError(`${structUtils_exports.prettyIdent(configuration, pluginIdent)} isn't referenced by the current configuration`);
        const relativePath = `.yarn/plugins/${pluginName}.cjs`;
        const absolutePath = ppath.resolve(project.cwd, relativePath);
        if (xfs.existsSync(absolutePath)) {
          report2.reportInfo(MessageName.UNNAMED, `Removing ${formatUtils_exports.pretty(configuration, relativePath, formatUtils_exports.Type.PATH)}...`);
          await xfs.removePromise(absolutePath);
        }
        report2.reportInfo(MessageName.UNNAMED, `Updating the configuration...`);
        await Configuration.updateConfiguration(project.cwd, (current) => {
          if (!Array.isArray(current.plugins))
            return current;
          const plugins = current.plugins.filter((plugin23) => {
            return plugin23.path !== relativePath;
          });
          if (current.plugins.length === plugins.length)
            return current;
          return {
            ...current,
            plugins
          };
        });
      });
      return report.exitCode();
    }
  };
  PluginRemoveCommand.paths = [
    [`plugin`, `remove`]
  ];
  PluginRemoveCommand.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `remove a plugin`,
    details: `
      This command deletes the specified plugin from the .yarn/plugins folder and removes it from the configuration.

      **Note:** The plugins have to be referenced by their name property, which can be obtained using the \`yarn plugin runtime\` command. Shorthands are not allowed.
   `,
    examples: [[
      `Remove a plugin imported from the Yarn repository`,
      `$0 plugin remove @yarnpkg/plugin-typescript`
    ], [
      `Remove a plugin imported from a local file`,
      `$0 plugin remove my-local-plugin`
    ]]
  });
  var remove_default = PluginRemoveCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\plugin\runtime.ts
  var PluginListCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const name of configuration.plugins.keys()) {
          const builtin = this.context.plugins.plugins.has(name);
          let label = name;
          if (builtin)
            label += ` [builtin]`;
          report2.reportJson({name, builtin});
          report2.reportInfo(null, `${label}`);
        }
      });
      return report.exitCode();
    }
  };
  PluginListCommand.paths = [
    [`plugin`, `runtime`]
  ];
  PluginListCommand.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `list the active plugins`,
    details: `
      This command prints the currently active plugins. Will be displayed both builtin plugins and external plugins.
    `,
    examples: [[
      `List the currently active plugins`,
      `$0 plugin runtime`
    ]]
  });
  var runtime_default = PluginListCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\rebuild.ts
  var RunCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.idents = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const filteredIdents = new Set();
      for (const identStr of this.idents)
        filteredIdents.add(structUtils_exports.parseIdent(identStr).identHash);
      await project.resolveEverything({
        cache: cache2,
        report: new ThrowReport()
      });
      const bstatePath = configuration.get(`bstatePath`);
      const bstate = xfs.existsSync(bstatePath) ? parseSyml(await xfs.readFilePromise(bstatePath, `utf8`)) : {};
      const nextBState = new Map();
      for (const pkg of project.storedPackages.values()) {
        if (!Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash))
          continue;
        if (filteredIdents.size === 0 || filteredIdents.has(pkg.identHash))
          continue;
        const buildHash = bstate[pkg.locatorHash];
        nextBState.set(pkg.locatorHash, buildHash);
      }
      if (nextBState.size > 0) {
        const bstatePath2 = configuration.get(`bstatePath`);
        const bstateFile = Project.generateBuildStateFile(nextBState, project.storedPackages);
        await xfs.mkdirPromise(ppath.dirname(bstatePath2), {recursive: true});
        await xfs.changeFilePromise(bstatePath2, bstateFile, {
          automaticNewlines: true
        });
      } else {
        await xfs.removePromise(bstatePath);
      }
      const installReport = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeLogs: !this.context.quiet
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  RunCommand.paths = [
    [`rebuild`]
  ];
  RunCommand.usage = Command.Usage({
    description: `rebuild the project's native packages`,
    details: `
      This command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.

      Note that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).

      By default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.
    `,
    examples: [[
      `Rebuild all packages`,
      `$0 rebuild`
    ], [
      `Rebuild fsevents only`,
      `$0 rebuild fsevents`
    ]]
  });
  var rebuild_default = RunCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\remove.ts
  var import_micromatch5 = __toModule(require_micromatch());
  var RemoveCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Apply the operation to all workspaces from the current project`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const affectedWorkspaces = this.all ? project.workspaces : [workspace];
      const targets = [
        Target.REGULAR,
        Target.DEVELOPMENT,
        Target.PEER
      ];
      const unreferencedPatterns = [];
      let hasChanged = false;
      const afterWorkspaceDependencyRemovalList = [];
      for (const pattern of this.patterns) {
        let isReferenced = false;
        const pseudoIdent = structUtils_exports.parseIdent(pattern);
        for (const workspace2 of affectedWorkspaces) {
          const peerDependenciesMeta = [...workspace2.manifest.peerDependenciesMeta.keys()];
          for (const stringifiedIdent of import_micromatch5.default(peerDependenciesMeta, pattern)) {
            workspace2.manifest.peerDependenciesMeta.delete(stringifiedIdent);
            hasChanged = true;
            isReferenced = true;
          }
          for (const target of targets) {
            const descriptors = workspace2.manifest.getForScope(target);
            const stringifiedIdents = [...descriptors.values()].map((descriptor) => {
              return structUtils_exports.stringifyIdent(descriptor);
            });
            for (const stringifiedIdent of import_micromatch5.default(stringifiedIdents, structUtils_exports.stringifyIdent(pseudoIdent))) {
              const {identHash} = structUtils_exports.parseIdent(stringifiedIdent);
              const removedDescriptor = descriptors.get(identHash);
              if (typeof removedDescriptor === `undefined`)
                throw new Error(`Assertion failed: Expected the descriptor to be registered`);
              workspace2.manifest[target].delete(identHash);
              afterWorkspaceDependencyRemovalList.push([
                workspace2,
                target,
                removedDescriptor
              ]);
              hasChanged = true;
              isReferenced = true;
            }
          }
        }
        if (!isReferenced) {
          unreferencedPatterns.push(pattern);
        }
      }
      const patterns = unreferencedPatterns.length > 1 ? `Patterns` : `Pattern`;
      const dont = unreferencedPatterns.length > 1 ? `don't` : `doesn't`;
      const which = this.all ? `any` : `this`;
      if (unreferencedPatterns.length > 0)
        throw new UsageError(`${patterns} ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} ${dont} match any packages referenced by ${which} workspace`);
      if (hasChanged) {
        await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyRemoval, afterWorkspaceDependencyRemovalList);
        const report = await StreamReport.start({
          configuration,
          stdout: this.context.stdout
        }, async (report2) => {
          await project.install({cache: cache2, report: report2});
        });
        return report.exitCode();
      }
      return 0;
    }
  };
  RemoveCommand.paths = [
    [`remove`]
  ];
  RemoveCommand.usage = Command.Usage({
    description: `remove dependencies from the project`,
    details: `
      This command will remove the packages matching the specified patterns from the current workspace.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.
    `,
    examples: [[
      `Remove a dependency from the current project`,
      `$0 remove lodash`
    ], [
      `Remove a dependency from all workspaces at once`,
      `$0 remove lodash --all`
    ], [
      `Remove all dependencies starting with \`eslint-\``,
      `$0 remove 'eslint-*'`
    ], [
      `Remove all dependencies with the \`@babel\` scope`,
      `$0 remove '@babel/*'`
    ], [
      `Remove all dependencies matching \`react-dom\` or \`react-helmet\``,
      `$0 remove 'react-{dom,helmet}'`
    ]]
  });
  var remove_default2 = RemoveCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\runIndex.ts
  var import_util7 = __toModule(require("util"));
  var RunCommand2 = class extends BaseCommand {
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const scripts = workspace.manifest.scripts;
        const keys = miscUtils10.sortMap(scripts.keys(), (key) => key);
        const inspectConfig = {
          breakLength: Infinity,
          colors: configuration.get(`enableColors`),
          maxArrayLength: 2
        };
        const maxKeyLength = keys.reduce((max, key) => {
          return Math.max(max, key.length);
        }, 0);
        for (const [key, value] of scripts.entries()) {
          report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${import_util7.inspect(value, inspectConfig)}`);
        }
      });
      return report.exitCode();
    }
  };
  RunCommand2.paths = [
    [`run`]
  ];
  var runIndex_default = RunCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\run.ts
  var RunCommand3 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.inspect = options_exports.String(`--inspect`, false, {
        tolerateBoolean: true,
        description: `Forwarded to the underlying Node process when executing a binary`
      });
      this.inspectBrk = options_exports.String(`--inspect-brk`, false, {
        tolerateBoolean: true,
        description: `Forwarded to the underlying Node process when executing a binary`
      });
      this.topLevel = options_exports.Boolean(`-T,--top-level`, false, {hidden: true});
      this.binariesOnly = options_exports.Boolean(`-B,--binaries-only`, false, {hidden: true});
      this.silent = options_exports.Boolean(`--silent`, {hidden: true});
      this.scriptName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace, locator} = await Project.find(configuration, this.context.cwd);
      await project.restoreInstallState();
      const effectiveLocator = this.topLevel ? project.topLevelWorkspace.anchoredLocator : locator;
      if (!this.binariesOnly && await scriptUtils_exports.hasPackageScript(effectiveLocator, this.scriptName, {project}))
        return await scriptUtils_exports.executePackageScript(effectiveLocator, this.scriptName, this.args, {project, stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr});
      const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(effectiveLocator, {project});
      const binary = binaries.get(this.scriptName);
      if (binary) {
        const nodeArgs = [];
        if (this.inspect) {
          if (typeof this.inspect === `string`) {
            nodeArgs.push(`--inspect=${this.inspect}`);
          } else {
            nodeArgs.push(`--inspect`);
          }
        }
        if (this.inspectBrk) {
          if (typeof this.inspectBrk === `string`) {
            nodeArgs.push(`--inspect-brk=${this.inspectBrk}`);
          } else {
            nodeArgs.push(`--inspect-brk`);
          }
        }
        return await scriptUtils_exports.executePackageAccessibleBinary(effectiveLocator, this.scriptName, this.args, {cwd: this.context.cwd, project, stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr, nodeArgs});
      }
      if (!this.topLevel && !this.binariesOnly && workspace && this.scriptName.includes(`:`)) {
        const candidateWorkspaces = await Promise.all(project.workspaces.map(async (workspace2) => {
          return workspace2.manifest.scripts.has(this.scriptName) ? workspace2 : null;
        }));
        const filteredWorkspaces = candidateWorkspaces.filter((workspace2) => {
          return workspace2 !== null;
        });
        if (filteredWorkspaces.length === 1) {
          return await scriptUtils_exports.executeWorkspaceScript(filteredWorkspaces[0], this.scriptName, this.args, {stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr});
        }
      }
      if (this.topLevel) {
        if (this.scriptName === `node-gyp`) {
          throw new UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${structUtils_exports.prettyLocator(configuration, locator)}). This typically happens because some package depends on "node-gyp" to build itself, but didn't list it in their dependencies. To fix that, please run "yarn add node-gyp" into your top-level workspace. You also can open an issue on the repository of the specified package to suggest them to use an optional peer dependency.`);
        } else {
          throw new UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${structUtils_exports.prettyLocator(configuration, locator)}).`);
        }
      } else {
        if (this.scriptName === `global`)
          throw new UsageError(`The 'yarn global' commands have been removed in 2.x - consider using 'yarn dlx' or a third-party plugin instead`);
        const userCommand = [this.scriptName].concat(this.args);
        for (const [pluginName, candidates] of pluginCommands)
          for (const candidate of candidates)
            if (userCommand.length >= candidate.length && JSON.stringify(userCommand.slice(0, candidate.length)) === JSON.stringify(candidate))
              throw new UsageError(`Couldn't find a script named "${this.scriptName}", but a matching command can be found in the ${pluginName} plugin. You can install it with "yarn plugin import ${pluginName}".`);
        throw new UsageError(`Couldn't find a script named "${this.scriptName}".`);
      }
    }
  };
  RunCommand3.paths = [
    [`run`]
  ];
  RunCommand3.usage = Command.Usage({
    description: `run a script defined in the package.json`,
    details: `
      This command will run a tool. The exact tool that will be executed will depend on the current state of your workspace:

      - If the \`scripts\` field from your local package.json contains a matching script name, its definition will get executed.

      - Otherwise, if one of the local workspace's dependencies exposes a binary with a matching name, this binary will get executed.

      - Otherwise, if the specified name contains a colon character and if one of the workspaces in the project contains exactly one script with a matching name, then this script will get executed.

      Whatever happens, the cwd of the spawned process will be the workspace that declares the script (which makes it possible to call commands cross-workspaces using the third syntax).
    `,
    examples: [[
      `Run the tests from the local workspace`,
      `$0 run test`
    ], [
      `Same thing, but without the "run" keyword`,
      `$0 test`
    ], [
      `Inspect Webpack while running`,
      `$0 run --inspect-brk webpack`
    ]]
  });
  var run_default2 = RunCommand3;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\set\resolution.ts
  var SetResolutionCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.save = options_exports.Boolean(`-s,--save`, false, {
        description: `Persist the resolution inside the top-level manifest`
      });
      this.descriptor = options_exports.String();
      this.resolution = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const fromDescriptor = structUtils_exports.parseDescriptor(this.descriptor, true);
      const toDescriptor = structUtils_exports.makeDescriptor(fromDescriptor, this.resolution);
      project.storedDescriptors.set(fromDescriptor.descriptorHash, fromDescriptor);
      project.storedDescriptors.set(toDescriptor.descriptorHash, toDescriptor);
      project.resolutionAliases.set(fromDescriptor.descriptorHash, toDescriptor.descriptorHash);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  SetResolutionCommand.paths = [
    [`set`, `resolution`]
  ];
  SetResolutionCommand.usage = Command.Usage({
    description: `enforce a package resolution`,
    details: `
      This command updates the resolution table so that \`descriptor\` is resolved by \`resolution\`.

      Note that by default this command only affect the current resolution table - meaning that this "manual override" will disappear if you remove the lockfile, or if the package disappear from the table. If you wish to make the enforced resolution persist whatever happens, add the \`-s,--save\` flag which will also edit the \`resolutions\` field from your top-level manifest.

      Note that no attempt is made at validating that \`resolution\` is a valid resolution entry for \`descriptor\`.
    `,
    examples: [[
      `Force all instances of lodash@npm:^1.2.3 to resolve to 1.5.0`,
      `$0 set resolution lodash@npm:^1.2.3 1.5.0`
    ]]
  });
  var resolution_default = SetResolutionCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\up.ts
  var import_enquirer2 = __toModule(require_enquirer());
  var import_micromatch6 = __toModule(require_micromatch());
  var UpCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.interactive = options_exports.Boolean(`-i,--interactive`, {
        description: `Offer various choices, depending on the detected upgrade paths`
      });
      this.exact = options_exports.Boolean(`-E,--exact`, false, {
        description: `Don't use any semver modifier on the resolved range`
      });
      this.tilde = options_exports.Boolean(`-T,--tilde`, false, {
        description: `Use the \`~\` semver modifier on the resolved range`
      });
      this.caret = options_exports.Boolean(`-C,--caret`, false, {
        description: `Use the \`^\` semver modifier on the resolved range`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const interactive = (_a2 = this.interactive) != null ? _a2 : configuration.get(`preferInteractive`);
      const modifier = getModifier(this, project);
      const strategies = interactive ? [
        Strategy.KEEP,
        Strategy.REUSE,
        Strategy.PROJECT,
        Strategy.LATEST
      ] : [
        Strategy.PROJECT,
        Strategy.LATEST
      ];
      const allSuggestionsPromises = [];
      const unreferencedPatterns = [];
      for (const pattern of this.patterns) {
        let isReferenced = false;
        const pseudoDescriptor = structUtils_exports.parseDescriptor(pattern);
        for (const workspace2 of project.workspaces) {
          for (const target of [Target.REGULAR, Target.DEVELOPMENT]) {
            const descriptors = workspace2.manifest.getForScope(target);
            const stringifiedIdents = [...descriptors.values()].map((descriptor) => {
              return structUtils_exports.stringifyIdent(descriptor);
            });
            for (const stringifiedIdent of import_micromatch6.default(stringifiedIdents, structUtils_exports.stringifyIdent(pseudoDescriptor))) {
              const ident = structUtils_exports.parseIdent(stringifiedIdent);
              const existingDescriptor = workspace2.manifest[target].get(ident.identHash);
              if (typeof existingDescriptor === `undefined`)
                throw new Error(`Assertion failed: Expected the descriptor to be registered`);
              const request2 = structUtils_exports.makeDescriptor(ident, pseudoDescriptor.range);
              allSuggestionsPromises.push(Promise.resolve().then(async () => {
                return [
                  workspace2,
                  target,
                  existingDescriptor,
                  await getSuggestedDescriptors(request2, {project, workspace: workspace2, cache: cache2, target, modifier, strategies})
                ];
              }));
              isReferenced = true;
            }
          }
        }
        if (!isReferenced) {
          unreferencedPatterns.push(pattern);
        }
      }
      if (unreferencedPatterns.length > 1)
        throw new UsageError(`Patterns ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} don't match any packages referenced by any workspace`);
      if (unreferencedPatterns.length > 0)
        throw new UsageError(`Pattern ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} doesn't match any packages referenced by any workspace`);
      const allSuggestions = await Promise.all(allSuggestionsPromises);
      const checkReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout,
        suggestInstall: false
      }, async (report) => {
        for (const [, , existing, {suggestions, rejections}] of allSuggestions) {
          const nonNullSuggestions = suggestions.filter((suggestion) => {
            return suggestion.descriptor !== null;
          });
          if (nonNullSuggestions.length === 0) {
            const [firstError] = rejections;
            if (typeof firstError === `undefined`)
              throw new Error(`Assertion failed: Expected an error to have been set`);
            const prettyError = this.cli.error(firstError);
            if (!project.configuration.get(`enableNetwork`)) {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range (note: network resolution has been disabled)

${prettyError}`);
            } else {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range

${prettyError}`);
            }
          } else if (nonNullSuggestions.length > 1 && !interactive) {
            report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} has multiple possible upgrade strategies; use -i to disambiguate manually`);
          }
        }
      });
      if (checkReport.hasErrors())
        return checkReport.exitCode();
      let askedQuestions = false;
      const afterWorkspaceDependencyReplacementList = [];
      for (const [workspace2, target, , {suggestions}] of allSuggestions) {
        let selected;
        const nonNullSuggestions = suggestions.filter((suggestion) => {
          return suggestion.descriptor !== null;
        });
        const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
        const areAllTheSame = nonNullSuggestions.every((suggestion) => structUtils_exports.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
        if (nonNullSuggestions.length === 1 || areAllTheSame) {
          selected = firstSuggestedDescriptor;
        } else {
          askedQuestions = true;
          ({answer: selected} = await import_enquirer2.prompt({
            type: `select`,
            name: `answer`,
            message: `Which range to you want to use in ${structUtils_exports.prettyWorkspace(configuration, workspace2)} \u276F ${target}?`,
            choices: suggestions.map(({descriptor, name, reason}) => descriptor ? {
              name,
              hint: reason,
              descriptor
            } : {
              name,
              hint: reason,
              disabled: true
            }),
            onCancel: () => process.exit(130),
            result(name) {
              return this.find(name, `descriptor`);
            },
            stdin: this.context.stdin,
            stdout: this.context.stdout
          }));
        }
        const current = workspace2.manifest[target].get(selected.identHash);
        if (typeof current === `undefined`)
          throw new Error(`Assertion failed: This descriptor should have a matching entry`);
        if (current.descriptorHash !== selected.descriptorHash) {
          workspace2.manifest[target].set(selected.identHash, selected);
          afterWorkspaceDependencyReplacementList.push([
            workspace2,
            target,
            current,
            selected
          ]);
        } else {
          const resolver = configuration.makeResolver();
          const resolveOptions = {project, resolver};
          const bound = resolver.bindDescriptor(current, workspace2.anchoredLocator, resolveOptions);
          project.forgetResolution(bound);
        }
      }
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
      if (askedQuestions)
        this.context.stdout.write(`
`);
      const installReport = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  UpCommand.paths = [
    [`up`]
  ];
  UpCommand.usage = Command.Usage({
    description: `upgrade dependencies across the project`,
    details: `
      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of \`dependencies\` or \`devDependencies\` - \`peerDependencies\` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.

      If \`-i,--interactive\` is set (or if the \`preferInteractive\` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.

      The, \`-C,--caret\`, \`-E,--exact\` and  \`-T,--tilde\` options have the same meaning as in the \`add\` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).

      Generally you can see \`yarn up\` as a counterpart to what was \`yarn upgrade --latest\` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike \`yarn upgrade\` which only upgraded dependencies in the current workspace, \`yarn up\` will upgrade all workspaces at the same time.

      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.
    `,
    examples: [[
      `Upgrade all instances of lodash to the latest release`,
      `$0 up lodash`
    ], [
      `Upgrade all instances of lodash to the latest release, but ask confirmation for each`,
      `$0 up lodash -i`
    ], [
      `Upgrade all instances of lodash to 1.2.3`,
      `$0 up lodash@1.2.3`
    ], [
      `Upgrade all instances of packages with the \`@babel\` scope to the latest release`,
      `$0 up '@babel/*'`
    ], [
      `Upgrade all instances of packages containing the word \`jest\` to the latest release`,
      `$0 up '*jest*'`
    ], [
      `Upgrade all instances of packages with the \`@babel\` scope to 7.0.0`,
      `$0 up '@babel/*@7.0.0'`
    ]]
  });
  var up_default = UpCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\why.ts
  var WhyCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `List, for each workspace, what are all the paths that lead to the dependency`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.peers = options_exports.Boolean(`--peers`, false, {
        description: `Also print the peer dependencies that match the specified name`
      });
      this.package = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const identHash = structUtils_exports.parseIdent(this.package).identHash;
      const whyTree = this.recursive ? whyRecursive(project, identHash, {configuration, peers: this.peers}) : whySimple(project, identHash, {configuration, peers: this.peers});
      treeUtils_exports.emitTree(whyTree, {
        configuration,
        stdout: this.context.stdout,
        json: this.json,
        separators: 1
      });
    }
  };
  WhyCommand.paths = [
    [`why`]
  ];
  WhyCommand.usage = Command.Usage({
    description: `display the reason why a package is needed`,
    details: `
      This command prints the exact reasons why a package appears in the dependency tree.

      If \`-R,--recursive\` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named "Foo" when looking for "Bar", it means that "Foo" already got printed higher in the tree.
    `,
    examples: [[
      `Explain why lodash is used in your project`,
      `$0 why lodash`
    ]]
  });
  var why_default = WhyCommand;
  function whySimple(project, identHash, {configuration, peers}) {
    const sortedPackages = miscUtils10.sortMap(project.storedPackages.values(), (pkg) => {
      return structUtils_exports.stringifyLocator(pkg);
    });
    const rootChildren = {};
    const root = {children: rootChildren};
    for (const pkg of sortedPackages) {
      const nodeChildren = {};
      const node = null;
      for (const dependency of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        if (nextPkg.identHash !== identHash)
          continue;
        if (node === null) {
          const key2 = structUtils_exports.stringifyLocator(pkg);
          rootChildren[key2] = {value: [pkg, formatUtils_exports.Type.LOCATOR], children: nodeChildren};
        }
        const key = structUtils_exports.stringifyLocator(nextPkg);
        nodeChildren[key] = {value: [{
          descriptor: dependency,
          locator: nextPkg
        }, formatUtils_exports.Type.DEPENDENT]};
      }
    }
    return root;
  }
  function whyRecursive(project, identHash, {configuration, peers}) {
    const sortedWorkspaces = miscUtils10.sortMap(project.workspaces, (workspace) => {
      return structUtils_exports.stringifyLocator(workspace.anchoredLocator);
    });
    const seen = new Set();
    const dependents = new Set();
    const markAllDependents = (pkg) => {
      if (seen.has(pkg.locatorHash))
        return dependents.has(pkg.locatorHash);
      seen.add(pkg.locatorHash);
      if (pkg.identHash === identHash) {
        dependents.add(pkg.locatorHash);
        return true;
      }
      let depends = false;
      if (pkg.identHash === identHash)
        depends = true;
      for (const dependency of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        if (markAllDependents(nextPkg)) {
          depends = true;
        }
      }
      if (depends)
        dependents.add(pkg.locatorHash);
      return depends;
    };
    for (const workspace of sortedWorkspaces) {
      const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg)
        throw new Error(`Assertion failed: The package should have been registered`);
      markAllDependents(pkg);
    }
    const printed = new Set();
    const rootChildren = {};
    const root = {children: rootChildren};
    const printAllDependents = (pkg, parentChildren, dependency) => {
      if (!dependents.has(pkg.locatorHash))
        return;
      const nodeValue = dependency !== null ? formatUtils_exports.tuple(formatUtils_exports.Type.DEPENDENT, {locator: pkg, descriptor: dependency}) : formatUtils_exports.tuple(formatUtils_exports.Type.LOCATOR, pkg);
      const nodeChildren = {};
      const node = {
        value: nodeValue,
        children: nodeChildren
      };
      const key = structUtils_exports.stringifyLocator(pkg);
      parentChildren[key] = node;
      if (printed.has(pkg.locatorHash))
        return;
      printed.add(pkg.locatorHash);
      if (dependency !== null && project.tryWorkspaceByLocator(pkg))
        return;
      for (const dependency2 of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency2.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency2.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        printAllDependents(nextPkg, nodeChildren, dependency2);
      }
    };
    for (const workspace of sortedWorkspaces) {
      const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg)
        throw new Error(`Assertion failed: The package should have been registered`);
      printAllDependents(pkg, rootChildren, null);
    }
    return root;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\workspaces\list.ts
  var WorkspacesListCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Also return the cross-dependencies between workspaces`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const workspace of project.workspaces) {
          const {manifest} = workspace;
          let extra;
          if (this.verbose) {
            const workspaceDependencies = new Set();
            const mismatchedWorkspaceDependencies = new Set();
            for (const dependencyType of Manifest.hardDependencies) {
              for (const [identHash, descriptor] of manifest.getForScope(dependencyType)) {
                const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
                if (matchingWorkspace === null) {
                  if (project.workspacesByIdent.has(identHash)) {
                    mismatchedWorkspaceDependencies.add(descriptor);
                  }
                } else {
                  workspaceDependencies.add(matchingWorkspace);
                }
              }
            }
            extra = {
              workspaceDependencies: Array.from(workspaceDependencies).map((workspace2) => {
                return workspace2.relativeCwd;
              }),
              mismatchedWorkspaceDependencies: Array.from(mismatchedWorkspaceDependencies).map((descriptor) => {
                return structUtils_exports.stringifyDescriptor(descriptor);
              })
            };
          }
          report2.reportInfo(null, `${workspace.relativeCwd}`);
          report2.reportJson({
            location: workspace.relativeCwd,
            name: manifest.name ? structUtils_exports.stringifyIdent(manifest.name) : null,
            ...extra
          });
        }
      });
      return report.exitCode();
    }
  };
  WorkspacesListCommand.paths = [
    [`workspaces`, `list`]
  ];
  WorkspacesListCommand.usage = Command.Usage({
    category: `Workspace-related commands`,
    description: `list all available workspaces`,
    details: `
      This command will print the list of all workspaces in the project. If both the \`-v,--verbose\` and \`--json\` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).
    `
  });
  var list_default2 = WorkspacesListCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\commands\workspace.ts
  var WorkspaceCommand = class extends Command {
    constructor() {
      super(...arguments);
      this.workspaceName = options_exports.String();
      this.commandName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace: cwdWorkspace} = await Project.find(configuration, this.context.cwd);
      if (!cwdWorkspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const candidates = project.workspaces;
      const candidatesByName = new Map(candidates.map((workspace2) => {
        const ident = structUtils_exports.convertToIdent(workspace2.locator);
        return [structUtils_exports.stringifyIdent(ident), workspace2];
      }));
      const workspace = candidatesByName.get(this.workspaceName);
      if (workspace === void 0) {
        const otherNames = Array.from(candidatesByName.keys()).sort();
        throw new UsageError(`Workspace '${this.workspaceName}' not found. Did you mean any of the following:
  - ${otherNames.join(`
  - `)}?`);
      }
      return this.cli.run([this.commandName, ...this.args], {cwd: workspace.cwd});
    }
  };
  WorkspaceCommand.paths = [
    [`workspace`]
  ];
  WorkspaceCommand.usage = Command.Usage({
    category: `Workspace-related commands`,
    description: `run a command within the specified workspace`,
    details: `
      This command will run a given sub-command on a single workspace.
    `,
    examples: [[
      `Add a package to a single workspace`,
      `yarn workspace components add -D react`
    ], [
      `Run build script on a single workspace`,
      `yarn workspace components run build`
    ]]
  });
  var workspace_default = WorkspaceCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-ba2aa356ff\1\packages\plugin-essentials\sources\index.ts
  var plugin = {
    configuration: {
      enableImmutableInstalls: {
        description: `If true, prevents the install command from modifying the lockfile`,
        type: SettingsType.BOOLEAN,
        default: false
      },
      defaultSemverRangePrefix: {
        description: `The default save prefix: '^', '~' or ''`,
        type: SettingsType.STRING,
        values: [`^`, `~`, ``],
        default: Modifier.CARET
      }
    },
    commands: [
      clean_default,
      get_default,
      set_default,
      unset_default,
      resolution_default,
      sources_default,
      version_default2,
      list_default2,
      clipanion_default,
      help_default,
      run_default,
      version_default,
      add_default,
      bin_default,
      config_default,
      dedupe_default,
      exec_default,
      peerRequirements_default,
      info_default,
      install_default,
      link_default,
      node_default,
      sources_default2,
      import_default,
      remove_default,
      list_default,
      runtime_default,
      rebuild_default,
      remove_default2,
      runIndex_default,
      run_default2,
      up_default,
      why_default,
      workspace_default
    ]
  };
  var sources_default3 = plugin;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\index.ts
  var sources_exports7 = {};
  __export(sources_exports7, {
    default: () => sources_default4
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\extensions.ts
  var optionalPeerDep = {
    optional: true
  };
  var packageExtensions = [
    [`@samverschueren/stream-to-observable@<0.3.1`, {
      peerDependenciesMeta: {
        [`rxjs`]: optionalPeerDep,
        [`zenObservable`]: optionalPeerDep
      }
    }],
    [`any-observable@<0.5.1`, {
      peerDependenciesMeta: {
        [`rxjs`]: optionalPeerDep,
        [`zenObservable`]: optionalPeerDep
      }
    }],
    [`@pm2/agent@<1.0.4`, {
      dependencies: {
        [`debug`]: `*`
      }
    }],
    [`debug@<4.2.0`, {
      peerDependenciesMeta: {
        [`supports-color`]: optionalPeerDep
      }
    }],
    [`got@<11`, {
      dependencies: {
        [`@types/responselike`]: `^1.0.0`,
        [`@types/keyv`]: `^3.1.1`
      }
    }],
    [`cacheable-lookup@<4.1.2`, {
      dependencies: {
        [`@types/keyv`]: `^3.1.1`
      }
    }],
    [`http-link-dataloader@*`, {
      peerDependencies: {
        [`graphql`]: `^0.13.1 || ^14.0.0`
      }
    }],
    [`typescript-language-server@*`, {
      dependencies: {
        [`vscode-jsonrpc`]: `^5.0.1`,
        [`vscode-languageserver-protocol`]: `^3.15.0`
      }
    }],
    [`postcss-syntax@*`, {
      peerDependenciesMeta: {
        [`postcss-html`]: optionalPeerDep,
        [`postcss-jsx`]: optionalPeerDep,
        [`postcss-less`]: optionalPeerDep,
        [`postcss-markdown`]: optionalPeerDep,
        [`postcss-scss`]: optionalPeerDep
      }
    }],
    [`jss-plugin-rule-value-function@<=10.1.1`, {
      dependencies: {
        [`tiny-warning`]: `^1.0.2`
      }
    }],
    [`ink-select-input@<4.1.0`, {
      peerDependencies: {
        react: `^16.8.2`
      }
    }],
    [`promise-inflight@*`, {
      peerDependenciesMeta: {
        [`bluebird`]: optionalPeerDep
      }
    }],
    [`reactcss@*`, {
      peerDependencies: {
        react: `*`
      }
    }],
    [`react-color@<=2.19.0`, {
      peerDependencies: {
        react: `*`
      }
    }],
    [`gatsby-plugin-i18n@*`, {
      dependencies: {
        ramda: `^0.24.1`
      }
    }],
    [`useragent@^2.0.0`, {
      dependencies: {
        request: `^2.88.0`,
        yamlparser: `0.0.x`,
        semver: `5.5.x`
      }
    }],
    [`@apollographql/apollo-tools@*`, {
      peerDependencies: {
        graphql: `^14.2.1 || ^15.0.0`
      }
    }],
    [`material-table@^2.0.0`, {
      dependencies: {
        "@babel/runtime": `^7.11.2`
      }
    }],
    [`@babel/parser@*`, {
      dependencies: {
        "@babel/types": `^7.8.3`
      }
    }],
    [`fork-ts-checker-webpack-plugin@*`, {
      peerDependencies: {
        eslint: `>= 6`,
        typescript: `>= 2.7`,
        webpack: `>= 4`
      },
      peerDependenciesMeta: {
        eslint: optionalPeerDep
      }
    }],
    [`rc-animate@*`, {
      peerDependencies: {
        react: `^15.0.0 || ^16.0.0`,
        "react-dom": `^15.0.0 || ^16.0.0`
      }
    }],
    [`react-bootstrap-table2-paginator@*`, {
      dependencies: {
        classnames: `^2.2.6`
      }
    }],
    [`react-draggable@<=4.4.3`, {
      peerDependencies: {
        react: `>= 16.3.0`,
        "react-dom": `>= 16.3.0`
      }
    }],
    [`apollo-upload-client@<14`, {
      peerDependencies: {
        graphql: `14 - 15`
      }
    }],
    [`react-instantsearch-core@<=6.7.0`, {
      peerDependencies: {
        algoliasearch: `>= 3.1 < 5`
      }
    }],
    [`react-instantsearch-dom@<=6.7.0`, {
      dependencies: {
        "react-fast-compare": `^3.0.0`
      }
    }],
    [`ws@<7.2.1`, {
      peerDependencies: {
        bufferutil: `^4.0.1`,
        "utf-8-validate": `^5.0.2`
      },
      peerDependenciesMeta: {
        bufferutil: optionalPeerDep,
        "utf-8-validate": optionalPeerDep
      }
    }],
    [`react-portal@*`, {
      peerDependencies: {
        "react-dom": `^15.0.0-0 || ^16.0.0-0 || ^17.0.0-0`
      }
    }],
    [`create-react-app@*`, {
      peerDependencies: {
        [`react`]: `*`
      }
    }],
    [`testcafe@<=1.10.1`, {
      dependencies: {
        "@babel/plugin-transform-for-of": `^7.12.1`,
        "@babel/runtime": `^7.12.5`
      }
    }],
    [`testcafe-legacy-api@<=4.2.0`, {
      dependencies: {
        "testcafe-hammerhead": `^17.0.1`,
        "read-file-relative": `^1.2.0`
      }
    }]
  ];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\patches\fsevents.patch.ts
  var patch;
  function getPatch() {
    if (typeof patch === `undefined`)
      patch = require("zlib").brotliDecompressSync(Buffer.from(`G7weAByFTVk3Vs7UfHhq4yykgEM7pbW7TI43SG2S5tvGrwHBAzdz+s/npQ6tgEvobvxisrPIadkXeUAJotBn5bDZ5kAhcRqsIHe3F75Walet5hNalwgFDtxb0BiDUjiUQkjG0yW2hto9HPgiCkm316d6bC0kST72YN7D7rfkhCE9x4J0XwB0yavalxpUu2t9xszHrmtwalOxT7VslsxWcB1qpqZwERUra4psWhTV8BgwWeizurec82Caf1ABL11YMfbf8FJ9JBceZOkgmvrQPbC9DUldX/yMbmX06UQluCEjSwUoyO+EZPIjofr+/oAZUck2enraRD+oWLlnlYnj8xB+gwSo9lmmks4fXv574qSqcWA6z21uYkzMu3EWj+K23RxeQlLqiE35/rC8GcS4CGkKHKKq+zAIQwD9iRDNfiAqueLLpicFFrNsAI4zeTD/eO9MHcnRa5m8UT+M2+V+AkFST4BlKneiAQRSdST8KEAIyFlULt6wa9EBd0Ds28VmpaxquJdVt+nwdEs5xUskI13OVtFyY0UrQIRAlCuvvWivvlSKQfTO+2Q8OyUR1W5RvetaPz4jD27hdtwHFFA1Ptx6Ee/t2cY2rg2G46M1pNDRf2pWhvpy8pqMnuI3++4OF3+7OFIWXGjh+o7Nr2jNvbiYcQdQS1h903/jVFgOpA0yJ78z+x759bFA0rq+6aY5qPB4FzS3oYoLupDUhD9nDz6F6H7hpnlMf18KNKDu4IKjTWwrAnY6MFQw1W6ymOALHlFyCZmQhldg1MQHaMVVQTVgDC60TfaBqG++Y8PEoFhN/PBTZT175KNP/BlHDYGOOBmnBdzqJKplZ/ljiVG0ZBzfqeBRrrUkn6rA54462SgiliKoYVnbeptMdXNfAuaupIEi0bApF10TlgHfmEJAPUVidRVFyDupSem5po5vErPqWKhKbUIp0LozpYsIKK57dM/HKr+nguF+7924IIWMICkQ8JUigs9D+W+c4LnNoRtPPKNRUiCYmP+Jfo2lfKCKw8qpraEeWU3uiNRO6zcyKQoXPR5htmzzLznke7b4YbXW3I1lIRzmgG02Udb58U+7TpwyN7XymCgH+wuPDthZVQvRZuEP+SnLtMicz9m5zASWOBiAcLmkuFlTKuHspSIhCBD0yUPKcxu81A+4YD78rA2vtwsUEday9WNyrShyrl60rWmA+SmbYZkQOwFJWArxRYYc5jGhA5ikxYw1rx3ei4NmeX/lKiwpZ9Ln1tV2Ae7sArvxuVLbJjqJRjW1vFXAyHpvLG+8MJ6T2Ubx5M2KDa2SN6vuIGxJ9WQM9Mk3Q7aCNiZONXllhqq24DmoLbQfW2rYWsOgHWjtOmIQMyMKdiHZDjoyIq5+U700nZ6odJAoYXPQBvFNiQ78d5jaXliBqLTJEqUCwi+LiH2mx92EmNKDsJL74Z613+3lf20pxkV1+erOrjj8pW00vsPaahKUM+05ssd5uwM7K482KWEf3TCwlg/o3e5ngto7qSMz7YteIgCsF1UOcsLk7F7MxWbvrPMY473ew0G+noVL8EPbkmEMftMSeL6HFub/zy+2JQ==`, `base64`)).toString();
    return patch;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\patches\resolve.patch.ts
  var patch2;
  function getPatch2() {
    if (typeof patch2 === `undefined`)
      patch2 = require("zlib").brotliDecompressSync(Buffer.from(`G1QTIIzURnVBnGa0VPvr81orV8AFIqdU0sqrdcVgCdukgAZwi8a50gLk9+19Z2NcUILjmzXkzt4dzm5a6Yoys+/9qnKiaApXukOiuoyUaMcynG4X7X4vBaIE/PL30gwG6HSGJkLxb9PnLjfMr+748n7sM6C/NycK6ber/bX1reVVxta6W/31tZIhfrS+upoE/TPRHj0S/l0T59gTGdtKOp1OmMOJt9rhfucDdLJ2tgyfnO+u4YMkQAcYq/nebTcDmbXhqhgo6iQA4M3m4xya4Cos3p6klmkmQT+S4DLDZfwfMF+sUCx36KleOtaHLQfEIz0Bmncj/Ngi3lqOl4391EWEfIss6gVp3oDUGwsSZJKeOVONJWZg+Mue3KUMV3aMqYJ+7b2219D+GFDi8EV5y/Y+5J+He0oNjKAgqLsJziEsS9uIaCu3BHBKSXxNKKa2ShbfglcWoiiVT2kfGI7Gw+YJ/Sqy1H6wdFWtyVUQIa82JPwbeV25YKLzc5ZIFM6GCPSA+J9dTvJbs5LuuKnLP3f09gCu2jxqsAv6CA+ZySVaUJr2d3A70BC/uBCKr2OVrWgC3fSwb7NlfkgSEEiejrMGvhya9lMbVI6lMsFKN330A1/FOaefHQdNGLEZ3IwFF87H3xVlM0Xxsmbi/7A60oymRcIe0tH90alG6ez/yA7jwYotxuHWZdR+1HlMcddGHAV6QD/gXYPV0wnNv47I+5FGevzZFMqWSO8GU4nQ3FjsdgdJcD+c1rvudERKuLyd7bxiBpnsMDHsvPP4nXdXkld/gUNks3GAE1Otmb90bavDyiw4Mrx496Iw+jbLTgsCZGZXSZ9vM55C7KGe4HyJAKXEk0iT/Cj/PFwLJBN7pcP7ZFfYtUApGTWKkYhI9IE2zt/5ByH72wdvH+88b71zuv/FMCX3w6x5nzhY44Cg5IYv9LeKwHuHIWgPbfgrAcUxOlKkPRdQOIDF/aBuLPJAXD+TgxCNXx4jQxeR/qlBWVikFPfEI4rXMUc4kZ2w9KbPKYRvFUag0dVlVoyUP4zfidbTXAdZF88jAckl+NHjLFCNdX7EQ1PbLSOl+P+MqgwEOCi6dxgWZ7NCwJBjWKpk1LaxwKrhZ4aEC/0lMPJYe5S8xAakDcmA2kSS86GjEMTrv3VEu0S0YGZcxToMV524G4WAc4CReePePdipvs4aXRL5p+aeN96yfMGjsiTbQNxgbdRKc+keQ+NxYIEm1mBtEO29WrcbrqNbQRMR66KpGG4aG0NtmRyZ2JhUvu0paCklRlID8PT3gSiwZrqr4XZXoBBzBMrveWCuOg7iTgGDXDdbGi8XHkQf5KXDGFUxWueu5wkSa6gMWY1599g2piQjwBKIAPt4N5cOZdFBidz2feGwEAy1j1UydGxDSCCUsh314cUIIRV/dWCheceubL2gU8CibewmP7UxmN5kN4I7zfQhPxkP0NCcei8GXQpw4c3krEzW7PR2hgi/hqqqR58UJ/ZVfWxfcH5ZKMo4itkmPK0FCGxzzIRP20lK/gz28Y03sY233KvSVWUKl9rcbX6MbHjpUG8MvNlw72p6FwTejv92zgpnCxVJnIHHZhCBxNcHF5RTveRp513hUtTHHq4BIndlytZT5xoTSYfHKqKNr4o9kcGINIz6tZSKRdtbON3Ydr9cgqxHIeisMNIsvPg/IFMZuBbSqqDLeSO5dak1cGr76FtH2PC7hs0S0Oq3GsmF1Ga4YABAMGcdPAWzTk26B7cKV91I2b0V/GYvnsEQ1YGntRqi5EQqTlgZszbV/32GuZtUF49JOA/r4jAdwUOsbPo6mNoBlJPYjM5axrZaWQf33bFsLWqiyvvDOM4x0Ng802T7cuP2a3q98GWq6yiq6q3M77hcZlOUnmryctRYmI4Hb2F5XixFohkBmySCjU+M7/WQVE5YAtnlxiUJDhFN0y1tNeMWY9E0MfZi2rQ4eC72WXjsAA==`, `base64`)).toString();
    return patch2;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\patches\typescript.patch.ts
  var patch3;
  function getPatch3() {
    if (typeof patch3 === `undefined`)
      patch3 = require("zlib").brotliDecompressSync(Buffer.from(`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`, `base64`)).toString();
    return patch3;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-5fe64685a8\1\packages\plugin-compat\sources\index.ts
  var PATCHES = new Map([
    [structUtils_exports.makeIdent(null, `fsevents`).identHash, getPatch],
    [structUtils_exports.makeIdent(null, `resolve`).identHash, getPatch2],
    [structUtils_exports.makeIdent(null, `typescript`).identHash, getPatch3]
  ]);
  var plugin2 = {
    hooks: {
      registerPackageExtensions: async (configuration, registerPackageExtension) => {
        for (const [descriptorStr, extensionData] of packageExtensions) {
          registerPackageExtension(structUtils_exports.parseDescriptor(descriptorStr, true), extensionData);
        }
      },
      getBuiltinPatch: async (project, name) => {
        var _a2;
        const TAG = `compat/`;
        if (!name.startsWith(TAG))
          return void 0;
        const ident = structUtils_exports.parseIdent(name.slice(TAG.length));
        const patch7 = (_a2 = PATCHES.get(ident.identHash)) == null ? void 0 : _a2();
        return typeof patch7 !== `undefined` ? patch7 : null;
      },
      reduceDependency: async (dependency, project, locator, initialDescriptor) => {
        const patch7 = PATCHES.get(dependency.identHash);
        if (typeof patch7 === `undefined`)
          return dependency;
        return structUtils_exports.makeDescriptor(dependency, structUtils_exports.makeRange({
          protocol: `patch:`,
          source: structUtils_exports.stringifyDescriptor(dependency),
          selector: `builtin<compat/${structUtils_exports.stringifyIdent(dependency)}>`,
          params: null
        }));
      }
    }
  };
  var sources_default4 = plugin2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-0ee854167a\1\packages\plugin-dlx\sources\index.ts
  var sources_exports8 = {};
  __export(sources_exports8, {
    default: () => sources_default5
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-0ee854167a\1\packages\plugin-dlx\sources\commands\create.ts
  var CreateCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.pkg = options_exports.String(`-p,--package`, {
        description: `The package to run the provided command from`
      });
      this.quiet = options_exports.Boolean(`-q,--quiet`, false, {
        description: `Only report critical errors instead of printing the full install logs`
      });
      this.command = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const flags = [];
      if (this.pkg)
        flags.push(`--package`, this.pkg);
      if (this.quiet)
        flags.push(`--quiet`);
      const ident = structUtils_exports.parseIdent(this.command);
      const modified = structUtils_exports.makeIdent(ident.scope, `create-${ident.name}`);
      return this.cli.run([`dlx`, ...flags, structUtils_exports.stringifyIdent(modified), ...this.args]);
    }
  };
  CreateCommand.paths = [
    [`create`]
  ];
  var create_default = CreateCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-0ee854167a\1\packages\plugin-dlx\sources\commands\dlx.ts
  var DlxCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.pkg = options_exports.String(`-p,--package`, {
        description: `The package to run the provided command from`
      });
      this.quiet = options_exports.Boolean(`-q,--quiet`, false, {
        description: `Only report critical errors instead of printing the full install logs`
      });
      this.command = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      Configuration.telemetry = null;
      return await xfs.mktempPromise(async (baseDir) => {
        const tmpDir = ppath.join(baseDir, `dlx-${process.pid}`);
        await xfs.mkdirPromise(tmpDir);
        await xfs.writeFilePromise(ppath.join(tmpDir, `package.json`), `{}
`);
        await xfs.writeFilePromise(ppath.join(tmpDir, `yarn.lock`), ``);
        const targetYarnrc = ppath.join(tmpDir, `.yarnrc.yml`);
        const projectCwd = await Configuration.findProjectCwd(this.context.cwd, Filename.lockfile);
        const sourceYarnrc = projectCwd !== null ? ppath.join(projectCwd, `.yarnrc.yml`) : null;
        if (sourceYarnrc !== null && xfs.existsSync(sourceYarnrc)) {
          await xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
          await Configuration.updateConfiguration(tmpDir, (current) => {
            const nextConfiguration = {
              ...current,
              enableGlobalCache: true,
              enableTelemetry: false
            };
            if (Array.isArray(current.plugins)) {
              nextConfiguration.plugins = current.plugins.map((plugin23) => {
                const sourcePath = typeof plugin23 === `string` ? plugin23 : plugin23.path;
                const remapPath = npath.isAbsolute(sourcePath) ? sourcePath : npath.resolve(npath.fromPortablePath(projectCwd), sourcePath);
                if (typeof plugin23 === `string`) {
                  return remapPath;
                } else {
                  return {path: remapPath, spec: plugin23.spec};
                }
              });
            }
            return nextConfiguration;
          });
        } else {
          await xfs.writeFilePromise(targetYarnrc, `enableGlobalCache: true
enableTelemetry: false
`);
        }
        const pkgs = typeof this.pkg !== `undefined` ? [this.pkg] : [this.command];
        const command = structUtils_exports.parseDescriptor(this.command).name;
        const addExitCode = await this.cli.run([`add`, `--`, ...pkgs], {cwd: tmpDir, quiet: this.quiet});
        if (addExitCode !== 0)
          return addExitCode;
        if (!this.quiet)
          this.context.stdout.write(`
`);
        const configuration = await Configuration.find(tmpDir, this.context.plugins);
        const {project, workspace} = await Project.find(configuration, tmpDir);
        if (workspace === null)
          throw new WorkspaceRequiredError(project.cwd, tmpDir);
        await project.restoreInstallState();
        return await scriptUtils_exports.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr
        });
      });
    }
  };
  DlxCommand.paths = [
    [`dlx`]
  ];
  DlxCommand.usage = Command.Usage({
    description: `run a package in a temporary environment`,
    details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
    examples: [[
      `Use create-react-app to create a new React app`,
      `yarn dlx create-react-app ./my-app`
    ]]
  });
  var dlx_default = DlxCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-0ee854167a\1\packages\plugin-dlx\sources\index.ts
  var plugin3 = {
    commands: [
      create_default,
      dlx_default
    ]
  };
  var sources_default5 = plugin3;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\index.ts
  var sources_exports9 = {};
  __export(sources_exports9, {
    default: () => sources_default6,
    fileUtils: () => fileUtils_exports
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\constants.ts
  var FILE_REGEXP = /^(?:[a-zA-Z]:[\\/]|\.{0,2}\/)/;
  var TARBALL_REGEXP = /^[^?]*\.(?:tar\.gz|tgz)(?:::.*)?$/;
  var PROTOCOL = `file:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\fileUtils.ts
  var fileUtils_exports = {};
  __export(fileUtils_exports, {
    makeArchiveFromLocator: () => makeArchiveFromLocator,
    makeBufferFromLocator: () => makeBufferFromLocator,
    makeLocator: () => makeLocator2,
    makeSpec: () => makeSpec,
    parseSpec: () => parseSpec
  });
  function parseSpec(spec) {
    const {params, selector} = structUtils_exports.parseRange(spec);
    const path6 = npath.toPortablePath(selector);
    const parentLocator = params && typeof params.locator === `string` ? structUtils_exports.parseLocator(params.locator) : null;
    return {parentLocator, path: path6};
  }
  function makeSpec({parentLocator, path: path6, folderHash, protocol}) {
    const parentLocatorSpread = parentLocator !== null ? {locator: structUtils_exports.stringifyLocator(parentLocator)} : {};
    const folderHashSpread = typeof folderHash !== `undefined` ? {hash: folderHash} : {};
    return structUtils_exports.makeRange({
      protocol,
      source: path6,
      selector: path6,
      params: {
        ...folderHashSpread,
        ...parentLocatorSpread
      }
    });
  }
  function makeLocator2(ident, {parentLocator, path: path6, folderHash, protocol}) {
    return structUtils_exports.makeLocator(ident, makeSpec({parentLocator, path: path6, folderHash, protocol}));
  }
  async function makeArchiveFromLocator(locator, {protocol, fetchOptions, inMemory = false}) {
    const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol});
    const parentFetch = ppath.isAbsolute(path6) ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: PortablePath2.dot, localPath: PortablePath2.root} : await fetchOptions.fetcher.fetch(parentLocator, fetchOptions);
    const effectiveParentFetch = parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
      parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = ppath.join(effectiveParentFetch.prefixPath, path6);
    return await miscUtils10.releaseAfterUseAsync(async () => {
      return await tgzUtils_exports.makeArchiveFromDirectory(sourcePath, {
        baseFs: sourceFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        compressionLevel: fetchOptions.project.configuration.get(`compressionLevel`),
        inMemory
      });
    }, effectiveParentFetch.releaseFs);
  }
  async function makeBufferFromLocator(locator, {protocol, fetchOptions}) {
    const folderFs = await makeArchiveFromLocator(locator, {protocol, fetchOptions, inMemory: true});
    return folderFs.getBufferAndClose();
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\FileFetcher.ts
  var FileFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: PROTOCOL});
      if (ppath.isAbsolute(path6))
        return path6;
      const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
      if (parentLocalPath === null)
        return null;
      return ppath.resolve(parentLocalPath, path6);
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
        loader: () => this.fetchFromDisk(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        localPath: this.getLocalPath(locator, opts),
        checksum
      };
    }
    async fetchFromDisk(locator, opts) {
      return makeArchiveFromLocator(locator, {protocol: PROTOCOL, fetchOptions: opts});
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\FileResolver.ts
  var CACHE_VERSION2 = 1;
  var FileResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (descriptor.range.match(FILE_REGEXP))
        return true;
      if (!descriptor.range.startsWith(PROTOCOL))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      if (FILE_REGEXP.test(descriptor.range))
        descriptor = structUtils_exports.makeDescriptor(descriptor, `${PROTOCOL}${descriptor.range}`);
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const {path: path6, parentLocator} = parseSpec(descriptor.range);
      if (parentLocator === null)
        throw new Error(`Assertion failed: The descriptor should have been bound`);
      const archiveBuffer = await makeBufferFromLocator(structUtils_exports.makeLocator(descriptor, structUtils_exports.makeRange({
        protocol: PROTOCOL,
        source: path6,
        selector: path6,
        params: {
          locator: structUtils_exports.stringifyLocator(parentLocator)
        }
      })), {protocol: PROTOCOL, fetchOptions: opts.fetchOptions});
      const folderHash = hashUtils_exports.makeHash(`${CACHE_VERSION2}`, archiveBuffer).slice(0, 6);
      return [makeLocator2(descriptor, {parentLocator, path: path6, folderHash, protocol: PROTOCOL})];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
      const manifest = await miscUtils10.releaseAfterUseAsync(async () => {
        return await Manifest.find(packageFetch.prefixPath, {baseFs: packageFetch.packageFs});
      }, packageFetch.releaseFs);
      return {
        ...locator,
        version: manifest.version || `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\TarballFileFetcher.ts
  var TarballFileFetcher = class {
    supports(locator, opts) {
      if (!TARBALL_REGEXP.test(locator.reference))
        return false;
      if (locator.reference.startsWith(PROTOCOL))
        return true;
      return false;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
        loader: () => this.fetchFromDisk(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromDisk(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: PROTOCOL});
      const parentFetch = ppath.isAbsolute(path6) ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: PortablePath2.dot, localPath: PortablePath2.root} : await opts.fetcher.fetch(parentLocator, opts);
      const effectiveParentFetch = parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
      if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
      const sourceFs = effectiveParentFetch.packageFs;
      const sourcePath = ppath.join(effectiveParentFetch.prefixPath, path6);
      const sourceBuffer = await sourceFs.readFilePromise(sourcePath);
      return await miscUtils10.releaseAfterUseAsync(async () => {
        return await tgzUtils_exports.convertToZip(sourceBuffer, {
          compressionLevel: opts.project.configuration.get(`compressionLevel`),
          prefixPath: structUtils_exports.getIdentVendorPath(locator),
          stripComponents: 1
        });
      }, effectiveParentFetch.releaseFs);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\TarballFileResolver.ts
  var TarballFileResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!TARBALL_REGEXP.test(descriptor.range))
        return false;
      if (descriptor.range.startsWith(PROTOCOL))
        return true;
      if (FILE_REGEXP.test(descriptor.range))
        return true;
      return false;
    }
    supportsLocator(locator, opts) {
      if (!TARBALL_REGEXP.test(locator.reference))
        return false;
      if (locator.reference.startsWith(PROTOCOL))
        return true;
      return false;
    }
    shouldPersistResolution(locator, opts) {
      return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      if (FILE_REGEXP.test(descriptor.range))
        descriptor = structUtils_exports.makeDescriptor(descriptor, `${PROTOCOL}${descriptor.range}`);
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      let path6 = descriptor.range;
      if (path6.startsWith(PROTOCOL))
        path6 = path6.slice(PROTOCOL.length);
      return [structUtils_exports.makeLocator(descriptor, `${PROTOCOL}${npath.toPortablePath(path6)}`)];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
      const manifest = await miscUtils10.releaseAfterUseAsync(async () => {
        return await Manifest.find(packageFetch.prefixPath, {baseFs: packageFetch.packageFs});
      }, packageFetch.releaseFs);
      return {
        ...locator,
        version: manifest.version || `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-file-virtual-8057b73875\1\packages\plugin-file\sources\index.ts
  var plugin4 = {
    fetchers: [
      TarballFileFetcher,
      FileFetcher
    ],
    resolvers: [
      TarballFileResolver,
      FileResolver
    ]
  };
  var sources_default6 = plugin4;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-git-virtual-10be4489c8\1\packages\plugin-git\sources\index.ts
  var sources_exports10 = {};
  __export(sources_exports10, {
    default: () => sources_default7,
    gitUtils: () => gitUtils_exports
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-git-virtual-10be4489c8\1\packages\plugin-git\sources\gitUtils.ts
  var gitUtils_exports = {};
  __export(gitUtils_exports, {
    TreeishProtocols: () => TreeishProtocols,
    clone: () => clone,
    isGitUrl: () => isGitUrl,
    lsRemote: () => lsRemote,
    normalizeLocator: () => normalizeLocator,
    normalizeRepoUrl: () => normalizeRepoUrl,
    resolveUrl: () => resolveUrl,
    splitRepoUrl: () => splitRepoUrl
  });
  var import_querystring2 = __toModule(require("querystring"));
  var import_semver12 = __toModule(require_semver2());
  var import_url4 = __toModule(require("url"));
  function makeGitEnvironment() {
    return {
      ...process.env,
      GIT_SSH_COMMAND: `ssh -o BatchMode=yes`
    };
  }
  var gitPatterns = [
    /^ssh:/,
    /^git(?:\+[^:]+)?:/,
    /^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/,
    /^git@[^#]+\/[^#]+\.git(?:#.*)?$/,
    /^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/,
    /^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/
  ];
  var TreeishProtocols;
  (function(TreeishProtocols2) {
    TreeishProtocols2["Commit"] = `commit`;
    TreeishProtocols2["Head"] = `head`;
    TreeishProtocols2["Tag"] = `tag`;
    TreeishProtocols2["Semver"] = `semver`;
  })(TreeishProtocols || (TreeishProtocols = {}));
  function isGitUrl(url) {
    return url ? gitPatterns.some((pattern) => !!url.match(pattern)) : false;
  }
  function splitRepoUrl(url) {
    url = normalizeRepoUrl(url);
    const hashIndex = url.indexOf(`#`);
    if (hashIndex === -1) {
      return {
        repo: url,
        treeish: {
          protocol: TreeishProtocols.Head,
          request: `master`
        },
        extra: {}
      };
    }
    const repo = url.slice(0, hashIndex);
    const subsequent = url.slice(hashIndex + 1);
    if (subsequent.match(/^[a-z]+=/)) {
      const extra = import_querystring2.default.parse(subsequent);
      for (const [key, value] of Object.entries(extra))
        if (typeof value !== `string`)
          throw new Error(`Assertion failed: The ${key} parameter must be a literal string`);
      const requestedProtocol = Object.values(TreeishProtocols).find((protocol2) => {
        return Object.prototype.hasOwnProperty.call(extra, protocol2);
      });
      let protocol;
      let request2;
      if (typeof requestedProtocol !== `undefined`) {
        protocol = requestedProtocol;
        request2 = extra[requestedProtocol];
      } else {
        protocol = TreeishProtocols.Head;
        request2 = `master`;
      }
      for (const key of Object.values(TreeishProtocols))
        delete extra[key];
      return {
        repo,
        treeish: {protocol, request: request2},
        extra
      };
    } else {
      const colonIndex = subsequent.indexOf(`:`);
      let protocol;
      let request2;
      if (colonIndex === -1) {
        protocol = null;
        request2 = subsequent;
      } else {
        protocol = subsequent.slice(0, colonIndex);
        request2 = subsequent.slice(colonIndex + 1);
      }
      return {
        repo,
        treeish: {protocol, request: request2},
        extra: {}
      };
    }
  }
  function normalizeRepoUrl(url, {git = false} = {}) {
    var _a2;
    url = url.replace(/^git\+https:/, `https:`);
    url = url.replace(/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)(?:\.git)?(#.*)?$/, `https://github.com/$1/$2.git$3`);
    url = url.replace(/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/, `https://github.com/$1/$2.git#$3`);
    if (git) {
      url = url.replace(/^git\+([^:]+):/, `$1:`);
      let parsedUrl;
      try {
        parsedUrl = import_url4.default.parse(url);
      } catch {
        parsedUrl = null;
      }
      if (parsedUrl && parsedUrl.protocol === `ssh:` && ((_a2 = parsedUrl.path) == null ? void 0 : _a2.startsWith(`/:`))) {
        url = url.replace(/^ssh:\/\//, ``);
      }
    }
    return url;
  }
  function normalizeLocator(locator) {
    return structUtils_exports.makeLocator(locator, normalizeRepoUrl(locator.reference));
  }
  async function lsRemote(repo, configuration) {
    const normalizedRepoUrl = normalizeRepoUrl(repo, {git: true});
    const networkSettings = httpUtils_exports.getNetworkSettings(normalizedRepoUrl, {configuration});
    if (!networkSettings.enableNetwork)
      throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
    let res;
    try {
      res = await execUtils_exports.execvp(`git`, [`ls-remote`, `--refs`, normalizedRepoUrl], {
        cwd: configuration.startingCwd,
        env: makeGitEnvironment(),
        strict: true
      });
    } catch (error) {
      error.message = `Listing the refs for ${repo} failed`;
      throw error;
    }
    const refs = new Map();
    const matcher = /^([a-f0-9]{40})\t(refs\/[^\n]+)/gm;
    let match2;
    while ((match2 = matcher.exec(res.stdout)) !== null)
      refs.set(match2[2], match2[1]);
    return refs;
  }
  async function resolveUrl(url, configuration) {
    const {repo, treeish: {protocol, request: request2}, extra} = splitRepoUrl(url);
    const refs = await lsRemote(repo, configuration);
    const resolve = (protocol2, request3) => {
      switch (protocol2) {
        case TreeishProtocols.Commit: {
          if (!request3.match(/^[a-f0-9]{40}$/))
            throw new Error(`Invalid commit hash`);
          return import_querystring2.default.stringify({
            ...extra,
            commit: request3
          });
        }
        case TreeishProtocols.Head: {
          const head = refs.get(`refs/heads/${request3}`);
          if (typeof head === `undefined`)
            throw new Error(`Unknown head ("${request3}")`);
          return import_querystring2.default.stringify({
            ...extra,
            commit: head
          });
        }
        case TreeishProtocols.Tag: {
          const tag = refs.get(`refs/tags/${request3}`);
          if (typeof tag === `undefined`)
            throw new Error(`Unknown tag ("${request3}")`);
          return import_querystring2.default.stringify({
            ...extra,
            commit: tag
          });
        }
        case TreeishProtocols.Semver: {
          if (!import_semver12.default.validRange(request3))
            throw new Error(`Invalid range ("${request3}")`);
          const semverTags = new Map([...refs.entries()].filter(([ref]) => {
            return ref.startsWith(`refs/tags/`);
          }).map(([ref, hash]) => {
            return [import_semver12.default.parse(ref.slice(10)), hash];
          }).filter((entry) => {
            return entry[0] !== null;
          }));
          const bestVersion = import_semver12.default.maxSatisfying([...semverTags.keys()], request3);
          if (bestVersion === null)
            throw new Error(`No matching range ("${request3}")`);
          return import_querystring2.default.stringify({
            ...extra,
            commit: semverTags.get(bestVersion)
          });
        }
        case null: {
          let result;
          if ((result = tryResolve(TreeishProtocols.Commit, request3)) !== null)
            return result;
          if ((result = tryResolve(TreeishProtocols.Tag, request3)) !== null)
            return result;
          if ((result = tryResolve(TreeishProtocols.Head, request3)) !== null)
            return result;
          if (request3.match(/^[a-f0-9]+$/)) {
            throw new Error(`Couldn't resolve "${request3}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`);
          } else {
            throw new Error(`Couldn't resolve "${request3}" as either a commit, a tag, or a head`);
          }
        }
        default: {
          throw new Error(`Invalid Git resolution protocol ("${protocol2}")`);
        }
      }
    };
    const tryResolve = (protocol2, request3) => {
      try {
        return resolve(protocol2, request3);
      } catch (err) {
        return null;
      }
    };
    return `${repo}#${resolve(protocol, request2)}`;
  }
  async function clone(url, configuration) {
    return await configuration.getLimit(`cloneConcurrency`)(async () => {
      const {repo, treeish: {protocol, request: request2}} = splitRepoUrl(url);
      if (protocol !== `commit`)
        throw new Error(`Invalid treeish protocol when cloning`);
      const normalizedRepoUrl = normalizeRepoUrl(repo, {git: true});
      if (httpUtils_exports.getNetworkSettings(normalizedRepoUrl, {configuration}).enableNetwork === false)
        throw new Error(`Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
      const directory = await xfs.mktempPromise();
      const execOpts = {cwd: directory, env: makeGitEnvironment(), strict: true};
      try {
        await execUtils_exports.execvp(`git`, [`clone`, `-c core.autocrlf=false`, normalizedRepoUrl, npath.fromPortablePath(directory)], execOpts);
        await execUtils_exports.execvp(`git`, [`checkout`, `${request2}`], execOpts);
      } catch (error) {
        error.message = `Repository clone failed: ${error.message}`;
        throw error;
      }
      return directory;
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-git-virtual-10be4489c8\1\packages\plugin-git\sources\GitFetcher.ts
  var GitFetcher = class {
    supports(locator, opts) {
      return isGitUrl(locator.reference);
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const normalizedLocator = normalizeLocator(locator);
      const checksums = new Map(opts.checksums);
      checksums.set(normalizedLocator.locatorHash, expectedChecksum);
      const nextOpts = {...opts, checksums};
      const result = await this.downloadHosted(normalizedLocator, nextOpts);
      if (result !== null)
        return result;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote repository`),
        loader: () => this.cloneFromRemote(normalizedLocator, nextOpts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async downloadHosted(locator, opts) {
      return opts.project.configuration.reduceHook((hooks) => {
        return hooks.fetchHostedRepository;
      }, null, locator, opts);
    }
    async cloneFromRemote(locator, opts) {
      const cloneTarget = await clone(locator.reference, opts.project.configuration);
      const repoUrlParts = splitRepoUrl(locator.reference);
      const packagePath = ppath.join(cloneTarget, `package.tgz`);
      await scriptUtils_exports.prepareExternalProject(cloneTarget, packagePath, {
        configuration: opts.project.configuration,
        report: opts.report,
        workspace: repoUrlParts.extra.workspace
      });
      const sourceBuffer = await xfs.readFilePromise(packagePath);
      return await miscUtils10.releaseAfterUseAsync(async () => {
        return await tgzUtils_exports.convertToZip(sourceBuffer, {
          compressionLevel: opts.project.configuration.get(`compressionLevel`),
          prefixPath: structUtils_exports.getIdentVendorPath(locator),
          stripComponents: 1
        });
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-git-virtual-10be4489c8\1\packages\plugin-git\sources\GitResolver.ts
  var GitResolver = class {
    supportsDescriptor(descriptor, opts) {
      return isGitUrl(descriptor.range);
    }
    supportsLocator(locator, opts) {
      return isGitUrl(locator.reference);
    }
    shouldPersistResolution(locator, opts) {
      return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const reference = await resolveUrl(descriptor.range, opts.project.configuration);
      const locator = structUtils_exports.makeLocator(descriptor, reference);
      return [locator];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
      const manifest = await miscUtils10.releaseAfterUseAsync(async () => {
        return await Manifest.find(packageFetch.prefixPath, {baseFs: packageFetch.packageFs});
      }, packageFetch.releaseFs);
      return {
        ...locator,
        version: manifest.version || `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-git-virtual-10be4489c8\1\packages\plugin-git\sources\index.ts
  var plugin5 = {
    configuration: {
      cloneConcurrency: {
        description: `Maximal number of concurrent clones`,
        type: SettingsType.NUMBER,
        default: 2
      }
    },
    fetchers: [
      GitFetcher
    ],
    resolvers: [
      GitResolver
    ]
  };
  var sources_default7 = plugin5;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-github-virtual-63e7e81f62\1\packages\plugin-github\sources\index.ts
  var sources_exports11 = {};
  __export(sources_exports11, {
    default: () => sources_default8
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-github-virtual-63e7e81f62\1\packages\plugin-github\sources\githubUtils.ts
  var import_querystring3 = __toModule(require("querystring"));
  var githubPatterns = [
    /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+)\/tarball\/([^/#]+)(?:#(.*))?$/,
    /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+?)(?:\.git)?(?:#(.*))?$/
  ];
  function isGithubUrl(url) {
    return url ? githubPatterns.some((pattern) => !!url.match(pattern)) : false;
  }
  function parseGithubUrl(urlStr) {
    let match2;
    for (const pattern of githubPatterns) {
      match2 = urlStr.match(pattern);
      if (match2) {
        break;
      }
    }
    if (!match2)
      throw new Error(invalidGithubUrlMessage(urlStr));
    let [, auth, username, reponame, treeish = `master`] = match2;
    const {commit} = import_querystring3.default.parse(treeish);
    treeish = commit || treeish.replace(/[^:]*:/, ``);
    return {auth, username, reponame, treeish};
  }
  function invalidGithubUrlMessage(url) {
    return `Input cannot be parsed as a valid GitHub URL ('${url}').`;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-github-virtual-63e7e81f62\1\packages\plugin-github\sources\GithubFetcher.ts
  var GithubFetcher = class {
    supports(locator, opts) {
      if (!isGithubUrl(locator.reference))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from GitHub`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      const sourceBuffer = await httpUtils_exports.get(this.getLocatorUrl(locator, opts), {
        configuration: opts.project.configuration
      });
      return await xfs.mktempPromise(async (extractPath) => {
        const extractTarget = new CwdFS(extractPath);
        await tgzUtils_exports.extractArchiveTo(sourceBuffer, extractTarget, {
          stripComponents: 1
        });
        const repoUrlParts = gitUtils_exports.splitRepoUrl(locator.reference);
        const packagePath = ppath.join(extractPath, `package.tgz`);
        await scriptUtils_exports.prepareExternalProject(extractPath, packagePath, {
          configuration: opts.project.configuration,
          report: opts.report,
          workspace: repoUrlParts.extra.workspace
        });
        const packedBuffer = await xfs.readFilePromise(packagePath);
        return await tgzUtils_exports.convertToZip(packedBuffer, {
          compressionLevel: opts.project.configuration.get(`compressionLevel`),
          prefixPath: structUtils_exports.getIdentVendorPath(locator),
          stripComponents: 1
        });
      });
    }
    getLocatorUrl(locator, opts) {
      const {auth, username, reponame, treeish} = parseGithubUrl(locator.reference);
      return `https://${auth ? `${auth}@` : ``}github.com/${username}/${reponame}/archive/${treeish}.tar.gz`;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-github-virtual-63e7e81f62\1\packages\plugin-github\sources\index.ts
  var plugin6 = {
    hooks: {
      async fetchHostedRepository(previous, locator, opts) {
        if (previous !== null)
          return previous;
        const fetcher = new GithubFetcher();
        if (!fetcher.supports(locator, opts))
          return null;
        try {
          return await fetcher.fetch(locator, opts);
        } catch (error) {
          return null;
        }
      }
    }
  };
  var sources_default8 = plugin6;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-http-virtual-efdd0ad8a8\1\packages\plugin-http\sources\index.ts
  var sources_exports12 = {};
  __export(sources_exports12, {
    default: () => sources_default9
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-http-virtual-efdd0ad8a8\1\packages\plugin-http\sources\constants.ts
  var TARBALL_REGEXP2 = /^[^?]*\.(?:tar\.gz|tgz)(?:\?.*)?$/;
  var PROTOCOL_REGEXP = /^https?:/;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-http-virtual-efdd0ad8a8\1\packages\plugin-http\sources\TarballHttpFetcher.ts
  var TarballHttpFetcher = class {
    supports(locator, opts) {
      if (!TARBALL_REGEXP2.test(locator.reference))
        return false;
      if (PROTOCOL_REGEXP.test(locator.reference))
        return true;
      return false;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      const sourceBuffer = await httpUtils_exports.get(locator.reference, {
        configuration: opts.project.configuration
      });
      return await tgzUtils_exports.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-http-virtual-efdd0ad8a8\1\packages\plugin-http\sources\TarballHttpResolver.ts
  var TarballHttpResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!TARBALL_REGEXP2.test(descriptor.range))
        return false;
      if (PROTOCOL_REGEXP.test(descriptor.range))
        return true;
      return false;
    }
    supportsLocator(locator, opts) {
      if (!TARBALL_REGEXP2.test(locator.reference))
        return false;
      if (PROTOCOL_REGEXP.test(locator.reference))
        return true;
      return false;
    }
    shouldPersistResolution(locator, opts) {
      return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      return [structUtils_exports.convertDescriptorToLocator(descriptor)];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
      const manifest = await miscUtils10.releaseAfterUseAsync(async () => {
        return await Manifest.find(packageFetch.prefixPath, {baseFs: packageFetch.packageFs});
      }, packageFetch.releaseFs);
      return {
        ...locator,
        version: manifest.version || `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-http-virtual-efdd0ad8a8\1\packages\plugin-http\sources\index.ts
  var plugin7 = {
    fetchers: [
      TarballHttpFetcher
    ],
    resolvers: [
      TarballHttpResolver
    ]
  };
  var sources_default9 = plugin7;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-init-virtual-bb60ce87e8\1\packages\plugin-init\sources\index.ts
  var sources_exports13 = {};
  __export(sources_exports13, {
    default: () => sources_default10
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-init-virtual-bb60ce87e8\1\packages\plugin-init\sources\commands\init.ts
  var import_merge = __toModule(require_merge4());
  var import_util8 = __toModule(require("util"));
  var InitCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.private = options_exports.Boolean(`-p,--private`, false, {
        description: `Initialize a private package`
      });
      this.workspace = options_exports.Boolean(`-w,--workspace`, false, {
        description: `Initialize a workspace root with a \`packages/\` directory`
      });
      this.install = options_exports.String(`-i,--install`, false, {
        tolerateBoolean: true,
        description: `Initialize a package with a specific bundle that will be locked in the project`
      });
      this.usev2 = options_exports.Boolean(`-2`, false, {hidden: true});
      this.yes = options_exports.Boolean(`-y,--yes`, {hidden: true});
      this.assumeFreshProject = options_exports.Boolean(`--assume-fresh-project`, false, {hidden: true});
    }
    async execute() {
      if (xfs.existsSync(ppath.join(this.context.cwd, Manifest.fileName)))
        throw new UsageError(`A package.json already exists in the specified directory`);
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const install = this.install ? this.install === true ? `latest` : this.install : null;
      if (install !== null) {
        return await this.executeProxy(configuration, install);
      } else {
        return await this.executeRegular(configuration);
      }
    }
    async executeProxy(configuration, version) {
      if (configuration.get(`yarnPath`) !== null)
        throw new UsageError(`Cannot use the --install flag when the current directory already uses yarnPath (from ${configuration.sources.get(`yarnPath`)})`);
      if (configuration.projectCwd !== null)
        throw new UsageError(`Cannot use the --install flag when the current directory is already part of a project`);
      if (!xfs.existsSync(this.context.cwd))
        await xfs.mkdirPromise(this.context.cwd, {recursive: true});
      const lockfilePath = ppath.join(this.context.cwd, configuration.get(`lockfileFilename`));
      if (!xfs.existsSync(lockfilePath))
        await xfs.writeFilePromise(lockfilePath, ``);
      const versionExitCode = await this.cli.run([`set`, `version`, version]);
      if (versionExitCode !== 0)
        return versionExitCode;
      this.context.stdout.write(`
`);
      const args = [`--assume-fresh-project`];
      if (this.private)
        args.push(`-p`);
      if (this.workspace)
        args.push(`-w`);
      if (this.yes)
        args.push(`-y`);
      return await xfs.mktempPromise(async (binFolder) => {
        const {code} = await execUtils_exports.pipevp(`yarn`, [`init`, ...args], {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr,
          env: await scriptUtils_exports.makeScriptEnv({binFolder})
        });
        return code;
      });
    }
    async executeRegular(configuration) {
      let existingProject = null;
      if (!this.assumeFreshProject) {
        try {
          existingProject = await Project.find(configuration, this.context.cwd);
        } catch {
          existingProject = null;
        }
      }
      if (!xfs.existsSync(this.context.cwd))
        await xfs.mkdirPromise(this.context.cwd, {recursive: true});
      const manifest = new Manifest();
      const fields = Object.fromEntries(configuration.get(`initFields`).entries());
      manifest.load(fields);
      manifest.name = structUtils_exports.makeIdent(configuration.get(`initScope`), ppath.basename(this.context.cwd));
      manifest.private = this.private || this.workspace;
      if (this.workspace) {
        await xfs.mkdirPromise(ppath.join(this.context.cwd, `packages`), {recursive: true});
        manifest.workspaceDefinitions = [{
          pattern: `packages/*`
        }];
      }
      const serialized = {};
      manifest.exportTo(serialized);
      import_util8.inspect.styles.name = `cyan`;
      this.context.stdout.write(`${import_util8.inspect(serialized, {
        depth: Infinity,
        colors: true,
        compact: false
      })}
`);
      const manifestPath = ppath.join(this.context.cwd, Manifest.fileName);
      await xfs.changeFilePromise(manifestPath, `${JSON.stringify(serialized, null, 2)}
`);
      const readmePath = ppath.join(this.context.cwd, `README.md`);
      if (!xfs.existsSync(readmePath))
        await xfs.writeFilePromise(readmePath, `# ${structUtils_exports.stringifyIdent(manifest.name)}
`);
      if (!existingProject) {
        const lockfilePath = ppath.join(this.context.cwd, Filename.lockfile);
        await xfs.writeFilePromise(lockfilePath, ``);
        const gitattributesLines = [
          `/.yarn/** linguist-vendored`
        ];
        const gitattributesBody = gitattributesLines.map((line) => {
          return `${line}
`;
        }).join(``);
        const gitattributesPath = ppath.join(this.context.cwd, `.gitattributes`);
        if (!xfs.existsSync(gitattributesPath))
          await xfs.writeFilePromise(gitattributesPath, gitattributesBody);
        const gitignoreLines = [
          `/.yarn/*`,
          `!/.yarn/releases`,
          `!/.yarn/plugins`,
          `!/.yarn/sdks`,
          ``,
          `# Swap the comments on the following lines if you don't wish to use zero-installs`,
          `# Documentation here: https://yarnpkg.com/features/zero-installs`,
          `!/.yarn/cache`,
          `#/.pnp.*`
        ];
        const gitignoreBody = gitignoreLines.map((line) => {
          return `${line}
`;
        }).join(``);
        const gitignorePath = ppath.join(this.context.cwd, `.gitignore`);
        if (!xfs.existsSync(gitignorePath))
          await xfs.writeFilePromise(gitignorePath, gitignoreBody);
        const editorConfigProperties = {
          [`*`]: {
            endOfLine: `lf`,
            insertFinalNewline: true
          },
          [`*.{js,json,yml}`]: {
            charset: `utf-8`,
            indentStyle: `space`,
            indentSize: 2
          }
        };
        import_merge.default(editorConfigProperties, configuration.get(`initEditorConfig`));
        let editorConfigBody = `root = true
`;
        for (const [selector, props] of Object.entries(editorConfigProperties)) {
          editorConfigBody += `
[${selector}]
`;
          for (const [propName, propValue] of Object.entries(props)) {
            const snakeCaseName = propName.replace(/[A-Z]/g, ($0) => `_${$0.toLowerCase()}`);
            editorConfigBody += `${snakeCaseName} = ${propValue}
`;
          }
        }
        const editorConfigPath = ppath.join(this.context.cwd, `.editorconfig`);
        if (!xfs.existsSync(editorConfigPath))
          await xfs.writeFilePromise(editorConfigPath, editorConfigBody);
        await execUtils_exports.execvp(`git`, [`init`], {
          cwd: this.context.cwd
        });
      }
    }
  };
  InitCommand.paths = [
    [`init`]
  ];
  InitCommand.usage = Command.Usage({
    description: `create a new package`,
    details: `
      This command will setup a new package in your local directory.

      If the \`-p,--private\` or \`-w,--workspace\` options are set, the package will be private by default.

      If the \`-w,--workspace\` option is set, the package will be configured to accept a set of workspaces in the \`packages/\` directory.

      If the \`-i,--install\` option is given a value, Yarn will first download it using \`yarn set version\` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be \`latest\`.

      The initial settings of the manifest can be changed by using the \`initScope\` and \`initFields\` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via \`initEditorConfig\`, and will initialize a Git repository in the current directory.
    `,
    examples: [[
      `Create a new package in the local directory`,
      `yarn init`
    ], [
      `Create a new private package in the local directory`,
      `yarn init -p`
    ], [
      `Create a new package and store the Yarn release inside`,
      `yarn init -i=latest`
    ], [
      `Create a new private package and defines it as a workspace root`,
      `yarn init -w`
    ]]
  });
  var init_default = InitCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-init-virtual-bb60ce87e8\1\packages\plugin-init\sources\index.ts
  var plugin8 = {
    configuration: {
      initScope: {
        description: `Scope used when creating packages via the init command`,
        type: SettingsType.STRING,
        default: null
      },
      initFields: {
        description: `Additional fields to set when creating packages via the init command`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.ANY
        }
      },
      initEditorConfig: {
        description: `Extra rules to define in the generator editorconfig`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.ANY
        }
      }
    },
    commands: [
      init_default
    ]
  };
  var sources_default10 = plugin8;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\index.ts
  var sources_exports14 = {};
  __export(sources_exports14, {
    default: () => sources_default11
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\constants.ts
  var LINK_PROTOCOL = `portal:`;
  var RAW_LINK_PROTOCOL = `link:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\LinkFetcher.ts
  var LinkFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(LINK_PROTOCOL))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: LINK_PROTOCOL});
      if (ppath.isAbsolute(path6))
        return path6;
      const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
      if (parentLocalPath === null)
        return null;
      return ppath.resolve(parentLocalPath, path6);
    }
    async fetch(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: LINK_PROTOCOL});
      const parentFetch = ppath.isAbsolute(path6) ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: PortablePath2.dot, localPath: PortablePath2.root} : await opts.fetcher.fetch(parentLocator, opts);
      const effectiveParentFetch = parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
      if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
      const sourceFs = effectiveParentFetch.packageFs;
      const sourcePath = ppath.join(effectiveParentFetch.prefixPath, path6);
      if (parentFetch.localPath) {
        return {packageFs: new CwdFS(sourcePath, {baseFs: sourceFs}), releaseFs: effectiveParentFetch.releaseFs, prefixPath: PortablePath2.dot, localPath: sourcePath};
      } else {
        return {packageFs: new JailFS(sourcePath, {baseFs: sourceFs}), releaseFs: effectiveParentFetch.releaseFs, prefixPath: PortablePath2.dot};
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\LinkResolver.ts
  var LinkResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(LINK_PROTOCOL))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(LINK_PROTOCOL))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const path6 = descriptor.range.slice(LINK_PROTOCOL.length);
      return [structUtils_exports.makeLocator(descriptor, `${LINK_PROTOCOL}${npath.toPortablePath(path6)}`)];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
      const manifest = await miscUtils10.releaseAfterUseAsync(async () => {
        return await Manifest.find(packageFetch.prefixPath, {baseFs: packageFetch.packageFs});
      }, packageFetch.releaseFs);
      return {
        ...locator,
        version: manifest.version || `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.SOFT,
        dependencies: new Map([...manifest.dependencies]),
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\RawLinkFetcher.ts
  var RawLinkFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(RAW_LINK_PROTOCOL))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: RAW_LINK_PROTOCOL});
      if (ppath.isAbsolute(path6))
        return path6;
      const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
      if (parentLocalPath === null)
        return null;
      return ppath.resolve(parentLocalPath, path6);
    }
    async fetch(locator, opts) {
      const {parentLocator, path: path6} = structUtils_exports.parseFileStyleRange(locator.reference, {protocol: RAW_LINK_PROTOCOL});
      const parentFetch = ppath.isAbsolute(path6) ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: PortablePath2.dot, localPath: PortablePath2.root} : await opts.fetcher.fetch(parentLocator, opts);
      const effectiveParentFetch = parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
      if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
      const sourceFs = effectiveParentFetch.packageFs;
      const sourcePath = ppath.join(effectiveParentFetch.prefixPath, path6);
      if (parentFetch.localPath) {
        return {packageFs: new CwdFS(sourcePath, {baseFs: sourceFs}), releaseFs: effectiveParentFetch.releaseFs, prefixPath: PortablePath2.dot, discardFromLookup: true, localPath: sourcePath};
      } else {
        return {packageFs: new JailFS(sourcePath, {baseFs: sourceFs}), releaseFs: effectiveParentFetch.releaseFs, prefixPath: PortablePath2.dot, discardFromLookup: true};
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\RawLinkResolver.ts
  var RawLinkResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(RAW_LINK_PROTOCOL))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(RAW_LINK_PROTOCOL))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const path6 = descriptor.range.slice(RAW_LINK_PROTOCOL.length);
      return [structUtils_exports.makeLocator(descriptor, `${RAW_LINK_PROTOCOL}${npath.toPortablePath(path6)}`)];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      return {
        ...locator,
        version: `0.0.0`,
        languageName: opts.project.configuration.get(`defaultLanguageName`),
        linkType: LinkType.SOFT,
        dependencies: new Map(),
        peerDependencies: new Map(),
        dependenciesMeta: new Map(),
        peerDependenciesMeta: new Map(),
        bin: new Map()
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-link-virtual-71ac88a7be\1\packages\plugin-link\sources\index.ts
  var plugin9 = {
    fetchers: [
      RawLinkFetcher,
      LinkFetcher
    ],
    resolvers: [
      RawLinkResolver,
      LinkResolver
    ]
  };
  var sources_default11 = plugin9;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-6c4ffdc97c\1\packages\plugin-node-modules\sources\index.ts
  var sources_exports16 = {};
  __export(sources_exports16, {
    default: () => sources_default13
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\index.ts
  var import_fs9 = __toModule(require("fs"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\NodeModulesFS.ts
  var import_fs8 = __toModule(require("fs"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\WatchManager.ts
  var import_events2 = __toModule(require("events"));
  var WatchEventEmitter = class extends import_events2.EventEmitter {
    constructor(dirWatchers, watchPath, watcherId) {
      super();
      this.dirWatchers = dirWatchers;
      this.watchPath = watchPath;
      this.watcherId = watcherId;
    }
    close() {
      const dirWatcher = this.dirWatchers.get(this.watchPath);
      dirWatcher.eventEmitters.delete(this.watcherId);
      if (dirWatcher.eventEmitters.size === 0) {
        this.dirWatchers.delete(this.watchPath);
      }
    }
  };
  var WatchManager = class extends import_events2.EventEmitter {
    constructor() {
      super(...arguments);
      this.dirWatchers = new Map();
      this.lastWatcherId = 0;
    }
    registerWatcher(watchPath, dirList, callback) {
      let dirWatcher = this.dirWatchers.get(watchPath);
      if (!dirWatcher) {
        dirWatcher = {eventEmitters: new Map(), dirEntries: dirList};
        this.dirWatchers.set(watchPath, dirWatcher);
      }
      const watcherId = this.lastWatcherId++;
      const watchEventEmitter = new WatchEventEmitter(this.dirWatchers, watchPath, watcherId);
      dirWatcher.eventEmitters.set(watcherId, watchEventEmitter);
      watchEventEmitter.on(`rename`, (filename) => callback(`rename`, filename));
      return watchEventEmitter;
    }
    notifyWatchers(resolvePath) {
      for (const [watchPath, dirWatcher] of this.dirWatchers) {
        const newDirEntries = resolvePath(watchPath).dirList || new Set();
        const dirEntryDiff = new Set();
        for (const entry of newDirEntries) {
          if (!dirWatcher.dirEntries.has(entry)) {
            dirEntryDiff.add(entry);
          }
        }
        for (const entry of dirWatcher.dirEntries) {
          if (!newDirEntries.has(entry)) {
            dirEntryDiff.add(entry);
          }
        }
        for (const entry of dirEntryDiff) {
          for (const watchEventEmitter of dirWatcher.eventEmitters.values()) {
            watchEventEmitter.emit(`rename`, entry);
          }
        }
        dirWatcher.dirEntries = newDirEntries;
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\hoist.ts
  var Hoistable;
  (function(Hoistable2) {
    Hoistable2[Hoistable2["YES"] = 0] = "YES";
    Hoistable2[Hoistable2["NO"] = 1] = "NO";
    Hoistable2[Hoistable2["DEPENDS"] = 2] = "DEPENDS";
  })(Hoistable || (Hoistable = {}));
  var makeLocator3 = (name, reference) => `${name}@${reference}`;
  var makeIdent2 = (name, reference) => {
    const hashIdx = reference.indexOf(`#`);
    const realReference = hashIdx >= 0 ? reference.substring(hashIdx + 1) : reference;
    return makeLocator3(name, realReference);
  };
  var DebugLevel;
  (function(DebugLevel2) {
    DebugLevel2[DebugLevel2["NONE"] = -1] = "NONE";
    DebugLevel2[DebugLevel2["PERF"] = 0] = "PERF";
    DebugLevel2[DebugLevel2["CHECK"] = 1] = "CHECK";
    DebugLevel2[DebugLevel2["REASONS"] = 2] = "REASONS";
    DebugLevel2[DebugLevel2["INTENSIVE_CHECK"] = 9] = "INTENSIVE_CHECK";
  })(DebugLevel || (DebugLevel = {}));
  var hoist = (tree, opts = {}) => {
    const debugLevel = opts.debugLevel || Number(process.env.NM_DEBUG_LEVEL || -1);
    const check = opts.check || debugLevel >= 9;
    const hoistingLimits = opts.hoistingLimits || new Map();
    const options = {check, debugLevel, hoistingLimits};
    if (options.debugLevel >= 0)
      console.time(`hoist`);
    const treeCopy = cloneTree(tree, options);
    hoistTo(treeCopy, [treeCopy], new Set([treeCopy.locator]), options);
    if (options.debugLevel >= 0)
      console.timeEnd(`hoist`);
    if (options.debugLevel >= 1) {
      const checkLog = selfCheck(treeCopy);
      if (checkLog) {
        throw new Error(`${checkLog}, after hoisting finished:
${dumpDepTree(treeCopy)}`);
      }
    }
    if (options.debugLevel >= 2)
      console.log(dumpDepTree(treeCopy));
    return shrinkTree(treeCopy);
  };
  var getHoistedDependencies = (rootNode) => {
    const hoistedDependencies = new Map();
    const seenNodes = new Set();
    const addHoistedDependencies = (node) => {
      if (seenNodes.has(node))
        return;
      seenNodes.add(node);
      for (const dep of node.hoistedDependencies.values())
        if (!rootNode.dependencies.has(dep.name))
          hoistedDependencies.set(dep.name, dep);
      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          addHoistedDependencies(dep);
        }
      }
    };
    addHoistedDependencies(rootNode);
    return hoistedDependencies;
  };
  var decoupleGraphNode = (parent, node) => {
    if (node.decoupled)
      return node;
    const {name, references, ident, locator, dependencies, originalDependencies, hoistedDependencies, peerNames, reasons, isHoistBorder} = node;
    const clone2 = {
      name,
      references: new Set(references),
      ident,
      locator,
      dependencies: new Map(dependencies),
      originalDependencies: new Map(originalDependencies),
      hoistedDependencies: new Map(hoistedDependencies),
      peerNames: new Set(peerNames),
      reasons: new Map(reasons),
      decoupled: true,
      isHoistBorder
    };
    const selfDep = clone2.dependencies.get(name);
    if (selfDep && selfDep.ident == clone2.ident)
      clone2.dependencies.set(name, clone2);
    parent.dependencies.set(clone2.name, clone2);
    return clone2;
  };
  var getHoistIdentMap = (rootNode, preferenceMap) => {
    const identMap = new Map([[rootNode.name, [rootNode.ident]]]);
    for (const dep of rootNode.dependencies.values()) {
      if (!rootNode.peerNames.has(dep.name)) {
        identMap.set(dep.name, [dep.ident]);
      }
    }
    const keyList = Array.from(preferenceMap.keys());
    keyList.sort((key1, key2) => {
      const entry1 = preferenceMap.get(key1);
      const entry2 = preferenceMap.get(key2);
      if (entry2.peerDependents.size !== entry1.peerDependents.size) {
        return entry2.peerDependents.size - entry1.peerDependents.size;
      } else {
        return entry2.dependents.size - entry1.dependents.size;
      }
    });
    for (const key of keyList) {
      const name = key.substring(0, key.indexOf(`@`, 1));
      const ident = key.substring(name.length + 1);
      if (!rootNode.peerNames.has(name)) {
        let idents = identMap.get(name);
        if (!idents) {
          idents = [];
          identMap.set(name, idents);
        }
        if (idents.indexOf(ident) < 0) {
          idents.push(ident);
        }
      }
    }
    return identMap;
  };
  var getSortedRegularDependencies = (node) => {
    const dependencies = new Set();
    const addDep = (dep, seenDeps = new Set()) => {
      if (seenDeps.has(dep))
        return;
      seenDeps.add(dep);
      for (const peerName of dep.peerNames) {
        if (!node.peerNames.has(peerName)) {
          const peerDep = node.dependencies.get(peerName);
          if (peerDep && !dependencies.has(peerDep)) {
            addDep(peerDep, seenDeps);
          }
        }
      }
      dependencies.add(dep);
    };
    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        addDep(dep);
      }
    }
    return dependencies;
  };
  var hoistTo = (tree, rootNodePath, rootNodePathLocators, options, seenNodes = new Set()) => {
    const rootNode = rootNodePath[rootNodePath.length - 1];
    if (seenNodes.has(rootNode))
      return;
    seenNodes.add(rootNode);
    const preferenceMap = buildPreferenceMap(rootNode);
    const hoistIdentMap = getHoistIdentMap(rootNode, preferenceMap);
    const hoistIdents = new Map(Array.from(hoistIdentMap.entries()).map(([k, v]) => [k, v[0]]));
    const hoistedDependencies = rootNode === tree ? new Map() : getHoistedDependencies(rootNode);
    let wasStateChanged;
    do {
      hoistGraph(tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options);
      wasStateChanged = false;
      for (const [name, idents] of hoistIdentMap) {
        if (idents.length > 1 && !rootNode.dependencies.has(name)) {
          hoistIdents.delete(name);
          idents.shift();
          hoistIdents.set(name, idents[0]);
          wasStateChanged = true;
        }
      }
    } while (wasStateChanged);
    for (const dependency of rootNode.dependencies.values()) {
      if (!rootNode.peerNames.has(dependency.name) && !rootNodePathLocators.has(dependency.locator)) {
        rootNodePathLocators.add(dependency.locator);
        hoistTo(tree, [...rootNodePath, dependency], rootNodePathLocators, options);
        rootNodePathLocators.delete(dependency.locator);
      }
    }
  };
  var getNodeHoistInfo = (rootNodePathLocators, nodePath, node, hoistedDependencies, hoistIdents, hoistIdentMap, {outputReason}) => {
    let reasonRoot;
    let reason = null;
    let dependsOn = new Set();
    if (outputReason)
      reasonRoot = `${Array.from(rootNodePathLocators).map((x) => prettyPrintLocator(x)).join(`\u2192`)}`;
    const parentNode = nodePath[nodePath.length - 1];
    const isSelfReference = node.ident === parentNode.ident;
    const hoistedIdent = hoistIdents.get(node.name);
    let isHoistable = hoistedIdent === node.ident && !isSelfReference;
    if (outputReason && !isHoistable && hoistedIdent && !isSelfReference)
      reason = `- filled by: ${prettyPrintLocator(hoistIdentMap.get(node.name)[0])} at ${reasonRoot}`;
    if (isHoistable) {
      let isNameAvailable = false;
      const hoistedDep = hoistedDependencies.get(node.name);
      isNameAvailable = !hoistedDep || hoistedDep.ident === node.ident;
      if (outputReason && !isNameAvailable)
        reason = `- filled by: ${prettyPrintLocator(hoistedDep.locator)} at ${reasonRoot}`;
      if (isNameAvailable) {
        for (let idx = 1; idx < nodePath.length - 1; idx++) {
          const parent = nodePath[idx];
          const parentDep = parent.dependencies.get(node.name);
          if (parentDep && parentDep.ident !== node.ident) {
            isNameAvailable = false;
            if (outputReason)
              reason = `- filled by: ${prettyPrintLocator(parentDep.locator)} at ${prettyPrintLocator(parent.locator)}`;
            break;
          }
        }
      }
      isHoistable = isNameAvailable;
    }
    if (isHoistable) {
      let arePeerDepsSatisfied = true;
      const checkList = new Set(node.peerNames);
      for (let idx = nodePath.length - 1; idx >= 1; idx--) {
        const parent = nodePath[idx];
        for (const name of checkList) {
          if (parent.peerNames.has(name) && parent.originalDependencies.has(name))
            continue;
          const parentDepNode = parent.dependencies.get(name);
          if (parentDepNode) {
            if (idx === nodePath.length - 1) {
              dependsOn.add(parentDepNode);
            } else {
              dependsOn = null;
              arePeerDepsSatisfied = false;
              if (outputReason) {
                reason = `- peer dependency ${prettyPrintLocator(parentDepNode.locator)} from parent ${prettyPrintLocator(parent.locator)} was not hoisted to ${reasonRoot}`;
              }
            }
          }
          checkList.delete(name);
        }
        if (!arePeerDepsSatisfied) {
          break;
        }
      }
      isHoistable = arePeerDepsSatisfied;
    }
    if (dependsOn !== null && dependsOn.size > 0) {
      return {isHoistable: 2, dependsOn, reason};
    } else {
      return {isHoistable: isHoistable ? 0 : 1, reason};
    }
  };
  var hoistGraph = (tree, rootNodePath, rootNodePathLocators, hoistedDependencies, hoistIdents, hoistIdentMap, options) => {
    const rootNode = rootNodePath[rootNodePath.length - 1];
    const seenNodes = new Set();
    const hoistNodeDependencies = (nodePath, locatorPath, parentNode, newNodes2) => {
      if (seenNodes.has(parentNode))
        return;
      const nextLocatorPath = [...locatorPath, parentNode.locator];
      const dependantTree = new Map();
      const hoistInfos = new Map();
      for (const subDependency of getSortedRegularDependencies(parentNode)) {
        let hoistInfo = null;
        if (!hoistInfo)
          hoistInfo = getNodeHoistInfo(rootNodePathLocators, [rootNode, ...nodePath, parentNode], subDependency, hoistedDependencies, hoistIdents, hoistIdentMap, {outputReason: options.debugLevel >= 2});
        hoistInfos.set(subDependency, hoistInfo);
        if (hoistInfo.isHoistable === 2) {
          for (const node of hoistInfo.dependsOn) {
            const nodeDependants = dependantTree.get(node.name) || new Set();
            nodeDependants.add(subDependency.name);
            dependantTree.set(node.name, nodeDependants);
          }
        }
      }
      const unhoistableNodes = new Set();
      const addUnhoistableNode = (node, hoistInfo, reason) => {
        if (!unhoistableNodes.has(node)) {
          unhoistableNodes.add(node);
          if (node.ident !== parentNode.ident)
            hoistInfos.set(node, {isHoistable: 1, reason});
          for (const dependantName of dependantTree.get(node.name) || []) {
            addUnhoistableNode(parentNode.dependencies.get(dependantName), hoistInfo, reason);
          }
        }
      };
      let reasonRoot;
      if (options.debugLevel >= 2)
        reasonRoot = `${Array.from(rootNodePathLocators).map((x) => prettyPrintLocator(x)).join(`\u2192`)}`;
      for (const [node, hoistInfo] of hoistInfos)
        if (hoistInfo.isHoistable === 1)
          addUnhoistableNode(node, hoistInfo, `- peer dependency ${prettyPrintLocator(node.locator)} from parent ${prettyPrintLocator(parentNode.locator)} was not hoisted to ${reasonRoot}`);
      for (const node of hoistInfos.keys()) {
        if (!unhoistableNodes.has(node)) {
          parentNode.dependencies.delete(node.name);
          parentNode.hoistedDependencies.set(node.name, node);
          parentNode.reasons.delete(node.name);
          const hoistedNode = rootNode.dependencies.get(node.name);
          if (!hoistedNode) {
            if (rootNode.ident !== node.ident) {
              rootNode.dependencies.set(node.name, node);
              newNodes2.add(node);
            }
          } else {
            for (const reference of node.references) {
              hoistedNode.references.add(reference);
            }
          }
        }
      }
      if (options.check) {
        const checkLog = selfCheck(tree);
        if (checkLog) {
          throw new Error(`${checkLog}, after hoisting dependencies of ${[rootNode, ...nodePath, parentNode].map((x) => prettyPrintLocator(x.locator)).join(`\u2192`)}:
${dumpDepTree(tree)}`);
        }
      }
      const children = getSortedRegularDependencies(parentNode);
      for (const node of children) {
        if (unhoistableNodes.has(node) && nextLocatorPath.indexOf(node.locator) < 0) {
          const hoistInfo = hoistInfos.get(node);
          if (hoistInfo.isHoistable !== 0)
            parentNode.reasons.set(node.name, hoistInfo.reason);
          if (!node.isHoistBorder) {
            seenNodes.add(parentNode);
            const decoupledNode = decoupleGraphNode(parentNode, node);
            hoistNodeDependencies([...nodePath, parentNode], [...locatorPath, parentNode.locator], decoupledNode, nextNewNodes);
            seenNodes.delete(parentNode);
          }
        }
      }
    };
    let newNodes;
    let nextNewNodes = new Set(getSortedRegularDependencies(rootNode));
    do {
      newNodes = nextNewNodes;
      nextNewNodes = new Set();
      for (const dep of newNodes) {
        if (dep.locator === rootNode.locator || dep.isHoistBorder)
          continue;
        const decoupledDependency = decoupleGraphNode(rootNode, dep);
        hoistNodeDependencies([], Array.from(rootNodePathLocators), decoupledDependency, nextNewNodes);
      }
    } while (nextNewNodes.size > 0);
  };
  var selfCheck = (tree) => {
    const log = [];
    const seenNodes = new Set();
    const parents = new Set();
    const checkNode = (node, parentDeps) => {
      if (seenNodes.has(node))
        return;
      seenNodes.add(node);
      if (parents.has(node))
        return;
      const dependencies = new Map(parentDeps);
      for (const dep of node.dependencies.values())
        if (!node.peerNames.has(dep.name))
          dependencies.set(dep.name, dep);
      for (const origDep of node.originalDependencies.values()) {
        const dep = dependencies.get(origDep.name);
        const prettyPrintTreePath = () => `${Array.from(parents).concat([node]).map((x) => prettyPrintLocator(x.locator)).join(`\u2192`)}`;
        if (node.peerNames.has(origDep.name)) {
          const parentDep = parentDeps.get(origDep.name);
          if (parentDep !== dep || !parentDep || parentDep.ident !== origDep.ident) {
            log.push(`${prettyPrintTreePath()} - broken peer promise: expected ${origDep.ident} but found ${parentDep ? parentDep.ident : parentDep}`);
          }
        } else {
          if (!dep) {
            log.push(`${prettyPrintTreePath()} - broken require promise: no required dependency ${origDep.locator} found`);
          } else if (dep.ident !== origDep.ident) {
            log.push(`${prettyPrintTreePath()} - broken require promise for ${origDep.name}: expected ${origDep.ident}, but found: ${dep.ident}`);
          }
        }
      }
      parents.add(node);
      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          checkNode(dep, dependencies);
        }
      }
      parents.delete(node);
    };
    checkNode(tree, tree.dependencies);
    return log.join(`
`);
  };
  var cloneTree = (tree, options) => {
    const {identName, name, reference, peerNames} = tree;
    const treeCopy = {
      name,
      references: new Set([reference]),
      locator: makeLocator3(identName, reference),
      ident: makeIdent2(identName, reference),
      dependencies: new Map(),
      originalDependencies: new Map(),
      hoistedDependencies: new Map(),
      peerNames: new Set(peerNames),
      reasons: new Map(),
      decoupled: true,
      isHoistBorder: true
    };
    const seenNodes = new Map([[tree, treeCopy]]);
    const addNode = (node, parentNode) => {
      let workNode = seenNodes.get(node);
      const isSeen = !!workNode;
      if (!workNode) {
        const {name: name2, identName: identName2, reference: reference2, peerNames: peerNames2} = node;
        const dependenciesNmHoistingLimits = options.hoistingLimits.get(parentNode.locator);
        workNode = {
          name: name2,
          references: new Set([reference2]),
          locator: makeLocator3(identName2, reference2),
          ident: makeIdent2(identName2, reference2),
          dependencies: new Map(),
          originalDependencies: new Map(),
          hoistedDependencies: new Map(),
          peerNames: new Set(peerNames2),
          reasons: new Map(),
          decoupled: true,
          isHoistBorder: dependenciesNmHoistingLimits ? dependenciesNmHoistingLimits.has(name2) : false
        };
        seenNodes.set(node, workNode);
      }
      parentNode.dependencies.set(node.name, workNode);
      parentNode.originalDependencies.set(node.name, workNode);
      if (!isSeen) {
        for (const dep of node.dependencies) {
          addNode(dep, workNode);
        }
      } else {
        const seenCoupledNodes = new Set();
        const markNodeCoupled = (node2) => {
          if (seenCoupledNodes.has(node2))
            return;
          seenCoupledNodes.add(node2);
          node2.decoupled = false;
          for (const dep of node2.dependencies.values()) {
            if (!node2.peerNames.has(dep.name)) {
              markNodeCoupled(dep);
            }
          }
        };
        markNodeCoupled(workNode);
      }
    };
    for (const dep of tree.dependencies)
      addNode(dep, treeCopy);
    return treeCopy;
  };
  var getIdentName = (locator) => locator.substring(0, locator.indexOf(`@`, 1));
  var shrinkTree = (tree) => {
    const treeCopy = {
      name: tree.name,
      identName: getIdentName(tree.locator),
      references: new Set(tree.references),
      dependencies: new Set()
    };
    const seenNodes = new Set([tree]);
    const addNode = (node, parentWorkNode, parentNode) => {
      const isSeen = seenNodes.has(node);
      let resultNode;
      if (parentWorkNode === node) {
        resultNode = parentNode;
      } else {
        const {name, references, locator} = node;
        resultNode = {
          name,
          identName: getIdentName(locator),
          references,
          dependencies: new Set()
        };
      }
      parentNode.dependencies.add(resultNode);
      if (!isSeen) {
        seenNodes.add(node);
        for (const dep of node.dependencies.values()) {
          if (!node.peerNames.has(dep.name)) {
            addNode(dep, node, resultNode);
          }
        }
        seenNodes.delete(node);
      }
    };
    for (const dep of tree.dependencies.values())
      addNode(dep, tree, treeCopy);
    return treeCopy;
  };
  var buildPreferenceMap = (rootNode) => {
    const preferenceMap = new Map();
    const seenNodes = new Set([rootNode]);
    const getPreferenceKey = (node) => `${node.name}@${node.ident}`;
    const getOrCreatePreferenceEntry = (node) => {
      const key = getPreferenceKey(node);
      let entry = preferenceMap.get(key);
      if (!entry) {
        entry = {dependents: new Set(), peerDependents: new Set()};
        preferenceMap.set(key, entry);
      }
      return entry;
    };
    const addDependent = (dependent, node) => {
      const isSeen = !!seenNodes.has(node);
      const entry = getOrCreatePreferenceEntry(node);
      entry.dependents.add(dependent.ident);
      if (!isSeen) {
        seenNodes.add(node);
        for (const dep of node.dependencies.values()) {
          if (node.peerNames.has(dep.name)) {
            const entry2 = getOrCreatePreferenceEntry(dep);
            entry2.peerDependents.add(node.ident);
          } else {
            addDependent(node, dep);
          }
        }
      }
    };
    for (const dep of rootNode.dependencies.values())
      if (!rootNode.peerNames.has(dep.name))
        addDependent(rootNode, dep);
    return preferenceMap;
  };
  var prettyPrintLocator = (locator) => {
    const idx = locator.indexOf(`@`, 1);
    const name = locator.substring(0, idx);
    const reference = locator.substring(idx + 1);
    if (reference === `workspace:.`) {
      return `.`;
    } else if (!reference) {
      return `${name}`;
    } else {
      const version = (reference.indexOf(`#`) > 0 ? reference.split(`#`)[1] : reference).replace(`npm:`, ``);
      if (reference.startsWith(`virtual`)) {
        return `v:${name}@${version}`;
      } else {
        return `${name}@${version}`;
      }
    }
  };
  var MAX_NODES_TO_DUMP = 5e4;
  var dumpDepTree = (tree) => {
    let nodeCount = 0;
    const dumpPackage = (pkg, parents, prefix = ``) => {
      if (nodeCount > MAX_NODES_TO_DUMP || parents.has(pkg))
        return ``;
      nodeCount++;
      const dependencies = Array.from(pkg.dependencies.values());
      let str = ``;
      parents.add(pkg);
      for (let idx = 0; idx < dependencies.length; idx++) {
        const dep = dependencies[idx];
        if (!pkg.peerNames.has(dep.name)) {
          const reason = pkg.reasons.get(dep.name);
          const identName = getIdentName(dep.locator);
          str += `${prefix}${idx < dependencies.length - 1 ? `\u251C\u2500` : `\u2514\u2500`}${(parents.has(dep) ? `>` : ``) + (identName !== dep.name ? `a:${dep.name}:` : ``) + prettyPrintLocator(dep.locator) + (reason ? ` ${reason}` : ``)}
`;
          str += dumpPackage(dep, parents, `${prefix}${idx < dependencies.length - 1 ? `\u2502 ` : `  `}`);
        }
      }
      parents.delete(pkg);
      return str;
    };
    const treeDump = dumpPackage(tree, new Set());
    return treeDump + (nodeCount > MAX_NODES_TO_DUMP ? `
Tree is too large, part of the tree has been dunped
` : ``);
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\buildNodeModulesTree.ts
  var LinkType2;
  (function(LinkType4) {
    LinkType4["HARD"] = `HARD`;
    LinkType4["SOFT"] = `SOFT`;
  })(LinkType2 || (LinkType2 = {}));
  var NodeModulesHoistingLimits;
  (function(NodeModulesHoistingLimits2) {
    NodeModulesHoistingLimits2["WORKSPACES"] = `workspaces`;
    NodeModulesHoistingLimits2["DEPENDENCIES"] = `dependencies`;
    NodeModulesHoistingLimits2["NONE"] = `none`;
  })(NodeModulesHoistingLimits || (NodeModulesHoistingLimits = {}));
  var NODE_MODULES = `node_modules`;
  var WORKSPACE_NAME_SUFFIX = `$wsroot$`;
  var buildNodeModulesTree = (pnp2, options) => {
    const {packageTree, hoistingLimits} = buildPackageTree(pnp2, options);
    const hoistedTree = hoist(packageTree, {hoistingLimits});
    return populateNodeModulesTree(pnp2, hoistedTree, options);
  };
  var stringifyLocator2 = (locator) => `${locator.name}@${locator.reference}`;
  var buildLocatorMap = (nodeModulesTree) => {
    const map = new Map();
    for (const [location, val] of nodeModulesTree.entries()) {
      if (!val.dirList) {
        let entry = map.get(val.locator);
        if (!entry) {
          entry = {target: val.target, linkType: val.linkType, locations: [], aliases: val.aliases};
          map.set(val.locator, entry);
        }
        entry.locations.push(location);
      }
    }
    for (const val of map.values()) {
      val.locations = val.locations.sort((loc1, loc2) => {
        const len1 = loc1.split(ppath.delimiter).length;
        const len2 = loc2.split(ppath.delimiter).length;
        return len1 !== len2 ? len2 - len1 : loc2.localeCompare(loc1);
      });
    }
    return map;
  };
  function isPortalLocator(locatorKey) {
    let descriptor = structUtils_exports.parseDescriptor(locatorKey);
    if (structUtils_exports.isVirtualDescriptor(descriptor))
      descriptor = structUtils_exports.devirtualizeDescriptor(descriptor);
    return descriptor.range.startsWith(`portal:`);
  }
  var buildPackageTree = (pnp2, options) => {
    const pnpRoots = pnp2.getDependencyTreeRoots();
    const hoistingLimits = new Map();
    const workspaceDependenciesMap = new Map();
    const topPkg = pnp2.getPackageInformation(pnp2.topLevel);
    if (topPkg === null)
      throw new Error(`Assertion failed: Expected the top-level package to have been registered`);
    const topLocator = pnp2.findPackageLocator(topPkg.packageLocation);
    if (topLocator === null)
      throw new Error(`Assertion failed: Expected the top-level package to have a physical locator`);
    const topPkgPortableLocation = npath.toPortablePath(topPkg.packageLocation);
    const topLocatorKey = stringifyLocator2(topLocator);
    if (options.project) {
      const workspaceTree = {children: new Map()};
      const cwdSegments = options.project.cwd.split(ppath.sep);
      for (const [cwd, workspace] of options.project.workspacesByCwd) {
        const segments = cwd.split(ppath.sep).slice(cwdSegments.length);
        let node = workspaceTree;
        for (const segment of segments) {
          let nextNode = node.children.get(segment);
          if (!nextNode) {
            nextNode = {children: new Map()};
            node.children.set(segment, nextNode);
          }
          node = nextNode;
        }
        node.workspaceLocator = {name: structUtils_exports.stringifyIdent(workspace.anchoredLocator), reference: workspace.anchoredLocator.reference};
      }
      const addWorkspace = (node, parentWorkspaceLocator) => {
        if (node.workspaceLocator) {
          const parentLocatorKey = stringifyLocator2(parentWorkspaceLocator);
          let dependencies = workspaceDependenciesMap.get(parentLocatorKey);
          if (!dependencies) {
            dependencies = new Set();
            workspaceDependenciesMap.set(parentLocatorKey, dependencies);
          }
          dependencies.add(node.workspaceLocator);
        }
        for (const child of node.children.values()) {
          addWorkspace(child, node.workspaceLocator || parentWorkspaceLocator);
        }
      };
      for (const child of workspaceTree.children.values()) {
        addWorkspace(child, workspaceTree.workspaceLocator);
      }
    } else {
      for (const locator of pnpRoots) {
        if (locator.name !== topLocator.name || locator.reference !== topLocator.reference) {
          let dependencies = workspaceDependenciesMap.get(topLocatorKey);
          if (!dependencies) {
            dependencies = new Set();
            workspaceDependenciesMap.set(topLocatorKey, dependencies);
          }
          dependencies.add(locator);
        }
      }
    }
    const packageTree = {
      name: topLocator.name,
      identName: topLocator.name,
      reference: topLocator.reference,
      peerNames: topPkg.packagePeers,
      dependencies: new Set()
    };
    const nodes = new Map();
    const getNodeKey = (name, locator) => `${stringifyLocator2(locator)}:${name}`;
    const addPackageToTree = (name, pkg, locator, parent, parentDependencies, parentRelativeCwd, isHoistBorder) => {
      var _a2, _b;
      const nodeKey = getNodeKey(name, locator);
      let node = nodes.get(nodeKey);
      const isSeen = !!node;
      if (!isSeen && locator.name === topLocator.name && locator.reference === topLocator.reference) {
        node = packageTree;
        nodes.set(nodeKey, packageTree);
      }
      if (!node) {
        node = {
          name,
          identName: locator.name,
          reference: locator.reference,
          dependencies: new Set(),
          peerNames: pkg.packagePeers
        };
        nodes.set(nodeKey, node);
      }
      if (isHoistBorder) {
        const parentLocatorKey = stringifyLocator2({name: parent.identName, reference: parent.reference});
        const dependencyBorders = hoistingLimits.get(parentLocatorKey) || new Set();
        hoistingLimits.set(parentLocatorKey, dependencyBorders);
        dependencyBorders.add(node.name);
      }
      const allDependencies = new Map(pkg.packageDependencies);
      if (options.project) {
        const workspace = options.project.workspacesByCwd.get(npath.toPortablePath(pkg.packageLocation.slice(0, -1)));
        if (workspace) {
          const peerCandidates = new Set([
            ...Array.from(workspace.manifest.peerDependencies.values(), (x) => structUtils_exports.stringifyIdent(x)),
            ...Array.from(workspace.manifest.peerDependenciesMeta.keys())
          ]);
          for (const peerName of peerCandidates) {
            if (!allDependencies.has(peerName)) {
              allDependencies.set(peerName, parentDependencies.get(peerName) || null);
              node.peerNames.add(peerName);
            }
          }
        }
      }
      const locatorKey = stringifyLocator2(locator);
      const workspaceDependencies = workspaceDependenciesMap.get(locatorKey);
      if (workspaceDependencies) {
        for (const workspaceLocator of workspaceDependencies) {
          allDependencies.set(`${workspaceLocator.name}${WORKSPACE_NAME_SUFFIX}`, workspaceLocator.reference);
        }
      }
      parent.dependencies.add(node);
      const shouldAddChildrenDependencies = options.pnpifyFs || !isPortalLocator(nodeKey);
      if (!isSeen && shouldAddChildrenDependencies) {
        for (const [depName, referencish] of allDependencies) {
          if (referencish !== null) {
            const depLocator = pnp2.getLocator(depName, referencish);
            const pkgLocator = pnp2.getLocator(depName.replace(WORKSPACE_NAME_SUFFIX, ``), referencish);
            const depPkg = pnp2.getPackageInformation(pkgLocator);
            if (depPkg === null)
              throw new Error(`Assertion failed: Expected the package to have been registered`);
            const parentHoistingLimits = (_a2 = options.hoistingLimitsByCwd) == null ? void 0 : _a2.get(parentRelativeCwd);
            const relativeDepCwd = ppath.relative(topPkgPortableLocation, npath.toPortablePath(depPkg.packageLocation)) || PortablePath2.dot;
            const depHoistingLimits = (_b = options.hoistingLimitsByCwd) == null ? void 0 : _b.get(relativeDepCwd);
            const isHoistBorder2 = parentHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES || depHoistingLimits === NodeModulesHoistingLimits.WORKSPACES;
            addPackageToTree(depName, depPkg, depLocator, node, allDependencies, relativeDepCwd, isHoistBorder2);
          }
        }
      }
    };
    addPackageToTree(topLocator.name, topPkg, topLocator, packageTree, topPkg.packageDependencies, PortablePath2.dot, false);
    return {packageTree, hoistingLimits};
  };
  function getTargetLocatorPath(locator, pnp2, options) {
    const pkgLocator = pnp2.getLocator(locator.name.replace(WORKSPACE_NAME_SUFFIX, ``), locator.reference);
    const info = pnp2.getPackageInformation(pkgLocator);
    if (info === null)
      throw new Error(`Assertion failed: Expected the package to be registered`);
    let linkType;
    let target;
    if (options.pnpifyFs) {
      target = npath.toPortablePath(info.packageLocation);
      linkType = LinkType2.SOFT;
    } else {
      const truePath = pnp2.resolveVirtual && locator.reference && locator.reference.startsWith(`virtual:`) ? pnp2.resolveVirtual(info.packageLocation) : info.packageLocation;
      target = npath.toPortablePath(truePath || info.packageLocation);
      linkType = info.linkType;
    }
    return {linkType, target};
  }
  var populateNodeModulesTree = (pnp2, hoistedTree, options) => {
    const tree = new Map();
    const makeLeafNode = (locator, aliases) => {
      const {linkType, target} = getTargetLocatorPath(locator, pnp2, options);
      return {
        locator: stringifyLocator2(locator),
        target,
        linkType,
        aliases
      };
    };
    const getPackageName = (identName) => {
      const [nameOrScope, name] = identName.split(`/`);
      return name ? {
        scope: toFilename(nameOrScope),
        name: toFilename(name)
      } : {
        scope: null,
        name: toFilename(nameOrScope)
      };
    };
    const seenNodes = new Set();
    const buildTree = (pkg, locationPrefix) => {
      if (seenNodes.has(pkg))
        return;
      seenNodes.add(pkg);
      for (const dep of pkg.dependencies) {
        if (dep === pkg || dep.identName === pkg.identName.replace(WORKSPACE_NAME_SUFFIX, ``))
          continue;
        const references = Array.from(dep.references).sort();
        const locator = {name: dep.identName, reference: references[0]};
        const {name, scope} = getPackageName(dep.name);
        const packageNameParts = scope ? [scope, name] : [name];
        const nodeModulesDirPath = ppath.join(locationPrefix, NODE_MODULES);
        const nodeModulesLocation = ppath.join(nodeModulesDirPath, ...packageNameParts);
        const leafNode = makeLeafNode(locator, references.slice(1));
        if (!dep.name.endsWith(WORKSPACE_NAME_SUFFIX)) {
          const prevNode = tree.get(nodeModulesLocation);
          if (prevNode) {
            if (prevNode.dirList) {
              throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge dir node with leaf node`);
            } else {
              const locator1 = structUtils_exports.parseLocator(prevNode.locator);
              const locator2 = structUtils_exports.parseLocator(leafNode.locator);
              if (prevNode.linkType !== leafNode.linkType)
                throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different link types`);
              else if (locator1.identHash !== locator2.identHash)
                throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different idents ${structUtils_exports.stringifyLocator(locator1)} and ${structUtils_exports.stringifyLocator(locator2)}`);
              leafNode.aliases = [...leafNode.aliases, ...prevNode.aliases, structUtils_exports.parseLocator(prevNode.locator).reference];
            }
          }
          tree.set(nodeModulesLocation, leafNode);
          const segments = nodeModulesLocation.split(`/`);
          const nodeModulesIdx = segments.indexOf(NODE_MODULES);
          let segCount = segments.length - 1;
          while (nodeModulesIdx >= 0 && segCount > nodeModulesIdx) {
            const dirPath = npath.toPortablePath(segments.slice(0, segCount).join(ppath.sep));
            const targetDir = toFilename(segments[segCount]);
            const subdirs = tree.get(dirPath);
            if (!subdirs) {
              tree.set(dirPath, {dirList: new Set([targetDir])});
            } else if (subdirs.dirList) {
              if (subdirs.dirList.has(targetDir)) {
                break;
              } else {
                subdirs.dirList.add(targetDir);
              }
            }
            segCount--;
          }
        }
        buildTree(dep, leafNode.linkType === LinkType2.SOFT ? leafNode.target : nodeModulesLocation);
      }
    };
    const rootNode = makeLeafNode({name: hoistedTree.name, reference: Array.from(hoistedTree.references)[0]}, []);
    const rootPath = rootNode.target;
    tree.set(rootPath, rootNode);
    buildTree(hoistedTree, rootPath);
    return tree;
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\NodeModulesFS.ts
  var import_dynamicRequire = __toModule(require_dynamicRequire());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\resolveNodeModulesPath.ts
  var NODE_MODULES2 = `node_modules`;
  var resolveNodeModulesPath = (inputPath, nodeModulesTree) => {
    const result = {resolvedPath: inputPath};
    const segments = inputPath.split(ppath.sep);
    const firstIdx = segments.indexOf(NODE_MODULES2);
    if (firstIdx < 0)
      return result;
    let lastIdx = segments.lastIndexOf(NODE_MODULES2);
    if (typeof segments[lastIdx + 1] !== `undefined`)
      lastIdx++;
    if (segments[lastIdx][0] === `@` && typeof segments[lastIdx + 1] !== `undefined`)
      lastIdx++;
    let locationCandidate = npath.toPortablePath(segments.slice(0, firstIdx).join(ppath.sep));
    let node, lastNode, lastNodeLocation;
    let curIdx = firstIdx;
    let request2 = PortablePath2.dot;
    while (curIdx <= lastIdx) {
      const curSegment = toFilename(segments[curIdx]);
      locationCandidate = ppath.join(locationCandidate, curSegment);
      node = nodeModulesTree.get(locationCandidate);
      if (node) {
        if (node.linkType === LinkType2.SOFT)
          locationCandidate = node.target;
        lastNode = node;
        request2 = PortablePath2.dot;
        lastNodeLocation = node.dirList ? locationCandidate : node.target;
      } else {
        request2 = ppath.join(request2, curSegment);
      }
      curIdx++;
    }
    request2 = ppath.join(request2, ...segments.slice(lastIdx + 1).map((x) => toFilename(x)));
    if (lastNode) {
      if (!lastNode.dirList || request2 !== PortablePath2.dot) {
        result.resolvedPath = ppath.join(lastNodeLocation, request2);
        result.isSymlink = lastNode && lastNode.linkType === LinkType2.SOFT && request2 === PortablePath2.dot;
      } else if (request2 === PortablePath2.dot) {
        result.dirList = lastNode.dirList;
        result.forwardedDirPath = npath.toPortablePath(segments.slice(0, firstIdx).join(ppath.sep));
        if (result.forwardedDirPath.endsWith(`.zip`)) {
          result.forwardedDirPath = ppath.dirname(result.forwardedDirPath);
        }
      }
    }
    return result;
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\NodeModulesFS.ts
  var NodeModulesFS = class extends ProxiedFS {
    constructor(pnp2, {realFs = import_fs8.default, pnpifyFs = true} = {}) {
      super(npath);
      this.baseFs = new PortableNodeModulesFS(pnp2, {baseFs: new NodeFS(realFs), pnpifyFs});
    }
    mapFromBase(path6) {
      return npath.fromPortablePath(path6);
    }
    mapToBase(path6) {
      return npath.toPortablePath(path6);
    }
  };
  var WRITE_FLAGS_REGEX = /[+wa]/;
  var PortableNodeModulesFS = class extends FakeFS {
    constructor(pnp2, {baseFs = new NodeFS(), pnpifyFs = true} = {}) {
      super(ppath);
      if (!pnp2.getDependencyTreeRoots)
        throw new Error(`NodeModulesFS supports PnP API versions 3+, please upgrade your PnP API provider`);
      this.options = {baseFs, pnpifyFs};
      this.baseFs = baseFs;
      this.nodeModulesTree = buildNodeModulesTree(pnp2, this.options);
      this.watchManager = new WatchManager();
      const pnpRootPath = npath.toPortablePath(pnp2.getPackageInformation(pnp2.topLevel).packageLocation);
      this.pnpFilePath = ppath.join(pnpRootPath, Filename.pnpCjs);
      this.watchPnpFile(pnpRootPath);
    }
    watchPnpFile(pnpRootPath) {
      this.baseFs.watch(pnpRootPath, {persistent: false}, (_, filename) => {
        if (filename === Filename.pnpCjs) {
          const pnp2 = import_dynamicRequire.dynamicRequireNoCache(this.pnpFilePath);
          this.nodeModulesTree = buildNodeModulesTree(pnp2, this.options);
          this.watchManager.notifyWatchers((nodePath) => resolveNodeModulesPath(nodePath, this.nodeModulesTree));
        }
      });
    }
    persistPath(dir) {
      const pathStack = [];
      let curPath = dir;
      while (!this.baseFs.existsSync(curPath)) {
        pathStack.push(curPath);
        curPath = ppath.dirname(curPath);
      }
      for (const fullPath of pathStack.reverse()) {
        this.baseFs.mkdirSync(fullPath);
      }
    }
    persistVirtualParentFolder(p) {
      if (typeof p !== `number`) {
        const parentPath = this.resolvePath(ppath.dirname(p));
        if (parentPath.dirList) {
          this.persistPath(parentPath.resolvedPath);
        }
      }
    }
    getExtractHint(hints) {
      return this.baseFs.getExtractHint(hints);
    }
    resolve(path6) {
      return this.baseFs.resolve(this.resolvePath(path6).resolvedPath);
    }
    getBaseFs() {
      return this.baseFs;
    }
    resolvePath(p) {
      if (typeof p === `number`) {
        return {resolvedPath: p, fullOriginalPath: p};
      } else {
        const fullOriginalPath = this.pathUtils.resolve(p);
        return {...resolveNodeModulesPath(fullOriginalPath, this.nodeModulesTree), fullOriginalPath};
      }
    }
    resolveFilePath(p) {
      if (typeof p === `number`)
        return p;
      const pnpPath = this.resolvePath(p);
      return pnpPath.resolvedPath;
    }
    resolveDirOrFilePath(p) {
      if (typeof p === `number`)
        return p;
      const pnpPath = this.resolvePath(p);
      return pnpPath.forwardedDirPath || pnpPath.resolvedPath;
    }
    resolveLink(opts) {
      const {p, onSymlink, onRealPath, statOptions} = opts;
      const pnpPath = this.resolvePath(p);
      if (pnpPath.isSymlink) {
        let stat;
        try {
          stat = this.baseFs.lstatSync(pnpPath.resolvedPath, statOptions);
        } catch (e) {
        }
        if (stat) {
          return onSymlink(stat, this.pathUtils.relative(this.pathUtils.dirname(pnpPath.fullOriginalPath), pnpPath.resolvedPath));
        }
      }
      return onRealPath(pnpPath.forwardedDirPath || pnpPath.resolvedPath);
    }
    static makeSymlinkStats(stats) {
      return Object.assign(stats, {
        isFile: () => false,
        isDirectory: () => false,
        isSymbolicLink: () => true
      });
    }
    getRealPath() {
      return this.baseFs.getRealPath();
    }
    async openPromise(p, flags, mode) {
      if (WRITE_FLAGS_REGEX.test(flags))
        this.persistVirtualParentFolder(p);
      return await this.baseFs.openPromise(this.resolveFilePath(p), flags, mode);
    }
    openSync(p, flags, mode) {
      if (WRITE_FLAGS_REGEX.test(flags))
        this.persistVirtualParentFolder(p);
      return this.baseFs.openSync(this.resolveFilePath(p), flags, mode);
    }
    async opendirPromise(p, opts) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList || this.resolvePath(ppath.join(p, `node_modules`)).dirList) {
        let fsDirList = [];
        try {
          fsDirList = await this.baseFs.readdirPromise(pnpPath.resolvedPath);
        } catch (e) {
        }
        const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
        return opendir(this, p, entries);
      } else {
        return await this.baseFs.opendirPromise(pnpPath.resolvedPath, opts);
      }
    }
    opendirSync(p, opts) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList || this.resolvePath(ppath.join(p, `node_modules`)).dirList) {
        let fsDirList = [];
        try {
          fsDirList = this.baseFs.readdirSync(pnpPath.resolvedPath);
        } catch (e) {
        }
        const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
        return opendir(this, p, entries);
      } else {
        return this.baseFs.opendirSync(pnpPath.resolvedPath, opts);
      }
    }
    async readPromise(fd, buffer, offset, length, position) {
      return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    }
    readSync(fd, buffer, offset, length, position) {
      return this.baseFs.readSync(fd, buffer, offset, length, position);
    }
    async writePromise(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }
    writeSync(fd, buffer, offset, length, position) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }
    async closePromise(fd) {
      await this.baseFs.closePromise(fd);
    }
    closeSync(fd) {
      this.baseFs.closeSync(fd);
    }
    createReadStream(p, opts) {
      return this.baseFs.createReadStream(p !== null ? this.resolveFilePath(p) : p, opts);
    }
    createWriteStream(p, opts) {
      return this.baseFs.createWriteStream(p !== null ? this.resolveDirOrFilePath(p) : p, opts);
    }
    async realpathPromise(p) {
      const pnpPath = this.resolvePath(p);
      return pnpPath.dirList ? pnpPath.resolvedPath : this.baseFs.realpathPromise(pnpPath.resolvedPath);
    }
    realpathSync(p) {
      const pnpPath = this.resolvePath(p);
      return pnpPath.dirList ? pnpPath.resolvedPath : this.baseFs.realpathSync(pnpPath.resolvedPath);
    }
    async existsPromise(p) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList) {
        return true;
      } else {
        return await this.baseFs.existsPromise(pnpPath.resolvedPath);
      }
    }
    existsSync(p) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList) {
        return true;
      } else {
        return this.baseFs.existsSync(pnpPath.resolvedPath);
      }
    }
    async accessPromise(p, mode) {
      return await this.baseFs.accessPromise(this.resolveDirOrFilePath(p), mode);
    }
    accessSync(p, mode) {
      return this.baseFs.accessSync(this.resolveDirOrFilePath(p), mode);
    }
    async statPromise(p, opts) {
      return await this.baseFs.statPromise(this.resolveDirOrFilePath(p), opts);
    }
    statSync(p, opts) {
      return this.baseFs.statSync(this.resolveDirOrFilePath(p), opts);
    }
    async fstatPromise(fd, opts) {
      return await this.baseFs.fstatPromise(fd, opts);
    }
    fstatSync(fd, opts) {
      return this.baseFs.fstatSync(fd, opts);
    }
    async lstatPromise(p, opts) {
      return this.resolveLink({
        p,
        op: `lstat`,
        onSymlink: (stats) => PortableNodeModulesFS.makeSymlinkStats(stats),
        onRealPath: async (resolvedPath) => await this.baseFs.lstatPromise(resolvedPath, opts),
        statOptions: opts
      });
    }
    lstatSync(p, opts) {
      return this.resolveLink({
        p,
        op: `lstat`,
        onSymlink: (stats) => PortableNodeModulesFS.makeSymlinkStats(stats),
        onRealPath: (resolvedPath) => this.baseFs.lstatSync(resolvedPath, opts),
        statOptions: opts
      });
    }
    async chmodPromise(p, mask) {
      return await this.baseFs.chmodPromise(this.resolveDirOrFilePath(p), mask);
    }
    chmodSync(p, mask) {
      return this.baseFs.chmodSync(this.resolveDirOrFilePath(p), mask);
    }
    async chownPromise(p, uid, gid) {
      return await this.baseFs.chownPromise(this.resolveDirOrFilePath(p), uid, gid);
    }
    chownSync(p, uid, gid) {
      return this.baseFs.chownSync(this.resolveDirOrFilePath(p), uid, gid);
    }
    async renamePromise(oldP, newP) {
      return await this.baseFs.renamePromise(this.resolveDirOrFilePath(oldP), this.resolveDirOrFilePath(newP));
    }
    renameSync(oldP, newP) {
      return this.baseFs.renameSync(this.resolveDirOrFilePath(oldP), this.resolveDirOrFilePath(newP));
    }
    async copyFilePromise(sourceP, destP, flags) {
      return await this.baseFs.copyFilePromise(this.resolveFilePath(sourceP), this.resolveDirOrFilePath(destP), flags);
    }
    copyFileSync(sourceP, destP, flags) {
      return this.baseFs.copyFileSync(this.resolveFilePath(sourceP), this.resolveDirOrFilePath(destP), flags);
    }
    async appendFilePromise(p, content, opts) {
      return await this.baseFs.appendFilePromise(this.resolveDirOrFilePath(p), content, opts);
    }
    appendFileSync(p, content, opts) {
      return this.baseFs.appendFileSync(this.resolveDirOrFilePath(p), content, opts);
    }
    async writeFilePromise(p, content, opts) {
      return await this.baseFs.writeFilePromise(this.resolveDirOrFilePath(p), content, opts);
    }
    writeFileSync(p, content, opts) {
      return this.baseFs.writeFileSync(this.resolveDirOrFilePath(p), content, opts);
    }
    async unlinkPromise(p) {
      return await this.baseFs.unlinkPromise(this.resolveDirOrFilePath(p));
    }
    unlinkSync(p) {
      return this.baseFs.unlinkSync(this.resolveDirOrFilePath(p));
    }
    async utimesPromise(p, atime, mtime) {
      return await this.baseFs.utimesPromise(this.resolveDirOrFilePath(p), atime, mtime);
    }
    utimesSync(p, atime, mtime) {
      return this.baseFs.utimesSync(this.resolveDirOrFilePath(p), atime, mtime);
    }
    async mkdirPromise(p, opts) {
      const pnpPath = this.resolvePath(p);
      this.persistVirtualParentFolder(p);
      return this.baseFs.mkdirPromise(pnpPath.resolvedPath, opts);
    }
    mkdirSync(p, opts) {
      const pnpPath = this.resolvePath(p);
      this.persistVirtualParentFolder(p);
      return this.baseFs.mkdirSync(pnpPath.resolvedPath, opts);
    }
    async rmdirPromise(p, opts) {
      return await this.baseFs.rmdirPromise(this.resolveDirOrFilePath(p), opts);
    }
    rmdirSync(p, opts) {
      return this.baseFs.rmdirSync(this.resolveDirOrFilePath(p), opts);
    }
    async linkPromise(existingP, newP) {
      return await this.baseFs.linkPromise(this.resolveDirOrFilePath(existingP), this.resolveDirOrFilePath(newP));
    }
    linkSync(existingP, newP) {
      return this.baseFs.linkSync(this.resolveDirOrFilePath(existingP), this.resolveDirOrFilePath(newP));
    }
    async symlinkPromise(target, p) {
      return await this.baseFs.symlinkPromise(this.resolveDirOrFilePath(target), this.resolveDirOrFilePath(p));
    }
    symlinkSync(target, p) {
      return this.baseFs.symlinkSync(this.resolveDirOrFilePath(target), this.resolveDirOrFilePath(p));
    }
    async readFilePromise(p, encoding) {
      switch (encoding) {
        case `utf8`:
          return await this.baseFs.readFilePromise(this.resolveFilePath(p), encoding);
        default:
          return await this.baseFs.readFilePromise(this.resolveFilePath(p), encoding);
      }
    }
    readFileSync(p, encoding) {
      switch (encoding) {
        case `utf8`:
          return this.baseFs.readFileSync(this.resolveFilePath(p), encoding);
        default:
          return this.baseFs.readFileSync(this.resolveFilePath(p), encoding);
      }
    }
    async readdirPromise(p, {withFileTypes} = {}) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList || this.resolvePath(ppath.join(p, `node_modules`)).dirList) {
        let fsDirList = [];
        try {
          fsDirList = await this.baseFs.readdirPromise(pnpPath.resolvedPath);
        } catch (e) {
        }
        const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
        if (!withFileTypes)
          return entries;
        return entries.map((name) => {
          return Object.assign(this.lstatSync(ppath.join(p, name)), {
            name
          });
        });
      } else {
        return await this.baseFs.readdirPromise(pnpPath.resolvedPath, {withFileTypes});
      }
    }
    readdirSync(p, {withFileTypes} = {}) {
      const pnpPath = this.resolvePath(p);
      if (pnpPath.dirList || this.resolvePath(ppath.join(p, `node_modules`)).dirList) {
        let fsDirList = [];
        try {
          fsDirList = this.baseFs.readdirSync(pnpPath.resolvedPath);
        } catch (e) {
        }
        const entries = Array.from(pnpPath.dirList || [`node_modules`]).concat(fsDirList).sort();
        if (!withFileTypes)
          return entries;
        return entries.map((name) => {
          return Object.assign(this.lstatSync(ppath.join(p, name)), {
            name
          });
        });
      } else {
        return this.baseFs.readdirSync(pnpPath.resolvedPath, {withFileTypes});
      }
    }
    async readlinkPromise(p) {
      return this.resolveLink({
        p,
        op: `readlink`,
        onSymlink: (_stats, targetPath) => targetPath,
        onRealPath: async (targetPath) => await this.baseFs.readlinkPromise(this.resolveDirOrFilePath(targetPath))
      });
    }
    readlinkSync(p) {
      return this.resolveLink({
        p,
        op: `readlink`,
        onSymlink: (_stats, targetPath) => targetPath,
        onRealPath: (targetPath) => this.baseFs.readlinkSync(this.resolveDirOrFilePath(targetPath))
      });
    }
    async truncatePromise(p, len) {
      return await this.baseFs.truncatePromise(this.resolveDirOrFilePath(p), len);
    }
    truncateSync(p, len) {
      return this.baseFs.truncateSync(this.resolveDirOrFilePath(p), len);
    }
    watch(p, a, b) {
      const pnpPath = this.resolvePath(p);
      const watchPath = pnpPath.resolvedPath;
      if (watchPath && pnpPath.dirList) {
        const callback = typeof a === `function` ? a : typeof b === `function` ? b : () => {
        };
        return this.watchManager.registerWatcher(watchPath, pnpPath.dirList, callback);
      } else {
        return this.baseFs.watch(this.resolveDirOrFilePath(p), a, b);
      }
    }
    watchFile(p, a, b) {
      return this.baseFs.watchFile(this.resolveDirOrFilePath(p), a, b);
    }
    unwatchFile(p, cb) {
      return this.baseFs.unwatchFile(this.resolveDirOrFilePath(p), cb);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-pnpify-virtual-d6646f3271\1\packages\yarnpkg-pnpify\sources\index.ts
  var import_dynamicRequire2 = __toModule(require_dynamicRequire());
  var fsPatched = false;
  var pnp;
  try {
    pnp = import_dynamicRequire2.dynamicRequire(`pnpapi`);
  } catch (e) {
  }
  var patchFs2 = () => {
    if (pnp && !fsPatched) {
      const realFs = {...import_fs9.default};
      const nodeModulesFS = new NodeModulesFS(pnp, {realFs});
      patchFs(import_fs9.default, nodeModulesFS);
      fsPatched = true;
    }
  };
  if (!process.mainModule)
    patchFs2();

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\index.ts
  var sources_exports15 = {};
  __export(sources_exports15, {
    PnpInstaller: () => PnpInstaller,
    PnpLinker: () => PnpLinker,
    default: () => sources_default12,
    getPnpPath: () => getPnpPath,
    jsInstallUtils: () => jsInstallUtils_exports,
    pnpUtils: () => pnpUtils_exports,
    quotePathIfNeeded: () => quotePathIfNeeded
  });
  var import_semver14 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\types.ts
  var LinkType3;
  (function(LinkType4) {
    LinkType4["HARD"] = `HARD`;
    LinkType4["SOFT"] = `SOFT`;
  })(LinkType3 || (LinkType3 = {}));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\generatePrettyJson.ts
  var PrettyJsonState;
  (function(PrettyJsonState2) {
    PrettyJsonState2["DEFAULT"] = `DEFAULT`;
    PrettyJsonState2["TOP_LEVEL"] = `TOP_LEVEL`;
    PrettyJsonState2["FALLBACK_EXCLUSION_LIST"] = `FALLBACK_EXCLUSION_LIST`;
    PrettyJsonState2["FALLBACK_EXCLUSION_ENTRIES"] = `FALLBACK_EXCLUSION_ENTRIES`;
    PrettyJsonState2["FALLBACK_EXCLUSION_DATA"] = `FALLBACK_EXCLUSION_DATA`;
    PrettyJsonState2["PACKAGE_REGISTRY_DATA"] = `PACKAGE_REGISTRY_DATA`;
    PrettyJsonState2["PACKAGE_REGISTRY_ENTRIES"] = `PACKAGE_REGISTRY_ENTRIES`;
    PrettyJsonState2["PACKAGE_STORE_DATA"] = `PACKAGE_STORE_DATA`;
    PrettyJsonState2["PACKAGE_STORE_ENTRIES"] = `PACKAGE_STORE_ENTRIES`;
    PrettyJsonState2["PACKAGE_INFORMATION_DATA"] = `PACKAGE_INFORMATION_DATA`;
    PrettyJsonState2["PACKAGE_DEPENDENCIES"] = `PACKAGE_DEPENDENCIES`;
    PrettyJsonState2["PACKAGE_DEPENDENCY"] = `PACKAGE_DEPENDENCY`;
  })(PrettyJsonState || (PrettyJsonState = {}));
  var prettyJsonMachine = {
    [PrettyJsonState.DEFAULT]: {
      collapsed: false,
      next: {
        [`*`]: PrettyJsonState.DEFAULT
      }
    },
    [PrettyJsonState.TOP_LEVEL]: {
      collapsed: false,
      next: {
        [`fallbackExclusionList`]: PrettyJsonState.FALLBACK_EXCLUSION_LIST,
        [`packageRegistryData`]: PrettyJsonState.PACKAGE_REGISTRY_DATA,
        [`*`]: PrettyJsonState.DEFAULT
      }
    },
    [PrettyJsonState.FALLBACK_EXCLUSION_LIST]: {
      collapsed: false,
      next: {
        [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES
      }
    },
    [PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES]: {
      collapsed: true,
      next: {
        [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_DATA
      }
    },
    [PrettyJsonState.FALLBACK_EXCLUSION_DATA]: {
      collapsed: true,
      next: {
        [`*`]: PrettyJsonState.DEFAULT
      }
    },
    [PrettyJsonState.PACKAGE_REGISTRY_DATA]: {
      collapsed: false,
      next: {
        [`*`]: PrettyJsonState.PACKAGE_REGISTRY_ENTRIES
      }
    },
    [PrettyJsonState.PACKAGE_REGISTRY_ENTRIES]: {
      collapsed: true,
      next: {
        [`*`]: PrettyJsonState.PACKAGE_STORE_DATA
      }
    },
    [PrettyJsonState.PACKAGE_STORE_DATA]: {
      collapsed: false,
      next: {
        [`*`]: PrettyJsonState.PACKAGE_STORE_ENTRIES
      }
    },
    [PrettyJsonState.PACKAGE_STORE_ENTRIES]: {
      collapsed: true,
      next: {
        [`*`]: PrettyJsonState.PACKAGE_INFORMATION_DATA
      }
    },
    [PrettyJsonState.PACKAGE_INFORMATION_DATA]: {
      collapsed: false,
      next: {
        [`packageDependencies`]: PrettyJsonState.PACKAGE_DEPENDENCIES,
        [`*`]: PrettyJsonState.DEFAULT
      }
    },
    [PrettyJsonState.PACKAGE_DEPENDENCIES]: {
      collapsed: false,
      next: {
        [`*`]: PrettyJsonState.PACKAGE_DEPENDENCY
      }
    },
    [PrettyJsonState.PACKAGE_DEPENDENCY]: {
      collapsed: true,
      next: {
        [`*`]: PrettyJsonState.DEFAULT
      }
    }
  };
  function generateCollapsedArray(data, state, indent) {
    let result = ``;
    result += `[`;
    for (let t7 = 0, T = data.length; t7 < T; ++t7) {
      result += generateNext(String(t7), data[t7], state, indent).replace(/^ +/g, ``);
      if (t7 + 1 < T) {
        result += `, `;
      }
    }
    result += `]`;
    return result;
  }
  function generateExpandedArray(data, state, indent) {
    const nextIndent = `${indent}  `;
    let result = ``;
    result += indent;
    result += `[
`;
    for (let t7 = 0, T = data.length; t7 < T; ++t7) {
      result += nextIndent + generateNext(String(t7), data[t7], state, nextIndent).replace(/^ +/, ``);
      if (t7 + 1 < T)
        result += `,`;
      result += `
`;
    }
    result += indent;
    result += `]`;
    return result;
  }
  function generateCollapsedObject(data, state, indent) {
    const keys = Object.keys(data);
    let result = ``;
    result += `{`;
    for (let t7 = 0, T = keys.length; t7 < T; ++t7) {
      const key = keys[t7];
      const value = data[key];
      if (typeof value === `undefined`)
        continue;
      result += JSON.stringify(key);
      result += `: `;
      result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
      if (t7 + 1 < T) {
        result += `, `;
      }
    }
    result += `}`;
    return result;
  }
  function generateExpandedObject(data, state, indent) {
    const keys = Object.keys(data);
    const nextIndent = `${indent}  `;
    let result = ``;
    result += indent;
    result += `{
`;
    for (let t7 = 0, T = keys.length; t7 < T; ++t7) {
      const key = keys[t7];
      const value = data[key];
      if (typeof value === `undefined`)
        continue;
      result += nextIndent;
      result += JSON.stringify(key);
      result += `: `;
      result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
      if (t7 + 1 < T)
        result += `,`;
      result += `
`;
    }
    result += indent;
    result += `}`;
    return result;
  }
  function generateNext(key, data, state, indent) {
    const {next} = prettyJsonMachine[state];
    const nextState = next[key] || next[`*`];
    return generate(data, nextState, indent);
  }
  function generate(data, state, indent) {
    const {collapsed} = prettyJsonMachine[state];
    if (Array.isArray(data)) {
      if (collapsed) {
        return generateCollapsedArray(data, state, indent);
      } else {
        return generateExpandedArray(data, state, indent);
      }
    }
    if (typeof data === `object` && data !== null) {
      if (collapsed) {
        return generateCollapsedObject(data, state, indent);
      } else {
        return generateExpandedObject(data, state, indent);
      }
    }
    return JSON.stringify(data);
  }
  function generatePrettyJson(data) {
    return generate(data, PrettyJsonState.TOP_LEVEL, ``);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\generateSerializedState.ts
  function sortMap6(values, mappers) {
    const asArray = Array.from(values);
    if (!Array.isArray(mappers))
      mappers = [mappers];
    const stringified = [];
    for (const mapper of mappers)
      stringified.push(asArray.map((value) => mapper(value)));
    const indices = asArray.map((_, index) => index);
    indices.sort((a, b) => {
      for (const layer of stringified) {
        const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
        if (comparison !== 0) {
          return comparison;
        }
      }
      return 0;
    });
    return indices.map((index) => {
      return asArray[index];
    });
  }
  function generateFallbackExclusionList(settings) {
    const fallbackExclusionList = new Map();
    const sortedData = sortMap6(settings.fallbackExclusionList || [], [
      ({name, reference}) => name,
      ({name, reference}) => reference
    ]);
    for (const {name, reference} of sortedData) {
      let references = fallbackExclusionList.get(name);
      if (typeof references === `undefined`)
        fallbackExclusionList.set(name, references = new Set());
      references.add(reference);
    }
    return Array.from(fallbackExclusionList).map(([name, references]) => {
      return [name, Array.from(references)];
    });
  }
  function generateFallbackPoolData(settings) {
    return sortMap6(settings.fallbackPool || [], ([name]) => name);
  }
  function generatePackageRegistryData(settings) {
    const packageRegistryData = [];
    for (const [packageName, packageStore] of sortMap6(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
      const packageStoreData = [];
      packageRegistryData.push([packageName, packageStoreData]);
      for (const [packageReference, {packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup}] of sortMap6(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
        const normalizedDependencies = [];
        if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
          normalizedDependencies.push([packageName, packageReference]);
        for (const [dependencyName, dependencyReference] of sortMap6(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
          normalizedDependencies.push([dependencyName, dependencyReference]);
        const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
        const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
        packageStoreData.push([packageReference, {
          packageLocation,
          packageDependencies: normalizedDependencies,
          packagePeers: normalizedPeers,
          linkType,
          discardFromLookup: normalizedDiscardFromLookup
        }]);
      }
    }
    return packageRegistryData;
  }
  function generateLocationBlacklistData(settings) {
    return sortMap6(settings.blacklistedLocations || [], (location) => location);
  }
  function generateSerializedState(settings) {
    return {
      __info: [
        `This file is automatically generated. Do not touch it, or risk`,
        `your modifications being lost. We also recommend you not to read`,
        `it either without using the @yarnpkg/pnp package, as the data layout`,
        `is entirely unspecified and WILL change from a version to another.`
      ],
      dependencyTreeRoots: settings.dependencyTreeRoots,
      enableTopLevelFallback: settings.enableTopLevelFallback || false,
      ignorePatternData: settings.ignorePattern || null,
      fallbackExclusionList: generateFallbackExclusionList(settings),
      fallbackPool: generateFallbackPoolData(settings),
      locationBlacklistData: generateLocationBlacklistData(settings),
      packageRegistryData: generatePackageRegistryData(settings)
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\generatePnpScript.ts
  var import_hook = __toModule(require_hook());
  function generateLoader(shebang, loader) {
    return [
      shebang ? `${shebang}
` : ``,
      `/* eslint-disable */

`,
      `try {
`,
      `  Object.freeze({}).detectStrictMode = true;
`,
      `} catch (error) {
`,
      `  throw new Error(\`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.\`);
`,
      `}
`,
      `
`,
      `var __non_webpack_module__ = module;
`,
      `
`,
      `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
      loader.replace(/^/gm, `  `),
      `}
`,
      `
`,
      import_hook.default()
    ].join(``);
  }
  function generateJsonString(data) {
    return JSON.stringify(data, null, 2);
  }
  function generateInlinedSetup(data) {
    return [
      `return hydrateRuntimeState(${generatePrettyJson(data)}, {basePath: basePath || __dirname});
`
    ].join(``);
  }
  function generateSplitSetup(dataLocation) {
    return [
      `var path = require('path');
`,
      `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});
`,
      `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});
`
    ].join(``);
  }
  function generateInlinedScript(settings) {
    const data = generateSerializedState(settings);
    const setup = generateInlinedSetup(data);
    const loaderFile = generateLoader(settings.shebang, setup);
    return loaderFile;
  }
  function generateSplitScript(settings) {
    const data = generateSerializedState(settings);
    const setup = generateSplitSetup(settings.dataLocation);
    const loaderFile = generateLoader(settings.shebang, setup);
    return {dataFile: generateJsonString(data), loaderFile};
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\hydratePnpApi.ts
  var import_fs10 = __toModule(require("fs"));
  var import_path17 = __toModule(require("path"));
  var import_util9 = __toModule(require("util"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\loader\hydrateRuntimeState.ts
  function hydrateRuntimeState(data, {basePath}) {
    const portablePath = npath.toPortablePath(basePath);
    const absolutePortablePath = ppath.resolve(portablePath);
    const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
    const packageLocatorsByLocations = new Map();
    const packageLocationLengths = new Set();
    const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
      return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
        if (packageName === null !== (packageReference === null))
          throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
        if (!packageInformationData.discardFromLookup) {
          const packageLocator = {name: packageName, reference: packageReference};
          packageLocatorsByLocations.set(packageInformationData.packageLocation, packageLocator);
          packageLocationLengths.add(packageInformationData.packageLocation.length);
        }
        let resolvedPackageLocation = null;
        return [packageReference, {
          packageDependencies: new Map(packageInformationData.packageDependencies),
          packagePeers: new Set(packageInformationData.packagePeers),
          linkType: packageInformationData.linkType,
          discardFromLookup: packageInformationData.discardFromLookup || false,
          get packageLocation() {
            return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
          }
        }];
      }))];
    }));
    for (const location of data.locationBlacklistData)
      packageLocatorsByLocations.set(location, null);
    const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
      return [packageName, new Set(packageReferences)];
    }));
    const fallbackPool = new Map(data.fallbackPool);
    const dependencyTreeRoots = data.dependencyTreeRoots;
    const enableTopLevelFallback = data.enableTopLevelFallback;
    return {
      basePath: portablePath,
      dependencyTreeRoots,
      enableTopLevelFallback,
      fallbackExclusionList,
      fallbackPool,
      ignorePattern,
      packageLocationLengths: [...packageLocationLengths].sort((a, b) => b - a),
      packageLocatorsByLocations,
      packageRegistry
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\loader\makeApi.ts
  var import_module2 = __toModule(require("module"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\loader\internalTools.ts
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["API_ERROR"] = `API_ERROR`;
    ErrorCode2["BLACKLISTED"] = `BLACKLISTED`;
    ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
    ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
    ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
    ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
    ErrorCode2["INTERNAL"] = `INTERNAL`;
    ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
    ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  })(ErrorCode || (ErrorCode = {}));
  var MODULE_NOT_FOUND_ERRORS = new Set([
    ErrorCode.BLACKLISTED,
    ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
    ErrorCode.MISSING_DEPENDENCY,
    ErrorCode.MISSING_PEER_DEPENDENCY,
    ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
    ErrorCode.UNDECLARED_DEPENDENCY
  ]);
  function makeError3(pnpCode, message, data = {}) {
    const code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
    const propertySpec = {
      configurable: true,
      writable: true,
      enumerable: false
    };
    return Object.defineProperties(new Error(message), {
      code: {
        ...propertySpec,
        value: code
      },
      pnpCode: {
        ...propertySpec,
        value: pnpCode
      },
      data: {
        ...propertySpec,
        value: data
      }
    });
  }
  function getPathForDisplay(p) {
    return npath.normalize(npath.fromPortablePath(p));
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\loader\makeApi.ts
  function makeApi(runtimeState, opts) {
    const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
    const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
    const builtinModules2 = new Set(import_module2.Module.builtinModules || Object.keys(process.binding(`natives`)));
    const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
    const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
    const isDirRegExp = /\/$/;
    const topLevelLocator = {name: null, reference: null};
    const fallbackLocators = [];
    const emittedWarnings = new Set();
    if (runtimeState.enableTopLevelFallback === true)
      fallbackLocators.push(topLevelLocator);
    if (opts.compatibilityMode !== false) {
      for (const name of [`react-scripts`, `gatsby`]) {
        const packageStore = runtimeState.packageRegistry.get(name);
        if (packageStore) {
          for (const reference of packageStore.keys()) {
            if (reference === null) {
              throw new Error(`Assertion failed: This reference shouldn't be null`);
            } else {
              fallbackLocators.push({name, reference});
            }
          }
        }
      }
    }
    const {
      ignorePattern,
      packageRegistry,
      packageLocatorsByLocations,
      packageLocationLengths
    } = runtimeState;
    function makeLogEntry(name, args) {
      return {
        fn: name,
        args,
        error: null,
        result: null
      };
    }
    function maybeLog(name, fn) {
      if (opts.allowDebug === false)
        return fn;
      if (Number.isFinite(debugLevel)) {
        if (debugLevel >= 2) {
          return (...args) => {
            const logEntry = makeLogEntry(name, args);
            try {
              return logEntry.result = fn(...args);
            } catch (error) {
              throw logEntry.error = error;
            } finally {
              console.trace(logEntry);
            }
          };
        } else if (debugLevel >= 1) {
          return (...args) => {
            try {
              return fn(...args);
            } catch (error) {
              const logEntry = makeLogEntry(name, args);
              logEntry.error = error;
              console.trace(logEntry);
              throw error;
            }
          };
        }
      }
      return fn;
    }
    function getPackageInformationSafe(packageLocator) {
      const packageInformation = getPackageInformation(packageLocator);
      if (!packageInformation) {
        throw makeError3(ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
      }
      return packageInformation;
    }
    function isDependencyTreeRoot(packageLocator) {
      if (packageLocator.name === null)
        return true;
      for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
        if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
          return true;
      return false;
    }
    function applyNodeExtensionResolution(unqualifiedPath, candidates, {extensions}) {
      let stat;
      try {
        candidates.push(unqualifiedPath);
        stat = opts.fakeFs.statSync(unqualifiedPath);
      } catch (error) {
      }
      if (stat && !stat.isDirectory())
        return opts.fakeFs.realpathSync(unqualifiedPath);
      if (stat && stat.isDirectory()) {
        let pkgJson;
        try {
          pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, `package.json`), `utf8`));
        } catch (error) {
        }
        let nextUnqualifiedPath;
        if (pkgJson && pkgJson.main)
          nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
        if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
          const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {extensions});
          if (resolution !== null) {
            return resolution;
          }
        }
      }
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = `${unqualifiedPath}${extensions[i]}`;
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
      if (stat && stat.isDirectory()) {
        for (let i = 0, length = extensions.length; i < length; i++) {
          const candidateFile = ppath.format({dir: unqualifiedPath, name: `index`, ext: extensions[i]});
          candidates.push(candidateFile);
          if (opts.fakeFs.existsSync(candidateFile)) {
            return candidateFile;
          }
        }
      }
      return null;
    }
    function makeFakeModule(path6) {
      const fakeModule = new import_module2.Module(path6, null);
      fakeModule.filename = path6;
      fakeModule.paths = import_module2.Module._nodeModulePaths(path6);
      return fakeModule;
    }
    function callNativeResolution(request2, issuer) {
      if (issuer.endsWith(`/`))
        issuer = ppath.join(issuer, `internal.js`);
      return import_module2.Module._resolveFilename(npath.fromPortablePath(request2), makeFakeModule(npath.fromPortablePath(issuer)), false, {plugnplay: false});
    }
    function isPathIgnored(path6) {
      if (ignorePattern === null)
        return false;
      const subPath = ppath.contains(runtimeState.basePath, path6);
      if (subPath === null)
        return false;
      if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
        return true;
      } else {
        return false;
      }
    }
    const VERSIONS = {std: 3, resolveVirtual: 1, getAllLocators: 1};
    const topLevel = topLevelLocator;
    function getPackageInformation({name, reference}) {
      const packageInformationStore = packageRegistry.get(name);
      if (!packageInformationStore)
        return null;
      const packageInformation = packageInformationStore.get(reference);
      if (!packageInformation)
        return null;
      return packageInformation;
    }
    function findPackageDependents({name, reference}) {
      const dependents = [];
      for (const [dependentName, packageInformationStore] of packageRegistry) {
        if (dependentName === null)
          continue;
        for (const [dependentReference, packageInformation] of packageInformationStore) {
          if (dependentReference === null)
            continue;
          const dependencyReference = packageInformation.packageDependencies.get(name);
          if (dependencyReference !== reference)
            continue;
          if (dependentName === name && dependentReference === reference)
            continue;
          dependents.push({
            name: dependentName,
            reference: dependentReference
          });
        }
      }
      return dependents;
    }
    function findBrokenPeerDependencies(dependency, initialPackage) {
      const brokenPackages = new Map();
      const alreadyVisited = new Set();
      const traversal = (currentPackage) => {
        const identifier = JSON.stringify(currentPackage.name);
        if (alreadyVisited.has(identifier))
          return;
        alreadyVisited.add(identifier);
        const dependents = findPackageDependents(currentPackage);
        for (const dependent of dependents) {
          const dependentInformation = getPackageInformationSafe(dependent);
          if (dependentInformation.packagePeers.has(dependency)) {
            traversal(dependent);
          } else {
            let brokenSet = brokenPackages.get(dependent.name);
            if (typeof brokenSet === `undefined`)
              brokenPackages.set(dependent.name, brokenSet = new Set());
            brokenSet.add(dependent.reference);
          }
        }
      };
      traversal(initialPackage);
      const brokenList = [];
      for (const name of [...brokenPackages.keys()].sort())
        for (const reference of [...brokenPackages.get(name)].sort())
          brokenList.push({name, reference});
      return brokenList;
    }
    function findPackageLocator(location) {
      if (isPathIgnored(location))
        return null;
      let relativeLocation = ppath.relative(runtimeState.basePath, location);
      if (!relativeLocation.match(isStrictRegExp))
        relativeLocation = `./${relativeLocation}`;
      if (!relativeLocation.endsWith(`/`))
        relativeLocation = `${relativeLocation}/`;
      let from = 0;
      while (from < packageLocationLengths.length && packageLocationLengths[from] > relativeLocation.length)
        from += 1;
      for (let t7 = from; t7 < packageLocationLengths.length; ++t7) {
        const locator = packageLocatorsByLocations.get(relativeLocation.substr(0, packageLocationLengths[t7]));
        if (typeof locator === `undefined`)
          continue;
        if (locator === null) {
          const locationForDisplay = getPathForDisplay(location);
          throw makeError3(ErrorCode.BLACKLISTED, `A forbidden path has been used in the package resolution process - this is usually caused by one of your tools calling 'fs.realpath' on the return value of 'require.resolve'. Since we need to use symlinks to simultaneously provide valid filesystem paths and disambiguate peer dependencies, they must be passed untransformed to 'require'.

Forbidden path: ${locationForDisplay}`, {location: locationForDisplay});
        }
        return locator;
      }
      return null;
    }
    function resolveToUnqualified(request2, issuer, {considerBuiltins = true} = {}) {
      if (request2 === `pnpapi`)
        return npath.toPortablePath(opts.pnpapiResolution);
      if (considerBuiltins && builtinModules2.has(request2))
        return null;
      const requestForDisplay = getPathForDisplay(request2);
      const issuerForDisplay = issuer && getPathForDisplay(issuer);
      if (issuer && isPathIgnored(issuer)) {
        if (!ppath.isAbsolute(request2) || findPackageLocator(request2) === null) {
          const result = callNativeResolution(request2, issuer);
          if (result === false) {
            throw makeError3(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay});
          }
          return npath.toPortablePath(result);
        }
      }
      let unqualifiedPath;
      const dependencyNameMatch = request2.match(pathRegExp);
      if (!dependencyNameMatch) {
        if (ppath.isAbsolute(request2)) {
          unqualifiedPath = ppath.normalize(request2);
        } else {
          if (!issuer) {
            throw makeError3(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {request: requestForDisplay, issuer: issuerForDisplay});
          }
          const absoluteIssuer = ppath.resolve(issuer);
          if (issuer.match(isDirRegExp)) {
            unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request2));
          } else {
            unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request2));
          }
        }
        findPackageLocator(unqualifiedPath);
      } else {
        if (!issuer) {
          throw makeError3(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {request: requestForDisplay, issuer: issuerForDisplay});
        }
        const [, dependencyName, subPath] = dependencyNameMatch;
        const issuerLocator = findPackageLocator(issuer);
        if (!issuerLocator) {
          const result = callNativeResolution(request2, issuer);
          if (result === false) {
            throw makeError3(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay});
          }
          return npath.toPortablePath(result);
        }
        const issuerInformation = getPackageInformationSafe(issuerLocator);
        let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
        let fallbackReference = null;
        if (dependencyReference == null) {
          if (issuerLocator.name !== null) {
            const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
            const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
            if (canUseFallbacks) {
              for (let t7 = 0, T = fallbackLocators.length; t7 < T; ++t7) {
                const fallbackInformation = getPackageInformationSafe(fallbackLocators[t7]);
                const reference = fallbackInformation.packageDependencies.get(dependencyName);
                if (reference == null)
                  continue;
                if (alwaysWarnOnFallback)
                  fallbackReference = reference;
                else
                  dependencyReference = reference;
                break;
              }
              if (runtimeState.enableTopLevelFallback) {
                if (dependencyReference == null && fallbackReference === null) {
                  const reference = runtimeState.fallbackPool.get(dependencyName);
                  if (reference != null) {
                    fallbackReference = reference;
                  }
                }
              }
            }
          }
        }
        let error = null;
        if (dependencyReference === null) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError3(ErrorCode.MISSING_PEER_DEPENDENCY, `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
          } else {
            const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
            if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
              error = makeError3(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors});
            } else {
              error = makeError3(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors});
            }
          }
        } else if (dependencyReference === void 0) {
          if (!considerBuiltins && builtinModules2.has(request2)) {
            if (isDependencyTreeRoot(issuerLocator)) {
              error = makeError3(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
            } else {
              error = makeError3(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName});
            }
          } else {
            if (isDependencyTreeRoot(issuerLocator)) {
              error = makeError3(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
            } else {
              error = makeError3(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName} (via "${requestForDisplay}")
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName});
            }
          }
        }
        if (dependencyReference == null) {
          if (fallbackReference === null || error === null)
            throw error || new Error(`Assertion failed: Expected an error to have been set`);
          dependencyReference = fallbackReference;
          const message = error.message.replace(/\n.*/g, ``);
          error.message = message;
          if (!emittedWarnings.has(message) && debugLevel !== 0) {
            emittedWarnings.add(message);
            process.emitWarning(error);
          }
        }
        const dependencyLocator = Array.isArray(dependencyReference) ? {name: dependencyReference[0], reference: dependencyReference[1]} : {name: dependencyName, reference: dependencyReference};
        const dependencyInformation = getPackageInformationSafe(dependencyLocator);
        if (!dependencyInformation.packageLocation) {
          throw makeError3(ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference} (via "${requestForDisplay}")
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator)});
        }
        const dependencyLocation = dependencyInformation.packageLocation;
        if (subPath) {
          unqualifiedPath = ppath.join(dependencyLocation, subPath);
        } else {
          unqualifiedPath = dependencyLocation;
        }
      }
      return ppath.normalize(unqualifiedPath);
    }
    function resolveUnqualified(unqualifiedPath, {extensions = Object.keys(import_module2.Module._extensions)} = {}) {
      const candidates = [];
      const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {extensions});
      if (qualifiedPath) {
        return ppath.normalize(qualifiedPath);
      } else {
        const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
        throw makeError3(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Qualified path resolution failed - none of the candidates can be found on the disk.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Rejected candidate: ${getPathForDisplay(candidate)}
`).join(``)}`, {unqualifiedPath: unqualifiedPathForDisplay});
      }
    }
    function resolveRequest(request2, issuer, {considerBuiltins, extensions} = {}) {
      const unqualifiedPath = resolveToUnqualified(request2, issuer, {considerBuiltins});
      if (unqualifiedPath === null)
        return null;
      try {
        return resolveUnqualified(unqualifiedPath, {extensions});
      } catch (resolutionError) {
        if (resolutionError.pnpCode === `QUALIFIED_PATH_RESOLUTION_FAILED`)
          Object.assign(resolutionError.data, {request: getPathForDisplay(request2), issuer: issuer && getPathForDisplay(issuer)});
        throw resolutionError;
      }
    }
    function resolveVirtual(request2) {
      const normalized = ppath.normalize(request2);
      const resolved = VirtualFS.resolveVirtual(normalized);
      return resolved !== normalized ? resolved : null;
    }
    return {
      VERSIONS,
      topLevel,
      getLocator: (name, referencish) => {
        if (Array.isArray(referencish)) {
          return {name: referencish[0], reference: referencish[1]};
        } else {
          return {name, reference: referencish};
        }
      },
      getDependencyTreeRoots: () => {
        return [...runtimeState.dependencyTreeRoots];
      },
      getAllLocators() {
        const locators = [];
        for (const [name, entry] of packageRegistry)
          for (const reference of entry.keys())
            if (name !== null && reference !== null)
              locators.push({name, reference});
        return locators;
      },
      getPackageInformation: (locator) => {
        const info = getPackageInformation(locator);
        if (info === null)
          return null;
        const packageLocation = npath.fromPortablePath(info.packageLocation);
        const nativeInfo = {...info, packageLocation};
        return nativeInfo;
      },
      findPackageLocator: (path6) => {
        return findPackageLocator(npath.toPortablePath(path6));
      },
      resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request2, issuer, opts2) => {
        const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
        const resolution = resolveToUnqualified(npath.toPortablePath(request2), portableIssuer, opts2);
        if (resolution === null)
          return null;
        return npath.fromPortablePath(resolution);
      }),
      resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
        return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
      }),
      resolveRequest: maybeLog(`resolveRequest`, (request2, issuer, opts2) => {
        const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
        const resolution = resolveRequest(npath.toPortablePath(request2), portableIssuer, opts2);
        if (resolution === null)
          return null;
        return npath.fromPortablePath(resolution);
      }),
      resolveVirtual: maybeLog(`resolveVirtual`, (path6) => {
        const result = resolveVirtual(npath.toPortablePath(path6));
        if (result !== null) {
          return npath.fromPortablePath(result);
        } else {
          return null;
        }
      })
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\hydratePnpApi.ts
  var readFileP = import_util9.promisify(import_fs10.readFile);

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-pnp\sources\makeRuntimeApi.ts
  var makeRuntimeApi = (settings, basePath, fakeFs) => {
    const data = generateSerializedState(settings);
    const state = hydrateRuntimeState(data, {basePath});
    const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
    return makeApi(state, {fakeFs, pnpapiResolution});
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\jsInstallUtils.ts
  var jsInstallUtils_exports = {};
  __export(jsInstallUtils_exports, {
    checkAndReportManifestCompatibility: () => checkAndReportManifestCompatibility,
    extractBuildScripts: () => extractBuildScripts,
    getExtractHint: () => getExtractHint,
    hasBindingGyp: () => hasBindingGyp
  });
  function checkAndReportManifestCompatibility(pkg, requirements, label, {configuration, report}) {
    if (!Manifest.isManifestFieldCompatible(requirements.manifest.os, process.platform)) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.INCOMPATIBLE_OS, `${structUtils_exports.prettyLocator(configuration, pkg)} The platform ${process.platform} is incompatible with this module, ${label} skipped.`);
      return false;
    }
    if (!Manifest.isManifestFieldCompatible(requirements.manifest.cpu, process.arch)) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.INCOMPATIBLE_CPU, `${structUtils_exports.prettyLocator(configuration, pkg)} The CPU architecture ${process.arch} is incompatible with this module, ${label} skipped.`);
      return false;
    }
    return true;
  }
  function extractBuildScripts(pkg, requirements, dependencyMeta, {configuration, report}) {
    const buildScripts = [];
    for (const scriptName of [`preinstall`, `install`, `postinstall`])
      if (requirements.manifest.scripts.has(scriptName))
        buildScripts.push([BuildType.SCRIPT, scriptName]);
    if (!requirements.manifest.scripts.has(`install`) && requirements.misc.hasBindingGyp)
      buildScripts.push([BuildType.SHELLCODE, `node-gyp rebuild`]);
    if (buildScripts.length === 0)
      return [];
    if (!configuration.get(`enableScripts`) && !dependencyMeta.built) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.DISABLED_BUILD_SCRIPTS, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
      return [];
    }
    if (pkg.linkType !== LinkType.HARD) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.SOFT_LINK_BUILD, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
      return [];
    }
    if (dependencyMeta && dependencyMeta.built === false) {
      report == null ? void 0 : report.reportInfoOnce(MessageName.BUILD_DISABLED, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
      return [];
    }
    const isManifestCompatible = checkAndReportManifestCompatibility(pkg, requirements, `build`, {configuration, report});
    if (!isManifestCompatible)
      return [];
    return buildScripts;
  }
  var FORCED_EXTRACT_FILETYPES = new Set([
    `.exe`,
    `.h`,
    `.hh`,
    `.hpp`,
    `.c`,
    `.cc`,
    `.cpp`,
    `.java`,
    `.jar`,
    `.node`
  ]);
  function getExtractHint(fetchResult) {
    return fetchResult.packageFs.getExtractHint({relevantExtensions: FORCED_EXTRACT_FILETYPES});
  }
  function hasBindingGyp(fetchResult) {
    const bindingFilePath = ppath.join(fetchResult.prefixPath, `binding.gyp`);
    return fetchResult.packageFs.existsSync(bindingFilePath);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\pnpUtils.ts
  var pnpUtils_exports = {};
  __export(pnpUtils_exports, {
    getUnpluggedPath: () => getUnpluggedPath
  });
  function getUnpluggedPath(locator, {configuration}) {
    return ppath.resolve(configuration.get(`pnpUnpluggedFolder`), structUtils_exports.slugifyLocator(locator));
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\PnpLinker.ts
  var FORCED_UNPLUG_PACKAGES = new Set([
    structUtils_exports.makeIdent(null, `nan`).identHash,
    structUtils_exports.makeIdent(null, `node-gyp`).identHash,
    structUtils_exports.makeIdent(null, `node-pre-gyp`).identHash,
    structUtils_exports.makeIdent(null, `node-addon-api`).identHash,
    structUtils_exports.makeIdent(null, `fsevents`).identHash
  ]);
  var PnpLinker = class {
    constructor() {
      this.mode = `strict`;
    }
    supportsPackage(pkg, opts) {
      if (opts.project.configuration.get(`nodeLinker`) !== `pnp`)
        return false;
      if (opts.project.configuration.get(`pnpMode`) !== this.mode)
        return false;
      return true;
    }
    async findPackageLocation(locator, opts) {
      const pnpPath = getPnpPath(opts.project).cjs;
      if (!xfs.existsSync(pnpPath))
        throw new UsageError(`The project in ${formatUtils_exports.pretty(opts.project.configuration, `${opts.project.cwd}/package.json`, formatUtils_exports.Type.PATH)} doesn't seem to have been installed - running an install there might help`);
      const pnpFile = miscUtils10.dynamicRequireNoCache(pnpPath);
      const packageLocator = {name: structUtils_exports.stringifyIdent(locator), reference: locator.reference};
      const packageInformation = pnpFile.getPackageInformation(packageLocator);
      if (!packageInformation)
        throw new UsageError(`Couldn't find ${structUtils_exports.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
      return npath.toPortablePath(packageInformation.packageLocation);
    }
    async findPackageLocator(location, opts) {
      const pnpPath = getPnpPath(opts.project).cjs;
      if (!xfs.existsSync(pnpPath))
        return null;
      const pnpFile = miscUtils10.dynamicRequireNoCache(pnpPath);
      const locator = pnpFile.findPackageLocator(npath.fromPortablePath(location));
      if (!locator)
        return null;
      return structUtils_exports.makeLocator(structUtils_exports.parseIdent(locator.name), locator.reference);
    }
    makeInstaller(opts) {
      return new PnpInstaller(opts);
    }
  };
  var PnpInstaller = class {
    constructor(opts) {
      this.opts = opts;
      this.mode = `strict`;
      this.packageRegistry = new Map();
      this.virtualTemplates = new Map();
      this.customData = {
        store: new Map()
      };
      this.unpluggedPaths = new Set();
      this.opts = opts;
    }
    getCustomDataKey() {
      return JSON.stringify({
        name: `PnpInstaller`,
        version: 1
      });
    }
    attachCustomData(customData) {
      this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
      const key1 = structUtils_exports.stringifyIdent(pkg);
      const key2 = pkg.reference;
      const isWorkspace = !!this.opts.project.tryWorkspaceByLocator(pkg);
      const hasVirtualInstances = pkg.peerDependencies.size > 0 && !structUtils_exports.isVirtualLocator(pkg);
      const mayNeedToBeBuilt = !hasVirtualInstances && !isWorkspace;
      const mayNeedToBeUnplugged = !hasVirtualInstances && pkg.linkType !== LinkType.SOFT;
      let customPackageData = this.customData.store.get(pkg.locatorHash);
      if (typeof customPackageData === `undefined`) {
        customPackageData = await extractCustomPackageData(pkg, fetchResult);
        if (pkg.linkType === LinkType.HARD) {
          this.customData.store.set(pkg.locatorHash, customPackageData);
        }
      }
      const dependencyMeta = this.opts.project.getDependencyMeta(pkg, pkg.version);
      const buildScripts = mayNeedToBeBuilt ? extractBuildScripts(pkg, customPackageData, dependencyMeta, {configuration: this.opts.project.configuration, report: this.opts.report}) : [];
      const packageFs = mayNeedToBeUnplugged ? await this.unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) : fetchResult.packageFs;
      if (ppath.isAbsolute(fetchResult.prefixPath))
        throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
      const packageRawLocation = ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
      const packageLocation = normalizeDirectoryPath(this.opts.project.cwd, packageRawLocation);
      const packageDependencies = new Map();
      const packagePeers = new Set();
      if (structUtils_exports.isVirtualLocator(pkg)) {
        for (const descriptor of pkg.peerDependencies.values()) {
          packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), null);
          packagePeers.add(structUtils_exports.stringifyIdent(descriptor));
        }
        if (!this.opts.project.tryWorkspaceByLocator(pkg)) {
          const devirtualized = structUtils_exports.devirtualizeLocator(pkg);
          this.virtualTemplates.set(devirtualized.locatorHash, {
            location: normalizeDirectoryPath(this.opts.project.cwd, VirtualFS.resolveVirtual(packageRawLocation)),
            locator: devirtualized
          });
        }
      }
      miscUtils10.getMapWithDefault(this.packageRegistry, key1).set(key2, {
        packageLocation,
        packageDependencies,
        packagePeers,
        linkType: pkg.linkType,
        discardFromLookup: fetchResult.discardFromLookup || false
      });
      return {
        packageLocation: packageRawLocation,
        buildDirective: buildScripts.length > 0 ? buildScripts : null
      };
    }
    async attachInternalDependencies(locator, dependencies) {
      const packageInformation = this.getPackageInformation(locator);
      for (const [descriptor, locator2] of dependencies) {
        const target = !structUtils_exports.areIdentsEqual(descriptor, locator2) ? [structUtils_exports.stringifyIdent(locator2), locator2.reference] : locator2.reference;
        packageInformation.packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), target);
      }
    }
    async attachExternalDependents(locator, dependentPaths) {
      for (const dependentPath of dependentPaths) {
        const packageInformation = this.getDiskInformation(dependentPath);
        packageInformation.packageDependencies.set(structUtils_exports.stringifyIdent(locator), locator.reference);
      }
    }
    async finalizeInstall() {
      const blacklistedPaths = new Set();
      for (const {locator, location} of this.virtualTemplates.values()) {
        miscUtils10.getMapWithDefault(this.packageRegistry, structUtils_exports.stringifyIdent(locator)).set(locator.reference, {
          packageLocation: location,
          packageDependencies: new Map(),
          packagePeers: new Set(),
          linkType: LinkType.SOFT,
          discardFromLookup: false
        });
      }
      this.packageRegistry.set(null, new Map([
        [null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)]
      ]));
      const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
      const blacklistedLocations = blacklistedPaths;
      const dependencyTreeRoots = this.opts.project.workspaces.map(({anchoredLocator}) => ({name: structUtils_exports.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference}));
      const enableTopLevelFallback = pnpFallbackMode !== `none`;
      const fallbackExclusionList = [];
      const fallbackPool = new Map();
      const ignorePattern = miscUtils10.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
      const packageRegistry = this.packageRegistry;
      const shebang = this.opts.project.configuration.get(`pnpShebang`);
      if (pnpFallbackMode === `dependencies-only`) {
        for (const pkg of this.opts.project.storedPackages.values())
          if (this.opts.project.tryWorkspaceByLocator(pkg))
            fallbackExclusionList.push({name: structUtils_exports.stringifyIdent(pkg), reference: pkg.reference});
      }
      await this.finalizeInstallWithPnp({
        blacklistedLocations,
        dependencyTreeRoots,
        enableTopLevelFallback,
        fallbackExclusionList,
        fallbackPool,
        ignorePattern,
        packageRegistry,
        shebang
      });
      return {
        customData: this.customData
      };
    }
    async transformPnpSettings(pnpSettings) {
    }
    async finalizeInstallWithPnp(pnpSettings) {
      if (this.opts.project.configuration.get(`pnpMode`) !== this.mode)
        return;
      const pnpPath = getPnpPath(this.opts.project);
      const pnpDataPath = this.opts.project.configuration.get(`pnpDataPath`);
      if (xfs.existsSync(pnpPath.cjsLegacy)) {
        this.opts.report.reportWarning(MessageName.UNNAMED, `Removing the old ${formatUtils_exports.pretty(this.opts.project.configuration, Filename.pnpJs, formatUtils_exports.Type.PATH)} file. You might need to manually update existing references to reference the new ${formatUtils_exports.pretty(this.opts.project.configuration, Filename.pnpCjs, formatUtils_exports.Type.PATH)} file. If you use PnPify SDKs, you'll have to rerun ${formatUtils_exports.pretty(this.opts.project.configuration, `yarn pnpify --sdk`, formatUtils_exports.Type.CODE)}.`);
        await xfs.removePromise(pnpPath.cjsLegacy);
      }
      if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
        await xfs.removePromise(pnpPath.cjs);
        await xfs.removePromise(pnpDataPath);
        return;
      }
      const nodeModules = await this.locateNodeModules(pnpSettings.ignorePattern);
      if (nodeModules.length > 0) {
        this.opts.report.reportWarning(MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);
        for (const nodeModulesPath of nodeModules) {
          await xfs.removePromise(nodeModulesPath);
        }
      }
      await this.transformPnpSettings(pnpSettings);
      if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
        const loaderFile = generateInlinedScript(pnpSettings);
        await xfs.changeFilePromise(pnpPath.cjs, loaderFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpPath.cjs, 493);
        await xfs.removePromise(pnpDataPath);
      } else {
        const dataLocation = ppath.relative(ppath.dirname(pnpPath.cjs), pnpDataPath);
        const {dataFile, loaderFile} = generateSplitScript({...pnpSettings, dataLocation});
        await xfs.changeFilePromise(pnpPath.cjs, loaderFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpPath.cjs, 493);
        await xfs.changeFilePromise(pnpDataPath, dataFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpDataPath, 420);
      }
      const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);
      if (this.unpluggedPaths.size === 0) {
        await xfs.removePromise(pnpUnpluggedFolder);
      } else {
        for (const entry of await xfs.readdirPromise(pnpUnpluggedFolder)) {
          const unpluggedPath = ppath.resolve(pnpUnpluggedFolder, entry);
          if (!this.unpluggedPaths.has(unpluggedPath)) {
            await xfs.removePromise(unpluggedPath);
          }
        }
      }
    }
    async locateNodeModules(ignorePattern) {
      const nodeModules = [];
      const ignoreRegExp = ignorePattern ? new RegExp(ignorePattern) : null;
      for (const workspace of this.opts.project.workspaces) {
        const nodeModulesPath = ppath.join(workspace.cwd, `node_modules`);
        if (ignoreRegExp && ignoreRegExp.test(ppath.relative(this.opts.project.cwd, workspace.cwd)) || !xfs.existsSync(nodeModulesPath))
          continue;
        const directoryListing = await xfs.readdirPromise(nodeModulesPath, {
          withFileTypes: true
        });
        const nonCacheEntries = directoryListing.filter((entry) => {
          return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
        });
        if (nonCacheEntries.length === directoryListing.length) {
          nodeModules.push(nodeModulesPath);
        } else {
          for (const entry of nonCacheEntries) {
            nodeModules.push(ppath.join(nodeModulesPath, entry.name));
          }
        }
      }
      return nodeModules;
    }
    async unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) {
      if (this.shouldBeUnplugged(pkg, customPackageData, dependencyMeta)) {
        return this.unplugPackage(pkg, fetchResult);
      } else {
        return fetchResult.packageFs;
      }
    }
    shouldBeUnplugged(pkg, customPackageData, dependencyMeta) {
      if (typeof dependencyMeta.unplugged !== `undefined`)
        return dependencyMeta.unplugged;
      if (FORCED_UNPLUG_PACKAGES.has(pkg.identHash))
        return true;
      if (customPackageData.manifest.preferUnplugged !== null)
        return customPackageData.manifest.preferUnplugged;
      if (extractBuildScripts(pkg, customPackageData, dependencyMeta, {configuration: this.opts.project.configuration}).length > 0 || customPackageData.misc.extractHint)
        return true;
      return false;
    }
    async unplugPackage(locator, fetchResult) {
      const unplugPath = getUnpluggedPath(locator, {configuration: this.opts.project.configuration});
      this.unpluggedPaths.add(unplugPath);
      const readyFile = ppath.join(unplugPath, fetchResult.prefixPath, `.ready`);
      if (await xfs.existsPromise(readyFile))
        return new CwdFS(unplugPath);
      await xfs.mkdirPromise(unplugPath, {recursive: true});
      await xfs.copyPromise(unplugPath, PortablePath2.dot, {baseFs: fetchResult.packageFs, overwrite: false});
      await xfs.writeFilePromise(readyFile, ``);
      return new CwdFS(unplugPath);
    }
    getPackageInformation(locator) {
      const key1 = structUtils_exports.stringifyIdent(locator);
      const key2 = locator.reference;
      const packageInformationStore = this.packageRegistry.get(key1);
      if (!packageInformationStore)
        throw new Error(`Assertion failed: The package information store should have been available (for ${structUtils_exports.prettyIdent(this.opts.project.configuration, locator)})`);
      const packageInformation = packageInformationStore.get(key2);
      if (!packageInformation)
        throw new Error(`Assertion failed: The package information should have been available (for ${structUtils_exports.prettyLocator(this.opts.project.configuration, locator)})`);
      return packageInformation;
    }
    getDiskInformation(path6) {
      const packageStore = miscUtils10.getMapWithDefault(this.packageRegistry, `@@disk`);
      const normalizedPath = normalizeDirectoryPath(this.opts.project.cwd, path6);
      return miscUtils10.getFactoryWithDefault(packageStore, normalizedPath, () => ({
        packageLocation: normalizedPath,
        packageDependencies: new Map(),
        packagePeers: new Set(),
        linkType: LinkType.SOFT,
        discardFromLookup: false
      }));
    }
  };
  function normalizeDirectoryPath(root, folder) {
    let relativeFolder = ppath.relative(root, folder);
    if (!relativeFolder.match(/^\.{0,2}\//))
      relativeFolder = `./${relativeFolder}`;
    return relativeFolder.replace(/\/?$/, `/`);
  }
  async function extractCustomPackageData(pkg, fetchResult) {
    var _a2;
    const manifest = (_a2 = await Manifest.tryFind(fetchResult.prefixPath, {baseFs: fetchResult.packageFs})) != null ? _a2 : new Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
      if (!preservedScripts.has(scriptName))
        manifest.scripts.delete(scriptName);
    return {
      manifest: {
        os: manifest.os,
        cpu: manifest.cpu,
        scripts: manifest.scripts,
        preferUnplugged: manifest.preferUnplugged
      },
      misc: {
        extractHint: getExtractHint(fetchResult),
        hasBindingGyp: hasBindingGyp(fetchResult)
      }
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\commands\unplug.ts
  var import_micromatch7 = __toModule(require_micromatch());
  var import_semver13 = __toModule(require_semver2());
  var UnplugCommand = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Unplug direct dependencies from the entire project`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Unplug both direct and transitive dependencies`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      if (configuration.get(`nodeLinker`) !== `pnp`)
        throw new UsageError(`This command can only be used if the \`nodeLinker\` option is set to \`pnp\``);
      await project.restoreInstallState();
      const unreferencedPatterns = new Set(this.patterns);
      const matchers = this.patterns.map((pattern) => {
        const patternDescriptor = structUtils_exports.parseDescriptor(pattern);
        const pseudoDescriptor = patternDescriptor.range !== `unknown` ? patternDescriptor : structUtils_exports.makeDescriptor(patternDescriptor, `*`);
        if (!import_semver13.default.validRange(pseudoDescriptor.range))
          throw new UsageError(`The range of the descriptor patterns must be a valid semver range (${structUtils_exports.prettyDescriptor(configuration, pseudoDescriptor)})`);
        return (pkg) => {
          const stringifiedIdent = structUtils_exports.stringifyIdent(pkg);
          if (!import_micromatch7.default.isMatch(stringifiedIdent, structUtils_exports.stringifyIdent(pseudoDescriptor)))
            return false;
          if (pkg.version && !semverUtils_exports.satisfiesWithPrereleases(pkg.version, pseudoDescriptor.range))
            return false;
          unreferencedPatterns.delete(pattern);
          return true;
        };
      });
      const getAllMatchingPackages = () => {
        const selection2 = [];
        for (const pkg of project.storedPackages.values())
          if (!project.tryWorkspaceByLocator(pkg) && !structUtils_exports.isVirtualLocator(pkg) && matchers.some((matcher) => matcher(pkg)))
            selection2.push(pkg);
        return selection2;
      };
      const getSelectedPackages = (roots) => {
        const seen = new Set();
        const selection2 = [];
        const traverse = (pkg, depth) => {
          if (seen.has(pkg.locatorHash))
            return;
          seen.add(pkg.locatorHash);
          if (!project.tryWorkspaceByLocator(pkg) && matchers.some((matcher) => matcher(pkg)))
            selection2.push(pkg);
          if (depth > 0 && !this.recursive)
            return;
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
              throw new Error(`Assertion failed: The resolution should have been registered`);
            const nextPkg = project.storedPackages.get(resolution);
            if (!nextPkg)
              throw new Error(`Assertion failed: The package should have been registered`);
            traverse(nextPkg, depth + 1);
          }
        };
        for (const workspace2 of roots) {
          const pkg = project.storedPackages.get(workspace2.anchoredLocator.locatorHash);
          if (!pkg)
            throw new Error(`Assertion failed: The package should have been registered`);
          traverse(pkg, 0);
        }
        return selection2;
      };
      let selection;
      let projectOrWorkspaces;
      if (this.all && this.recursive) {
        selection = getAllMatchingPackages();
        projectOrWorkspaces = `the project`;
      } else if (this.all) {
        selection = getSelectedPackages(project.workspaces);
        projectOrWorkspaces = `any workspace`;
      } else {
        selection = getSelectedPackages([workspace]);
        projectOrWorkspaces = `this workspace`;
      }
      if (unreferencedPatterns.size > 1)
        throw new UsageError(`Patterns ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, formatUtils_exports.Type.CODE)} don't match any packages referenced by ${projectOrWorkspaces}`);
      if (unreferencedPatterns.size > 0)
        throw new UsageError(`Pattern ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, formatUtils_exports.Type.CODE)} doesn't match any packages referenced by ${projectOrWorkspaces}`);
      selection = miscUtils10.sortMap(selection, (pkg) => {
        return structUtils_exports.stringifyLocator(pkg);
      });
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        json: this.json
      }, async (report2) => {
        var _a2;
        for (const pkg of selection) {
          const version = (_a2 = pkg.version) != null ? _a2 : `unknown`;
          const dependencyMeta = project.topLevelWorkspace.manifest.ensureDependencyMeta(structUtils_exports.makeDescriptor(pkg, version));
          dependencyMeta.unplugged = true;
          report2.reportInfo(MessageName.UNNAMED, `Will unpack ${structUtils_exports.prettyLocator(configuration, pkg)} to ${formatUtils_exports.pretty(configuration, getUnpluggedPath(pkg, {configuration}), formatUtils_exports.Type.PATH)}`);
          report2.reportJson({
            locator: structUtils_exports.stringifyLocator(pkg),
            version
          });
        }
        await project.topLevelWorkspace.persistManifest();
        report2.reportSeparator();
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  UnplugCommand.paths = [
    [`unplug`]
  ];
  UnplugCommand.usage = Command.Usage({
    description: `force the unpacking of a list of packages`,
    details: `
      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.

      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via \`pnpUnpluggedFolder\`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).

      Running the command will set a persistent flag inside your top-level \`package.json\`, in the \`dependenciesMeta\` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run \`yarn install\` to apply the modification.

      By default, only direct dependencies from the current workspace are affected. If \`-A,--all\` is set, direct dependencies from the entire project are affected. Using the \`-R,--recursive\` flag will affect transitive dependencies as well as direct ones.

      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.
    `,
    examples: [[
      `Unplug the lodash dependency from the active workspace`,
      `yarn unplug lodash`
    ], [
      `Unplug all instances of lodash referenced by any workspace`,
      `yarn unplug lodash -A`
    ], [
      `Unplug all instances of lodash referenced by the active workspace and its dependencies`,
      `yarn unplug lodash -R`
    ], [
      `Unplug all instances of lodash, anywhere`,
      `yarn unplug lodash -AR`
    ], [
      `Unplug one specific version of lodash`,
      `yarn unplug lodash@1.2.3`
    ], [
      `Unplug all packages with the \`@babel\` scope`,
      `yarn unplug '@babel/*'`
    ], [
      `Unplug all packages (only for testing, not recommended)`,
      `yarn unplug -R '*'`
    ]]
  });
  var unplug_default = UnplugCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-afab17303c\1\packages\plugin-pnp\sources\index.ts
  var getPnpPath = (project) => {
    return {
      cjs: ppath.join(project.cwd, Filename.pnpCjs),
      cjsLegacy: ppath.join(project.cwd, Filename.pnpJs)
    };
  };
  var quotePathIfNeeded = (path6) => {
    return /\s/.test(path6) ? JSON.stringify(path6) : path6;
  };
  async function setupScriptEnvironment(project, env, makePathWrapper2) {
    const pnpPath = getPnpPath(project).cjs;
    const pnpRequire = `--require ${quotePathIfNeeded(npath.fromPortablePath(pnpPath))}`;
    if (pnpPath.includes(` `) && import_semver14.default.lt(process.versions.node, `12.0.0`))
      throw new Error(`Expected the build location to not include spaces when using Node < 12.0.0 (${process.versions.node})`);
    if (xfs.existsSync(pnpPath)) {
      let nodeOptions = env.NODE_OPTIONS || ``;
      const pnpRegularExpression = /\s*--require\s+\S*\.pnp\.c?js\s*/g;
      nodeOptions = nodeOptions.replace(pnpRegularExpression, ` `).trim();
      nodeOptions = nodeOptions ? `${pnpRequire} ${nodeOptions}` : pnpRequire;
      env.NODE_OPTIONS = nodeOptions;
    }
  }
  async function populateYarnPaths(project, definePath) {
    definePath(getPnpPath(project).cjs);
    definePath(project.configuration.get(`pnpDataPath`));
    definePath(project.configuration.get(`pnpUnpluggedFolder`));
  }
  var plugin10 = {
    hooks: {
      populateYarnPaths,
      setupScriptEnvironment
    },
    configuration: {
      nodeLinker: {
        description: `The linker used for installing Node packages, one of: "pnp", "node-modules"`,
        type: SettingsType.STRING,
        default: `pnp`
      },
      pnpMode: {
        description: `If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.`,
        type: SettingsType.STRING,
        default: `strict`
      },
      pnpShebang: {
        description: `String to prepend to the generated PnP script`,
        type: SettingsType.STRING,
        default: `#!/usr/bin/env node`
      },
      pnpIgnorePatterns: {
        description: `Array of glob patterns; files matching them will use the classic resolution`,
        type: SettingsType.STRING,
        default: [],
        isArray: true
      },
      pnpEnableInlining: {
        description: `If true, the PnP data will be inlined along with the generated loader`,
        type: SettingsType.BOOLEAN,
        default: true
      },
      pnpFallbackMode: {
        description: `If true, the generated PnP loader will follow the top-level fallback rule`,
        type: SettingsType.STRING,
        default: `dependencies-only`
      },
      pnpUnpluggedFolder: {
        description: `Folder where the unplugged packages must be stored`,
        type: SettingsType.ABSOLUTE_PATH,
        default: `./.yarn/unplugged`
      },
      pnpDataPath: {
        description: `Path of the file where the PnP data (used by the loader) must be written`,
        type: SettingsType.ABSOLUTE_PATH,
        default: `./.pnp.data.json`
      }
    },
    linkers: [
      PnpLinker
    ],
    commands: [
      unplug_default
    ]
  };
  var sources_default12 = plugin10;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-6c4ffdc97c\1\packages\plugin-node-modules\sources\NodeModulesLinker.ts
  var import_cmd_shim = __toModule(require_cmd_shim());
  var import_fs11 = __toModule(require("fs"));
  var STATE_FILE_VERSION = 1;
  var NODE_MODULES3 = `node_modules`;
  var DOT_BIN = `.bin`;
  var INSTALL_STATE_FILE = `.yarn-state.yml`;
  var NodeModulesLinker = class {
    supportsPackage(pkg, opts) {
      return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
    }
    async findPackageLocation(locator, opts) {
      const workspace = opts.project.tryWorkspaceByLocator(locator);
      if (workspace)
        return workspace.cwd;
      const installState = await findInstallState(opts.project, {unrollAliases: true});
      if (installState === null)
        throw new UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
      const locatorInfo = installState.locatorMap.get(structUtils_exports.stringifyLocator(locator));
      if (!locatorInfo) {
        const err = new UsageError(`Couldn't find ${structUtils_exports.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
        err.code = `LOCATOR_NOT_INSTALLED`;
        throw err;
      }
      return locatorInfo.locations[0];
    }
    async findPackageLocator(location, opts) {
      const installState = await findInstallState(opts.project, {unrollAliases: true});
      if (installState === null)
        return null;
      const {locationRoot, segments} = parseLocation(ppath.resolve(location), {skipPrefix: opts.project.cwd});
      let locationNode = installState.locationTree.get(locationRoot);
      if (!locationNode)
        return null;
      let locator = locationNode.locator;
      for (const segment of segments) {
        locationNode = locationNode.children.get(segment);
        if (!locationNode)
          break;
        locator = locationNode.locator || locator;
      }
      return structUtils_exports.parseLocator(locator);
    }
    makeInstaller(opts) {
      return new NodeModulesInstaller(opts);
    }
  };
  var NodeModulesInstaller = class {
    constructor(opts) {
      this.opts = opts;
      this.localStore = new Map();
      this.customData = {
        store: new Map()
      };
    }
    getCustomDataKey() {
      return JSON.stringify({
        name: `NodeModulesInstaller`,
        version: 1
      });
    }
    attachCustomData(customData) {
      this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
      var _a2;
      const packageLocation = ppath.resolve(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
      let customPackageData = this.customData.store.get(pkg.locatorHash);
      if (typeof customPackageData === `undefined`) {
        customPackageData = await extractCustomPackageData2(pkg, fetchResult);
        if (pkg.linkType === LinkType.HARD) {
          this.customData.store.set(pkg.locatorHash, customPackageData);
        }
      }
      if (!jsInstallUtils_exports.checkAndReportManifestCompatibility(pkg, customPackageData, `link`, {configuration: this.opts.project.configuration, report: this.opts.report}))
        return {packageLocation: null, buildDirective: null};
      const packageDependencies = new Map();
      const packagePeers = new Set();
      if (!packageDependencies.has(structUtils_exports.stringifyIdent(pkg)))
        packageDependencies.set(structUtils_exports.stringifyIdent(pkg), pkg.reference);
      if (structUtils_exports.isVirtualLocator(pkg)) {
        for (const descriptor of pkg.peerDependencies.values()) {
          packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), null);
          packagePeers.add(structUtils_exports.stringifyIdent(descriptor));
        }
      }
      const pnpNode = {
        packageLocation: `${npath.fromPortablePath(packageLocation)}/`,
        packageDependencies,
        packagePeers,
        linkType: pkg.linkType,
        discardFromLookup: (_a2 = fetchResult.discardFromLookup) != null ? _a2 : false
      };
      this.localStore.set(pkg.locatorHash, {
        pkg,
        customPackageData,
        dependencyMeta: this.opts.project.getDependencyMeta(pkg, pkg.version),
        pnpNode
      });
      return {
        packageLocation,
        buildDirective: null
      };
    }
    async attachInternalDependencies(locator, dependencies) {
      const slot = this.localStore.get(locator.locatorHash);
      if (typeof slot === `undefined`)
        throw new Error(`Assertion failed: Expected information object to have been registered`);
      for (const [descriptor, locator2] of dependencies) {
        const target = !structUtils_exports.areIdentsEqual(descriptor, locator2) ? [structUtils_exports.stringifyIdent(locator2), locator2.reference] : locator2.reference;
        slot.pnpNode.packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), target);
      }
    }
    async attachExternalDependents(locator, dependentPaths) {
      throw new Error(`External dependencies haven't been implemented for the node-modules linker`);
    }
    async finalizeInstall() {
      if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`)
        return void 0;
      const defaultFsLayer = new VirtualFS({
        baseFs: new ZipOpenFS({
          libzip: await getLibzipPromise(),
          maxOpenFiles: 80,
          readOnlyArchives: true
        })
      });
      let preinstallState = await findInstallState(this.opts.project);
      if (preinstallState === null) {
        const bstatePath = this.opts.project.configuration.get(`bstatePath`);
        if (await xfs.existsPromise(bstatePath))
          await xfs.unlinkPromise(bstatePath);
        preinstallState = {locatorMap: new Map(), binSymlinks: new Map(), locationTree: new Map()};
      }
      const hoistingLimitsByCwd = new Map(this.opts.project.workspaces.map((workspace) => {
        var _a2, _b;
        let hoistingLimits = this.opts.project.configuration.get(`nmHoistingLimits`);
        try {
          hoistingLimits = miscUtils10.validateEnum(NodeModulesHoistingLimits, (_b = (_a2 = workspace.manifest.installConfig) == null ? void 0 : _a2.hoistingLimits) != null ? _b : hoistingLimits);
        } catch (e) {
          const workspaceName = structUtils_exports.prettyWorkspace(this.opts.project.configuration, workspace);
          this.opts.report.reportWarning(MessageName.INVALID_MANIFEST, `${workspaceName}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values(NodeModulesHoistingLimits).join(`, `)}, using default: "${hoistingLimits}"`);
        }
        return [workspace.relativeCwd, hoistingLimits];
      }));
      const pnpApi = {
        VERSIONS: {
          std: 1
        },
        topLevel: {
          name: null,
          reference: null
        },
        getLocator: (name, referencish) => {
          if (Array.isArray(referencish)) {
            return {name: referencish[0], reference: referencish[1]};
          } else {
            return {name, reference: referencish};
          }
        },
        getDependencyTreeRoots: () => {
          return this.opts.project.workspaces.map((workspace) => {
            const anchoredLocator = workspace.anchoredLocator;
            return {name: structUtils_exports.stringifyIdent(workspace.locator), reference: anchoredLocator.reference};
          });
        },
        getPackageInformation: (pnpLocator) => {
          const locator = pnpLocator.reference === null ? this.opts.project.topLevelWorkspace.anchoredLocator : structUtils_exports.makeLocator(structUtils_exports.parseIdent(pnpLocator.name), pnpLocator.reference);
          const slot = this.localStore.get(locator.locatorHash);
          if (typeof slot === `undefined`)
            throw new Error(`Assertion failed: Expected the package reference to have been registered`);
          return slot.pnpNode;
        },
        findPackageLocator: (location) => {
          const workspace = this.opts.project.tryWorkspaceByCwd(npath.toPortablePath(location));
          if (workspace !== null) {
            const anchoredLocator = workspace.anchoredLocator;
            return {name: structUtils_exports.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference};
          }
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveToUnqualified: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveUnqualified: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveRequest: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveVirtual: (path6) => {
          return npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(path6)));
        }
      };
      const nmTree = buildNodeModulesTree(pnpApi, {pnpifyFs: false, hoistingLimitsByCwd, project: this.opts.project});
      const locatorMap = buildLocatorMap(nmTree);
      await persistNodeModules(preinstallState, locatorMap, {
        baseFs: defaultFsLayer,
        project: this.opts.project,
        report: this.opts.report,
        loadManifest: async (locatorKey) => {
          const locator = structUtils_exports.parseLocator(locatorKey);
          const slot = this.localStore.get(locator.locatorHash);
          if (typeof slot === `undefined`)
            throw new Error(`Assertion failed: Expected the slot to exist`);
          return slot.customPackageData.manifest;
        }
      });
      const installStatuses = [];
      for (const [locatorKey, installRecord] of locatorMap.entries()) {
        if (isLinkLocator(locatorKey))
          continue;
        const locator = structUtils_exports.parseLocator(locatorKey);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`)
          throw new Error(`Assertion failed: Expected the slot to exist`);
        const buildScripts = jsInstallUtils_exports.extractBuildScripts(slot.pkg, slot.customPackageData, slot.dependencyMeta, {configuration: this.opts.project.configuration, report: this.opts.report});
        if (buildScripts.length === 0)
          continue;
        installStatuses.push({
          buildLocations: installRecord.locations,
          locatorHash: locator.locatorHash,
          buildDirective: buildScripts
        });
      }
      return {
        customData: this.customData,
        records: installStatuses
      };
    }
  };
  async function extractCustomPackageData2(pkg, fetchResult) {
    var _a2;
    const manifest = (_a2 = await Manifest.tryFind(fetchResult.prefixPath, {baseFs: fetchResult.packageFs})) != null ? _a2 : new Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
      if (!preservedScripts.has(scriptName))
        manifest.scripts.delete(scriptName);
    return {
      manifest: {
        bin: manifest.bin,
        os: manifest.os,
        cpu: manifest.cpu,
        scripts: manifest.scripts
      },
      misc: {
        extractHint: jsInstallUtils_exports.getExtractHint(fetchResult),
        hasBindingGyp: jsInstallUtils_exports.hasBindingGyp(fetchResult)
      }
    };
  }
  async function writeInstallState(project, locatorMap, binSymlinks) {
    let locatorState = ``;
    locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will
`;
    locatorState += `# cause your node_modules installation to become invalidated.
`;
    locatorState += `
`;
    locatorState += `__metadata:
`;
    locatorState += `  version: ${STATE_FILE_VERSION}
`;
    const locators = Array.from(locatorMap.keys()).sort();
    const topLevelLocator = structUtils_exports.stringifyLocator(project.topLevelWorkspace.anchoredLocator);
    for (const locator of locators) {
      const installRecord = locatorMap.get(locator);
      locatorState += `
`;
      locatorState += `${JSON.stringify(locator)}:
`;
      locatorState += `  locations:
`;
      for (const location of installRecord.locations) {
        const internalPath = ppath.contains(project.cwd, location);
        if (internalPath === null)
          throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
        locatorState += `    - ${JSON.stringify(internalPath)}
`;
      }
      if (installRecord.aliases.length > 0) {
        locatorState += `  aliases:
`;
        for (const alias of installRecord.aliases) {
          locatorState += `    - ${JSON.stringify(alias)}
`;
        }
      }
      if (locator === topLevelLocator && binSymlinks.size > 0) {
        locatorState += `  bin:
`;
        for (const [location, symlinks] of binSymlinks) {
          const internalPath = ppath.contains(project.cwd, location);
          if (internalPath === null)
            throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
          locatorState += `    ${JSON.stringify(internalPath)}:
`;
          for (const [name, target] of symlinks) {
            const relativePath = ppath.relative(ppath.join(location, NODE_MODULES3), target);
            locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}
`;
          }
        }
      }
    }
    const rootPath = project.cwd;
    const installStatePath = ppath.join(rootPath, NODE_MODULES3, INSTALL_STATE_FILE);
    await xfs.changeFilePromise(installStatePath, locatorState, {
      automaticNewlines: true
    });
  }
  async function findInstallState(project, {unrollAliases = false} = {}) {
    const rootPath = project.cwd;
    const installStatePath = ppath.join(rootPath, NODE_MODULES3, INSTALL_STATE_FILE);
    if (!xfs.existsSync(installStatePath))
      return null;
    const locatorState = parseSyml(await xfs.readFilePromise(installStatePath, `utf8`));
    if (locatorState.__metadata.version > STATE_FILE_VERSION)
      return null;
    const locatorMap = new Map();
    const binSymlinks = new Map();
    delete locatorState.__metadata;
    for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
      const locations = installRecord.locations.map((location) => {
        return ppath.join(rootPath, location);
      });
      const recordSymlinks = installRecord.bin;
      if (recordSymlinks) {
        for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
          const location = ppath.join(rootPath, npath.toPortablePath(relativeLocation));
          const symlinks = miscUtils10.getMapWithDefault(binSymlinks, location);
          for (const [name, target] of Object.entries(locationSymlinks)) {
            symlinks.set(toFilename(name), npath.toPortablePath([location, NODE_MODULES3, target].join(ppath.delimiter)));
          }
        }
      }
      locatorMap.set(locatorStr, {
        target: PortablePath2.dot,
        linkType: LinkType.HARD,
        locations,
        aliases: installRecord.aliases || []
      });
      if (unrollAliases && installRecord.aliases) {
        for (const reference of installRecord.aliases) {
          const {scope, name} = structUtils_exports.parseLocator(locatorStr);
          const alias = structUtils_exports.makeLocator(structUtils_exports.makeIdent(scope, name), reference);
          const aliasStr = structUtils_exports.stringifyLocator(alias);
          locatorMap.set(aliasStr, {
            target: PortablePath2.dot,
            linkType: LinkType.HARD,
            locations,
            aliases: []
          });
        }
      }
    }
    return {locatorMap, binSymlinks, locationTree: buildLocationTree(locatorMap, {skipPrefix: project.cwd})};
  }
  var removeDir = async (dir, options) => {
    if (dir.split(ppath.sep).indexOf(NODE_MODULES3) < 0)
      throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);
    try {
      if (!options.innerLoop) {
        const stats = await xfs.lstatPromise(dir);
        if (stats.isSymbolicLink()) {
          await xfs.unlinkPromise(dir);
          return;
        }
      }
      const entries = await xfs.readdirPromise(dir, {withFileTypes: true});
      for (const entry of entries) {
        const targetPath = ppath.join(dir, toFilename(entry.name));
        if (entry.isDirectory()) {
          if (entry.name !== NODE_MODULES3 || options && options.innerLoop) {
            await removeDir(targetPath, {innerLoop: true, contentsOnly: false});
          }
        } else {
          await xfs.unlinkPromise(targetPath);
        }
      }
      if (!options.contentsOnly) {
        await xfs.rmdirPromise(dir);
      }
    } catch (e) {
      if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
        throw e;
      }
    }
  };
  var CONCURRENT_OPERATION_LIMIT = 4;
  var parseLocation = (location, {skipPrefix}) => {
    const projectRelativePath = ppath.contains(skipPrefix, location);
    if (projectRelativePath === null)
      throw new Error(`Assertion failed: Cannot process a path that isn't part of the requested prefix (${location} isn't within ${skipPrefix})`);
    const allSegments = projectRelativePath.split(ppath.sep).filter((segment) => segment !== ``);
    const nmIndex = allSegments.indexOf(NODE_MODULES3);
    const relativeRoot = allSegments.slice(0, nmIndex).join(ppath.sep);
    const locationRoot = ppath.join(skipPrefix, relativeRoot);
    const segments = allSegments.slice(nmIndex);
    return {locationRoot, segments};
  };
  var buildLocationTree = (locatorMap, {skipPrefix}) => {
    const locationTree = new Map();
    if (locatorMap === null)
      return locationTree;
    const makeNode2 = () => ({
      children: new Map(),
      linkType: LinkType.HARD
    });
    for (const [locator, info] of locatorMap.entries()) {
      if (info.linkType === LinkType.SOFT) {
        const internalPath = ppath.contains(skipPrefix, info.target);
        if (internalPath !== null) {
          const node = miscUtils10.getFactoryWithDefault(locationTree, info.target, makeNode2);
          node.locator = locator;
          node.linkType = info.linkType;
        }
      }
      for (const location of info.locations) {
        const {locationRoot, segments} = parseLocation(location, {skipPrefix});
        let node = miscUtils10.getFactoryWithDefault(locationTree, locationRoot, makeNode2);
        for (let idx = 0; idx < segments.length; ++idx) {
          const segment = segments[idx];
          if (segment !== `.`) {
            const nextNode = miscUtils10.getFactoryWithDefault(node.children, segment, makeNode2);
            node.children.set(segment, nextNode);
            node = nextNode;
          }
          if (idx === segments.length - 1) {
            node.locator = locator;
            node.linkType = info.linkType;
          }
        }
      }
    }
    return locationTree;
  };
  var symlinkPromise = async (srcPath, dstPath) => {
    let stats;
    try {
      if (process.platform === `win32`) {
        stats = xfs.lstatSync(srcPath);
      }
    } catch (e) {
    }
    if (process.platform == `win32` && (!stats || stats.isDirectory())) {
      xfs.symlinkPromise(srcPath, dstPath, `junction`);
    } else {
      xfs.symlinkPromise(ppath.relative(ppath.dirname(dstPath), srcPath), dstPath);
    }
  };
  var copyPromise2 = async (dstDir, srcDir, {baseFs, innerLoop}) => {
    await xfs.mkdirPromise(dstDir, {recursive: true});
    const entries = await baseFs.readdirPromise(srcDir, {withFileTypes: true});
    const copy = async (dstPath, srcPath, srcType) => {
      if (srcType.isFile()) {
        const stat = await baseFs.lstatPromise(srcPath);
        await baseFs.copyFilePromise(srcPath, dstPath);
        const mode = stat.mode & 511;
        if (mode !== 420) {
          await xfs.chmodPromise(dstPath, mode);
        }
      } else if (srcType.isSymbolicLink()) {
        const target = await baseFs.readlinkPromise(srcPath);
        await symlinkPromise(ppath.resolve(ppath.dirname(dstPath), target), dstPath);
      } else {
        throw new Error(`Unsupported file type (file: ${srcPath}, mode: 0o${await xfs.statSync(srcPath).mode.toString(8).padStart(6, `0`)})`);
      }
    };
    for (const entry of entries) {
      const srcPath = ppath.join(srcDir, toFilename(entry.name));
      const dstPath = ppath.join(dstDir, toFilename(entry.name));
      if (entry.isDirectory()) {
        if (entry.name !== NODE_MODULES3 || innerLoop) {
          await copyPromise2(dstPath, srcPath, {baseFs, innerLoop: true});
        }
      } else {
        await copy(dstPath, srcPath, entry);
      }
    }
  };
  function refineNodeModulesRoots(locationTree, binSymlinks) {
    const refinedLocationTree = new Map([...locationTree]);
    const refinedBinSymlinks = new Map([...binSymlinks]);
    for (const [workspaceRoot, node] of locationTree) {
      const nodeModulesRoot = ppath.join(workspaceRoot, NODE_MODULES3);
      if (!xfs.existsSync(nodeModulesRoot)) {
        node.children.delete(NODE_MODULES3);
        for (const location of refinedBinSymlinks.keys()) {
          if (ppath.contains(nodeModulesRoot, location) !== null) {
            refinedBinSymlinks.delete(location);
          }
        }
      }
    }
    return {locationTree: refinedLocationTree, binSymlinks: refinedBinSymlinks};
  }
  function isLinkLocator(locatorKey) {
    let descriptor = structUtils_exports.parseDescriptor(locatorKey);
    if (structUtils_exports.isVirtualDescriptor(descriptor))
      descriptor = structUtils_exports.devirtualizeDescriptor(descriptor);
    return descriptor.range.startsWith(`link:`);
  }
  async function createBinSymlinkMap(installState, locationTree, projectRoot, {loadManifest}) {
    const locatorScriptMap = new Map();
    for (const [locatorKey, {locations}] of installState) {
      const manifest = !isLinkLocator(locatorKey) ? await loadManifest(locatorKey, locations[0]) : null;
      const bin = new Map();
      if (manifest) {
        for (const [name, value] of manifest.bin) {
          const target = ppath.join(locations[0], value);
          if (value !== `` && xfs.existsSync(target)) {
            bin.set(name, value);
          }
        }
      }
      locatorScriptMap.set(locatorKey, bin);
    }
    const binSymlinks = new Map();
    const getBinSymlinks = (location, parentLocatorLocation, node) => {
      const symlinks = new Map();
      const internalPath = ppath.contains(projectRoot, location);
      if (node.locator && internalPath !== null) {
        const binScripts = locatorScriptMap.get(node.locator);
        for (const [filename, scriptPath] of binScripts) {
          const symlinkTarget = ppath.join(location, npath.toPortablePath(scriptPath));
          symlinks.set(toFilename(filename), symlinkTarget);
        }
        for (const [childLocation, childNode] of node.children) {
          const absChildLocation = ppath.join(location, childLocation);
          const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);
          if (childSymlinks.size > 0) {
            binSymlinks.set(location, new Map([...binSymlinks.get(location) || new Map(), ...childSymlinks]));
          }
        }
      } else {
        for (const [childLocation, childNode] of node.children) {
          const childSymlinks = getBinSymlinks(ppath.join(location, childLocation), parentLocatorLocation, childNode);
          for (const [name, symlinkTarget] of childSymlinks) {
            symlinks.set(name, symlinkTarget);
          }
        }
      }
      return symlinks;
    };
    for (const [location, node] of locationTree) {
      const symlinks = getBinSymlinks(location, location, node);
      if (symlinks.size > 0) {
        binSymlinks.set(location, new Map([...binSymlinks.get(location) || new Map(), ...symlinks]));
      }
    }
    return binSymlinks;
  }
  var areRealLocatorsEqual = (locatorKey1, locatorKey2) => {
    if (!locatorKey1 || !locatorKey2)
      return locatorKey1 === locatorKey2;
    let locator1 = structUtils_exports.parseLocator(locatorKey1);
    if (structUtils_exports.isVirtualLocator(locator1))
      locator1 = structUtils_exports.devirtualizeLocator(locator1);
    let locator2 = structUtils_exports.parseLocator(locatorKey2);
    if (structUtils_exports.isVirtualLocator(locator2))
      locator2 = structUtils_exports.devirtualizeLocator(locator2);
    return structUtils_exports.areLocatorsEqual(locator1, locator2);
  };
  async function persistNodeModules(preinstallState, installState, {baseFs, project, report, loadManifest}) {
    const rootNmDirPath = ppath.join(project.cwd, NODE_MODULES3);
    const {locationTree: prevLocationTree, binSymlinks: prevBinSymlinks} = refineNodeModulesRoots(preinstallState.locationTree, preinstallState.binSymlinks);
    const locationTree = buildLocationTree(installState, {skipPrefix: project.cwd});
    const addQueue = [];
    const addModule = async ({srcDir, dstDir, linkType}) => {
      const promise = (async () => {
        try {
          if (linkType === LinkType.SOFT) {
            await xfs.mkdirPromise(ppath.dirname(dstDir), {recursive: true});
            await symlinkPromise(ppath.resolve(srcDir), dstDir);
          } else {
            await copyPromise2(dstDir, srcDir, {baseFs});
          }
        } catch (e) {
          e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
          throw e;
        } finally {
          progress.tick();
        }
      })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
      addQueue.push(promise);
      if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
        await Promise.race(addQueue);
      }
    };
    const cloneModule = async (srcDir, dstDir, options) => {
      const promise = (async () => {
        const cloneDir = async (srcDir2, dstDir2, options2) => {
          try {
            if (!options2 || !options2.innerLoop)
              await xfs.mkdirPromise(dstDir2, {recursive: true});
            const entries = await xfs.readdirPromise(srcDir2, {withFileTypes: true});
            for (const entry of entries) {
              if ((!options2 || !options2.innerLoop) && entry.name === DOT_BIN)
                continue;
              const src = ppath.join(srcDir2, entry.name);
              const dst = ppath.join(dstDir2, entry.name);
              if (entry.isDirectory()) {
                if (entry.name !== NODE_MODULES3 || options2 && options2.innerLoop) {
                  await xfs.mkdirPromise(dst, {recursive: true});
                  await cloneDir(src, dst, {innerLoop: true});
                }
              } else {
                await xfs.copyFilePromise(src, dst, import_fs11.default.constants.COPYFILE_FICLONE);
              }
            }
          } catch (e) {
            if (!options2 || !options2.innerLoop)
              e.message = `While cloning ${srcDir2} -> ${dstDir2} ${e.message}`;
            throw e;
          } finally {
            if (!options2 || !options2.innerLoop) {
              progress.tick();
            }
          }
        };
        await cloneDir(srcDir, dstDir, options);
      })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
      addQueue.push(promise);
      if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
        await Promise.race(addQueue);
      }
    };
    const removeOutdatedDirs = async (location, prevNode, node) => {
      if (!node) {
        if (prevNode.children.has(NODE_MODULES3))
          await removeDir(ppath.join(location, NODE_MODULES3), {contentsOnly: false});
        await removeDir(location, {contentsOnly: location === rootNmDirPath});
      } else {
        for (const [segment, prevChildNode] of prevNode.children) {
          const childNode = node.children.get(segment);
          await removeOutdatedDirs(ppath.join(location, segment), prevChildNode, childNode);
        }
      }
    };
    for (const [location, prevNode] of prevLocationTree) {
      const node = locationTree.get(location);
      for (const [segment, prevChildNode] of prevNode.children) {
        if (segment === `.`)
          continue;
        const childNode = node ? node.children.get(segment) : node;
        await removeOutdatedDirs(ppath.join(location, segment), prevChildNode, childNode);
      }
    }
    const cleanNewDirs = async (location, node, prevNode) => {
      if (!prevNode) {
        if (node.children.has(NODE_MODULES3))
          await removeDir(ppath.join(location, NODE_MODULES3), {contentsOnly: true});
        await removeDir(location, {contentsOnly: node.linkType === LinkType.HARD});
      } else {
        if (!areRealLocatorsEqual(node.locator, prevNode.locator))
          await removeDir(location, {contentsOnly: node.linkType === LinkType.HARD});
        for (const [segment, childNode] of node.children) {
          const prevChildNode = prevNode.children.get(segment);
          await cleanNewDirs(ppath.join(location, segment), childNode, prevChildNode);
        }
      }
    };
    for (const [location, node] of locationTree) {
      const prevNode = prevLocationTree.get(location);
      for (const [segment, childNode] of node.children) {
        if (segment === `.`)
          continue;
        const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
        await cleanNewDirs(ppath.join(location, segment), childNode, prevChildNode);
      }
    }
    const addList = [];
    for (const [prevLocator, {locations}] of preinstallState.locatorMap.entries()) {
      for (const location of locations) {
        const {locationRoot, segments} = parseLocation(location, {
          skipPrefix: project.cwd
        });
        let node = locationTree.get(locationRoot);
        let curLocation = locationRoot;
        if (node) {
          for (const segment of segments) {
            curLocation = ppath.join(curLocation, segment);
            node = node.children.get(segment);
            if (!node) {
              break;
            }
          }
          if (node && !areRealLocatorsEqual(node.locator, prevLocator)) {
            const info = installState.get(node.locator);
            const srcDir = info.target;
            const dstDir = curLocation;
            const linkType = info.linkType;
            if (srcDir !== dstDir) {
              addList.push({srcDir, dstDir, linkType});
            }
          }
        }
      }
    }
    for (const [locator, {locations}] of installState.entries()) {
      for (const location of locations) {
        const {locationRoot, segments} = parseLocation(location, {
          skipPrefix: project.cwd
        });
        let prevTreeNode = prevLocationTree.get(locationRoot);
        let node = locationTree.get(locationRoot);
        let curLocation = locationRoot;
        const info = installState.get(locator);
        const srcDir = info.target;
        const dstDir = location;
        if (srcDir === dstDir)
          continue;
        const linkType = info.linkType;
        for (const segment of segments)
          node = node.children.get(segment);
        if (!prevTreeNode) {
          addList.push({srcDir, dstDir, linkType});
        } else {
          for (const segment of segments) {
            curLocation = ppath.join(curLocation, segment);
            prevTreeNode = prevTreeNode.children.get(segment);
            if (!prevTreeNode) {
              addList.push({srcDir, dstDir, linkType});
              break;
            }
          }
        }
      }
    }
    const progress = Report.progressViaCounter(addList.length);
    const reportedProgress = report.reportProgress(progress);
    try {
      const persistedLocations = new Map();
      for (const entry of addList) {
        if (entry.linkType === LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
          persistedLocations.set(entry.srcDir, entry.dstDir);
          await addModule({...entry});
        }
      }
      await Promise.all(addQueue);
      addQueue.length = 0;
      for (const entry of addList) {
        const persistedDir = persistedLocations.get(entry.srcDir);
        if (entry.linkType !== LinkType.SOFT && entry.dstDir !== persistedDir) {
          await cloneModule(persistedDir, entry.dstDir);
        }
      }
      await Promise.all(addQueue);
      await xfs.mkdirPromise(rootNmDirPath, {recursive: true});
      const binSymlinks = await createBinSymlinkMap(installState, locationTree, project.cwd, {loadManifest});
      await persistBinSymlinks(prevBinSymlinks, binSymlinks);
      await writeInstallState(project, installState, binSymlinks);
    } finally {
      reportedProgress.stop();
    }
  }
  async function persistBinSymlinks(previousBinSymlinks, binSymlinks) {
    for (const location of previousBinSymlinks.keys()) {
      if (!binSymlinks.has(location)) {
        const binDir = ppath.join(location, NODE_MODULES3, DOT_BIN);
        await xfs.removePromise(binDir);
      }
    }
    for (const [location, symlinks] of binSymlinks) {
      const binDir = ppath.join(location, NODE_MODULES3, DOT_BIN);
      const prevSymlinks = previousBinSymlinks.get(location) || new Map();
      await xfs.mkdirPromise(binDir, {recursive: true});
      for (const name of prevSymlinks.keys()) {
        if (!symlinks.has(name)) {
          await xfs.removePromise(ppath.join(binDir, name));
          if (process.platform === `win32`) {
            await xfs.removePromise(ppath.join(binDir, toFilename(`${name}.cmd`)));
          }
        }
      }
      for (const [name, target] of symlinks) {
        const prevTarget = prevSymlinks.get(name);
        const symlinkPath = ppath.join(binDir, name);
        if (prevTarget === target)
          continue;
        if (process.platform === `win32`) {
          await import_cmd_shim.default(npath.fromPortablePath(target), npath.fromPortablePath(symlinkPath), {createPwshFile: false});
        } else {
          await xfs.removePromise(symlinkPath);
          await symlinkPromise(target, symlinkPath);
          await xfs.chmodPromise(target, 493);
        }
      }
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-6c4ffdc97c\1\packages\plugin-node-modules\sources\PnpLooseLinker.ts
  var PnpLooseLinker = class extends PnpLinker {
    constructor() {
      super(...arguments);
      this.mode = `loose`;
    }
    makeInstaller(opts) {
      return new PnpLooseInstaller(opts);
    }
  };
  var PnpLooseInstaller = class extends PnpInstaller {
    constructor() {
      super(...arguments);
      this.mode = `loose`;
    }
    async transformPnpSettings(pnpSettings) {
      const defaultFsLayer = new VirtualFS({
        baseFs: new ZipOpenFS({
          libzip: await getLibzipPromise(),
          maxOpenFiles: 80,
          readOnlyArchives: true
        })
      });
      const pnp2 = makeRuntimeApi(pnpSettings, this.opts.project.cwd, defaultFsLayer);
      const nmTree = buildNodeModulesTree(pnp2, {pnpifyFs: false, project: this.opts.project});
      const fallbackPool = new Map();
      pnpSettings.fallbackPool = fallbackPool;
      const registerFallback = (name, entry2) => {
        const locator = structUtils_exports.parseLocator(entry2.locator);
        const identStr = structUtils_exports.stringifyIdent(locator);
        if (identStr === name) {
          fallbackPool.set(name, locator.reference);
        } else {
          fallbackPool.set(name, [identStr, locator.reference]);
        }
      };
      const root = ppath.join(this.opts.project.cwd, Filename.nodeModules);
      const entry = nmTree.get(root);
      if (typeof entry === `undefined`)
        throw new Error(`Assertion failed: Expected a root junction point`);
      if (`target` in entry)
        throw new Error(`Assertion failed: Expected the root junction point to be a directory`);
      for (const childName of entry.dirList) {
        const childP = ppath.join(root, childName);
        const child = nmTree.get(childP);
        if (typeof child === `undefined`)
          throw new Error(`Assertion failed: Expected the child to have been registered`);
        if (`target` in child) {
          registerFallback(childName, child);
        } else {
          for (const subChildName of child.dirList) {
            const subChildP = ppath.join(childP, subChildName);
            const subChild = nmTree.get(subChildP);
            if (typeof subChild === `undefined`)
              throw new Error(`Assertion failed: Expected the subchild to have been registered`);
            if (`target` in subChild) {
              registerFallback(`${childName}/${subChildName}`, subChild);
            } else {
              throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
            }
          }
        }
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-6c4ffdc97c\1\packages\plugin-node-modules\sources\index.ts
  var plugin11 = {
    configuration: {
      nmHoistingLimits: {
        description: `Prevent packages can be hoisted past specific levels`,
        type: SettingsType.STRING,
        values: [
          NodeModulesHoistingLimits.WORKSPACES,
          NodeModulesHoistingLimits.DEPENDENCIES,
          NodeModulesHoistingLimits.NONE
        ],
        default: `none`
      }
    },
    linkers: [
      NodeModulesLinker,
      PnpLooseLinker
    ]
  };
  var sources_default13 = plugin11;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\index.ts
  var sources_exports29 = {};
  __export(sources_exports29, {
    default: () => sources_default17,
    npmConfigUtils: () => npmConfigUtils_exports,
    npmHttpUtils: () => npmHttpUtils_exports,
    npmPublishUtils: () => npmPublishUtils_exports2
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmHttpFetcher.ts
  var import_semver15 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\constants.ts
  var PROTOCOL2 = `npm:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\npmHttpUtils.ts
  var npmHttpUtils_exports = {};
  __export(npmHttpUtils_exports, {
    AuthType: () => AuthType,
    del: () => del2,
    get: () => get2,
    getIdentUrl: () => getIdentUrl,
    handleInvalidAuthenticationError: () => handleInvalidAuthenticationError,
    post: () => post2,
    put: () => put2
  });
  var import_enquirer3 = __toModule(require_enquirer());
  var import_url5 = __toModule(require("url"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\npmConfigUtils.ts
  var npmConfigUtils_exports = {};
  __export(npmConfigUtils_exports, {
    RegistryType: () => RegistryType,
    getAuthConfiguration: () => getAuthConfiguration,
    getDefaultRegistry: () => getDefaultRegistry,
    getPublishRegistry: () => getPublishRegistry,
    getRegistryConfiguration: () => getRegistryConfiguration,
    getScopeConfiguration: () => getScopeConfiguration,
    getScopeRegistry: () => getScopeRegistry,
    normalizeRegistry: () => normalizeRegistry
  });
  var RegistryType;
  (function(RegistryType3) {
    RegistryType3["FETCH_REGISTRY"] = `npmRegistryServer`;
    RegistryType3["PUBLISH_REGISTRY"] = `npmPublishRegistry`;
  })(RegistryType || (RegistryType = {}));
  function normalizeRegistry(registry) {
    return registry.replace(/\/$/, ``);
  }
  function getPublishRegistry(manifest, {configuration}) {
    if (manifest.publishConfig && manifest.publishConfig.registry)
      return normalizeRegistry(manifest.publishConfig.registry);
    if (manifest.name)
      return getScopeRegistry(manifest.name.scope, {configuration, type: RegistryType.PUBLISH_REGISTRY});
    return getDefaultRegistry({configuration, type: RegistryType.PUBLISH_REGISTRY});
  }
  function getScopeRegistry(scope, {configuration, type = RegistryType.FETCH_REGISTRY}) {
    const scopeConfiguration = getScopeConfiguration(scope, {configuration});
    if (scopeConfiguration === null)
      return getDefaultRegistry({configuration, type});
    const scopeRegistry = scopeConfiguration.get(type);
    if (scopeRegistry === null)
      return getDefaultRegistry({configuration, type});
    return normalizeRegistry(scopeRegistry);
  }
  function getDefaultRegistry({configuration, type = RegistryType.FETCH_REGISTRY}) {
    const defaultRegistry = configuration.get(type);
    if (defaultRegistry !== null)
      return normalizeRegistry(defaultRegistry);
    return normalizeRegistry(configuration.get(RegistryType.FETCH_REGISTRY));
  }
  function getRegistryConfiguration(registry, {configuration}) {
    const registryConfigurations = configuration.get(`npmRegistries`);
    const exactEntry = registryConfigurations.get(registry);
    if (typeof exactEntry !== `undefined`)
      return exactEntry;
    const noProtocolEntry = registryConfigurations.get(registry.replace(/^[a-z]+:/, ``));
    if (typeof noProtocolEntry !== `undefined`)
      return noProtocolEntry;
    return null;
  }
  function getScopeConfiguration(scope, {configuration}) {
    if (scope === null)
      return null;
    const scopeConfigurations = configuration.get(`npmScopes`);
    const scopeConfiguration = scopeConfigurations.get(scope);
    if (!scopeConfiguration)
      return null;
    return scopeConfiguration;
  }
  function getAuthConfiguration(registry, {configuration, ident}) {
    const scopeConfiguration = ident && getScopeConfiguration(ident.scope, {configuration});
    if ((scopeConfiguration == null ? void 0 : scopeConfiguration.get(`npmAuthIdent`)) || (scopeConfiguration == null ? void 0 : scopeConfiguration.get(`npmAuthToken`)))
      return scopeConfiguration;
    const registryConfiguration = getRegistryConfiguration(registry, {configuration});
    return registryConfiguration || configuration;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\npmHttpUtils.ts
  var AuthType;
  (function(AuthType3) {
    AuthType3[AuthType3["NO_AUTH"] = 0] = "NO_AUTH";
    AuthType3[AuthType3["BEST_EFFORT"] = 1] = "BEST_EFFORT";
    AuthType3[AuthType3["CONFIGURATION"] = 2] = "CONFIGURATION";
    AuthType3[AuthType3["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
  })(AuthType || (AuthType = {}));
  async function handleInvalidAuthenticationError(error, {attemptedAs, registry, headers, configuration}) {
    if (error.name === `HTTPError` && error.response.statusCode === 401) {
      throw new ReportError(MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami(registry, headers, {configuration})}` : `attempted as ${attemptedAs}`})`);
    }
  }
  function getIdentUrl(ident) {
    if (ident.scope) {
      return `/@${ident.scope}%2f${ident.name}`;
    } else {
      return `/${ident.name}`;
    }
  }
  async function get2(path6, {configuration, headers, ident, authType, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry(ident.scope, {configuration});
    if (ident && ident.scope && typeof authType === `undefined`)
      authType = 1;
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    let url;
    try {
      url = new import_url5.URL(path6);
    } catch (e) {
      url = new import_url5.URL(registry + path6);
    }
    try {
      return await httpUtils_exports.get(url.href, {configuration, headers, ...rest});
    } catch (error) {
      await handleInvalidAuthenticationError(error, {registry, configuration, headers});
      throw error;
    }
  }
  async function post2(path6, body, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.post(registry + path6, body, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError(error)) {
        await handleInvalidAuthenticationError(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp();
      const headersWithOtp = {...headers, ...getOtpHeaders(otp)};
      try {
        return await httpUtils_exports.post(`${registry}${path6}`, body, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  async function put2(path6, body, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.put(registry + path6, body, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError(error)) {
        await handleInvalidAuthenticationError(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp();
      const headersWithOtp = {...headers, ...getOtpHeaders(otp)};
      try {
        return await httpUtils_exports.put(`${registry}${path6}`, body, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  async function del2(path6, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.del(registry + path6, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError(error)) {
        await handleInvalidAuthenticationError(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp();
      const headersWithOtp = {...headers, ...getOtpHeaders(otp)};
      try {
        return await httpUtils_exports.del(`${registry}${path6}`, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  function getAuthenticationHeader(registry, {authType = 2, configuration, ident}) {
    const effectiveConfiguration = getAuthConfiguration(registry, {configuration, ident});
    const mustAuthenticate = shouldAuthenticate(effectiveConfiguration, authType);
    if (!mustAuthenticate)
      return null;
    if (effectiveConfiguration.get(`npmAuthToken`))
      return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
    if (effectiveConfiguration.get(`npmAuthIdent`))
      return `Basic ${effectiveConfiguration.get(`npmAuthIdent`)}`;
    if (mustAuthenticate && authType !== 1) {
      throw new ReportError(MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
    } else {
      return null;
    }
  }
  function shouldAuthenticate(authConfiguration, authType) {
    switch (authType) {
      case 2:
        return authConfiguration.get(`npmAlwaysAuth`);
      case 1:
      case 3:
        return true;
      case 0:
        return false;
      default:
        throw new Error(`Unreachable`);
    }
  }
  async function whoami(registry, headers, {configuration}) {
    var _a2;
    if (typeof headers === `undefined` || typeof headers.authorization === `undefined`)
      return `an anonymous user`;
    try {
      const response = await httpUtils_exports.get(new import_url5.URL(`${registry}/-/whoami`).href, {
        configuration,
        headers,
        jsonResponse: true
      });
      return (_a2 = response.username) != null ? _a2 : `an unknown user`;
    } catch {
      return `an unknown user`;
    }
  }
  async function askForOtp() {
    if (process.env.TEST_ENV)
      return process.env.TEST_NPM_2FA_TOKEN || ``;
    const {otp} = await import_enquirer3.prompt({
      type: `password`,
      name: `otp`,
      message: `One-time password:`,
      required: true,
      onCancel: () => process.exit(130)
    });
    return otp;
  }
  function isOtpError(error) {
    if (error.name !== `HTTPError`)
      return false;
    try {
      const authMethods = error.response.headers[`www-authenticate`].split(/,\s*/).map((s) => s.toLowerCase());
      return authMethods.includes(`otp`);
    } catch (e) {
      return false;
    }
  }
  function getOtpHeaders(otp) {
    return {
      [`npm-otp`]: otp
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmHttpFetcher.ts
  var NpmHttpFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL2))
        return false;
      const {selector, params} = structUtils_exports.parseRange(locator.reference);
      if (!import_semver15.default.valid(selector))
        return false;
      if (params === null || typeof params.__archiveUrl !== `string`)
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      const {params} = structUtils_exports.parseRange(locator.reference);
      if (params === null || typeof params.__archiveUrl !== `string`)
        throw new Error(`Assertion failed: The archiveUrl querystring parameter should have been available`);
      const sourceBuffer = await get2(params.__archiveUrl, {
        configuration: opts.project.configuration,
        ident: locator
      });
      return await tgzUtils_exports.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmRemapResolver.ts
  var NpmRemapResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL2))
        return false;
      if (!structUtils_exports.tryParseDescriptor(descriptor.range.slice(PROTOCOL2.length), true))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL2.length), true);
      return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL2.length), true);
      return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
    }
    async getSatisfying(descriptor, references, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL2.length), true);
      return opts.resolver.getSatisfying(nextDescriptor, references, opts);
    }
    resolve(locator, opts) {
      throw new Error(`Unreachable`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmSemverFetcher.ts
  var import_semver16 = __toModule(require_semver2());
  var import_url6 = __toModule(require("url"));
  var NpmSemverFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL2))
        return false;
      const url = new import_url6.URL(locator.reference);
      if (!import_semver16.default.valid(url.pathname))
        return false;
      if (url.searchParams.has(`__archiveUrl`))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      let sourceBuffer;
      try {
        sourceBuffer = await get2(NpmSemverFetcher.getLocatorUrl(locator), {
          configuration: opts.project.configuration,
          ident: locator
        });
      } catch (error) {
        sourceBuffer = await get2(NpmSemverFetcher.getLocatorUrl(locator).replace(/%2f/g, `/`), {
          configuration: opts.project.configuration,
          ident: locator
        });
      }
      return await tgzUtils_exports.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }
    static isConventionalTarballUrl(locator, url, {configuration}) {
      let registry = getScopeRegistry(locator.scope, {configuration});
      const path6 = NpmSemverFetcher.getLocatorUrl(locator);
      url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`);
      registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
      url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
      if (url === registry + path6)
        return true;
      if (url === registry + path6.replace(/%2f/g, `/`))
        return true;
      return false;
    }
    static getLocatorUrl(locator) {
      const version = import_semver16.default.clean(locator.reference.slice(PROTOCOL2.length));
      if (version === null)
        throw new ReportError(MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
      return `${getIdentUrl(locator)}/-/${locator.name}-${version}.tgz`;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmSemverResolver.ts
  var import_semver17 = __toModule(require_semver2());
  var NODE_GYP_IDENT = structUtils_exports.makeIdent(null, `node-gyp`);
  var NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
  var NpmSemverResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL2))
        return false;
      return !!semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL2.length));
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL2))
        return false;
      const {selector} = structUtils_exports.parseRange(locator.reference);
      if (!import_semver17.default.valid(selector))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const range = semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL2.length));
      if (range === null)
        throw new Error(`Expected a valid range, got ${descriptor.range.slice(PROTOCOL2.length)}`);
      const registryData = await get2(getIdentUrl(descriptor), {
        configuration: opts.project.configuration,
        ident: descriptor,
        jsonResponse: true
      });
      const candidates = miscUtils10.mapAndFilter(Object.keys(registryData.versions), (version) => {
        try {
          const candidate = new semverUtils_exports.SemVer(version);
          if (range.test(candidate)) {
            return candidate;
          }
        } catch {
        }
        return miscUtils10.mapAndFilter.skip;
      });
      const noDeprecatedCandidates = candidates.filter((version) => {
        return !registryData.versions[version.raw].deprecated;
      });
      const finalCandidates = noDeprecatedCandidates.length > 0 ? noDeprecatedCandidates : candidates;
      finalCandidates.sort((a, b) => {
        return -a.compare(b);
      });
      return finalCandidates.map((version) => {
        const versionLocator = structUtils_exports.makeLocator(descriptor, `${PROTOCOL2}${version.raw}`);
        const archiveUrl = registryData.versions[version.raw].dist.tarball;
        if (NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {configuration: opts.project.configuration})) {
          return versionLocator;
        } else {
          return structUtils_exports.bindLocator(versionLocator, {__archiveUrl: archiveUrl});
        }
      });
    }
    async getSatisfying(descriptor, references, opts) {
      const range = semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL2.length));
      if (range === null)
        throw new Error(`Expected a valid range, got ${descriptor.range.slice(PROTOCOL2.length)}`);
      return references.map((reference) => {
        try {
          return new semverUtils_exports.SemVer(reference.slice(PROTOCOL2.length));
        } catch {
          return null;
        }
      }).filter((version) => version !== null).filter((version) => range.test(version)).sort((a, b) => -a.compare(b)).map((version) => structUtils_exports.makeLocator(descriptor, `${PROTOCOL2}${version.raw}`));
    }
    async resolve(locator, opts) {
      const {selector} = structUtils_exports.parseRange(locator.reference);
      const version = import_semver17.default.clean(selector);
      if (version === null)
        throw new ReportError(MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
      const registryData = await get2(getIdentUrl(locator), {
        configuration: opts.project.configuration,
        ident: locator,
        jsonResponse: true
      });
      if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
        throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
      if (!Object.prototype.hasOwnProperty.call(registryData.versions, version))
        throw new ReportError(MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
      const manifest = new Manifest();
      manifest.load(registryData.versions[version]);
      if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
        for (const value of manifest.scripts.values()) {
          if (value.match(NODE_GYP_MATCH)) {
            manifest.dependencies.set(NODE_GYP_IDENT.identHash, structUtils_exports.makeDescriptor(NODE_GYP_IDENT, `latest`));
            opts.report.reportWarning(MessageName.NODE_GYP_INJECTED, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
            break;
          }
        }
      }
      if (typeof manifest.raw.deprecated === `string`)
        opts.report.reportWarning(MessageName.DEPRECATED_PACKAGE, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
      return {
        ...locator,
        version,
        languageName: `node`,
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\NpmTagResolver.ts
  var NpmTagResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL2))
        return false;
      if (!TAG_REGEXP.test(descriptor.range.slice(PROTOCOL2.length)))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const tag = descriptor.range.slice(PROTOCOL2.length);
      const registryData = await get2(getIdentUrl(descriptor), {
        configuration: opts.project.configuration,
        ident: descriptor,
        jsonResponse: true
      });
      if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`))
        throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
      const distTags = registryData[`dist-tags`];
      if (!Object.prototype.hasOwnProperty.call(distTags, tag))
        throw new ReportError(MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
      const version = distTags[tag];
      const versionLocator = structUtils_exports.makeLocator(descriptor, `${PROTOCOL2}${version}`);
      const archiveUrl = registryData.versions[version].dist.tarball;
      if (NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {configuration: opts.project.configuration})) {
        return [versionLocator];
      } else {
        return [structUtils_exports.bindLocator(versionLocator, {__archiveUrl: archiveUrl})];
      }
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      throw new Error(`Unreachable`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\npmPublishUtils.ts
  var npmPublishUtils_exports2 = {};
  __export(npmPublishUtils_exports2, {
    makePublishBody: () => makePublishBody2
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-42b46eedf7\1\packages\plugin-pack\sources\index.ts
  var sources_exports28 = {};
  __export(sources_exports28, {
    default: () => sources_default16,
    packUtils: () => packUtils_exports2
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\BaseCommand.ts
  var BaseCommand2 = class extends Command {
    constructor() {
      super(...arguments);
      this.cwd = options_exports.String(`--cwd`, {hidden: true});
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\WorkspaceRequiredError.ts
  var WorkspaceRequiredError2 = class extends UsageError {
    constructor(projectCwd, cwd) {
      const relativePath = ppath.relative(projectCwd, cwd);
      const manifestPath = ppath.join(projectCwd, Manifest.fileName);
      super(`This command can only be run from within a workspace of your project (${relativePath} isn't a workspace of ${manifestPath}).`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\getDynamicLibs.ts
  var semver18 = __toModule(require_semver2());
  var typanion2 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\getPluginConfiguration.ts
  var _7 = __toModule(require_semver2());
  var _8 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\add.ts
  var import_enquirer4 = __toModule(require_enquirer());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\suggestUtils.ts
  var import_semver18 = __toModule(require_semver2());
  var Target2;
  (function(Target3) {
    Target3["REGULAR"] = `dependencies`;
    Target3["DEVELOPMENT"] = `devDependencies`;
    Target3["PEER"] = `peerDependencies`;
  })(Target2 || (Target2 = {}));
  var Modifier2;
  (function(Modifier3) {
    Modifier3["CARET"] = `^`;
    Modifier3["TILDE"] = `~`;
    Modifier3["EXACT"] = ``;
  })(Modifier2 || (Modifier2 = {}));
  var Strategy3;
  (function(Strategy5) {
    Strategy5["KEEP"] = `keep`;
    Strategy5["REUSE"] = `reuse`;
    Strategy5["PROJECT"] = `project`;
    Strategy5["LATEST"] = `latest`;
    Strategy5["CACHE"] = `cache`;
  })(Strategy3 || (Strategy3 = {}));
  function getModifier2(flags, project) {
    if (flags.exact)
      return Modifier2.EXACT;
    if (flags.caret)
      return Modifier2.CARET;
    if (flags.tilde)
      return Modifier2.TILDE;
    return project.configuration.get(`defaultSemverRangePrefix`);
  }
  var SIMPLE_SEMVER2 = /^([\^~]?)[0-9]+(?:\.[0-9]+){0,2}(?:-\S+)?$/;
  function extractRangeModifier2(range, {project}) {
    const match2 = range.match(SIMPLE_SEMVER2);
    return match2 ? match2[1] : project.configuration.get(`defaultSemverRangePrefix`);
  }
  function applyModifier2(descriptor, modifier) {
    let {protocol, source, params, selector} = structUtils_exports.parseRange(descriptor.range);
    if (import_semver18.default.valid(selector))
      selector = `${modifier}${descriptor.range}`;
    return structUtils_exports.makeDescriptor(descriptor, structUtils_exports.makeRange({protocol, source, params, selector}));
  }
  async function findProjectDescriptors2(ident, {project, target}) {
    const matches = new Map();
    const getDescriptorEntry = (descriptor) => {
      let entry = matches.get(descriptor.descriptorHash);
      if (!entry) {
        matches.set(descriptor.descriptorHash, entry = {
          descriptor,
          locators: []
        });
      }
      return entry;
    };
    for (const workspace of project.workspaces) {
      if (target === Target2.PEER) {
        const peerDescriptor = workspace.manifest.peerDependencies.get(ident.identHash);
        if (peerDescriptor !== void 0) {
          getDescriptorEntry(peerDescriptor).locators.push(workspace.locator);
        }
      } else {
        const regularDescriptor = workspace.manifest.dependencies.get(ident.identHash);
        const developmentDescriptor = workspace.manifest.devDependencies.get(ident.identHash);
        if (target === Target2.DEVELOPMENT) {
          if (developmentDescriptor !== void 0) {
            getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
          } else if (regularDescriptor !== void 0) {
            getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
          }
        } else {
          if (regularDescriptor !== void 0) {
            getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
          } else if (developmentDescriptor !== void 0) {
            getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
          }
        }
      }
    }
    return matches;
  }
  async function extractDescriptorFromPath2(path6, {cwd, workspace}) {
    return await makeTemporaryCache2(async (cache2) => {
      if (!ppath.isAbsolute(path6)) {
        path6 = ppath.relative(workspace.cwd, ppath.resolve(cwd, path6));
        if (!path6.match(/^\.{0,2}\//)) {
          path6 = `./${path6}`;
        }
      }
      const {project} = workspace;
      const descriptor = await fetchDescriptorFrom2(structUtils_exports.makeIdent(null, `archive`), path6, {project: workspace.project, cache: cache2, workspace});
      if (!descriptor)
        throw new Error(`Assertion failed: The descriptor should have been found`);
      const report = new ThrowReport();
      const resolver = project.configuration.makeResolver();
      const fetcher = project.configuration.makeFetcher();
      const resolverOptions = {checksums: project.storedChecksums, project, cache: cache2, fetcher, report, resolver};
      const boundDescriptor = resolver.bindDescriptor(descriptor, workspace.anchoredLocator, resolverOptions);
      const locator = structUtils_exports.convertDescriptorToLocator(boundDescriptor);
      const fetchResult = await fetcher.fetch(locator, resolverOptions);
      const manifest = await Manifest.find(fetchResult.prefixPath, {baseFs: fetchResult.packageFs});
      if (!manifest.name)
        throw new Error(`Target path doesn't have a name`);
      return structUtils_exports.makeDescriptor(manifest.name, path6);
    });
  }
  async function getSuggestedDescriptors2(request2, {project, workspace, cache: cache2, target, modifier, strategies, maxResults = Infinity}) {
    if (!(maxResults >= 0))
      throw new Error(`Invalid maxResults (${maxResults})`);
    if (request2.range !== `unknown`) {
      return {
        suggestions: [{
          descriptor: request2,
          name: `Use ${structUtils_exports.prettyDescriptor(project.configuration, request2)}`,
          reason: `(unambiguous explicit request)`
        }],
        rejections: []
      };
    }
    const existing = typeof workspace !== `undefined` && workspace !== null ? workspace.manifest[target].get(request2.identHash) || null : null;
    const suggested = [];
    const rejected = [];
    const trySuggest = async (cb) => {
      try {
        await cb();
      } catch (e) {
        rejected.push(e);
      }
    };
    for (const strategy of strategies) {
      if (suggested.length >= maxResults)
        break;
      switch (strategy) {
        case Strategy3.KEEP:
          {
            await trySuggest(async () => {
              if (existing) {
                suggested.push({
                  descriptor: existing,
                  name: `Keep ${structUtils_exports.prettyDescriptor(project.configuration, existing)}`,
                  reason: `(no changes)`
                });
              }
            });
          }
          break;
        case Strategy3.REUSE:
          {
            await trySuggest(async () => {
              for (const {descriptor, locators} of (await findProjectDescriptors2(request2, {project, target})).values()) {
                if (locators.length === 1 && locators[0].locatorHash === workspace.anchoredLocator.locatorHash) {
                  if (strategies.includes(Strategy3.KEEP))
                    continue;
                }
                let reason = `(originally used by ${structUtils_exports.prettyLocator(project.configuration, locators[0])}`;
                reason += locators.length > 1 ? ` and ${locators.length - 1} other${locators.length > 2 ? `s` : ``})` : `)`;
                suggested.push({
                  descriptor,
                  name: `Reuse ${structUtils_exports.prettyDescriptor(project.configuration, descriptor)}`,
                  reason
                });
              }
            });
          }
          break;
        case Strategy3.CACHE:
          {
            await trySuggest(async () => {
              for (const descriptor of project.storedDescriptors.values()) {
                if (descriptor.identHash === request2.identHash) {
                  suggested.push({
                    descriptor,
                    name: `Reuse ${structUtils_exports.prettyDescriptor(project.configuration, descriptor)}`,
                    reason: `(already used somewhere in the lockfile)`
                  });
                }
              }
            });
          }
          break;
        case Strategy3.PROJECT:
          {
            await trySuggest(async () => {
              if (workspace.manifest.name !== null && request2.identHash === workspace.manifest.name.identHash)
                return;
              const candidateWorkspace = project.tryWorkspaceByIdent(request2);
              if (candidateWorkspace === null)
                return;
              suggested.push({
                descriptor: candidateWorkspace.anchoredDescriptor,
                name: `Attach ${structUtils_exports.prettyWorkspace(project.configuration, candidateWorkspace)}`,
                reason: `(local workspace at ${candidateWorkspace.cwd})`
              });
            });
          }
          break;
        case Strategy3.LATEST:
          {
            await trySuggest(async () => {
              if (request2.range !== `unknown`) {
                suggested.push({
                  descriptor: request2,
                  name: `Use ${structUtils_exports.prettyRange(project.configuration, request2.range)}`,
                  reason: `(explicit range requested)`
                });
              } else if (target === Target2.PEER) {
                suggested.push({
                  descriptor: structUtils_exports.makeDescriptor(request2, `*`),
                  name: `Use *`,
                  reason: `(catch-all peer dependency pattern)`
                });
              } else if (!project.configuration.get(`enableNetwork`)) {
                suggested.push({
                  descriptor: null,
                  name: `Resolve from latest`,
                  reason: formatUtils_exports.pretty(project.configuration, `(unavailable because enableNetwork is toggled off)`, `grey`)
                });
              } else {
                let latest = await fetchDescriptorFrom2(request2, `latest`, {project, cache: cache2, workspace, preserveModifier: false});
                if (latest) {
                  latest = applyModifier2(latest, modifier);
                  suggested.push({
                    descriptor: latest,
                    name: `Use ${structUtils_exports.prettyDescriptor(project.configuration, latest)}`,
                    reason: `(resolved from latest)`
                  });
                }
              }
            });
          }
          break;
      }
    }
    return {
      suggestions: suggested.slice(0, maxResults),
      rejections: rejected.slice(0, maxResults)
    };
  }
  async function fetchDescriptorFrom2(ident, range, {project, cache: cache2, workspace, preserveModifier = true}) {
    const latestDescriptor = structUtils_exports.makeDescriptor(ident, range);
    const report = new ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const resolver = project.configuration.makeResolver();
    const fetchOptions = {project, fetcher, cache: cache2, checksums: project.storedChecksums, report, skipIntegrityCheck: true};
    const resolveOptions = {...fetchOptions, resolver, fetchOptions};
    const boundDescriptor = resolver.bindDescriptor(latestDescriptor, workspace.anchoredLocator, resolveOptions);
    const candidateLocators = await resolver.getCandidates(boundDescriptor, new Map(), resolveOptions);
    if (candidateLocators.length === 0)
      return null;
    const bestLocator = candidateLocators[0];
    let {protocol, source, params, selector} = structUtils_exports.parseRange(structUtils_exports.convertToManifestRange(bestLocator.reference));
    if (protocol === project.configuration.get(`defaultProtocol`))
      protocol = null;
    if (import_semver18.default.valid(selector) && preserveModifier !== false) {
      const referenceRange = typeof preserveModifier === `string` ? preserveModifier : latestDescriptor.range;
      const modifier = extractRangeModifier2(referenceRange, {project});
      selector = modifier + selector;
    }
    return structUtils_exports.makeDescriptor(bestLocator, structUtils_exports.makeRange({protocol, source, params, selector}));
  }
  async function makeTemporaryCache2(cb) {
    return await xfs.mktempPromise(async (cacheDir) => {
      const configuration = Configuration.create(cacheDir);
      configuration.useWithSource(cacheDir, {
        enableMirror: false,
        compressionLevel: 0
      }, cacheDir, {overwrite: true});
      return await cb(new Cache(cacheDir, {configuration, check: false, immutable: false}));
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\add.ts
  var AddCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.exact = options_exports.Boolean(`-E,--exact`, false, {
        description: `Don't use any semver modifier on the resolved range`
      });
      this.tilde = options_exports.Boolean(`-T,--tilde`, false, {
        description: `Use the \`~\` semver modifier on the resolved range`
      });
      this.caret = options_exports.Boolean(`-C,--caret`, false, {
        description: `Use the \`^\` semver modifier on the resolved range`
      });
      this.dev = options_exports.Boolean(`-D,--dev`, false, {
        description: `Add a package as a dev dependency`
      });
      this.peer = options_exports.Boolean(`-P,--peer`, false, {
        description: `Add a package as a peer dependency`
      });
      this.optional = options_exports.Boolean(`-O,--optional`, false, {
        description: `Add / upgrade a package to an optional regular / peer dependency`
      });
      this.preferDev = options_exports.Boolean(`--prefer-dev`, false, {
        description: `Add / upgrade a package to a dev dependency`
      });
      this.interactive = options_exports.Boolean(`-i,--interactive`, false, {
        description: `Reuse the specified package from other workspaces in the project`
      });
      this.cached = options_exports.Boolean(`--cached`, false, {
        description: `Reuse the highest version already used somewhere within the project`
      });
      this.packages = options_exports.Rest();
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const interactive = (_a2 = this.interactive) != null ? _a2 : configuration.get(`preferInteractive`);
      const modifier = getModifier2(this, project);
      const strategies = [
        ...interactive ? [
          Strategy3.REUSE
        ] : [],
        Strategy3.PROJECT,
        ...this.cached ? [
          Strategy3.CACHE
        ] : [],
        Strategy3.LATEST
      ];
      const maxResults = interactive ? Infinity : 1;
      const allSuggestions = await Promise.all(this.packages.map(async (pseudoDescriptor) => {
        const request2 = pseudoDescriptor.match(/^\.{0,2}\//) ? await extractDescriptorFromPath2(pseudoDescriptor, {cwd: this.context.cwd, workspace}) : structUtils_exports.parseDescriptor(pseudoDescriptor);
        const target = suggestTarget2(workspace, request2, {
          dev: this.dev,
          peer: this.peer,
          preferDev: this.preferDev,
          optional: this.optional
        });
        const suggestions = await getSuggestedDescriptors2(request2, {project, workspace, cache: cache2, target, modifier, strategies, maxResults});
        return [request2, suggestions, target];
      }));
      const checkReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout,
        suggestInstall: false
      }, async (report) => {
        for (const [request2, {suggestions, rejections}] of allSuggestions) {
          const nonNullSuggestions = suggestions.filter((suggestion) => {
            return suggestion.descriptor !== null;
          });
          if (nonNullSuggestions.length === 0) {
            const [firstError] = rejections;
            if (typeof firstError === `undefined`)
              throw new Error(`Assertion failed: Expected an error to have been set`);
            const prettyError = this.cli.error(firstError);
            if (!project.configuration.get(`enableNetwork`)) {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, request2)} can't be resolved to a satisfying range (note: network resolution has been disabled):

${prettyError}`);
            } else {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, request2)} can't be resolved to a satisfying range:

${prettyError}`);
            }
          }
        }
      });
      if (checkReport.hasErrors())
        return checkReport.exitCode();
      let askedQuestions = false;
      const afterWorkspaceDependencyAdditionList = [];
      const afterWorkspaceDependencyReplacementList = [];
      for (const [, {suggestions}, target] of allSuggestions) {
        let selected;
        const nonNullSuggestions = suggestions.filter((suggestion) => {
          return suggestion.descriptor !== null;
        });
        const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
        const areAllTheSame = nonNullSuggestions.every((suggestion) => structUtils_exports.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
        if (nonNullSuggestions.length === 1 || areAllTheSame) {
          selected = firstSuggestedDescriptor;
        } else {
          askedQuestions = true;
          ({answer: selected} = await import_enquirer4.prompt({
            type: `select`,
            name: `answer`,
            message: `Which range do you want to use?`,
            choices: suggestions.map(({descriptor, name, reason}) => descriptor ? {
              name,
              hint: reason,
              descriptor
            } : {
              name,
              hint: reason,
              disabled: true
            }),
            onCancel: () => process.exit(130),
            result(name) {
              return this.find(name, `descriptor`);
            },
            stdin: this.context.stdin,
            stdout: this.context.stdout
          }));
        }
        const current = workspace.manifest[target].get(selected.identHash);
        if (typeof current === `undefined` || current.descriptorHash !== selected.descriptorHash) {
          workspace.manifest[target].set(selected.identHash, selected);
          if (this.optional) {
            if (target === `dependencies`) {
              workspace.manifest.ensureDependencyMeta({
                ...selected,
                range: `unknown`
              }).optional = true;
            } else if (target === `peerDependencies`) {
              workspace.manifest.ensurePeerDependencyMeta({
                ...selected,
                range: `unknown`
              }).optional = true;
            }
          }
          if (typeof current === `undefined`) {
            afterWorkspaceDependencyAdditionList.push([
              workspace,
              target,
              selected,
              strategies
            ]);
          } else {
            afterWorkspaceDependencyReplacementList.push([
              workspace,
              target,
              current,
              selected
            ]);
          }
        }
      }
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyAddition, afterWorkspaceDependencyAdditionList);
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
      if (askedQuestions)
        this.context.stdout.write(`
`);
      const installReport = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeLogs: !this.context.quiet
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  AddCommand2.paths = [
    [`add`]
  ];
  AddCommand2.usage = Command.Usage({
    description: `add dependencies to the project`,
    details: `
      This command adds a package to the package.json for the nearest workspace.

      - If it didn't exist before, the package will by default be added to the regular \`dependencies\` field, but this behavior can be overriden thanks to the \`-D,--dev\` flag (which will cause the dependency to be added to the \`devDependencies\` field instead) and the \`-P,--peer\` flag (which will do the same but for \`peerDependencies\`).

      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your \`dependencies\` or \`devDependencies\` (it won't ever update \`peerDependencies\`, though).

      - If set, the \`--prefer-dev\` flag will operate as a more flexible \`-D,--dev\` in that it will add the package to your \`devDependencies\` if it isn't already listed in either \`dependencies\` or \`devDependencies\`, but it will also happily upgrade your \`dependencies\` if that's what you already use (whereas \`-D,--dev\` would throw an exception).

      - If set, the \`-O,--optional\` flag will add the package to the \`optionalDependencies\` field and, in combination with the \`-P,--peer\` flag, it will add the package as an optional peer dependency. If the package was already listed in your \`dependencies\`, it will be upgraded to \`optionalDependencies\`. If the package was already listed in your \`peerDependencies\`, in combination with the \`-P,--peer\` flag, it will be upgraded to an optional peer dependency: \`"peerDependenciesMeta": { "<package>": { "optional": true } }\`

      - If the added package doesn't specify a range at all its \`latest\` tag will be resolved and the returned version will be used to generate a new semver range (using the \`^\` modifier by default unless otherwise configured via the \`defaultSemverRangePrefix\` configuration, or the \`~\` modifier if \`-T,--tilde\` is specified, or no modifier at all if \`-E,--exact\` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use \`-P,--peer\` the default range will be \`*\` and won't be resolved at all.

      - If the added package specifies a range (such as \`^1.0.0\`, \`latest\`, or \`rc\`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as \`rc\` will be encoded as-is rather than being converted into a semver range).

      If the \`--cached\` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.

      If the \`-i,--interactive\` option is used (or if the \`preferInteractive\` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.

      For a compilation of all the supported protocols, please consult the dedicated page from our website: https://yarnpkg.com/features/protocols.
    `,
    examples: [[
      `Add a regular package to the current workspace`,
      `$0 add lodash`
    ], [
      `Add a specific version for a package to the current workspace`,
      `$0 add lodash@1.2.3`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using a URL`,
      `$0 add lodash@https://github.com/lodash/lodash`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol`,
      `$0 add lodash@github:lodash/lodash`
    ], [
      `Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)`,
      `$0 add lodash@lodash/lodash`
    ], [
      `Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)`,
      `$0 add lodash-es@lodash/lodash#es`
    ]]
  });
  var add_default2 = AddCommand2;
  function suggestTarget2(workspace, ident, {dev, peer, preferDev, optional}) {
    const hasRegular = workspace.manifest[Target2.REGULAR].has(ident.identHash);
    const hasDev = workspace.manifest[Target2.DEVELOPMENT].has(ident.identHash);
    const hasPeer = workspace.manifest[Target2.PEER].has(ident.identHash);
    if ((dev || peer) && hasRegular)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);
    if (!dev && !peer && hasPeer)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);
    if (optional && hasDev)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);
    if (optional && !peer && hasPeer)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);
    if ((dev || preferDev) && optional)
      throw new UsageError(`Package "${structUtils_exports.prettyIdent(workspace.project.configuration, ident)}" cannot simultaneously be a dev dependency and an optional dependency`);
    if (peer)
      return Target2.PEER;
    if (dev || preferDev)
      return Target2.DEVELOPMENT;
    if (hasRegular)
      return Target2.REGULAR;
    if (hasDev)
      return Target2.DEVELOPMENT;
    return Target2.REGULAR;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\bin.ts
  var BinCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Print both the binary name and the locator of the package that provides the binary`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.name = options_exports.String({required: false});
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, locator} = await Project.find(configuration, this.context.cwd);
      await project.restoreInstallState();
      if (this.name) {
        const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(locator, {project});
        const binary = binaries.get(this.name);
        if (!binary)
          throw new UsageError(`Couldn't find a binary named "${this.name}" for package "${structUtils_exports.prettyLocator(configuration, locator)}"`);
        const [, binaryFile] = binary;
        this.context.stdout.write(`${binaryFile}
`);
        return 0;
      }
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(locator, {project});
        const keys = Array.from(binaries.keys());
        const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
        for (const [name, [pkg, binaryFile]] of binaries) {
          report2.reportJson({
            name,
            source: structUtils_exports.stringifyIdent(pkg),
            path: binaryFile
          });
        }
        if (this.verbose) {
          for (const [name, [pkg]] of binaries) {
            report2.reportInfo(null, `${name.padEnd(maxKeyLength, ` `)}   ${structUtils_exports.prettyLocator(configuration, pkg)}`);
          }
        } else {
          for (const name of binaries.keys()) {
            report2.reportInfo(null, name);
          }
        }
      });
      return report.exitCode();
    }
  };
  BinCommand2.paths = [
    [`bin`]
  ];
  BinCommand2.usage = Command.Usage({
    description: `get the path to a binary script`,
    details: `
      When used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the \`-v,--verbose\` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.

      When an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.
    `,
    examples: [[
      `List all the available binaries`,
      `$0 bin`
    ], [
      `Print the path to a specific binary`,
      `$0 bin eslint`
    ]]
  });
  var bin_default2 = BinCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\cache\clean.ts
  var CacheCleanCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.mirror = options_exports.Boolean(`--mirror`, false, {
        description: `Remove the global cache files instead of the local cache files`
      });
      this.all = options_exports.Boolean(`--all`, false, {
        description: `Remove both the global cache files and the local cache files of the current project`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const cache2 = await Cache.find(configuration);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async () => {
        const cleanMirror = (this.all || this.mirror) && cache2.mirrorCwd !== null;
        const cleanCache = !this.mirror;
        if (cleanMirror)
          await xfs.removePromise(cache2.mirrorCwd);
        if (cleanCache) {
          await xfs.removePromise(cache2.cwd);
        }
      });
      return report.exitCode();
    }
  };
  CacheCleanCommand2.paths = [
    [`cache`, `clean`],
    [`cache`, `clear`]
  ];
  CacheCleanCommand2.usage = Command.Usage({
    description: `remove the shared cache files`,
    details: `
      This command will remove all the files from the cache.
    `,
    examples: [[
      `Remove all the local archives`,
      `$0 cache clean`
    ], [
      `Remove all the archives stored in the ~/.yarn directory`,
      `$0 cache clean --mirror`
    ]]
  });
  var clean_default2 = CacheCleanCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\config\get.ts
  var import_get4 = __toModule(require_get());
  var import_util10 = __toModule(require("util"));
  var ConfigGetCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.unsafe = options_exports.Boolean(`--no-redacted`, false, {
        description: `Don't redact secrets (such as tokens) from the output`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const displayedValue = configuration.getSpecial(name, {
        hideSecrets: !this.unsafe,
        getNativePaths: true
      });
      const asObject = miscUtils10.convertMapsToIndexableObjects(displayedValue);
      const requestedObject = path6 ? import_get4.default(asObject, path6) : asObject;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportJson(requestedObject);
      });
      if (!this.json) {
        if (typeof requestedObject === `string`) {
          this.context.stdout.write(`${requestedObject}
`);
          return report.exitCode();
        }
        import_util10.inspect.styles.name = `cyan`;
        this.context.stdout.write(`${import_util10.inspect(requestedObject, {
          depth: Infinity,
          colors: configuration.get(`enableColors`),
          compact: false
        })}
`);
      }
      return report.exitCode();
    }
  };
  ConfigGetCommand2.paths = [
    [`config`, `get`]
  ];
  ConfigGetCommand2.usage = Command.Usage({
    description: `read a configuration settings`,
    details: `
      This command will print a configuration setting.

      Secrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the \`--no-redacted\` to get the untransformed value.
    `,
    examples: [[
      `Print a simple configuration setting`,
      `yarn config get yarnPath`
    ], [
      `Print a complex configuration setting`,
      `yarn config get packageExtensions`
    ], [
      `Print a nested field from the configuration`,
      `yarn config get 'npmScopes["my-company"].npmRegistryServer'`
    ], [
      `Print a token from the configuration`,
      `yarn config get npmAuthToken --no-redacted`
    ], [
      `Print a configuration setting as JSON`,
      `yarn config get packageExtensions --json`
    ]]
  });
  var get_default2 = ConfigGetCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\config\set.ts
  var import_cloneDeep3 = __toModule(require_cloneDeep());
  var import_get5 = __toModule(require_get());
  var import_set3 = __toModule(require_set2());
  var import_util11 = __toModule(require("util"));
  var ConfigSetCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Set complex configuration settings to JSON values`
      });
      this.home = options_exports.Boolean(`-H,--home`, false, {
        description: `Update the home configuration instead of the project configuration`
      });
      this.name = options_exports.String();
      this.value = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (!configuration.projectCwd)
        throw new UsageError(`This command must be run from within a project folder`);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*\.?/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const value = this.json ? JSON.parse(this.value) : this.value;
      const updateConfiguration = this.home ? (patch7) => Configuration.updateHomeConfiguration(patch7) : (patch7) => Configuration.updateConfiguration(configuration.projectCwd, patch7);
      await updateConfiguration((current) => {
        if (path6) {
          const clone2 = import_cloneDeep3.default(current);
          import_set3.default(clone2, this.name, value);
          return clone2;
        } else {
          return {
            ...current,
            [name]: value
          };
        }
      });
      const updatedConfiguration = await Configuration.find(this.context.cwd, this.context.plugins);
      const displayedValue = updatedConfiguration.getSpecial(name, {
        hideSecrets: true,
        getNativePaths: true
      });
      const asObject = miscUtils10.convertMapsToIndexableObjects(displayedValue);
      const requestedObject = path6 ? import_get5.default(asObject, path6) : asObject;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout
      }, async (report2) => {
        import_util11.inspect.styles.name = `cyan`;
        report2.reportInfo(MessageName.UNNAMED, `Successfully set ${this.name} to ${import_util11.inspect(requestedObject, {
          depth: Infinity,
          colors: configuration.get(`enableColors`),
          compact: false
        })}`);
      });
      return report.exitCode();
    }
  };
  ConfigSetCommand2.paths = [
    [`config`, `set`]
  ];
  ConfigSetCommand2.usage = Command.Usage({
    description: `change a configuration settings`,
    details: `
      This command will set a configuration setting.

      When used without the \`--json\` flag, it can only set a simple configuration setting (a string, a number, or a boolean).

      When used with the \`--json\` flag, it can set both simple and complex configuration settings, including Arrays and Objects.
    `,
    examples: [[
      `Set a simple configuration setting (a string, a number, or a boolean)`,
      `yarn config set initScope myScope`
    ], [
      `Set a simple configuration setting (a string, a number, or a boolean) using the \`--json\` flag`,
      `yarn config set initScope --json \\"myScope\\"`
    ], [
      `Set a complex configuration setting (an Array) using the \`--json\` flag`,
      `yarn config set unsafeHttpWhitelist --json '["*.example.com", "example.com"]'`
    ], [
      `Set a complex configuration setting (an Object) using the \`--json\` flag`,
      `yarn config set packageExtensions --json '{ "@babel/parser@*": { "dependencies": { "@babel/types": "*" } } }'`
    ], [
      `Set a nested configuration setting`,
      `yarn config set npmScopes.company.npmRegistryServer "https://npm.example.com"`
    ], [
      `Set a nested configuration setting using indexed access for non-simple keys`,
      `yarn config set 'npmRegistries["//npm.example.com"].npmAuthToken' "ffffffff-ffff-ffff-ffff-ffffffffffff"`
    ]]
  });
  var set_default2 = ConfigSetCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\config\unset.ts
  var import_cloneDeep4 = __toModule(require_cloneDeep());
  var import_unset3 = __toModule(require_unset());
  var ConfigUnsetCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.home = options_exports.Boolean(`-H,--home`, false, {
        description: `Update the home configuration instead of the project configuration`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (!configuration.projectCwd)
        throw new UsageError(`This command must be run from within a project folder`);
      const name = this.name.replace(/[.[].*$/, ``);
      const path6 = this.name.replace(/^[^.[]*\.?/, ``);
      const setting = configuration.settings.get(name);
      if (typeof setting === `undefined`)
        throw new UsageError(`Couldn't find a configuration settings named "${name}"`);
      const updateConfiguration = this.home ? (patch7) => Configuration.updateHomeConfiguration(patch7) : (patch7) => Configuration.updateConfiguration(configuration.projectCwd, patch7);
      await updateConfiguration((current) => {
        if (path6) {
          const clone2 = import_cloneDeep4.default(current);
          import_unset3.default(clone2, this.name);
          return clone2;
        } else {
          const next = import_unset3.default({...current}, name);
          return next;
        }
      });
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportInfo(MessageName.UNNAMED, `Successfully unset ${this.name}`);
      });
      return report.exitCode();
    }
  };
  ConfigUnsetCommand2.paths = [
    [`config`, `unset`]
  ];
  ConfigUnsetCommand2.usage = Command.Usage({
    description: `unset a configuration setting`,
    details: `
      This command will unset a configuration setting.
    `,
    examples: [[
      `Unset a simple configuration setting`,
      `yarn config unset initScope`
    ], [
      `Unset a complex configuration setting`,
      `yarn config unset packageExtensions`
    ], [
      `Unset a nested configuration setting`,
      `yarn config unset npmScopes.company.npmRegistryServer`
    ]]
  });
  var unset_default2 = ConfigUnsetCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\config.ts
  var import_util12 = __toModule(require("util"));
  var ConfigCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Print the setting description on top of the regular key/value information`
      });
      this.why = options_exports.Boolean(`--why`, false, {
        description: `Print the reason why a setting is set a particular way`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins, {
        strict: false
      });
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        if (configuration.invalid.size > 0 && !this.json) {
          for (const [key, source] of configuration.invalid)
            report2.reportError(MessageName.INVALID_CONFIGURATION_KEY, `Invalid configuration key "${key}" in ${source}`);
          report2.reportSeparator();
        }
        if (this.json) {
          const keys = miscUtils10.sortMap(configuration.settings.keys(), (key) => key);
          for (const key of keys) {
            const data = configuration.settings.get(key);
            const effective = configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            });
            const source = configuration.sources.get(key);
            if (this.verbose) {
              report2.reportJson({key, effective, source});
            } else {
              report2.reportJson({key, effective, source, ...data});
            }
          }
        } else {
          const keys = miscUtils10.sortMap(configuration.settings.keys(), (key) => key);
          const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
          const inspectConfig = {
            breakLength: Infinity,
            colors: configuration.get(`enableColors`),
            maxArrayLength: 2
          };
          if (this.why || this.verbose) {
            const keysAndDescriptions = keys.map((key) => {
              const setting = configuration.settings.get(key);
              if (!setting)
                throw new Error(`Assertion failed: This settings ("${key}") should have been registered`);
              const description = this.why ? configuration.sources.get(key) || `<default>` : setting.description;
              return [key, description];
            });
            const maxDescriptionLength = keysAndDescriptions.reduce((max, [, description]) => {
              return Math.max(max, description.length);
            }, 0);
            for (const [key, description] of keysAndDescriptions) {
              report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${description.padEnd(maxDescriptionLength, ` `)}   ${import_util12.inspect(configuration.getSpecial(key, {hideSecrets: true, getNativePaths: true}), inspectConfig)}`);
            }
          } else {
            for (const key of keys) {
              report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${import_util12.inspect(configuration.getSpecial(key, {hideSecrets: true, getNativePaths: true}), inspectConfig)}`);
            }
          }
        }
      });
      return report.exitCode();
    }
  };
  ConfigCommand2.paths = [
    [`config`]
  ];
  ConfigCommand2.usage = Command.Usage({
    description: `display the current configuration`,
    details: `
      This command prints the current active configuration settings.
    `,
    examples: [[
      `Print the active configuration settings`,
      `$0 config`
    ]]
  });
  var config_default2 = ConfigCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\dedupe.ts
  var t3 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\dedupeUtils.ts
  var import_micromatch8 = __toModule(require_micromatch());
  var Strategy4;
  (function(Strategy5) {
    Strategy5["HIGHEST"] = `highest`;
  })(Strategy4 || (Strategy4 = {}));
  var acceptedStrategies2 = new Set(Object.values(Strategy4));
  var DEDUPE_ALGORITHMS2 = {
    highest: async (project, patterns, {resolver, fetcher, resolveOptions, fetchOptions}) => {
      const locatorsByIdent = new Map();
      for (const [descriptorHash, locatorHash] of project.storedResolutions) {
        const descriptor = project.storedDescriptors.get(descriptorHash);
        if (typeof descriptor === `undefined`)
          throw new Error(`Assertion failed: The descriptor (${descriptorHash}) should have been registered`);
        miscUtils10.getSetWithDefault(locatorsByIdent, descriptor.identHash).add(locatorHash);
      }
      return Array.from(project.storedDescriptors.values(), async (descriptor) => {
        if (patterns.length && !import_micromatch8.default.isMatch(structUtils_exports.stringifyIdent(descriptor), patterns))
          return null;
        const currentResolution = project.storedResolutions.get(descriptor.descriptorHash);
        if (typeof currentResolution === `undefined`)
          throw new Error(`Assertion failed: The resolution (${descriptor.descriptorHash}) should have been registered`);
        const currentPackage = project.originalPackages.get(currentResolution);
        if (typeof currentPackage === `undefined`)
          return null;
        if (!resolver.shouldPersistResolution(currentPackage, resolveOptions))
          return null;
        const locators = locatorsByIdent.get(descriptor.identHash);
        if (typeof locators === `undefined`)
          throw new Error(`Assertion failed: The resolutions (${descriptor.identHash}) should have been registered`);
        if (locators.size === 1)
          return null;
        const references = [...locators].map((locatorHash) => {
          const pkg = project.originalPackages.get(locatorHash);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
          return pkg.reference;
        });
        const candidates = await resolver.getSatisfying(descriptor, references, resolveOptions);
        const bestCandidate = candidates == null ? void 0 : candidates[0];
        if (typeof bestCandidate === `undefined`)
          return null;
        const updatedResolution = bestCandidate.locatorHash;
        const updatedPackage = project.originalPackages.get(updatedResolution);
        if (typeof updatedPackage === `undefined`)
          throw new Error(`Assertion failed: The package (${updatedResolution}) should have been registered`);
        if (updatedResolution === currentResolution)
          return null;
        return {descriptor, currentPackage, updatedPackage};
      });
    }
  };
  async function dedupe2(project, {strategy, patterns, cache: cache2, report}) {
    const {configuration} = project;
    const throwReport = new ThrowReport();
    const resolver = configuration.makeResolver();
    const fetcher = configuration.makeFetcher();
    const fetchOptions = {
      cache: cache2,
      checksums: project.storedChecksums,
      fetcher,
      project,
      report: throwReport,
      skipIntegrityCheck: true
    };
    const resolveOptions = {
      project,
      resolver,
      report: throwReport,
      fetchOptions
    };
    return await report.startTimerPromise(`Deduplication step`, async () => {
      const algorithm = DEDUPE_ALGORITHMS2[strategy];
      const dedupePromises = await algorithm(project, patterns, {resolver, resolveOptions, fetcher, fetchOptions});
      const progress = Report.progressViaCounter(dedupePromises.length);
      report.reportProgress(progress);
      let dedupedPackageCount = 0;
      await Promise.all(dedupePromises.map((dedupePromise) => dedupePromise.then((dedupe3) => {
        if (dedupe3 === null)
          return;
        dedupedPackageCount++;
        const {descriptor, currentPackage, updatedPackage} = dedupe3;
        report.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyDescriptor(configuration, descriptor)} can be deduped from ${structUtils_exports.prettyLocator(configuration, currentPackage)} to ${structUtils_exports.prettyLocator(configuration, updatedPackage)}`);
        report.reportJson({
          descriptor: structUtils_exports.stringifyDescriptor(descriptor),
          currentResolution: structUtils_exports.stringifyLocator(currentPackage),
          updatedResolution: structUtils_exports.stringifyLocator(updatedPackage)
        });
        project.storedResolutions.set(descriptor.descriptorHash, updatedPackage.locatorHash);
      }).finally(() => progress.tick())));
      let packages;
      switch (dedupedPackageCount) {
        case 0:
          {
            packages = `No packages`;
          }
          break;
        case 1:
          {
            packages = `One package`;
          }
          break;
        default: {
          packages = `${dedupedPackageCount} packages`;
        }
      }
      const prettyStrategy = formatUtils_exports.pretty(configuration, strategy, formatUtils_exports.Type.CODE);
      report.reportInfo(MessageName.UNNAMED, `${packages} can be deduped using the ${prettyStrategy} strategy`);
      return dedupedPackageCount;
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\dedupe.ts
  var DedupeCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.strategy = options_exports.String(`-s,--strategy`, Strategy4.HIGHEST, {
        description: `The strategy to use when deduping dependencies`,
        validator: t3.isEnum(Strategy4)
      });
      this.check = options_exports.Boolean(`-c,--check`, false, {
        description: `Exit with exit code 1 when duplicates are found, without persisting the dependency tree`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      let dedupedPackageCount = 0;
      const dedupeReport = await StreamReport.start({
        configuration,
        includeFooter: false,
        stdout: this.context.stdout,
        json: this.json
      }, async (report) => {
        dedupedPackageCount = await dedupe2(project, {strategy: this.strategy, patterns: this.patterns, cache: cache2, report});
      });
      if (dedupeReport.hasErrors())
        return dedupeReport.exitCode();
      if (this.check) {
        return dedupedPackageCount ? 1 : 0;
      } else {
        const installReport = await StreamReport.start({
          configuration,
          stdout: this.context.stdout,
          json: this.json
        }, async (report) => {
          await project.install({cache: cache2, report});
        });
        return installReport.exitCode();
      }
    }
  };
  DedupeCommand2.paths = [
    [`dedupe`]
  ];
  DedupeCommand2.usage = Command.Usage({
    description: `deduplicate dependencies with overlapping ranges`,
    details: `
      Duplicates are defined as descriptors with overlapping ranges being resolved and locked to different locators. They are a natural consequence of Yarn's deterministic installs, but they can sometimes pile up and unnecessarily increase the size of your project.

      This command dedupes dependencies in the current project using different strategies (only one is implemented at the moment):

      - \`highest\`: Reuses (where possible) the locators with the highest versions. This means that dependencies can only be upgraded, never downgraded. It's also guaranteed that it never takes more than a single pass to dedupe the entire dependency tree.

      **Note:** Even though it never produces a wrong dependency tree, this command should be used with caution, as it modifies the dependency tree, which can sometimes cause problems when packages don't strictly follow semver recommendations. Because of this, it is recommended to also review the changes manually.

      If set, the \`-c,--check\` flag will only report the found duplicates, without persisting the modified dependency tree. If changes are found, the command will exit with a non-zero exit code, making it suitable for CI purposes.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      ### In-depth explanation:

      Yarn doesn't deduplicate dependencies by default, otherwise installs wouldn't be deterministic and the lockfile would be useless. What it actually does is that it tries to not duplicate dependencies in the first place.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@*\`will cause Yarn to reuse \`foo@2.3.4\`, even if the latest \`foo\` is actually \`foo@2.10.14\`, thus preventing unnecessary duplication.

      Duplication happens when Yarn can't unlock dependencies that have already been locked inside the lockfile.

      **Example:** If \`foo@^2.3.4\` (a dependency of a dependency) has already been resolved to \`foo@2.3.4\`, running \`yarn add foo@2.10.14\` will cause Yarn to install \`foo@2.10.14\` because the existing resolution doesn't satisfy the range \`2.10.14\`. This behavior can lead to (sometimes) unwanted duplication, since now the lockfile contains 2 separate resolutions for the 2 \`foo\` descriptors, even though they have overlapping ranges, which means that the lockfile can be simplified so that both descriptors resolve to \`foo@2.10.14\`.
    `,
    examples: [[
      `Dedupe all packages`,
      `$0 dedupe`
    ], [
      `Dedupe all packages using a specific strategy`,
      `$0 dedupe --strategy highest`
    ], [
      `Dedupe a specific package`,
      `$0 dedupe lodash`
    ], [
      `Dedupe all packages with the \`@babel/*\` scope`,
      `$0 dedupe '@babel/*'`
    ], [
      `Check for duplicates (can be used as a CI step)`,
      `$0 dedupe --check`
    ]]
  });
  var dedupe_default2 = DedupeCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\entries\clipanion.ts
  var ClipanionCommand2 = class extends Command {
    async execute() {
      const {plugins} = await Configuration.find(this.context.cwd, this.context.plugins);
      const pluginDefinitions = [];
      for (const plugin23 of plugins) {
        const {commands} = plugin23[1];
        if (commands) {
          const cli = Cli.from(commands);
          const definitions = cli.definitions();
          pluginDefinitions.push([plugin23[0], definitions]);
        }
      }
      const clipanionDefinitions = this.cli.definitions();
      const arePathsEqual = (path1, path22) => path1.split(` `).slice(1).join() === path22.split(` `).slice(1).join();
      const defaultPlugins = require_package2()[`@yarnpkg/builder`].bundles.standard;
      for (const pluginDefinition of pluginDefinitions) {
        const definitions = pluginDefinition[1];
        for (const definition of definitions) {
          clipanionDefinitions.find((clipanionDefinition) => arePathsEqual(clipanionDefinition.path, definition.path)).plugin = {
            name: pluginDefinition[0],
            isDefault: defaultPlugins.includes(pluginDefinition[0])
          };
        }
      }
      this.context.stdout.write(`${JSON.stringify({
        commands: clipanionDefinitions
      }, null, 2)}
`);
    }
  };
  ClipanionCommand2.paths = [
    [`--clipanion=definitions`]
  ];
  var clipanion_default2 = ClipanionCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\entries\help.ts
  var HelpCommand4 = class extends Command {
    async execute() {
      this.context.stdout.write(this.cli.usage(null));
    }
  };
  HelpCommand4.paths = [
    [`help`],
    [`--help`],
    [`-h`]
  ];
  var help_default2 = HelpCommand4;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\entries\run.ts
  var EntryCommand2 = class extends Command {
    constructor() {
      super(...arguments);
      this.leadingArgument = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      if (this.leadingArgument.match(/[\\/]/) && !structUtils_exports.tryParseIdent(this.leadingArgument)) {
        const newCwd = ppath.resolve(this.context.cwd, npath.toPortablePath(this.leadingArgument));
        return await this.cli.run(this.args, {cwd: newCwd});
      } else {
        return await this.cli.run([`run`, this.leadingArgument, ...this.args]);
      }
    }
  };
  var run_default3 = EntryCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\entries\version.ts
  var VersionCommand3 = class extends Command {
    async execute() {
      this.context.stdout.write(`${YarnVersion || `<unknown>`}
`);
    }
  };
  VersionCommand3.paths = [
    [`-v`],
    [`--version`]
  ];
  var version_default3 = VersionCommand3;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\exec.ts
  var ExecCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.commandName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      return await xfs.mktempPromise(async (binFolder) => {
        const {code} = await execUtils_exports.pipevp(this.commandName, this.args, {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr,
          env: await scriptUtils_exports.makeScriptEnv({project, binFolder})
        });
        return code;
      });
    }
  };
  ExecCommand2.paths = [
    [`exec`]
  ];
  ExecCommand2.usage = Command.Usage({
    description: `execute a shell command`,
    details: `
      This command simply executes a shell binary within the context of the root directory of the active workspace.

      It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).
    `,
    examples: [[
      `Execute a shell command`,
      `$0 exec echo Hello World`
    ]]
  });
  var exec_default2 = ExecCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\explain\peerRequirements.ts
  var t4 = __toModule(require_lib());
  var ExplainPeerRequirementsCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.hash = options_exports.String({
        required: false,
        validator: t4.applyCascade(t4.isString(), [
          t4.matchesRegExp(/^p[0-9a-f]{5}$/)
        ])
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      await project.applyLightResolution();
      if (typeof this.hash !== `undefined`) {
        return await explainPeerRequirements2(this.hash, project, {
          stdout: this.context.stdout
        });
      }
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeFooter: false
      }, async (report2) => {
        var _a2;
        const sortCriterias = [
          ([, requirement]) => structUtils_exports.stringifyLocator(project.storedPackages.get(requirement.subject)),
          ([, requirement]) => structUtils_exports.stringifyIdent(requirement.requested)
        ];
        for (const [hash, requirement] of miscUtils10.sortMap(project.peerRequirements, sortCriterias)) {
          const subject = project.storedPackages.get(requirement.subject);
          if (typeof subject === `undefined`)
            throw new Error(`Assertion failed: Expected the subject package to have been registered`);
          const rootRequester = project.storedPackages.get(requirement.rootRequester);
          if (typeof rootRequester === `undefined`)
            throw new Error(`Assertion failed: Expected the root package to have been registered`);
          const providedDescriptor = (_a2 = subject.dependencies.get(requirement.requested.identHash)) != null ? _a2 : null;
          const prettyHash = formatUtils_exports.pretty(configuration, hash, formatUtils_exports.Type.CODE);
          const prettySubject = structUtils_exports.prettyLocator(configuration, subject);
          const prettyIdent2 = structUtils_exports.prettyIdent(configuration, requirement.requested);
          const prettyRoot = structUtils_exports.prettyIdent(configuration, rootRequester);
          const descendantCount = requirement.allRequesters.length - 1;
          const pluralized = `descendant${descendantCount === 1 ? `` : `s`}`;
          const maybeDescendants = descendantCount > 0 ? ` and ${descendantCount} ${pluralized}` : ``;
          const provides = providedDescriptor !== null ? `provides` : `doesn't provide`;
          report2.reportInfo(null, `${prettyHash} \u2192 ${prettySubject} ${provides} ${prettyIdent2} to ${prettyRoot}${maybeDescendants}`);
        }
      });
      return report.exitCode();
    }
  };
  ExplainPeerRequirementsCommand2.paths = [
    [`explain`, `peer-requirements`]
  ];
  ExplainPeerRequirementsCommand2.usage = Command.Usage({
    description: `explain a set of peer requirements`,
    details: `
      A set of peer requirements represents all peer requirements that a dependent must satisfy when providing a given peer request to a requester and its descendants.

      When the hash argument is specified, this command prints a detailed explanation of all requirements of the set corresponding to the hash and whether they're satisfied or not.

      When used without arguments, this command lists all sets of peer requirements and the corresponding hash that can be used to get detailed information about a given set.

      **Note:** A hash is a six-letter p-prefixed code that can be obtained from peer dependency warnings or from the list of all peer requirements (\`yarn explain peer-requirements\`).
    `,
    examples: [[
      `Explain the corresponding set of peer requirements for a hash`,
      `$0 explain peer-requirements p1a4ed`
    ], [
      `List all sets of peer requirements`,
      `$0 explain peer-requirements`
    ]]
  });
  var peerRequirements_default2 = ExplainPeerRequirementsCommand2;
  async function explainPeerRequirements2(peerRequirementsHash, project, opts) {
    const {configuration} = project;
    const requirement = project.peerRequirements.get(peerRequirementsHash);
    if (typeof requirement === `undefined`)
      throw new Error(`No peerDependency requirements found for hash: "${peerRequirementsHash}"`);
    const report = await StreamReport.start({
      configuration,
      stdout: opts.stdout,
      includeFooter: false
    }, async (report2) => {
      var _a2, _b;
      const subject = project.storedPackages.get(requirement.subject);
      if (typeof subject === `undefined`)
        throw new Error(`Assertion failed: Expected the subject package to have been registered`);
      const rootRequester = project.storedPackages.get(requirement.rootRequester);
      if (typeof rootRequester === `undefined`)
        throw new Error(`Assertion failed: Expected the root package to have been registered`);
      const providedDescriptor = (_a2 = subject.dependencies.get(requirement.requested.identHash)) != null ? _a2 : null;
      const providedResolution = providedDescriptor !== null ? project.storedResolutions.get(providedDescriptor.descriptorHash) : null;
      if (typeof providedResolution === `undefined`)
        throw new Error(`Assertion failed: Expected the resolution to have been registered`);
      const provided = providedResolution !== null ? project.storedPackages.get(providedResolution) : null;
      if (typeof provided === `undefined`)
        throw new Error(`Assertion failed: Expected the provided package to have been registered`);
      const allRequesters = [...requirement.allRequesters.values()].map((requesterHash) => {
        const pkg = project.storedPackages.get(requesterHash);
        if (typeof pkg === `undefined`)
          throw new Error(`Assertion failed: Expected the package to be registered`);
        const devirtualizedLocator = structUtils_exports.devirtualizeLocator(pkg);
        const devirtualizedPkg = project.storedPackages.get(devirtualizedLocator.locatorHash);
        if (typeof devirtualizedPkg === `undefined`)
          throw new Error(`Assertion failed: Expected the package to be registered`);
        const peerDependency = devirtualizedPkg.peerDependencies.get(requirement.requested.identHash);
        if (typeof peerDependency === `undefined`)
          throw new Error(`Assertion failed: Expected the peer dependency to be registered`);
        return {pkg, peerDependency};
      });
      if (provided !== null) {
        const satisfiesAllRanges = allRequesters.every(({peerDependency}) => {
          return semverUtils_exports.satisfiesWithPrereleases(provided.version, peerDependency.range);
        });
        report2.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyLocator(configuration, subject)} provides ${structUtils_exports.prettyLocator(configuration, provided)} with version ${structUtils_exports.prettyReference(configuration, (_b = provided.version) != null ? _b : `<missing>`)}, which ${satisfiesAllRanges ? `satisfies` : `doesn't satisfy`} the following requirements:`);
      } else {
        report2.reportInfo(MessageName.UNNAMED, `${structUtils_exports.prettyLocator(configuration, subject)} doesn't provide ${structUtils_exports.prettyIdent(configuration, requirement.requested)}, breaking the following requirements:`);
      }
      report2.reportSeparator();
      const Mark = formatUtils_exports.mark(configuration);
      const requirements = [];
      for (const {pkg, peerDependency} of miscUtils10.sortMap(allRequesters, (requester) => structUtils_exports.stringifyLocator(requester.pkg))) {
        const isSatisfied = provided !== null ? semverUtils_exports.satisfiesWithPrereleases(provided.version, peerDependency.range) : false;
        const mark2 = isSatisfied ? Mark.Check : Mark.Cross;
        requirements.push({
          stringifiedLocator: structUtils_exports.stringifyLocator(pkg),
          prettyLocator: structUtils_exports.prettyLocator(configuration, pkg),
          prettyRange: structUtils_exports.prettyRange(configuration, peerDependency.range),
          mark: mark2
        });
      }
      const maxStringifiedLocatorLength = Math.max(...requirements.map(({stringifiedLocator}) => stringifiedLocator.length));
      const maxPrettyRangeLength = Math.max(...requirements.map(({prettyRange: prettyRange2}) => prettyRange2.length));
      for (const {stringifiedLocator, prettyLocator: prettyLocator2, prettyRange: prettyRange2, mark: mark2} of miscUtils10.sortMap(requirements, ({stringifiedLocator: stringifiedLocator2}) => stringifiedLocator2)) {
        report2.reportInfo(null, `${prettyLocator2.padEnd(maxStringifiedLocatorLength + (prettyLocator2.length - stringifiedLocator.length), ` `)} \u2192 ${prettyRange2.padEnd(maxPrettyRangeLength, ` `)} ${mark2}`);
      }
      if (requirements.length > 1) {
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Note: these requirements start with ${structUtils_exports.prettyLocator(project.configuration, rootRequester)}`);
      }
    });
    return report.exitCode();
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\info.ts
  var import_micromatch9 = __toModule(require_micromatch());
  var InfoCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Print versions of a package from the whole project`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Print information for all packages, including transitive dependencies`
      });
      this.extra = options_exports.Array(`-X,--extra`, [], {
        description: `An array of requests of extra data provided by plugins`
      });
      this.cache = options_exports.Boolean(`--cache`, false, {
        description: `Print information about the cache entry of a package (path, size, checksum)`
      });
      this.dependents = options_exports.Boolean(`--dependents`, false, {
        description: `Print all dependents for each matching package`
      });
      this.manifest = options_exports.Boolean(`--manifest`, false, {
        description: `Print data obtained by looking at the package archive (license, homepage, ...)`
      });
      this.nameOnly = options_exports.Boolean(`--name-only`, false, {
        description: `Only print the name for the matching packages`
      });
      this.virtuals = options_exports.Boolean(`--virtuals`, false, {
        description: `Print each instance of the virtual packages`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace && !this.all)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const extraSet = new Set(this.extra);
      if (this.cache)
        extraSet.add(`cache`);
      if (this.dependents)
        extraSet.add(`dependents`);
      if (this.manifest)
        extraSet.add(`manifest`);
      const traverseWorkspace = (workspace2, {recursive}) => {
        const initialHash = workspace2.anchoredLocator.locatorHash;
        const seen = new Map();
        const pass = [initialHash];
        while (pass.length > 0) {
          const hash = pass.shift();
          if (seen.has(hash))
            continue;
          const pkg = project.storedPackages.get(hash);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: Expected the package to be registered`);
          seen.set(hash, pkg);
          if (structUtils_exports.isVirtualLocator(pkg))
            pass.push(structUtils_exports.devirtualizeLocator(pkg).locatorHash);
          if (!recursive && hash !== initialHash)
            continue;
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the resolution to be registered`);
            pass.push(resolution);
          }
        }
        return seen.values();
      };
      const traverseAllWorkspaces = ({recursive}) => {
        const aggregate = new Map();
        for (const workspace2 of project.workspaces)
          for (const pkg of traverseWorkspace(workspace2, {recursive}))
            aggregate.set(pkg.locatorHash, pkg);
        return aggregate.values();
      };
      const getLookupSet = ({all, recursive}) => {
        if (all && recursive)
          return project.storedPackages.values();
        if (all) {
          return traverseAllWorkspaces({recursive});
        } else {
          return traverseWorkspace(workspace, {recursive});
        }
      };
      const findSelectedSet = ({all, recursive}) => {
        const lookupSet = getLookupSet({all, recursive});
        const matchers = this.patterns.map((pattern) => {
          const patternLocator = structUtils_exports.parseLocator(pattern);
          const identRegex = import_micromatch9.default.makeRe(structUtils_exports.stringifyIdent(patternLocator));
          const patternIsVirtual = structUtils_exports.isVirtualLocator(patternLocator);
          const uvPatternLocator = patternIsVirtual ? structUtils_exports.devirtualizeLocator(patternLocator) : patternLocator;
          return (pkg) => {
            const stringifiedIdent = structUtils_exports.stringifyIdent(pkg);
            if (!identRegex.test(stringifiedIdent))
              return false;
            if (patternLocator.reference === `unknown`)
              return true;
            const pkgIsVirtual = structUtils_exports.isVirtualLocator(pkg);
            const uvPkgLocator = pkgIsVirtual ? structUtils_exports.devirtualizeLocator(pkg) : pkg;
            if (patternIsVirtual && pkgIsVirtual && patternLocator.reference !== pkg.reference)
              return false;
            if (uvPatternLocator.reference !== uvPkgLocator.reference)
              return false;
            return true;
          };
        });
        const sortedLookup2 = miscUtils10.sortMap([...lookupSet], (pkg) => {
          return structUtils_exports.stringifyLocator(pkg);
        });
        const selection2 = sortedLookup2.filter((pkg) => {
          return matchers.length === 0 || matchers.some((matcher) => matcher(pkg));
        });
        return {selection: selection2, sortedLookup: sortedLookup2};
      };
      const {selection, sortedLookup} = findSelectedSet({
        all: this.all,
        recursive: this.recursive
      });
      if (selection.length === 0)
        throw new UsageError(`No package matched your request`);
      const dependentMap = new Map();
      if (this.dependents) {
        for (const pkg of sortedLookup) {
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (typeof resolution === `undefined`)
              throw new Error(`Assertion failed: Expected the resolution to be registered`);
            miscUtils10.getArrayWithDefault(dependentMap, resolution).push(pkg);
          }
        }
      }
      const allInstances = new Map();
      for (const pkg of sortedLookup) {
        if (!structUtils_exports.isVirtualLocator(pkg))
          continue;
        const base = structUtils_exports.devirtualizeLocator(pkg);
        miscUtils10.getArrayWithDefault(allInstances, base.locatorHash).push(pkg);
      }
      const infoTreeChildren = {};
      const infoTree = {children: infoTreeChildren};
      const fetcher = configuration.makeFetcher();
      const fetcherOptions = {project, fetcher, cache: cache2, checksums: project.storedChecksums, report: new ThrowReport(), skipIntegrityCheck: true};
      const builtinInfoBuilders = [
        async (pkg, extra, registerData) => {
          var _a2, _b;
          if (!extra.has(`manifest`))
            return;
          const fetchResult = await fetcher.fetch(pkg, fetcherOptions);
          let manifest;
          try {
            manifest = await Manifest.find(fetchResult.prefixPath, {baseFs: fetchResult.packageFs});
          } finally {
            (_a2 = fetchResult.releaseFs) == null ? void 0 : _a2.call(fetchResult);
          }
          registerData(`Manifest`, {
            [`License`]: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, manifest.license),
            [`Homepage`]: formatUtils_exports.tuple(formatUtils_exports.Type.URL, (_b = manifest.raw.homepage) != null ? _b : null)
          });
        },
        async (pkg, extra, registerData) => {
          var _a2;
          if (!extra.has(`cache`))
            return;
          const checksum = (_a2 = project.storedChecksums.get(pkg.locatorHash)) != null ? _a2 : null;
          const cachePath = cache2.getLocatorPath(pkg, checksum);
          let stat;
          if (cachePath !== null) {
            try {
              stat = xfs.statSync(cachePath);
            } catch {
            }
          }
          const size = typeof stat !== `undefined` ? [stat.size, formatUtils_exports.Type.SIZE] : void 0;
          registerData(`Cache`, {
            [`Checksum`]: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, checksum),
            [`Path`]: formatUtils_exports.tuple(formatUtils_exports.Type.PATH, cachePath),
            [`Size`]: size
          });
        }
      ];
      for (const pkg of selection) {
        const isVirtual = structUtils_exports.isVirtualLocator(pkg);
        if (!this.virtuals && isVirtual)
          continue;
        const nodeChildren = {};
        const node = {
          value: [pkg, formatUtils_exports.Type.LOCATOR],
          children: nodeChildren
        };
        infoTreeChildren[structUtils_exports.stringifyLocator(pkg)] = node;
        if (this.nameOnly) {
          delete node.children;
          continue;
        }
        const instances = allInstances.get(pkg.locatorHash);
        if (typeof instances !== `undefined`) {
          nodeChildren.Instances = {
            label: `Instances`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NUMBER, instances.length)
          };
        }
        nodeChildren.Version = {
          label: `Version`,
          value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, pkg.version)
        };
        const registerData = (namespace, info) => {
          const namespaceNode = {};
          nodeChildren[namespace] = namespaceNode;
          if (Array.isArray(info)) {
            namespaceNode.children = info.map((value) => ({value}));
          } else {
            const namespaceChildren = {};
            namespaceNode.children = namespaceChildren;
            for (const [key, value] of Object.entries(info)) {
              if (typeof value === `undefined`)
                continue;
              namespaceChildren[key] = {
                label: key,
                value
              };
            }
          }
        };
        if (!isVirtual) {
          for (const infoBuilder of builtinInfoBuilders)
            await infoBuilder(pkg, extraSet, registerData);
          await configuration.triggerHook((hooks) => {
            return hooks.fetchPackageInfo;
          }, pkg, extraSet, registerData);
        }
        if (pkg.bin.size > 0 && !isVirtual) {
          registerData(`Exported Binaries`, [...pkg.bin.keys()].map((name) => {
            return formatUtils_exports.tuple(formatUtils_exports.Type.PATH, name);
          }));
        }
        const dependents = dependentMap.get(pkg.locatorHash);
        if (typeof dependents !== `undefined` && dependents.length > 0) {
          registerData(`Dependents`, dependents.map((dependent) => {
            return formatUtils_exports.tuple(formatUtils_exports.Type.LOCATOR, dependent);
          }));
        }
        if (pkg.dependencies.size > 0 && !isVirtual) {
          registerData(`Dependencies`, [...pkg.dependencies.values()].map((dependency) => {
            var _a2;
            const resolutionHash = project.storedResolutions.get(dependency.descriptorHash);
            const resolution = typeof resolutionHash !== `undefined` ? (_a2 = project.storedPackages.get(resolutionHash)) != null ? _a2 : null : null;
            return formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
              descriptor: dependency,
              locator: resolution
            });
          }));
        }
        if (pkg.peerDependencies.size > 0 && isVirtual) {
          registerData(`Peer dependencies`, [...pkg.peerDependencies.values()].map((peerDependency) => {
            var _a2, _b;
            const dependency = pkg.dependencies.get(peerDependency.identHash);
            const resolutionHash = typeof dependency !== `undefined` ? (_a2 = project.storedResolutions.get(dependency.descriptorHash)) != null ? _a2 : null : null;
            const resolution = resolutionHash !== null ? (_b = project.storedPackages.get(resolutionHash)) != null ? _b : null : null;
            return formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
              descriptor: peerDependency,
              locator: resolution
            });
          }));
        }
      }
      treeUtils_exports.emitTree(infoTree, {
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        separators: this.nameOnly ? 0 : 2
      });
    }
  };
  InfoCommand2.paths = [
    [`info`]
  ];
  InfoCommand2.usage = Command.Usage({
    description: `see information related to packages`,
    details: `
      This command prints various information related to the specified packages, accepting glob patterns.

      By default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the \`-A,--all\` flag. Adding the \`-R,--recursive\` flag will also report transitive dependencies.

      Some fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (\`--dependents\`, \`--manifest\`, \`--virtuals\`, ...) described in the option descriptions.

      Note that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use \`yarn why\` which will do just that (it also provides a \`-R,--recursive\` flag that may be of some help).
    `,
    examples: [[
      `Show information about Lodash`,
      `$0 info lodash`
    ]]
  });
  var info_default2 = InfoCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\install.ts
  var import_ci_info4 = __toModule(require_ci_info());
  var YarnCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.immutable = options_exports.Boolean(`--immutable`, {
        description: `Abort with an error exit code if the lockfile was to be modified`
      });
      this.immutableCache = options_exports.Boolean(`--immutable-cache`, {
        description: `Abort with an error exit code if the cache folder was to be modified`
      });
      this.checkCache = options_exports.Boolean(`--check-cache`, false, {
        description: `Always refetch the packages and ensure that their checksums are consistent`
      });
      this.inlineBuilds = options_exports.Boolean(`--inline-builds`, {
        description: `Verbosely print the output of the build steps of dependencies`
      });
      this.skipBuilds = options_exports.Boolean(`--skip-builds`, false, {
        description: `Skip the build step altogether`
      });
      this.cacheFolder = options_exports.String(`--cache-folder`, {hidden: true});
      this.frozenLockfile = options_exports.Boolean(`--frozen-lockfile`, {hidden: true});
      this.ignoreEngines = options_exports.Boolean(`--ignore-engines`, {hidden: true});
      this.nonInteractive = options_exports.Boolean(`--non-interactive`, {hidden: true});
      this.preferOffline = options_exports.Boolean(`--prefer-offline`, {hidden: true});
      this.production = options_exports.Boolean(`--production`, {hidden: true});
      this.registry = options_exports.String(`--registry`, {hidden: true});
      this.silent = options_exports.Boolean(`--silent`, {hidden: true});
    }
    async execute() {
      var _a2, _b, _c;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (typeof this.inlineBuilds !== `undefined`)
        configuration.useWithSource(`<cli>`, {enableInlineBuilds: this.inlineBuilds}, configuration.startingCwd, {overwrite: true});
      const isZeitNow = !!process.env.NOW_BUILDER;
      const isNetlify = !!process.env.NETLIFY;
      const isGCP = !!process.env.FUNCTION_TARGET || !!process.env.GOOGLE_RUNTIME;
      const reportDeprecation = async (message, {error}) => {
        const deprecationReport = await StreamReport.start({
          configuration,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          if (error) {
            report2.reportError(MessageName.DEPRECATED_CLI_SETTINGS, message);
          } else {
            report2.reportWarning(MessageName.DEPRECATED_CLI_SETTINGS, message);
          }
        });
        if (deprecationReport.hasErrors()) {
          return deprecationReport.exitCode();
        } else {
          return null;
        }
      };
      if (typeof this.ignoreEngines !== `undefined`) {
        const exitCode = await reportDeprecation(`The --ignore-engines option is deprecated; engine checking isn't a core feature anymore`, {
          error: !isZeitNow
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.registry !== `undefined`) {
        const exitCode = await reportDeprecation(`The --registry option is deprecated; prefer setting npmRegistryServer in your .yarnrc.yml file`, {
          error: false
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.preferOffline !== `undefined`) {
        const exitCode = await reportDeprecation(`The --prefer-offline flag is deprecated; use the --cached flag with 'yarn add' instead`, {
          error: !isZeitNow
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.production !== `undefined`) {
        const exitCode = await reportDeprecation(`The --production option is deprecated on 'install'; use 'yarn workspaces focus' instead`, {
          error: true
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.nonInteractive !== `undefined`) {
        const exitCode = await reportDeprecation(`The --non-interactive option is deprecated`, {
          error: !isGCP
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.frozenLockfile !== `undefined`) {
        const exitCode = await reportDeprecation(`The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead`, {
          error: !isGCP && !import_ci_info4.TRAVIS
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      if (typeof this.cacheFolder !== `undefined`) {
        const exitCode = await reportDeprecation(`The cache-folder option has been deprecated; use rc settings instead`, {
          error: !isNetlify
        });
        if (exitCode !== null) {
          return exitCode;
        }
      }
      const immutable = typeof this.immutable === `undefined` && typeof this.frozenLockfile === `undefined` ? (_a2 = configuration.get(`enableImmutableInstalls`)) != null ? _a2 : false : (_c = (_b = this.immutable) != null ? _b : this.frozenLockfile) != null ? _c : false;
      if (configuration.projectCwd !== null) {
        const fixReport = await StreamReport.start({
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          if (await autofixMergeConflicts2(configuration, immutable)) {
            report2.reportInfo(MessageName.AUTOMERGE_SUCCESS, `Automatically fixed merge conflicts \u{1F44D}`);
            report2.reportSeparator();
          }
        });
        if (fixReport.hasErrors()) {
          return fixReport.exitCode();
        }
      }
      if (configuration.projectCwd !== null) {
        const telemetryReport = await StreamReport.start({
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          includeFooter: false
        }, async (report2) => {
          var _a3;
          if ((_a3 = Configuration.telemetry) == null ? void 0 : _a3.isNew) {
            report2.reportInfo(MessageName.TELEMETRY_NOTICE, `Yarn will periodically gather anonymous telemetry: https://yarnpkg.com/advanced/telemetry`);
            report2.reportInfo(MessageName.TELEMETRY_NOTICE, `Run ${formatUtils_exports.pretty(configuration, `yarn config set --home enableTelemetry 0`, formatUtils_exports.Type.CODE)} to disable`);
            report2.reportSeparator();
          }
        });
        if (telemetryReport.hasErrors()) {
          return telemetryReport.exitCode();
        }
      }
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration, {immutable: this.immutableCache, check: this.checkCache});
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeLogs: true
      }, async (report2) => {
        await project.install({cache: cache2, report: report2, immutable, skipBuild: this.skipBuilds});
      });
      return report.exitCode();
    }
  };
  YarnCommand2.paths = [
    [`install`],
    Command.Default
  ];
  YarnCommand2.usage = Command.Usage({
    description: `install the project dependencies`,
    details: `
      This command setup your project if needed. The installation is splitted in four different steps that each have their own characteristics:

      - **Resolution:** First the package manager will resolve your dependencies. The exact way a dependency version is privileged over another isn't standardized outside of the regular semver guarantees. If a package doesn't resolve to what you would expect, check that all dependencies are correctly declared (also check our website for more information: ).

      - **Fetch:** Then we download all the dependencies if needed, and make sure that they're all stored within our cache (check the value of \`cacheFolder\` in \`yarn config\` to see where are stored the cache files).

      - **Link:** Then we send the dependency tree information to internal plugins tasked from writing them on the disk in some form (for example by generating the .pnp.cjs file you might know).

      - **Build:** Once the dependency tree has been written on the disk, the package manager will now be free to run the build scripts for all packages that might need it, in a topological order compatible with the way they depend on one another.

      Note that running this command is not part of the recommended workflow. Yarn supports zero-installs, which means that as long as you store your cache and your .pnp.cjs file inside your repository, everything will work without requiring any install right after cloning your repository or switching branches.

      If the \`--immutable\` option is set, Yarn will abort with an error exit code if the lockfile was to be modified (other paths can be added using the \`immutablePatterns\` configuration setting). For backward compatibility we offer an alias under the name of \`--frozen-lockfile\`, but it will be removed in a later release.

      If the \`--immutable-cache\` option is set, Yarn will abort with an error exit code if the cache folder was to be modified (either because files would be added, or because they'd be removed).

      If the \`--check-cache\` option is set, Yarn will always refetch the packages and will ensure that their checksum matches what's 1/ described in the lockfile 2/ inside the existing cache files (if present). This is recommended as part of your CI workflow if you're both following the Zero-Installs model and accepting PRs from third-parties, as they'd otherwise have the ability to alter the checked-in packages before submitting them.

      If the \`--inline-builds\` option is set, Yarn will verbosely print the output of the build steps of your dependencies (instead of writing them into individual files). This is likely useful mostly for debug purposes only when using Docker-like environments.

      If the \`--skip-builds\` option is set, Yarn will not run the build scripts at all. Note that this is different from setting \`enableScripts\` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.
    `,
    examples: [[
      `Install the project`,
      `$0 install`
    ], [
      `Validate a project when using Zero-Installs`,
      `$0 install --immutable --immutable-cache`
    ], [
      `Validate a project when using Zero-Installs (slightly safer if you accept external PRs)`,
      `$0 install --immutable --immutable-cache --check-cache`
    ]]
  });
  var install_default2 = YarnCommand2;
  var MERGE_CONFLICT_ANCESTOR2 = `|||||||`;
  var MERGE_CONFLICT_END2 = `>>>>>>>`;
  var MERGE_CONFLICT_SEP2 = `=======`;
  var MERGE_CONFLICT_START2 = `<<<<<<<`;
  async function autofixMergeConflicts2(configuration, immutable) {
    if (!configuration.projectCwd)
      return false;
    const lockfilePath = ppath.join(configuration.projectCwd, configuration.get(`lockfileFilename`));
    if (!await xfs.existsPromise(lockfilePath))
      return false;
    const file = await xfs.readFilePromise(lockfilePath, `utf8`);
    if (!file.includes(MERGE_CONFLICT_START2))
      return false;
    if (immutable)
      throw new ReportError(MessageName.AUTOMERGE_IMMUTABLE, `Cannot autofix a lockfile when running an immutable install`);
    const [left, right] = getVariants2(file);
    let parsedLeft;
    let parsedRight;
    try {
      parsedLeft = parseSyml(left);
      parsedRight = parseSyml(right);
    } catch (error) {
      throw new ReportError(MessageName.AUTOMERGE_FAILED_TO_PARSE, `The individual variants of the lockfile failed to parse`);
    }
    const merged = {
      ...parsedLeft,
      ...parsedRight
    };
    for (const [key, value] of Object.entries(merged))
      if (typeof value === `string`)
        delete merged[key];
    await xfs.changeFilePromise(lockfilePath, stringifySyml(merged), {
      automaticNewlines: true
    });
    return true;
  }
  function getVariants2(file) {
    const variants = [[], []];
    const lines = file.split(/\r?\n/g);
    let skip = false;
    while (lines.length > 0) {
      const line = lines.shift();
      if (typeof line === `undefined`)
        throw new Error(`Assertion failed: Some lines should remain`);
      if (line.startsWith(MERGE_CONFLICT_START2)) {
        while (lines.length > 0) {
          const conflictLine = lines.shift();
          if (typeof conflictLine === `undefined`)
            throw new Error(`Assertion failed: Some lines should remain`);
          if (conflictLine === MERGE_CONFLICT_SEP2) {
            skip = false;
            break;
          } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR2)) {
            skip = true;
            continue;
          } else {
            variants[0].push(conflictLine);
          }
        }
        while (lines.length > 0) {
          const conflictLine = lines.shift();
          if (typeof conflictLine === `undefined`)
            throw new Error(`Assertion failed: Some lines should remain`);
          if (conflictLine.startsWith(MERGE_CONFLICT_END2)) {
            break;
          } else {
            variants[1].push(conflictLine);
          }
        }
      } else {
        variants[0].push(line);
        variants[1].push(line);
      }
    }
    return [
      variants[0].join(`
`),
      variants[1].join(`
`)
    ];
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\link.ts
  var LinkCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Link all workspaces belonging to the target project to the current one`
      });
      this.private = options_exports.Boolean(`-p,--private`, false, {
        description: `Also link private workspaces belonging to the target project to the current one`
      });
      this.relative = options_exports.Boolean(`-r,--relative`, false, {
        description: `Link workspaces using relative paths instead of absolute paths`
      });
      this.destination = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const absoluteDestination = ppath.resolve(this.context.cwd, npath.toPortablePath(this.destination));
      const configuration2 = await Configuration.find(absoluteDestination, this.context.plugins);
      const {project: project2, workspace: workspace2} = await Project.find(configuration2, absoluteDestination);
      if (!workspace2)
        throw new WorkspaceRequiredError2(project2.cwd, absoluteDestination);
      const topLevelWorkspace = project.topLevelWorkspace;
      const linkedWorkspaces = [];
      if (this.all) {
        for (const workspace3 of project2.workspaces)
          if (workspace3.manifest.name && (!workspace3.manifest.private || this.private))
            linkedWorkspaces.push(workspace3);
        if (linkedWorkspaces.length === 0) {
          throw new UsageError(`No workspace found to be linked in the target project`);
        }
      } else {
        if (!workspace2.manifest.name)
          throw new UsageError(`The target workspace doesn't have a name and thus cannot be linked`);
        if (workspace2.manifest.private && !this.private)
          throw new UsageError(`The target workspace is marked private - use the --private flag to link it anyway`);
        linkedWorkspaces.push(workspace2);
      }
      for (const workspace3 of linkedWorkspaces) {
        const fullName = structUtils_exports.stringifyIdent(workspace3.locator);
        const target = this.relative ? ppath.relative(project.cwd, workspace3.cwd) : workspace3.cwd;
        topLevelWorkspace.manifest.resolutions.push({
          pattern: {descriptor: {fullName}},
          reference: `portal:${target}`
        });
      }
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  LinkCommand2.paths = [
    [`link`]
  ];
  LinkCommand2.usage = Command.Usage({
    description: `connect the local project to another one`,
    details: `
      This command will set a new \`resolutions\` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).

      There is no \`yarn unlink\` command. To unlink the workspaces from the current project one must revert the changes made to the \`resolutions\` field.
    `,
    examples: [[
      `Register a remote workspace for use in the current project`,
      `$0 link ~/ts-loader`
    ], [
      `Register all workspaces from a remote project for use in the current project`,
      `$0 link ~/jest --all`
    ]]
  });
  var link_default2 = LinkCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\node.ts
  var NodeCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.args = options_exports.Proxy();
    }
    async execute() {
      return this.cli.run([`exec`, `node`, ...this.args]);
    }
  };
  NodeCommand2.paths = [
    [`node`]
  ];
  NodeCommand2.usage = Command.Usage({
    description: `run node with the hook already setup`,
    details: `
      This command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).

      The Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.
    `,
    examples: [[
      `Run a Node script`,
      `$0 node ./my-script.js`
    ]]
  });
  var node_default2 = NodeCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\import\sources.ts
  var import_os8 = __toModule(require("os"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\set\version\sources.ts
  var import_os7 = __toModule(require("os"));
  var import_path18 = __toModule(require("path"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\set\version.ts
  var import_semver19 = __toModule(require_semver2());
  var SetVersionCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.onlyIfNeeded = options_exports.Boolean(`--only-if-needed`, false, {
        description: `Only lock the Yarn version if it isn't already locked`
      });
      this.version = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      if (configuration.get(`yarnPath`) && this.onlyIfNeeded)
        return 0;
      let bundleUrl;
      if (this.version === `latest` || this.version === `berry`)
        bundleUrl = `https://github.com/yarnpkg/berry/raw/master/packages/yarnpkg-cli/bin/yarn.js`;
      else if (this.version === `classic`)
        bundleUrl = `https://nightly.yarnpkg.com/latest.js`;
      else if (semverUtils_exports.satisfiesWithPrereleases(this.version, `>=2.0.0`))
        bundleUrl = `https://github.com/yarnpkg/berry/raw/%40yarnpkg/cli/${this.version}/packages/yarnpkg-cli/bin/yarn.js`;
      else if (semverUtils_exports.satisfiesWithPrereleases(this.version, `^0.x || ^1.x`))
        bundleUrl = `https://github.com/yarnpkg/yarn/releases/download/v${this.version}/yarn-${this.version}.js`;
      else if (import_semver19.default.validRange(this.version))
        throw new UsageError(`Support for ranges got removed - please use the exact version you want to install, or 'latest' to get the latest build available`);
      else
        throw new UsageError(`Invalid version descriptor "${this.version}"`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        report2.reportInfo(MessageName.UNNAMED, `Downloading ${formatUtils_exports.pretty(configuration, bundleUrl, `green`)}`);
        const bundleBuffer = await httpUtils_exports.get(bundleUrl, {configuration});
        await setVersion2(configuration, null, bundleBuffer, {report: report2});
      });
      return report.exitCode();
    }
  };
  SetVersionCommand2.paths = [
    [`set`, `version`]
  ];
  SetVersionCommand2.usage = Command.Usage({
    description: `lock the Yarn version used by the project`,
    details: `
      This command will download a specific release of Yarn directly from the Yarn GitHub repository, will store it inside your project, and will change the \`yarnPath\` settings from your project \`.yarnrc.yml\` file to point to the new file.

      A very good use case for this command is to enforce the version of Yarn used by the any single member of your team inside a same project - by doing this you ensure that you have control on Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting a different behavior than you.
    `,
    examples: [[
      `Download the latest release from the Yarn repository`,
      `$0 set version latest`
    ], [
      `Download the latest classic release from the Yarn repository`,
      `$0 set version classic`
    ], [
      `Download a specific Yarn 2 build`,
      `$0 set version 2.0.0-rc.30`
    ], [
      `Switch back to a specific Yarn 1 release`,
      `$0 set version 1.22.1`
    ]]
  });
  var version_default4 = SetVersionCommand2;
  async function setVersion2(configuration, bundleVersion, bundleBuffer, {report}) {
    const projectCwd = configuration.projectCwd ? configuration.projectCwd : configuration.startingCwd;
    if (bundleVersion === null) {
      await xfs.mktempPromise(async (tmpDir) => {
        const temporaryPath = ppath.join(tmpDir, `yarn.cjs`);
        await xfs.writeFilePromise(temporaryPath, bundleBuffer);
        const {stdout} = await execUtils_exports.execvp(process.execPath, [npath.fromPortablePath(temporaryPath), `--version`], {
          cwd: projectCwd,
          env: {...process.env, YARN_IGNORE_PATH: `1`}
        });
        bundleVersion = stdout.trim();
        if (!import_semver19.default.valid(bundleVersion)) {
          throw new Error(`Invalid semver version`);
        }
      });
    }
    const releaseFolder = ppath.resolve(projectCwd, `.yarn/releases`);
    const absolutePath = ppath.resolve(releaseFolder, `yarn-${bundleVersion}.cjs`);
    const displayPath = ppath.relative(configuration.startingCwd, absolutePath);
    const projectPath = ppath.relative(projectCwd, absolutePath);
    const yarnPath = configuration.get(`yarnPath`);
    const updateConfig = yarnPath === null || yarnPath.startsWith(`${releaseFolder}/`);
    report.reportInfo(MessageName.UNNAMED, `Saving the new release in ${formatUtils_exports.pretty(configuration, displayPath, `magenta`)}`);
    await xfs.removePromise(ppath.dirname(absolutePath));
    await xfs.mkdirPromise(ppath.dirname(absolutePath), {recursive: true});
    await xfs.writeFilePromise(absolutePath, bundleBuffer);
    await xfs.chmodPromise(absolutePath, 493);
    if (updateConfig) {
      await Configuration.updateConfiguration(projectCwd, {
        yarnPath: projectPath
      });
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\set\version\sources.ts
  var PR_REGEXP2 = /^[0-9]+$/;
  function getBranchRef2(branch) {
    if (PR_REGEXP2.test(branch)) {
      return `pull/${branch}/head`;
    } else {
      return branch;
    }
  }
  var cloneWorkflow2 = ({repository, branch}, target) => [
    [`git`, `init`, npath.fromPortablePath(target)],
    [`git`, `remote`, `add`, `origin`, repository],
    [`git`, `fetch`, `origin`, getBranchRef2(branch)],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`]
  ];
  var updateWorkflow2 = ({branch}) => [
    [`git`, `fetch`, `origin`, getBranchRef2(branch), `--force`],
    [`git`, `reset`, `--hard`, `FETCH_HEAD`],
    [`git`, `clean`, `-dfx`]
  ];
  var buildWorkflow3 = ({plugins, noMinify}, target) => [
    [`yarn`, `build:cli`, ...new Array().concat(...plugins.map((plugin23) => [`--plugin`, import_path18.default.resolve(target, plugin23)])), ...noMinify ? [`--no-minify`] : [], `|`]
  ];
  var SetVersionSourcesCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.installPath = options_exports.String(`--path`, {
        description: `The path where the repository should be cloned to`
      });
      this.repository = options_exports.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
        description: `The repository that should be cloned`
      });
      this.branch = options_exports.String(`--branch`, `master`, {
        description: `The branch of the repository that should be cloned`
      });
      this.plugins = options_exports.Array(`--plugin`, [], {
        description: `An array of additional plugins that should be included in the bundle`
      });
      this.noMinify = options_exports.Boolean(`--no-minify`, false, {
        description: `Build a bundle for development (debugging) - non-minified and non-mangled`
      });
      this.force = options_exports.Boolean(`-f,--force`, false, {
        description: `Always clone the repository instead of trying to fetch the latest commits`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const target = typeof this.installPath !== `undefined` ? ppath.resolve(this.context.cwd, npath.toPortablePath(this.installPath)) : ppath.resolve(npath.toPortablePath(import_os7.tmpdir()), `yarnpkg-sources`, hashUtils_exports.makeHash(this.repository).slice(0, 6));
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await prepareRepo2(this, {configuration, report: report2, target});
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Building a fresh bundle`);
        report2.reportSeparator();
        await runWorkflow2(buildWorkflow3(this, target), {configuration, context: this.context, target});
        report2.reportSeparator();
        const bundlePath = ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
        const bundleBuffer = await xfs.readFilePromise(bundlePath);
        await setVersion2(configuration, `sources`, bundleBuffer, {
          report: report2
        });
      });
      return report.exitCode();
    }
  };
  SetVersionSourcesCommand2.paths = [
    [`set`, `version`, `from`, `sources`]
  ];
  SetVersionSourcesCommand2.usage = Command.Usage({
    description: `build Yarn from master`,
    details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.
    `,
    examples: [[
      `Build Yarn from master`,
      `$0 set version from sources`
    ]]
  });
  var sources_default14 = SetVersionSourcesCommand2;
  async function runWorkflow2(workflow, {configuration, context, target}) {
    for (const [fileName, ...args] of workflow) {
      const usePipe = args[args.length - 1] === `|`;
      if (usePipe)
        args.pop();
      if (usePipe) {
        await execUtils_exports.pipevp(fileName, args, {
          cwd: target,
          stdin: context.stdin,
          stdout: context.stdout,
          stderr: context.stderr,
          strict: true
        });
      } else {
        context.stdout.write(`${formatUtils_exports.pretty(configuration, `  $ ${[fileName, ...args].join(` `)}`, `grey`)}
`);
        try {
          await execUtils_exports.execvp(fileName, args, {
            cwd: target,
            strict: true
          });
        } catch (error) {
          context.stdout.write(error.stdout || error.stack);
          throw error;
        }
      }
    }
  }
  async function prepareRepo2(spec, {configuration, report, target}) {
    let ready = false;
    if (!spec.force && xfs.existsSync(ppath.join(target, `.git`))) {
      report.reportInfo(MessageName.UNNAMED, `Fetching the latest commits`);
      report.reportSeparator();
      try {
        await runWorkflow2(updateWorkflow2(spec), {configuration, context: spec.context, target});
        ready = true;
      } catch (error) {
        report.reportSeparator();
        report.reportWarning(MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
      }
    }
    if (!ready) {
      report.reportInfo(MessageName.UNNAMED, `Cloning the remote repository`);
      report.reportSeparator();
      await xfs.removePromise(target);
      await xfs.mkdirPromise(target, {recursive: true});
      await runWorkflow2(cloneWorkflow2(spec, target), {configuration, context: spec.context, target});
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\import.ts
  var import_url7 = __toModule(require("url"));
  var import_vm2 = __toModule(require("vm"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\list.ts
  var REMOTE_REGISTRY2 = `https://raw.githubusercontent.com/yarnpkg/berry/master/plugins.yml`;
  async function getAvailablePlugins2(configuration) {
    const raw = await httpUtils_exports.get(REMOTE_REGISTRY2, {configuration});
    const data = parseSyml(raw.toString());
    return data;
  }
  var PluginDlCommand3 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        const data = await getAvailablePlugins2(configuration);
        for (const [name, {experimental, ...rest}] of Object.entries(data)) {
          let label = name;
          if (experimental)
            label += ` [experimental]`;
          report2.reportJson({name, experimental, ...rest});
          report2.reportInfo(null, label);
        }
      });
      return report.exitCode();
    }
  };
  PluginDlCommand3.paths = [
    [`plugin`, `list`]
  ];
  PluginDlCommand3.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `list the available official plugins`,
    details: `
      This command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in \`yarn plugin import\`.
    `,
    examples: [[
      `List the official plugins`,
      `$0 plugin list`
    ]]
  });
  var list_default3 = PluginDlCommand3;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\import.ts
  var PluginDlCommand4 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const {project} = await Project.find(configuration, this.context.cwd);
        let pluginSpec;
        let pluginBuffer;
        if (this.name.match(/^\.{0,2}[\\/]/) || npath.isAbsolute(this.name)) {
          const candidatePath = ppath.resolve(this.context.cwd, npath.toPortablePath(this.name));
          report2.reportInfo(MessageName.UNNAMED, `Reading ${formatUtils_exports.pretty(configuration, candidatePath, formatUtils_exports.Type.PATH)}`);
          pluginSpec = ppath.relative(project.cwd, candidatePath);
          pluginBuffer = await xfs.readFilePromise(candidatePath);
        } else {
          let pluginUrl;
          if (this.name.match(/^https?:/)) {
            try {
              new import_url7.URL(this.name);
            } catch {
              throw new ReportError(MessageName.INVALID_PLUGIN_REFERENCE, `Plugin specifier "${this.name}" is neither a plugin name nor a valid url`);
            }
            pluginSpec = this.name;
            pluginUrl = this.name;
          } else {
            const ident = structUtils_exports.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
            const identStr = structUtils_exports.stringifyIdent(ident);
            const data = await getAvailablePlugins2(configuration);
            if (!Object.prototype.hasOwnProperty.call(data, identStr))
              throw new ReportError(MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be referenced by their name; any other plugin will have to be referenced through its public url (for example https://github.com/yarnpkg/berry/raw/master/packages/plugin-typescript/bin/%40yarnpkg/plugin-typescript.js).`);
            pluginSpec = identStr;
            pluginUrl = data[identStr].url;
          }
          report2.reportInfo(MessageName.UNNAMED, `Downloading ${formatUtils_exports.pretty(configuration, pluginUrl, `green`)}`);
          pluginBuffer = await httpUtils_exports.get(pluginUrl, {configuration});
        }
        await savePlugin2(pluginSpec, pluginBuffer, {project, report: report2});
      });
      return report.exitCode();
    }
  };
  PluginDlCommand4.paths = [
    [`plugin`, `import`]
  ];
  PluginDlCommand4.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `download a plugin`,
    details: `
      This command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.

      Three types of plugin references are accepted:

      - If the plugin is stored within the Yarn repository, it can be referenced by name.
      - Third-party plugins can be referenced directly through their public urls.
      - Local plugins can be referenced by their path on the disk.

      Plugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the \`@yarnpkg/builder\` package).
    `,
    examples: [[
      `Download and activate the "@yarnpkg/plugin-exec" plugin`,
      `$0 plugin import @yarnpkg/plugin-exec`
    ], [
      `Download and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
      `$0 plugin import exec`
    ], [
      `Download and activate a community plugin`,
      `$0 plugin import https://example.org/path/to/plugin.js`
    ], [
      `Activate a local plugin`,
      `$0 plugin import ./path/to/plugin.js`
    ]]
  });
  var import_default2 = PluginDlCommand4;
  async function savePlugin2(pluginSpec, pluginBuffer, {project, report}) {
    const {configuration} = project;
    const vmExports = {};
    const vmModule = {exports: vmExports};
    import_vm2.runInNewContext(pluginBuffer.toString(), {
      module: vmModule,
      exports: vmExports
    });
    const pluginName = vmModule.exports.name;
    const relativePath = `.yarn/plugins/${pluginName}.cjs`;
    const absolutePath = ppath.resolve(project.cwd, relativePath);
    report.reportInfo(MessageName.UNNAMED, `Saving the new plugin in ${formatUtils_exports.pretty(configuration, relativePath, `magenta`)}`);
    await xfs.mkdirPromise(ppath.dirname(absolutePath), {recursive: true});
    await xfs.writeFilePromise(absolutePath, pluginBuffer);
    const pluginMeta = {
      path: relativePath,
      spec: pluginSpec
    };
    await Configuration.updateConfiguration(project.cwd, (current) => {
      const plugins = [];
      let hasBeenReplaced = false;
      for (const entry of current.plugins || []) {
        const userProvidedPath = typeof entry !== `string` ? entry.path : entry;
        const pluginPath = ppath.resolve(project.cwd, npath.toPortablePath(userProvidedPath));
        const {name} = miscUtils10.dynamicRequire(npath.fromPortablePath(pluginPath));
        if (name !== pluginName) {
          plugins.push(entry);
        } else {
          plugins.push(pluginMeta);
          hasBeenReplaced = true;
        }
      }
      if (!hasBeenReplaced)
        plugins.push(pluginMeta);
      return {...current, plugins};
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\import\sources.ts
  var buildWorkflow4 = ({pluginName, noMinify}, target) => [
    [`yarn`, `build:${pluginName}`, ...noMinify ? [`--no-minify`] : [], `|`]
  ];
  var PluginDlSourcesCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.installPath = options_exports.String(`--path`, {
        description: `The path where the repository should be cloned to`
      });
      this.repository = options_exports.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
        description: `The repository that should be cloned`
      });
      this.branch = options_exports.String(`--branch`, `master`, {
        description: `The branch of the repository that should be cloned`
      });
      this.noMinify = options_exports.Boolean(`--no-minify`, false, {
        description: `Build a plugin for development (debugging) - non-minified and non-mangled`
      });
      this.force = options_exports.Boolean(`-f,--force`, false, {
        description: `Always clone the repository instead of trying to fetch the latest commits`
      });
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const target = typeof this.installPath !== `undefined` ? ppath.resolve(this.context.cwd, npath.toPortablePath(this.installPath)) : ppath.resolve(npath.toPortablePath(import_os8.tmpdir()), `yarnpkg-sources`, hashUtils_exports.makeHash(this.repository).slice(0, 6));
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const {project} = await Project.find(configuration, this.context.cwd);
        const ident = structUtils_exports.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
        const identStr = structUtils_exports.stringifyIdent(ident);
        const data = await getAvailablePlugins2(configuration);
        if (!Object.prototype.hasOwnProperty.call(data, identStr))
          throw new ReportError(MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be built and imported from sources.`);
        const pluginSpec = identStr;
        const pluginName = pluginSpec.replace(/@yarnpkg\//, ``);
        await prepareRepo2(this, {configuration, report: report2, target});
        report2.reportSeparator();
        report2.reportInfo(MessageName.UNNAMED, `Building a fresh ${pluginName}`);
        report2.reportSeparator();
        await runWorkflow2(buildWorkflow4({
          pluginName,
          noMinify: this.noMinify
        }, target), {configuration, context: this.context, target});
        report2.reportSeparator();
        const pluginPath = ppath.resolve(target, `packages/${pluginName}/bundles/${pluginSpec}.js`);
        const pluginBuffer = await xfs.readFilePromise(pluginPath);
        await savePlugin2(pluginSpec, pluginBuffer, {project, report: report2});
      });
      return report.exitCode();
    }
  };
  PluginDlSourcesCommand2.paths = [
    [`plugin`, `import`, `from`, `sources`]
  ];
  PluginDlSourcesCommand2.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `build a plugin from sources`,
    details: `
      This command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.

      The plugins can be referenced by their short name if sourced from the official Yarn repository.
    `,
    examples: [[
      `Build and activate the "@yarnpkg/plugin-exec" plugin`,
      `$0 plugin import from sources @yarnpkg/plugin-exec`
    ], [
      `Build and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
      `$0 plugin import from sources exec`
    ]]
  });
  var sources_default15 = PluginDlSourcesCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\remove.ts
  var PluginRemoveCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.name = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const pluginName = this.name;
        const pluginIdent = structUtils_exports.parseIdent(pluginName);
        if (!configuration.plugins.has(pluginName))
          throw new UsageError(`${structUtils_exports.prettyIdent(configuration, pluginIdent)} isn't referenced by the current configuration`);
        const relativePath = `.yarn/plugins/${pluginName}.cjs`;
        const absolutePath = ppath.resolve(project.cwd, relativePath);
        if (xfs.existsSync(absolutePath)) {
          report2.reportInfo(MessageName.UNNAMED, `Removing ${formatUtils_exports.pretty(configuration, relativePath, formatUtils_exports.Type.PATH)}...`);
          await xfs.removePromise(absolutePath);
        }
        report2.reportInfo(MessageName.UNNAMED, `Updating the configuration...`);
        await Configuration.updateConfiguration(project.cwd, (current) => {
          if (!Array.isArray(current.plugins))
            return current;
          const plugins = current.plugins.filter((plugin23) => {
            return plugin23.path !== relativePath;
          });
          if (current.plugins.length === plugins.length)
            return current;
          return {
            ...current,
            plugins
          };
        });
      });
      return report.exitCode();
    }
  };
  PluginRemoveCommand2.paths = [
    [`plugin`, `remove`]
  ];
  PluginRemoveCommand2.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `remove a plugin`,
    details: `
      This command deletes the specified plugin from the .yarn/plugins folder and removes it from the configuration.

      **Note:** The plugins have to be referenced by their name property, which can be obtained using the \`yarn plugin runtime\` command. Shorthands are not allowed.
   `,
    examples: [[
      `Remove a plugin imported from the Yarn repository`,
      `$0 plugin remove @yarnpkg/plugin-typescript`
    ], [
      `Remove a plugin imported from a local file`,
      `$0 plugin remove my-local-plugin`
    ]]
  });
  var remove_default3 = PluginRemoveCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\plugin\runtime.ts
  var PluginListCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const name of configuration.plugins.keys()) {
          const builtin = this.context.plugins.plugins.has(name);
          let label = name;
          if (builtin)
            label += ` [builtin]`;
          report2.reportJson({name, builtin});
          report2.reportInfo(null, `${label}`);
        }
      });
      return report.exitCode();
    }
  };
  PluginListCommand2.paths = [
    [`plugin`, `runtime`]
  ];
  PluginListCommand2.usage = Command.Usage({
    category: `Plugin-related commands`,
    description: `list the active plugins`,
    details: `
      This command prints the currently active plugins. Will be displayed both builtin plugins and external plugins.
    `,
    examples: [[
      `List the currently active plugins`,
      `$0 plugin runtime`
    ]]
  });
  var runtime_default2 = PluginListCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\rebuild.ts
  var RunCommand4 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.idents = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const filteredIdents = new Set();
      for (const identStr of this.idents)
        filteredIdents.add(structUtils_exports.parseIdent(identStr).identHash);
      await project.resolveEverything({
        cache: cache2,
        report: new ThrowReport()
      });
      const bstatePath = configuration.get(`bstatePath`);
      const bstate = xfs.existsSync(bstatePath) ? parseSyml(await xfs.readFilePromise(bstatePath, `utf8`)) : {};
      const nextBState = new Map();
      for (const pkg of project.storedPackages.values()) {
        if (!Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash))
          continue;
        if (filteredIdents.size === 0 || filteredIdents.has(pkg.identHash))
          continue;
        const buildHash = bstate[pkg.locatorHash];
        nextBState.set(pkg.locatorHash, buildHash);
      }
      if (nextBState.size > 0) {
        const bstatePath2 = configuration.get(`bstatePath`);
        const bstateFile = Project.generateBuildStateFile(nextBState, project.storedPackages);
        await xfs.mkdirPromise(ppath.dirname(bstatePath2), {recursive: true});
        await xfs.changeFilePromise(bstatePath2, bstateFile, {
          automaticNewlines: true
        });
      } else {
        await xfs.removePromise(bstatePath);
      }
      const installReport = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeLogs: !this.context.quiet
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  RunCommand4.paths = [
    [`rebuild`]
  ];
  RunCommand4.usage = Command.Usage({
    description: `rebuild the project's native packages`,
    details: `
      This command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.

      Note that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).

      By default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.
    `,
    examples: [[
      `Rebuild all packages`,
      `$0 rebuild`
    ], [
      `Rebuild fsevents only`,
      `$0 rebuild fsevents`
    ]]
  });
  var rebuild_default2 = RunCommand4;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\remove.ts
  var import_micromatch10 = __toModule(require_micromatch());
  var RemoveCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Apply the operation to all workspaces from the current project`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState({
        restoreResolutions: false
      });
      const affectedWorkspaces = this.all ? project.workspaces : [workspace];
      const targets = [
        Target2.REGULAR,
        Target2.DEVELOPMENT,
        Target2.PEER
      ];
      const unreferencedPatterns = [];
      let hasChanged = false;
      const afterWorkspaceDependencyRemovalList = [];
      for (const pattern of this.patterns) {
        let isReferenced = false;
        const pseudoIdent = structUtils_exports.parseIdent(pattern);
        for (const workspace2 of affectedWorkspaces) {
          const peerDependenciesMeta = [...workspace2.manifest.peerDependenciesMeta.keys()];
          for (const stringifiedIdent of import_micromatch10.default(peerDependenciesMeta, pattern)) {
            workspace2.manifest.peerDependenciesMeta.delete(stringifiedIdent);
            hasChanged = true;
            isReferenced = true;
          }
          for (const target of targets) {
            const descriptors = workspace2.manifest.getForScope(target);
            const stringifiedIdents = [...descriptors.values()].map((descriptor) => {
              return structUtils_exports.stringifyIdent(descriptor);
            });
            for (const stringifiedIdent of import_micromatch10.default(stringifiedIdents, structUtils_exports.stringifyIdent(pseudoIdent))) {
              const {identHash} = structUtils_exports.parseIdent(stringifiedIdent);
              const removedDescriptor = descriptors.get(identHash);
              if (typeof removedDescriptor === `undefined`)
                throw new Error(`Assertion failed: Expected the descriptor to be registered`);
              workspace2.manifest[target].delete(identHash);
              afterWorkspaceDependencyRemovalList.push([
                workspace2,
                target,
                removedDescriptor
              ]);
              hasChanged = true;
              isReferenced = true;
            }
          }
        }
        if (!isReferenced) {
          unreferencedPatterns.push(pattern);
        }
      }
      const patterns = unreferencedPatterns.length > 1 ? `Patterns` : `Pattern`;
      const dont = unreferencedPatterns.length > 1 ? `don't` : `doesn't`;
      const which = this.all ? `any` : `this`;
      if (unreferencedPatterns.length > 0)
        throw new UsageError(`${patterns} ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} ${dont} match any packages referenced by ${which} workspace`);
      if (hasChanged) {
        await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyRemoval, afterWorkspaceDependencyRemovalList);
        const report = await StreamReport.start({
          configuration,
          stdout: this.context.stdout
        }, async (report2) => {
          await project.install({cache: cache2, report: report2});
        });
        return report.exitCode();
      }
      return 0;
    }
  };
  RemoveCommand2.paths = [
    [`remove`]
  ];
  RemoveCommand2.usage = Command.Usage({
    description: `remove dependencies from the project`,
    details: `
      This command will remove the packages matching the specified patterns from the current workspace.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.
    `,
    examples: [[
      `Remove a dependency from the current project`,
      `$0 remove lodash`
    ], [
      `Remove a dependency from all workspaces at once`,
      `$0 remove lodash --all`
    ], [
      `Remove all dependencies starting with \`eslint-\``,
      `$0 remove 'eslint-*'`
    ], [
      `Remove all dependencies with the \`@babel\` scope`,
      `$0 remove '@babel/*'`
    ], [
      `Remove all dependencies matching \`react-dom\` or \`react-helmet\``,
      `$0 remove 'react-{dom,helmet}'`
    ]]
  });
  var remove_default4 = RemoveCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\runIndex.ts
  var import_util13 = __toModule(require("util"));
  var RunCommand5 = class extends BaseCommand2 {
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const scripts = workspace.manifest.scripts;
        const keys = miscUtils10.sortMap(scripts.keys(), (key) => key);
        const inspectConfig = {
          breakLength: Infinity,
          colors: configuration.get(`enableColors`),
          maxArrayLength: 2
        };
        const maxKeyLength = keys.reduce((max, key) => {
          return Math.max(max, key.length);
        }, 0);
        for (const [key, value] of scripts.entries()) {
          report2.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${import_util13.inspect(value, inspectConfig)}`);
        }
      });
      return report.exitCode();
    }
  };
  RunCommand5.paths = [
    [`run`]
  ];
  var runIndex_default2 = RunCommand5;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\run.ts
  var RunCommand6 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.inspect = options_exports.String(`--inspect`, false, {
        tolerateBoolean: true,
        description: `Forwarded to the underlying Node process when executing a binary`
      });
      this.inspectBrk = options_exports.String(`--inspect-brk`, false, {
        tolerateBoolean: true,
        description: `Forwarded to the underlying Node process when executing a binary`
      });
      this.topLevel = options_exports.Boolean(`-T,--top-level`, false, {hidden: true});
      this.binariesOnly = options_exports.Boolean(`-B,--binaries-only`, false, {hidden: true});
      this.silent = options_exports.Boolean(`--silent`, {hidden: true});
      this.scriptName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace, locator} = await Project.find(configuration, this.context.cwd);
      await project.restoreInstallState();
      const effectiveLocator = this.topLevel ? project.topLevelWorkspace.anchoredLocator : locator;
      if (!this.binariesOnly && await scriptUtils_exports.hasPackageScript(effectiveLocator, this.scriptName, {project}))
        return await scriptUtils_exports.executePackageScript(effectiveLocator, this.scriptName, this.args, {project, stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr});
      const binaries = await scriptUtils_exports.getPackageAccessibleBinaries(effectiveLocator, {project});
      const binary = binaries.get(this.scriptName);
      if (binary) {
        const nodeArgs = [];
        if (this.inspect) {
          if (typeof this.inspect === `string`) {
            nodeArgs.push(`--inspect=${this.inspect}`);
          } else {
            nodeArgs.push(`--inspect`);
          }
        }
        if (this.inspectBrk) {
          if (typeof this.inspectBrk === `string`) {
            nodeArgs.push(`--inspect-brk=${this.inspectBrk}`);
          } else {
            nodeArgs.push(`--inspect-brk`);
          }
        }
        return await scriptUtils_exports.executePackageAccessibleBinary(effectiveLocator, this.scriptName, this.args, {cwd: this.context.cwd, project, stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr, nodeArgs});
      }
      if (!this.topLevel && !this.binariesOnly && workspace && this.scriptName.includes(`:`)) {
        const candidateWorkspaces = await Promise.all(project.workspaces.map(async (workspace2) => {
          return workspace2.manifest.scripts.has(this.scriptName) ? workspace2 : null;
        }));
        const filteredWorkspaces = candidateWorkspaces.filter((workspace2) => {
          return workspace2 !== null;
        });
        if (filteredWorkspaces.length === 1) {
          return await scriptUtils_exports.executeWorkspaceScript(filteredWorkspaces[0], this.scriptName, this.args, {stdin: this.context.stdin, stdout: this.context.stdout, stderr: this.context.stderr});
        }
      }
      if (this.topLevel) {
        if (this.scriptName === `node-gyp`) {
          throw new UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${structUtils_exports.prettyLocator(configuration, locator)}). This typically happens because some package depends on "node-gyp" to build itself, but didn't list it in their dependencies. To fix that, please run "yarn add node-gyp" into your top-level workspace. You also can open an issue on the repository of the specified package to suggest them to use an optional peer dependency.`);
        } else {
          throw new UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${structUtils_exports.prettyLocator(configuration, locator)}).`);
        }
      } else {
        if (this.scriptName === `global`)
          throw new UsageError(`The 'yarn global' commands have been removed in 2.x - consider using 'yarn dlx' or a third-party plugin instead`);
        const userCommand = [this.scriptName].concat(this.args);
        for (const [pluginName, candidates] of pluginCommands2)
          for (const candidate of candidates)
            if (userCommand.length >= candidate.length && JSON.stringify(userCommand.slice(0, candidate.length)) === JSON.stringify(candidate))
              throw new UsageError(`Couldn't find a script named "${this.scriptName}", but a matching command can be found in the ${pluginName} plugin. You can install it with "yarn plugin import ${pluginName}".`);
        throw new UsageError(`Couldn't find a script named "${this.scriptName}".`);
      }
    }
  };
  RunCommand6.paths = [
    [`run`]
  ];
  RunCommand6.usage = Command.Usage({
    description: `run a script defined in the package.json`,
    details: `
      This command will run a tool. The exact tool that will be executed will depend on the current state of your workspace:

      - If the \`scripts\` field from your local package.json contains a matching script name, its definition will get executed.

      - Otherwise, if one of the local workspace's dependencies exposes a binary with a matching name, this binary will get executed.

      - Otherwise, if the specified name contains a colon character and if one of the workspaces in the project contains exactly one script with a matching name, then this script will get executed.

      Whatever happens, the cwd of the spawned process will be the workspace that declares the script (which makes it possible to call commands cross-workspaces using the third syntax).
    `,
    examples: [[
      `Run the tests from the local workspace`,
      `$0 run test`
    ], [
      `Same thing, but without the "run" keyword`,
      `$0 test`
    ], [
      `Inspect Webpack while running`,
      `$0 run --inspect-brk webpack`
    ]]
  });
  var run_default4 = RunCommand6;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\set\resolution.ts
  var SetResolutionCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.save = options_exports.Boolean(`-s,--save`, false, {
        description: `Persist the resolution inside the top-level manifest`
      });
      this.descriptor = options_exports.String();
      this.resolution = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const fromDescriptor = structUtils_exports.parseDescriptor(this.descriptor, true);
      const toDescriptor = structUtils_exports.makeDescriptor(fromDescriptor, this.resolution);
      project.storedDescriptors.set(fromDescriptor.descriptorHash, fromDescriptor);
      project.storedDescriptors.set(toDescriptor.descriptorHash, toDescriptor);
      project.resolutionAliases.set(fromDescriptor.descriptorHash, toDescriptor.descriptorHash);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  SetResolutionCommand2.paths = [
    [`set`, `resolution`]
  ];
  SetResolutionCommand2.usage = Command.Usage({
    description: `enforce a package resolution`,
    details: `
      This command updates the resolution table so that \`descriptor\` is resolved by \`resolution\`.

      Note that by default this command only affect the current resolution table - meaning that this "manual override" will disappear if you remove the lockfile, or if the package disappear from the table. If you wish to make the enforced resolution persist whatever happens, add the \`-s,--save\` flag which will also edit the \`resolutions\` field from your top-level manifest.

      Note that no attempt is made at validating that \`resolution\` is a valid resolution entry for \`descriptor\`.
    `,
    examples: [[
      `Force all instances of lodash@npm:^1.2.3 to resolve to 1.5.0`,
      `$0 set resolution lodash@npm:^1.2.3 1.5.0`
    ]]
  });
  var resolution_default2 = SetResolutionCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\up.ts
  var import_enquirer5 = __toModule(require_enquirer());
  var import_micromatch11 = __toModule(require_micromatch());
  var UpCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.interactive = options_exports.Boolean(`-i,--interactive`, {
        description: `Offer various choices, depending on the detected upgrade paths`
      });
      this.exact = options_exports.Boolean(`-E,--exact`, false, {
        description: `Don't use any semver modifier on the resolved range`
      });
      this.tilde = options_exports.Boolean(`-T,--tilde`, false, {
        description: `Use the \`~\` semver modifier on the resolved range`
      });
      this.caret = options_exports.Boolean(`-C,--caret`, false, {
        description: `Use the \`^\` semver modifier on the resolved range`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const interactive = (_a2 = this.interactive) != null ? _a2 : configuration.get(`preferInteractive`);
      const modifier = getModifier2(this, project);
      const strategies = interactive ? [
        Strategy3.KEEP,
        Strategy3.REUSE,
        Strategy3.PROJECT,
        Strategy3.LATEST
      ] : [
        Strategy3.PROJECT,
        Strategy3.LATEST
      ];
      const allSuggestionsPromises = [];
      const unreferencedPatterns = [];
      for (const pattern of this.patterns) {
        let isReferenced = false;
        const pseudoDescriptor = structUtils_exports.parseDescriptor(pattern);
        for (const workspace2 of project.workspaces) {
          for (const target of [Target2.REGULAR, Target2.DEVELOPMENT]) {
            const descriptors = workspace2.manifest.getForScope(target);
            const stringifiedIdents = [...descriptors.values()].map((descriptor) => {
              return structUtils_exports.stringifyIdent(descriptor);
            });
            for (const stringifiedIdent of import_micromatch11.default(stringifiedIdents, structUtils_exports.stringifyIdent(pseudoDescriptor))) {
              const ident = structUtils_exports.parseIdent(stringifiedIdent);
              const existingDescriptor = workspace2.manifest[target].get(ident.identHash);
              if (typeof existingDescriptor === `undefined`)
                throw new Error(`Assertion failed: Expected the descriptor to be registered`);
              const request2 = structUtils_exports.makeDescriptor(ident, pseudoDescriptor.range);
              allSuggestionsPromises.push(Promise.resolve().then(async () => {
                return [
                  workspace2,
                  target,
                  existingDescriptor,
                  await getSuggestedDescriptors2(request2, {project, workspace: workspace2, cache: cache2, target, modifier, strategies})
                ];
              }));
              isReferenced = true;
            }
          }
        }
        if (!isReferenced) {
          unreferencedPatterns.push(pattern);
        }
      }
      if (unreferencedPatterns.length > 1)
        throw new UsageError(`Patterns ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} don't match any packages referenced by any workspace`);
      if (unreferencedPatterns.length > 0)
        throw new UsageError(`Pattern ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, FormatType.CODE)} doesn't match any packages referenced by any workspace`);
      const allSuggestions = await Promise.all(allSuggestionsPromises);
      const checkReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout,
        suggestInstall: false
      }, async (report) => {
        for (const [, , existing, {suggestions, rejections}] of allSuggestions) {
          const nonNullSuggestions = suggestions.filter((suggestion) => {
            return suggestion.descriptor !== null;
          });
          if (nonNullSuggestions.length === 0) {
            const [firstError] = rejections;
            if (typeof firstError === `undefined`)
              throw new Error(`Assertion failed: Expected an error to have been set`);
            const prettyError = this.cli.error(firstError);
            if (!project.configuration.get(`enableNetwork`)) {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range (note: network resolution has been disabled)

${prettyError}`);
            } else {
              report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range

${prettyError}`);
            }
          } else if (nonNullSuggestions.length > 1 && !interactive) {
            report.reportError(MessageName.CANT_SUGGEST_RESOLUTIONS, `${structUtils_exports.prettyDescriptor(configuration, existing)} has multiple possible upgrade strategies; use -i to disambiguate manually`);
          }
        }
      });
      if (checkReport.hasErrors())
        return checkReport.exitCode();
      let askedQuestions = false;
      const afterWorkspaceDependencyReplacementList = [];
      for (const [workspace2, target, , {suggestions}] of allSuggestions) {
        let selected;
        const nonNullSuggestions = suggestions.filter((suggestion) => {
          return suggestion.descriptor !== null;
        });
        const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
        const areAllTheSame = nonNullSuggestions.every((suggestion) => structUtils_exports.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
        if (nonNullSuggestions.length === 1 || areAllTheSame) {
          selected = firstSuggestedDescriptor;
        } else {
          askedQuestions = true;
          ({answer: selected} = await import_enquirer5.prompt({
            type: `select`,
            name: `answer`,
            message: `Which range to you want to use in ${structUtils_exports.prettyWorkspace(configuration, workspace2)} \u276F ${target}?`,
            choices: suggestions.map(({descriptor, name, reason}) => descriptor ? {
              name,
              hint: reason,
              descriptor
            } : {
              name,
              hint: reason,
              disabled: true
            }),
            onCancel: () => process.exit(130),
            result(name) {
              return this.find(name, `descriptor`);
            },
            stdin: this.context.stdin,
            stdout: this.context.stdout
          }));
        }
        const current = workspace2.manifest[target].get(selected.identHash);
        if (typeof current === `undefined`)
          throw new Error(`Assertion failed: This descriptor should have a matching entry`);
        if (current.descriptorHash !== selected.descriptorHash) {
          workspace2.manifest[target].set(selected.identHash, selected);
          afterWorkspaceDependencyReplacementList.push([
            workspace2,
            target,
            current,
            selected
          ]);
        } else {
          const resolver = configuration.makeResolver();
          const resolveOptions = {project, resolver};
          const bound = resolver.bindDescriptor(current, workspace2.anchoredLocator, resolveOptions);
          project.forgetResolution(bound);
        }
      }
      await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
      if (askedQuestions)
        this.context.stdout.write(`
`);
      const installReport = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report) => {
        await project.install({cache: cache2, report});
      });
      return installReport.exitCode();
    }
  };
  UpCommand2.paths = [
    [`up`]
  ];
  UpCommand2.usage = Command.Usage({
    description: `upgrade dependencies across the project`,
    details: `
      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of \`dependencies\` or \`devDependencies\` - \`peerDependencies\` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.

      If \`-i,--interactive\` is set (or if the \`preferInteractive\` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.

      The, \`-C,--caret\`, \`-E,--exact\` and  \`-T,--tilde\` options have the same meaning as in the \`add\` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).

      Generally you can see \`yarn up\` as a counterpart to what was \`yarn upgrade --latest\` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike \`yarn upgrade\` which only upgraded dependencies in the current workspace, \`yarn up\` will upgrade all workspaces at the same time.

      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.
    `,
    examples: [[
      `Upgrade all instances of lodash to the latest release`,
      `$0 up lodash`
    ], [
      `Upgrade all instances of lodash to the latest release, but ask confirmation for each`,
      `$0 up lodash -i`
    ], [
      `Upgrade all instances of lodash to 1.2.3`,
      `$0 up lodash@1.2.3`
    ], [
      `Upgrade all instances of packages with the \`@babel\` scope to the latest release`,
      `$0 up '@babel/*'`
    ], [
      `Upgrade all instances of packages containing the word \`jest\` to the latest release`,
      `$0 up '*jest*'`
    ], [
      `Upgrade all instances of packages with the \`@babel\` scope to 7.0.0`,
      `$0 up '@babel/*@7.0.0'`
    ]]
  });
  var up_default2 = UpCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\why.ts
  var WhyCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `List, for each workspace, what are all the paths that lead to the dependency`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.peers = options_exports.Boolean(`--peers`, false, {
        description: `Also print the peer dependencies that match the specified name`
      });
      this.package = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const identHash = structUtils_exports.parseIdent(this.package).identHash;
      const whyTree = this.recursive ? whyRecursive2(project, identHash, {configuration, peers: this.peers}) : whySimple2(project, identHash, {configuration, peers: this.peers});
      treeUtils_exports.emitTree(whyTree, {
        configuration,
        stdout: this.context.stdout,
        json: this.json,
        separators: 1
      });
    }
  };
  WhyCommand2.paths = [
    [`why`]
  ];
  WhyCommand2.usage = Command.Usage({
    description: `display the reason why a package is needed`,
    details: `
      This command prints the exact reasons why a package appears in the dependency tree.

      If \`-R,--recursive\` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named "Foo" when looking for "Bar", it means that "Foo" already got printed higher in the tree.
    `,
    examples: [[
      `Explain why lodash is used in your project`,
      `$0 why lodash`
    ]]
  });
  var why_default2 = WhyCommand2;
  function whySimple2(project, identHash, {configuration, peers}) {
    const sortedPackages = miscUtils10.sortMap(project.storedPackages.values(), (pkg) => {
      return structUtils_exports.stringifyLocator(pkg);
    });
    const rootChildren = {};
    const root = {children: rootChildren};
    for (const pkg of sortedPackages) {
      const nodeChildren = {};
      const node = null;
      for (const dependency of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        if (nextPkg.identHash !== identHash)
          continue;
        if (node === null) {
          const key2 = structUtils_exports.stringifyLocator(pkg);
          rootChildren[key2] = {value: [pkg, formatUtils_exports.Type.LOCATOR], children: nodeChildren};
        }
        const key = structUtils_exports.stringifyLocator(nextPkg);
        nodeChildren[key] = {value: [{
          descriptor: dependency,
          locator: nextPkg
        }, formatUtils_exports.Type.DEPENDENT]};
      }
    }
    return root;
  }
  function whyRecursive2(project, identHash, {configuration, peers}) {
    const sortedWorkspaces = miscUtils10.sortMap(project.workspaces, (workspace) => {
      return structUtils_exports.stringifyLocator(workspace.anchoredLocator);
    });
    const seen = new Set();
    const dependents = new Set();
    const markAllDependents = (pkg) => {
      if (seen.has(pkg.locatorHash))
        return dependents.has(pkg.locatorHash);
      seen.add(pkg.locatorHash);
      if (pkg.identHash === identHash) {
        dependents.add(pkg.locatorHash);
        return true;
      }
      let depends = false;
      if (pkg.identHash === identHash)
        depends = true;
      for (const dependency of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        if (markAllDependents(nextPkg)) {
          depends = true;
        }
      }
      if (depends)
        dependents.add(pkg.locatorHash);
      return depends;
    };
    for (const workspace of sortedWorkspaces) {
      const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg)
        throw new Error(`Assertion failed: The package should have been registered`);
      markAllDependents(pkg);
    }
    const printed = new Set();
    const rootChildren = {};
    const root = {children: rootChildren};
    const printAllDependents = (pkg, parentChildren, dependency) => {
      if (!dependents.has(pkg.locatorHash))
        return;
      const nodeValue = dependency !== null ? formatUtils_exports.tuple(formatUtils_exports.Type.DEPENDENT, {locator: pkg, descriptor: dependency}) : formatUtils_exports.tuple(formatUtils_exports.Type.LOCATOR, pkg);
      const nodeChildren = {};
      const node = {
        value: nodeValue,
        children: nodeChildren
      };
      const key = structUtils_exports.stringifyLocator(pkg);
      parentChildren[key] = node;
      if (printed.has(pkg.locatorHash))
        return;
      printed.add(pkg.locatorHash);
      if (dependency !== null && project.tryWorkspaceByLocator(pkg))
        return;
      for (const dependency2 of pkg.dependencies.values()) {
        if (!peers && pkg.peerDependencies.has(dependency2.identHash))
          continue;
        const resolution = project.storedResolutions.get(dependency2.descriptorHash);
        if (!resolution)
          throw new Error(`Assertion failed: The resolution should have been registered`);
        const nextPkg = project.storedPackages.get(resolution);
        if (!nextPkg)
          throw new Error(`Assertion failed: The package should have been registered`);
        printAllDependents(nextPkg, nodeChildren, dependency2);
      }
    };
    for (const workspace of sortedWorkspaces) {
      const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg)
        throw new Error(`Assertion failed: The package should have been registered`);
      printAllDependents(pkg, rootChildren, null);
    }
    return root;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\workspaces\list.ts
  var WorkspacesListCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.verbose = options_exports.Boolean(`-v,--verbose`, false, {
        description: `Also return the cross-dependencies between workspaces`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const report = await StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const workspace of project.workspaces) {
          const {manifest} = workspace;
          let extra;
          if (this.verbose) {
            const workspaceDependencies = new Set();
            const mismatchedWorkspaceDependencies = new Set();
            for (const dependencyType of Manifest.hardDependencies) {
              for (const [identHash, descriptor] of manifest.getForScope(dependencyType)) {
                const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
                if (matchingWorkspace === null) {
                  if (project.workspacesByIdent.has(identHash)) {
                    mismatchedWorkspaceDependencies.add(descriptor);
                  }
                } else {
                  workspaceDependencies.add(matchingWorkspace);
                }
              }
            }
            extra = {
              workspaceDependencies: Array.from(workspaceDependencies).map((workspace2) => {
                return workspace2.relativeCwd;
              }),
              mismatchedWorkspaceDependencies: Array.from(mismatchedWorkspaceDependencies).map((descriptor) => {
                return structUtils_exports.stringifyDescriptor(descriptor);
              })
            };
          }
          report2.reportInfo(null, `${workspace.relativeCwd}`);
          report2.reportJson({
            location: workspace.relativeCwd,
            name: manifest.name ? structUtils_exports.stringifyIdent(manifest.name) : null,
            ...extra
          });
        }
      });
      return report.exitCode();
    }
  };
  WorkspacesListCommand2.paths = [
    [`workspaces`, `list`]
  ];
  WorkspacesListCommand2.usage = Command.Usage({
    category: `Workspace-related commands`,
    description: `list all available workspaces`,
    details: `
      This command will print the list of all workspaces in the project. If both the \`-v,--verbose\` and \`--json\` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).
    `
  });
  var list_default4 = WorkspacesListCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\commands\workspace.ts
  var WorkspaceCommand2 = class extends Command {
    constructor() {
      super(...arguments);
      this.workspaceName = options_exports.String();
      this.commandName = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace: cwdWorkspace} = await Project.find(configuration, this.context.cwd);
      if (!cwdWorkspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const candidates = project.workspaces;
      const candidatesByName = new Map(candidates.map((workspace2) => {
        const ident = structUtils_exports.convertToIdent(workspace2.locator);
        return [structUtils_exports.stringifyIdent(ident), workspace2];
      }));
      const workspace = candidatesByName.get(this.workspaceName);
      if (workspace === void 0) {
        const otherNames = Array.from(candidatesByName.keys()).sort();
        throw new UsageError(`Workspace '${this.workspaceName}' not found. Did you mean any of the following:
  - ${otherNames.join(`
  - `)}?`);
      }
      return this.cli.run([this.commandName, ...this.args], {cwd: workspace.cwd});
    }
  };
  WorkspaceCommand2.paths = [
    [`workspace`]
  ];
  WorkspaceCommand2.usage = Command.Usage({
    category: `Workspace-related commands`,
    description: `run a command within the specified workspace`,
    details: `
      This command will run a given sub-command on a single workspace.
    `,
    examples: [[
      `Add a package to a single workspace`,
      `yarn workspace components add -D react`
    ], [
      `Run build script on a single workspace`,
      `yarn workspace components run build`
    ]]
  });
  var workspace_default2 = WorkspaceCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-essentials-virtual-a18b52070a\1\packages\plugin-essentials\sources\index.ts
  var plugin12 = {
    configuration: {
      enableImmutableInstalls: {
        description: `If true, prevents the install command from modifying the lockfile`,
        type: SettingsType.BOOLEAN,
        default: false
      },
      defaultSemverRangePrefix: {
        description: `The default save prefix: '^', '~' or ''`,
        type: SettingsType.STRING,
        values: [`^`, `~`, ``],
        default: Modifier2.CARET
      }
    },
    commands: [
      clean_default2,
      get_default2,
      set_default2,
      unset_default2,
      resolution_default2,
      sources_default14,
      version_default4,
      list_default4,
      clipanion_default2,
      help_default2,
      run_default3,
      version_default3,
      add_default2,
      bin_default2,
      config_default2,
      dedupe_default2,
      exec_default2,
      peerRequirements_default2,
      info_default2,
      install_default2,
      link_default2,
      node_default2,
      sources_default15,
      import_default2,
      remove_default3,
      list_default3,
      runtime_default2,
      rebuild_default2,
      remove_default4,
      runIndex_default2,
      run_default4,
      up_default2,
      why_default2,
      workspace_default2
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-f9d90af7d7\1\packages\plugin-compat\sources\extensions.ts
  var optionalPeerDep2 = {
    optional: true
  };
  var packageExtensions2 = [
    [`@samverschueren/stream-to-observable@<0.3.1`, {
      peerDependenciesMeta: {
        [`rxjs`]: optionalPeerDep2,
        [`zenObservable`]: optionalPeerDep2
      }
    }],
    [`any-observable@<0.5.1`, {
      peerDependenciesMeta: {
        [`rxjs`]: optionalPeerDep2,
        [`zenObservable`]: optionalPeerDep2
      }
    }],
    [`@pm2/agent@<1.0.4`, {
      dependencies: {
        [`debug`]: `*`
      }
    }],
    [`debug@<4.2.0`, {
      peerDependenciesMeta: {
        [`supports-color`]: optionalPeerDep2
      }
    }],
    [`got@<11`, {
      dependencies: {
        [`@types/responselike`]: `^1.0.0`,
        [`@types/keyv`]: `^3.1.1`
      }
    }],
    [`cacheable-lookup@<4.1.2`, {
      dependencies: {
        [`@types/keyv`]: `^3.1.1`
      }
    }],
    [`http-link-dataloader@*`, {
      peerDependencies: {
        [`graphql`]: `^0.13.1 || ^14.0.0`
      }
    }],
    [`typescript-language-server@*`, {
      dependencies: {
        [`vscode-jsonrpc`]: `^5.0.1`,
        [`vscode-languageserver-protocol`]: `^3.15.0`
      }
    }],
    [`postcss-syntax@*`, {
      peerDependenciesMeta: {
        [`postcss-html`]: optionalPeerDep2,
        [`postcss-jsx`]: optionalPeerDep2,
        [`postcss-less`]: optionalPeerDep2,
        [`postcss-markdown`]: optionalPeerDep2,
        [`postcss-scss`]: optionalPeerDep2
      }
    }],
    [`jss-plugin-rule-value-function@<=10.1.1`, {
      dependencies: {
        [`tiny-warning`]: `^1.0.2`
      }
    }],
    [`ink-select-input@<4.1.0`, {
      peerDependencies: {
        react: `^16.8.2`
      }
    }],
    [`promise-inflight@*`, {
      peerDependenciesMeta: {
        [`bluebird`]: optionalPeerDep2
      }
    }],
    [`reactcss@*`, {
      peerDependencies: {
        react: `*`
      }
    }],
    [`react-color@<=2.19.0`, {
      peerDependencies: {
        react: `*`
      }
    }],
    [`gatsby-plugin-i18n@*`, {
      dependencies: {
        ramda: `^0.24.1`
      }
    }],
    [`useragent@^2.0.0`, {
      dependencies: {
        request: `^2.88.0`,
        yamlparser: `0.0.x`,
        semver: `5.5.x`
      }
    }],
    [`@apollographql/apollo-tools@*`, {
      peerDependencies: {
        graphql: `^14.2.1 || ^15.0.0`
      }
    }],
    [`material-table@^2.0.0`, {
      dependencies: {
        "@babel/runtime": `^7.11.2`
      }
    }],
    [`@babel/parser@*`, {
      dependencies: {
        "@babel/types": `^7.8.3`
      }
    }],
    [`fork-ts-checker-webpack-plugin@*`, {
      peerDependencies: {
        eslint: `>= 6`,
        typescript: `>= 2.7`,
        webpack: `>= 4`
      },
      peerDependenciesMeta: {
        eslint: optionalPeerDep2
      }
    }],
    [`rc-animate@*`, {
      peerDependencies: {
        react: `^15.0.0 || ^16.0.0`,
        "react-dom": `^15.0.0 || ^16.0.0`
      }
    }],
    [`react-bootstrap-table2-paginator@*`, {
      dependencies: {
        classnames: `^2.2.6`
      }
    }],
    [`react-draggable@<=4.4.3`, {
      peerDependencies: {
        react: `>= 16.3.0`,
        "react-dom": `>= 16.3.0`
      }
    }],
    [`apollo-upload-client@<14`, {
      peerDependencies: {
        graphql: `14 - 15`
      }
    }],
    [`react-instantsearch-core@<=6.7.0`, {
      peerDependencies: {
        algoliasearch: `>= 3.1 < 5`
      }
    }],
    [`react-instantsearch-dom@<=6.7.0`, {
      dependencies: {
        "react-fast-compare": `^3.0.0`
      }
    }],
    [`ws@<7.2.1`, {
      peerDependencies: {
        bufferutil: `^4.0.1`,
        "utf-8-validate": `^5.0.2`
      },
      peerDependenciesMeta: {
        bufferutil: optionalPeerDep2,
        "utf-8-validate": optionalPeerDep2
      }
    }],
    [`react-portal@*`, {
      peerDependencies: {
        "react-dom": `^15.0.0-0 || ^16.0.0-0 || ^17.0.0-0`
      }
    }],
    [`create-react-app@*`, {
      peerDependencies: {
        [`react`]: `*`
      }
    }],
    [`testcafe@<=1.10.1`, {
      dependencies: {
        "@babel/plugin-transform-for-of": `^7.12.1`,
        "@babel/runtime": `^7.12.5`
      }
    }],
    [`testcafe-legacy-api@<=4.2.0`, {
      dependencies: {
        "testcafe-hammerhead": `^17.0.1`,
        "read-file-relative": `^1.2.0`
      }
    }]
  ];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-f9d90af7d7\1\packages\plugin-compat\sources\patches\fsevents.patch.ts
  var patch4;
  function getPatch4() {
    if (typeof patch4 === `undefined`)
      patch4 = require("zlib").brotliDecompressSync(Buffer.from(`G7weAByFTVk3Vs7UfHhq4yykgEM7pbW7TI43SG2S5tvGrwHBAzdz+s/npQ6tgEvobvxisrPIadkXeUAJotBn5bDZ5kAhcRqsIHe3F75Walet5hNalwgFDtxb0BiDUjiUQkjG0yW2hto9HPgiCkm316d6bC0kST72YN7D7rfkhCE9x4J0XwB0yavalxpUu2t9xszHrmtwalOxT7VslsxWcB1qpqZwERUra4psWhTV8BgwWeizurec82Caf1ABL11YMfbf8FJ9JBceZOkgmvrQPbC9DUldX/yMbmX06UQluCEjSwUoyO+EZPIjofr+/oAZUck2enraRD+oWLlnlYnj8xB+gwSo9lmmks4fXv574qSqcWA6z21uYkzMu3EWj+K23RxeQlLqiE35/rC8GcS4CGkKHKKq+zAIQwD9iRDNfiAqueLLpicFFrNsAI4zeTD/eO9MHcnRa5m8UT+M2+V+AkFST4BlKneiAQRSdST8KEAIyFlULt6wa9EBd0Ds28VmpaxquJdVt+nwdEs5xUskI13OVtFyY0UrQIRAlCuvvWivvlSKQfTO+2Q8OyUR1W5RvetaPz4jD27hdtwHFFA1Ptx6Ee/t2cY2rg2G46M1pNDRf2pWhvpy8pqMnuI3++4OF3+7OFIWXGjh+o7Nr2jNvbiYcQdQS1h903/jVFgOpA0yJ78z+x759bFA0rq+6aY5qPB4FzS3oYoLupDUhD9nDz6F6H7hpnlMf18KNKDu4IKjTWwrAnY6MFQw1W6ymOALHlFyCZmQhldg1MQHaMVVQTVgDC60TfaBqG++Y8PEoFhN/PBTZT175KNP/BlHDYGOOBmnBdzqJKplZ/ljiVG0ZBzfqeBRrrUkn6rA54462SgiliKoYVnbeptMdXNfAuaupIEi0bApF10TlgHfmEJAPUVidRVFyDupSem5po5vErPqWKhKbUIp0LozpYsIKK57dM/HKr+nguF+7924IIWMICkQ8JUigs9D+W+c4LnNoRtPPKNRUiCYmP+Jfo2lfKCKw8qpraEeWU3uiNRO6zcyKQoXPR5htmzzLznke7b4YbXW3I1lIRzmgG02Udb58U+7TpwyN7XymCgH+wuPDthZVQvRZuEP+SnLtMicz9m5zASWOBiAcLmkuFlTKuHspSIhCBD0yUPKcxu81A+4YD78rA2vtwsUEday9WNyrShyrl60rWmA+SmbYZkQOwFJWArxRYYc5jGhA5ikxYw1rx3ei4NmeX/lKiwpZ9Ln1tV2Ae7sArvxuVLbJjqJRjW1vFXAyHpvLG+8MJ6T2Ubx5M2KDa2SN6vuIGxJ9WQM9Mk3Q7aCNiZONXllhqq24DmoLbQfW2rYWsOgHWjtOmIQMyMKdiHZDjoyIq5+U700nZ6odJAoYXPQBvFNiQ78d5jaXliBqLTJEqUCwi+LiH2mx92EmNKDsJL74Z613+3lf20pxkV1+erOrjj8pW00vsPaahKUM+05ssd5uwM7K482KWEf3TCwlg/o3e5ngto7qSMz7YteIgCsF1UOcsLk7F7MxWbvrPMY473ew0G+noVL8EPbkmEMftMSeL6HFub/zy+2JQ==`, `base64`)).toString();
    return patch4;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-f9d90af7d7\1\packages\plugin-compat\sources\patches\resolve.patch.ts
  var patch5;
  function getPatch5() {
    if (typeof patch5 === `undefined`)
      patch5 = require("zlib").brotliDecompressSync(Buffer.from(`G1QTIIzURnVBnGa0VPvr81orV8AFIqdU0sqrdcVgCdukgAZwi8a50gLk9+19Z2NcUILjmzXkzt4dzm5a6Yoys+/9qnKiaApXukOiuoyUaMcynG4X7X4vBaIE/PL30gwG6HSGJkLxb9PnLjfMr+748n7sM6C/NycK6ber/bX1reVVxta6W/31tZIhfrS+upoE/TPRHj0S/l0T59gTGdtKOp1OmMOJt9rhfucDdLJ2tgyfnO+u4YMkQAcYq/nebTcDmbXhqhgo6iQA4M3m4xya4Cos3p6klmkmQT+S4DLDZfwfMF+sUCx36KleOtaHLQfEIz0Bmncj/Ngi3lqOl4391EWEfIss6gVp3oDUGwsSZJKeOVONJWZg+Mue3KUMV3aMqYJ+7b2219D+GFDi8EV5y/Y+5J+He0oNjKAgqLsJziEsS9uIaCu3BHBKSXxNKKa2ShbfglcWoiiVT2kfGI7Gw+YJ/Sqy1H6wdFWtyVUQIa82JPwbeV25YKLzc5ZIFM6GCPSA+J9dTvJbs5LuuKnLP3f09gCu2jxqsAv6CA+ZySVaUJr2d3A70BC/uBCKr2OVrWgC3fSwb7NlfkgSEEiejrMGvhya9lMbVI6lMsFKN330A1/FOaefHQdNGLEZ3IwFF87H3xVlM0Xxsmbi/7A60oymRcIe0tH90alG6ez/yA7jwYotxuHWZdR+1HlMcddGHAV6QD/gXYPV0wnNv47I+5FGevzZFMqWSO8GU4nQ3FjsdgdJcD+c1rvudERKuLyd7bxiBpnsMDHsvPP4nXdXkld/gUNks3GAE1Otmb90bavDyiw4Mrx496Iw+jbLTgsCZGZXSZ9vM55C7KGe4HyJAKXEk0iT/Cj/PFwLJBN7pcP7ZFfYtUApGTWKkYhI9IE2zt/5ByH72wdvH+88b71zuv/FMCX3w6x5nzhY44Cg5IYv9LeKwHuHIWgPbfgrAcUxOlKkPRdQOIDF/aBuLPJAXD+TgxCNXx4jQxeR/qlBWVikFPfEI4rXMUc4kZ2w9KbPKYRvFUag0dVlVoyUP4zfidbTXAdZF88jAckl+NHjLFCNdX7EQ1PbLSOl+P+MqgwEOCi6dxgWZ7NCwJBjWKpk1LaxwKrhZ4aEC/0lMPJYe5S8xAakDcmA2kSS86GjEMTrv3VEu0S0YGZcxToMV524G4WAc4CReePePdipvs4aXRL5p+aeN96yfMGjsiTbQNxgbdRKc+keQ+NxYIEm1mBtEO29WrcbrqNbQRMR66KpGG4aG0NtmRyZ2JhUvu0paCklRlID8PT3gSiwZrqr4XZXoBBzBMrveWCuOg7iTgGDXDdbGi8XHkQf5KXDGFUxWueu5wkSa6gMWY1599g2piQjwBKIAPt4N5cOZdFBidz2feGwEAy1j1UydGxDSCCUsh314cUIIRV/dWCheceubL2gU8CibewmP7UxmN5kN4I7zfQhPxkP0NCcei8GXQpw4c3krEzW7PR2hgi/hqqqR58UJ/ZVfWxfcH5ZKMo4itkmPK0FCGxzzIRP20lK/gz28Y03sY233KvSVWUKl9rcbX6MbHjpUG8MvNlw72p6FwTejv92zgpnCxVJnIHHZhCBxNcHF5RTveRp513hUtTHHq4BIndlytZT5xoTSYfHKqKNr4o9kcGINIz6tZSKRdtbON3Ydr9cgqxHIeisMNIsvPg/IFMZuBbSqqDLeSO5dak1cGr76FtH2PC7hs0S0Oq3GsmF1Ga4YABAMGcdPAWzTk26B7cKV91I2b0V/GYvnsEQ1YGntRqi5EQqTlgZszbV/32GuZtUF49JOA/r4jAdwUOsbPo6mNoBlJPYjM5axrZaWQf33bFsLWqiyvvDOM4x0Ng802T7cuP2a3q98GWq6yiq6q3M77hcZlOUnmryctRYmI4Hb2F5XixFohkBmySCjU+M7/WQVE5YAtnlxiUJDhFN0y1tNeMWY9E0MfZi2rQ4eC72WXjsAA==`, `base64`)).toString();
    return patch5;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-f9d90af7d7\1\packages\plugin-compat\sources\patches\typescript.patch.ts
  var patch6;
  function getPatch6() {
    if (typeof patch6 === `undefined`)
      patch6 = require("zlib").brotliDecompressSync(Buffer.from(`W/FcOBIh6A6ch1ZVK40i2DgInvHffCZC2DiAvIWvCah18cYQrZVDa/kQEQ4XZxwaXi59suGHIFFfXWfmr0IJmQMP7OmW19PK0KsK5SYxdxHgNvEjYtHF8+nIpGt4SgFjJxzvMnPmcgWkZf/dcu8yBWrIo4GrcbzmZOymmo/mxEhL7W8rtb8/L6ULH2ZTGymt4QJec0PwjqSURuTYuiUt+jAODSoyTIZotkF6ZhSqYii2d5mCzodUEilSnPYHHo4Tw386mbIVBjAkKIFEHfCbXdLdW/o7Mf///Wlv60/gCRB0KbpPVHThNqmzlrXvOffMiPxjSfYayfYHpHPPvU+S9eT5gytjfwCoki5cJU2dpk2VtKmmq2X6AFAFqAP+32lKs1GkDN/Pkrt8XTAEBaB2E9z3JGVs2m6YogngJS8nobaQZWCeA6wnhjPsqkvPRLKI7U5fUV8BCfRuv51OsKkRPs2/oMdQa+XWahoDiIg4m/Z9NZsl7V2HF2xtMsTJCKicYjNJ7aJJ4eL1Eodhj8QXOXv+nKdTow0dTo7nN9/Z7UIU1SnAj1m2C3XH/DeYr1IN6y8IitfnlPmcAN+nnq/xq5/eO/1KqkT+0+r1PRB0Pvh+Ub5g8Pybvs7aHeWfKIpw3EgtDEM8P2M0gkZv1nqmv8K1tbyvLYTI6eql9WsDu5y8gNqUknZQ4Dwaet0UA9kGYNvvGQqHHH3luYI8lQ6oCLE7VfWzZX+0lqNBlmbNMMQjkOCis0UOf4FGjvIu5RdL8NSz+jZDQGOwKKKuTE/J+mguq593ldeIr4or+bYdB+QRhud2sws1L2vayvX5KOFfg/skZLX4TaK9VFUPtlHP2+LhgIgy0z8vkMf+C//KorgcXRrI+4CAnfe/ujwW3Mj/PyBD6onW8FCEe+peXk3X4ZJvg1mUTxBwsru4DUJPINKPzZo4K4uuy7qbP50yqA2OhihkP4UyfjXPaiXbEitEqr8t7SG5efEqvivbuxCunXXZVRML+WCKL77hHBIEzBLjy6yqalURyBM3ag9BZ66XVGEUGu2A46XgAePKR9ttVA8aQhhEFyHt+EttqQrZh9yJgSGDCHrXVxSVCdiUsn96jBQH7jbChqviu2fPOf58OQa6+HrcBiQx+Dw5QZp+Zt81Z1VMkht3EoZB5pAMmUI9+vldXjucFpbWmk/squdlnXsbuhMyRTKwH900D7j1+pzEMWtoDD5nQAUAmw7VFkGIMgmrFl6rfIVYyHc+32EPKQ0CMBaQPqHPFIgmBRKcAiWjeqDESwTMCbcFqKruw9giq4mqYUc7i3C9AEf94cLtWLIoOqiyK552po+xWCzAMimiHrMwGd5wbQ5qXJsT0HBTon46vyJ3WgJuVEPIUZqLFbAwkHUVviWrQB93Hd8D6iYMeaHsW1ybZLbjiEmQZG9gCxBJQiWsYWdyA9Hbk+irMysIVLgeRtQUFGSbnSzX4+WuFT9Z4smbUEe1T0UqysuJd6Y05HS1iW0TdZIfMMg310/loSTpcRLIYK5eEAKLmzCgvTw6G2wQWGSVcaNudsjm1mqvO3NyQLIh72PxETtQY3w0+J98q3SXXNVA311BZ7EA9KrIXEZvmamvvNq/mkMQgjwXXMeFwnlF1MLweCqhj5lZOEUXkfowsJDWBee5g7LJHpVQFM2x8rNQxJOCuPuep+cDsSvQDogt+5pzWEaV8/PEZitbZe6zxA6bgWfZcmy6+P92xgxnTNZclUMuuwznWlflqwiJhktYyiGgQqzr8TL98sOH3IWftey1510Sm3cphSZL9ep0yQ2a47L9CeqX85K2FlMUQsLTvZA95maPte32YAq6R23G1f0lFN70TFQOgdrPcfcZhVCiZ5wwfQNzNAIdaHSlKnFpXV7zshpE9hA+zpw58OSPPQnmn3gvbqEWXnL0kfseCAouvKEQRvXK6IuP8/zoG97OwxX7ZWvlUj/tgEKc5rXbCDtdqssmh/DzXll08hFbiyS3GlqbZhQAvn3CB67sL0NkqqoqiE2IkuOLAuPJul12fzZnUH0jDhQaW8w6npGBnijnAWJE2riJGVJaZTBOcV0XansNYvC4JCs63X5acLvOgVMxc1Xppm1y2K4Cd673zuT2b3kBY7ZT/BDPpzK3Xqu4ouvsIUCSr55SgnDQtKWZ0aHctitBD6gWgHjXXnAZ6JkHTINWpU1YSyhTUGQXeofkMgEBOoiGSGzEhviWhoVLirfjG5dVDuwBX+0CJxs6saCuWl4lcUDJtZUuhTokl+a2sn9xH5pZPQEgXrd2Sog/5bL9g/bw7YGKAQpBpuoD5DqT3IqhGi9wydUo950EipH9DzJbIuKEBGCyS0bE1xEJke8OSEmSpIhYCJJk0YiLR9rO2YtlgN4DTChrsFNc2SVezjBtsxZL1wxDfaF8SCXlxsBBVI0Qq9yhGiKp4VHnSjXPNnLinXj6V23yDdZ/AZpX3wlsqesJt5Bpcmk79QzhvsK1DXY+OlG9s32TGAQrp0AAF+ougTH0Xa18kH0pF6Vho3Aowqitr3B9h3Iwn6mNQYQQYR/UuE7nYMh5XIZ1TxQuxyDYBYsashrUu/FO/wmN8Fb2TF3VGOJQ3uM3716D6O7rWxZB5aBr8GoGMi/S90Slr/T6KYgQnGKWxjiMxUbjDDd+JxKFYqNiq1KcXoFVWxaYaKX1ZrDlvwbaXf/WVK+/KrEmRHCMZfyIYRuqm/txKMr6N6YNqKqtMw2V4DXEc6PLUyUN4fzFp4xA2T91nQrlSE4EvQxqccpXtmD/8K+7YODYDQ10dOeOXzjCE2m8WZpVSHiTuXVhPdzvJJyZu1oRlFGvV8d3bIiVWL9AVceaug6E5MKry/vAwff77Me6uw/cWW+91LN8fQdzbifF28uVdb1tzntRF02Bf4mibjahfCe7raRDybnAo3+7Ju5WUfNwGHwA3tycufPKDO9qCoe4x2Qt1OReQOrW/QGMH6plBLi+YFnXqqqumIHUo4Hz8BOd4J3uyWNCmu4miez92Tqx/8ZweI3NIv0u3AHQOFJMeaT+gcQr8e1lPKmg0xgdsL9u3O/Jx7vrXyAAgTNwVrhHGTl6dwiWCWXH6noXBn/uusJK2vMiwrq6cTxJyy11txwOPOrkXxMKFNTsdqOYFj7Q5bnq3rEi0NN0seR8yehzuY51fHDo2zSw2GDY6xee61g73DGhWmpWJtvKVozLtLpk7nkoVcr2RkmkLG+jd09k8YtIU99qeUCIMfRBxAVm2YLozKvCl7kFAEK844oF8WRhc3jnRe27eEdqCjxdIwCwRGmoCwsUiTlYX9TlbVy5954Jf/rm80bf10NB9l2EZXsz0ZRXTV7uFgCYYBh4sbAaw+0Xt9MY7n25RwCAB8nKTLTl2OaiMW9jO1Dvtw7+Bh/odHtnwj4U0Zrj23m4rwJAcz7u9/f9r32elLsc3VT05m1UVb1oIDyP2sCxywj2YUgf34b0q+yXuQUAbAys+a4o7DQQ5LQjCO7ERFojABBuL2HjNrOZJHfifrPP3jH480TXwWbv5OxI72J2TMsAAHAh5eN5AfQkl60xadHVz5YJMtWqsk9xQYaqzvXDDBTbXEr+JPowCJsfsNF4mu+ItnZ2TL8FAHArqSyemDyQSJV8QkJ1aZIVJK5Lld3dAfGe/9YIAFhTEJqqsWLwgMMvzj0ugc+ruyEry+t4JTMuem0BgCIGzhgWBi7Rnqcxo19plwBAc3pK9PW8bGcQ2r855VMrS+iIGMyOaWwBAEEZNnaFZ4Fso70KM6Ugb1ojAFCUkaSxIgB+gLwfut90kQgNCMzyOp1XASA4i83QuIuvRtN+1XTr33Z6yzQvNkvuiBjyNZ0tADCLbLwxhgcDTrY3lRVlwPpGAIDbSs94D1paZuL32gGugJbWDQP1rpP6jFxkCpkd0zIAADxpNqVxrYHiZ6vwbLYSNHbbF0DZDPscFHeaXkz1I3n0+pDcL6DK03xPXO7ZMf0WAMD4pCWNa+0tBk8Bz6xN0dhp1yG4XiZSMwGAUBEGNNHM7zv0T9q5kQjLMhvSGJc9twBAGTW3C8KeQmAtE0b7MbheRsolAHDcB/V1824R2U744UT7YIW4LP4f13puAYBaBG4xYQiHgUWG0W4G12SkbAIApiJowIS9+eyRJdkhFSkxy/rXfRUAkrNY7vHkJ6Bove3NGKW5V39r+ZbdisZBqfia9hYAmFF2v5zhDgZouBsDTGsEAIzmLU/RIouvUlKCnmtGbmPV4mwkcDrpbbDwQj3ObFkf4F3qViC0d5N36kWqxySsWDscFymZAAOTRkcWeadIiIG/v4kF2Zn/8hF42ihb5efkULxFNXCk12cf7DJPzb/Bam929Wb57xsFoQOGcjr4iMks/kBBnm3wgfGz346J1f7kG/vanr6DerdxwA+RkW7zO+V6gsK5fi2fU7vWYmW7Pqy56+wTMoIPRxBJZ2FMoBq5tQRvAn2Xy8HcC4zH7yHeTG8B4+Gdad8tSjtq05zy0AlhMpOhlq3CX1WXPYNlJz9xc/ni/14GuTHUMv9HjhIEXszSK/pB0YjgCIGqAg3xePZRMdoyBIZpRoZpxla7kvl1MmHdA9MfgTlIJ+U97thWk+IYrYV9xN7HpmrJJL2ptRJASRqiW8t6ioqJpUDOrQ3EtFgdV6nL6LqwyND5aCwGFEo6dk3v4C8t9xgbiBGVy+uoOC8B+XseGAKz5kCmdHTidAb8cSkwuzQ5nKPQ0/wcK1/1NHaTDkt3T4Lv8NnnrsMt3dt7ykXssMtPueKKaqJg6U65mwYK0l7IKT2FaWrx8z8hKkcguliG6Nz7AC30YGBSSwT61FQWVdj3XzLGAB/3UyKQvhV+a/pYJNVVgZBF25fZbgfYxErIWPWh+JuVQ6I8Ga96oBdXg0dCCBO5w4bn+BWb3870n59iNsgjO1vH5fojuOHnnO54jwdEhKutrDxeWbwRh/5d4412T6w9MANoF1osCYhwwSOl/4WKHP/FM0yTJsdcYkoeFRyKEvO6x9A+hdFieS725qEJ0n5X5vl4YgI171qxwRfJt7Br+0mRh0UyhOwhJluuBMbrx/tZ3v9F+hH76Ypps58XLdnD3SA5H7h5fOPOE+qz/dRdCfC7qJjF6hvjZlTCsGCJSVjOBW7U26imcAgA7P3eSOwsVQvPRVnexvXr1pdztnXHdpDlk0na/DTWMj5exJwae8NClgleOwUR9qsXe1NisBmhvjzZ35YndxpLIwpgzpJpLyp7I9SxXx0BpvfXoWm7eJ6TW6dI/jgr49IZ9gyjG4sKYlnCRt/JBUuLgekouBmU6q/MdkJms4SBEH8P6MRcd++yTZYMYj7dX2EyLOOZ8wNVjn2YCEp4HKxSHgfrfRG8DNDPAJX4iJcB+ulMyY8xI2UlsuXRhzYCrWYsQ8mOM7GIRUu7iPheK26FN880OZmO9XO4fejbSnPKSmI3P4XE3CTWw1TPr7CC4sR5psE3apN0dmKn7Gp6TjdN+Dm6R4AkwPZtmnyreHZlsvAAmZZ14XTcAGJ6nRKEU+F8OgYopE5hiarElqwxc8Tm+Vj7XBCXNauBHxNtbd6vbHG9omNwyUzasZiNsqHSoD792EG8/1QHlwq7m1b1I3zUZPSIjWADVrtE5tZoUzYNa+AkvPw5FJdloZhmLmEP2sLpnj0cTDz1C/dGtscnJsecHi1v7Zr9ri39/09oRUw2qdon+Qr0fOg4UtOeVF32TMUb5oyyivv8Z7VaJKJYjeH2oxWngBfOka98OwqV4I3C2WLlmekdmHZdGnnQXCu92bXZninOFYxxpb4TmmBp7iUwRuaB2ygBjo6QBRzKO5ix50nF1BoufK12rNI2I00bfN0sQWKm0smf2WU7NcCkwj8dS+cTinRq4iULpFxpfsfWrpg3jqfs/8ss3VdmoIuKnqFtKdcM1ez6EgGYUvjidNQkxWoyzYZoSciqwR4qoa5DNd3QMS0eBN7O90ppGzkjTd6PZnDGss6wqZdndMsAgI3NQWMKnw0a7bLRFE0AQCLFljsgI0vghrPkuaRvT5whk5Im9SK6YY1anFpvFbyjR8+IlveZGaxY1gp44l0GAEAamh/JOA5G++4YX6MeTQBg9UZnW34Fms4U6GPIyuzzgu+ynopIasitFu/oZn7T8hgaeeouFYAxNfIaDq7FYx9+RvfNeBo5Lo6lGay1rLVg27cMAPjY1LxySWEXddpZNujRBABSooUtF0DrbAAJUTvJsg+//rvXH7t2b0B/cR0xXfeNuN/bFFjDT8chEsRhylcGANxIWEY+wa5AmeNzEem2kxDeqWM+M+SJWEtiOQ3sxOMDXrITisFEBEpVmDU2aSMJMTAiI5Z9YhAU9tQqxC/ODrRpmW29kWZDVFFWMa5ptrMNgkz3i7iYTUu/YoxiNTUcmnlrJEl1ikC9kt0yRIZVylFtnv0SQkjzlj4Ip+Qpg9Q5EyyyigB3p82NTNAktJjqxyT5vei0Y5baBF1qOXsf+gkLz1mnHl+mKCxY5BKpRmLi1q4wKFRDmQuoZT90vl0lT66J3p4qOxCDcHq0K7g9d10c9hlxSZZ2XB+dy57miYO7dXnMBLJUEYa1OCMa5Ul+7B1TYD6LaqgJSXW5W3SWLtokcZDp5rgtswslQ2NGFVm2KrRwymHmER9ttY19Iz54lrKO636M0t6x+sxlERbmNLq9BT2d7myJ0Ex7JxbgLkjB6sRj63ZHAUlONO0IN2/4zrZ3keMMwyMOM2fmFlXcBfVRhUUTAKUDRjh09MgjcXx1DQNiA8i0ZuDCKzutc3Z8jDxadOL4DowZMSJkQox6cWIapim9/0r0xnhb2CN7XIticq7Ju4XxSiQ5SDcZzqHeLsBn2Z090wYvXSniHIWlUiQOpMiUb4H3XX5Qfzz64qQwcPN9oB02j1V7Etbw/1KWAQD3JFsqCGcp3OKp5FxlR9W0shmhePxfJgCA2tluo4tX9+EUdxcv4Xn4fYzVi6BsIB4z9foY5TOa5JQjgNdf/c6W9nHwDc8/jy+Dy22AL6iyC84B3mNQPtImC8vHBFaOQNyKStZwenxxDt1Li239jQ5kny1KlT/qiNK44eP4NWzlUQ6lSgKZSV7fF4d9krlxOQW1wFsdTe9hVjYfRa9PwlHVU8AoHA63ofvfPSlm75k8DmCz0I+OqFvOqWNDV36/0gF+Ao7qyyCJCUOvUXMYzy5PVddZbGUjtUjWNxrEaHfncPCj3uWzqlMDsIUSS4TqWAujopMdFFM70PHTqQ5YYSWHK5nC+Qr2xOoYkOStnASeQiWLXyWz5bPKX27O5321gJrerr9lKDDPXFw2S9XTNEH2K8sfJqS2GFgLs+Ey4vWKUDPhSVRWlg+gIjz4s0u/sA5+adYGgMtEyDS4Gst6VTQC73qXAYBdkNYQVhpKG6iGbnsbJPg0AQAZnC273yI4932UAGC7GDOrZPI8gHdKmlKNiL3kU0OHqXljSR5w/aMpVaUimldH5QAUiBC4cZpq2Gqf9OnwA4eMf9vWoCxerZQDUEBC7C7hKrI/v6LvrBz+vlNBtJ/iEeIdFZufjlf3MAKQ/t4yAIAIYNYQRsuhUpDltjdBhkcTAGgy7mzW/R1DI79JAEAjau+qP/BzlJ9l1c8hrc18rJ3R+73NyD4qNj8dg1hHrci/UsoAABuhtMcipugb7tj8FaFrjiWHXTBC000pzd+KTzCV7wtLOm/Goc/9qM/DXDRKbTDEaRE49rnia/0r+aig6OJu98nPtWL8D7poAExnVP9zrztM8KWD8I0V67r77SdxEb4ObIqSS2zJDlN6CPsCgZr8Rnm6yaqYINI/FbUEnBthfhyjqp/TjQnSIYg9I4lk16sSPgMXzenMoJmH2vvxZI+56SBa/kJpK9PuCvK6H09vUu9NDzrk2UWpboZR54HRtC7K/LpSDl2D8LllJ1Ari0Rx/VsIRDBRZ+DU9NAjjuvDj+ON/aevT0499ictH0uH+omcu/Q7nti1GSZ3GJ3lvhIriXjHxNnQwdBffpaINbFHk3c9O/dN5PB0capHMBvmmT6bIWMlMh/aIiCga8PFvLdpG8ZUNbK3hbPErumX956RUrU8zwAAIKudmSx5e6fUWYc4Ss9f2xsMG86uaUdaBVo6NT/Ihqf6nucPfTvgKneER0QY6w3G916EX16I+QzolTCEFhl0bw5D7M9hg4vYLyHuinEkb8pE/3pL/noFCwJldDApCB9UzzxVsivBeTF8jVkDUx0Drdic4NGtZnEaaZViqxN9mLIhkAc3MKUVnurfEd4XTS3TSdshMDo7JtNkkDpzYrOVBiHFOUdWZjonWbH9lW2Oy1HYSAbE1x3faZFPFDcjhrkwUNDQuLl0HJV2kCq5Wbttk6d9VCYaZPiFA/QDwuPVFvn3FpS4Y3ggY+ruB1eU4TD+rRFIKXgP41IQF/87cTrPPABh/BNbN99Ue2W4pdzgO7hi1hQ73CCr2bGmpNPZ+rxwjyzX7/dfqVrAOjGee2FCTlbMVRMsSnFICneBI0p0P7fiGgswtsGaIetoRBmul7PWTzuiJFKhLUFfu4RdnZIDpJvCcuZGyEArU8bO/uLHx2HIi6tc5Xwiany0e0HABk2MxyD/zrSKY95+9jSdhp9tIExP1IN4kl849mIpdioNxuQQ6hABjIPm6OtD+6e4gNg0WGxoj/NsQW++gQ0mtGicAbhTSTe0P+17N5SBOlHQC6/wl1SlQdlORugyBRhmsb23jf2lTNVL88eCFpMTziomFZwxo5Q6CQk/JqwyifxvmAJaxkCF5QwlVqC4z3jq+Lw08+hqj6pE2zrb5HIUTd6MYYjJ4NHpyzPL5lyncUQcV8YjotIL3MiK3nk3gM88mV9JfK4jMzYrywiw2bJojg/rQ7Vpl1YS4CtGkius6/cGdMW1xkSug0Dpz5mqyKUX4gUYPFtzOaEf4wpJQeWqw8G8qgPfyvt/DVlaycH0maKvYXGLrpkrZh8uUom6R5QlrURpW+ipEmb7UUjQ6A9TmEj4qUDrBxU76J6zevRY40Lbwn1osRM+CxLPIMz7vSBi/hFlD26WzreghT28j/FZhMYP7bw/4PADokSKSObb/FlPNH9iQPstfzG4+fKt4yq4D4KyqsHOaxbCGv6fZhkA6AnsYRFTHHZxiYq7CDe1LBntrFFNzjUUXyYAQNwb62xd7apH/NcrRVMHv+Y9M6wEn7UKGIunNrphT59H/UTC0T7g4TDwytGVTdKFPOHrga7gH3pCQeJysXXE0qUdAGvRMRW+qRoRmrn+Pgcan3oTGLMBGexXQ8UOgRChxIfoCAwvkkzCH/RGfyta6Qddx9/i0we0+n+6ZSs2V5Q4gf+he66gprH10gIxSkAjinQyYKx0OFTsQNezLsvOJW5jC0g0GtMrZ3yvzX4S2HaLtRjiQ25nsFrDWDEnu/jHBXfLGM1wrPi5ksyn1s3Ocqi/fx2cp7txkpD/Ws5rs2QK/wPsYA8aXPF0/y7MvpHHdfMkCNIPsh6/IGx9gjZWbW/87rOdMxdzx2Nkj4W4L0zNYiCJRKMeDVg9BoqX/1svOUcRbGA1p2JK6ZkZfR40qO2aHNt1+1hQbyLQ6R0UNiy+4e3yp6Od0wAOBMj4hyWxru6DIPYPImGTzsW/n2AY3nxGXgxoLoGWOJ+vriBIdw7sCf08pH50Wbv+qsFHJCbOAD4JKzvrWkeUp56C1Uk50iWcq3WqUc40flU/alss/yMZbnSpM7R8ltU1G9wX1hmtJBkEwwUlc+tCxqJuij63yvqz83pZt+goa4eZDVzxoBFppzc+4fzEdqfudBvewAsLYbbDY02WLBELcV0z9ObN403Jt7dm8d3VPKI5RGxl+YyGiWS4m8GM2hCWN+ZvkArN4YECTtiBTqBR0I1ibkBzI8IwbRmHftxJuINreGR/csqPD2tgE2A5NVwKI+voAqwo8uPCktOM/t6zVwVT7VGngF46hwsG2oHgx2HPXmAHZo1rAIPulTSCp5oilyjw2NrIl9PaitujpaHN7+jNaULD2AzkumRisjImr0RfPuJM98gx3f4y+6WsnoMd1Xf0Vh7Ff67pn23t86tGVEnuYSJs04jEPrSc0RltGtVpkYVmOMtHlc68iVXARONK+ayG+EYI67C6iYV5gbXEBB8AHn09O8+lT6S6WAbe2xrCgRl4Zyyv7L4dErOrfdETYn5K1xuwvGdkyW668O9kOkIFcW5p7H6ha4tqhZ0M2cpFgzu5hF75qA/E52nahIamua94cVeYpo+qvXoYtdqgSlYoMf41/GdNtpm6ghK+izIHHaom4BPpD05vX/0B5mzDZUlo1yhLKj6BwdI0roKYLYEPfRgm7LzAK2Oi3mbJZaxr5zFLjRG7uBKXBU1bt1HyjYbLIS8M5w4GBisqn6HtmpUed+jRy1Vx4jDpQr0c56QZkSh4BtZt8D9bzLjJEOlslW91s//RI04wc8Tz4ipVCo4xCStcAzthSKQHcdRaINJ10ZYw3Wz5mpaZn+LxXt/vmvgrrpdzIxLD0sEYNkETL5vd3IEQMBWezGcX5dsyelfviI+UuL2r0uKYYT86gNKsiB1DIADbwfbvWxzHTxDH4YZ9R/NxVG99oQJGRswhLSxcU/SDVCNXy9/lGYP58wtTcn76+Jv+NfJu+JNPzKgB/9CSkcSPUSX02ervznnjb/pgoPLEXLsT2Rj8TSZsCH+ZCA6ES3sx88LI1um3943hU9ljufH3EvqCCjJAGoz9nNDR7Of0OlI809V7Sa0GfVKHpJmMxb2r1659xum0U+EfBHxMm33CEyOARZkx7sWaX64v4kJWK4FhMYeCZ8OUA+rZRz6mkShmrwVmWyYd9C2c9q/zQShF/NsT9VAJ5zkdp65hqQ5fk3+lKwMAMYLTx+LbxH4JCiUsJn2oIXHZiSOzR6ld5M0EAIJuRWbAhQWbnAGnSvTulrHr/V4/ABAsQKoItQawnZxP28CCebFcwHILf7oBTLgEd4+yyQDv2e/UNS8k1VmSDROyajopsSVAd7nZeQAcc4tVAFYXs/cMcJx/qwGAW1a0ACKCblODHJ7XGFpH5mItwazRQJy6AgmgbP/hOPwSahh+f+uNT9+E/Cmzzz7ysnh1ChJAfUSxMaUqMmq/Z5orjrqpsrue2ojiDdKxqumDDBPCKqZSlgGAlsBuFmYwjXAdUlz2wa8ax0uc0vt67NEEADCM6eLa3IBvs/SuGOry9gMAKDDbidKBm7aPAk+ssRbMcv9sMM4x8IIWubciRKVw3CZKjdYv4n7bQP7AtAViAjieIm/YPA45OE4heshGWhkAsBI0yML8tBHaLYbDvm2E6Q0jMz/2KeVEgysuNC+AYxKLP1eOgFviJ4/YjbnnEhBn3kngeHEum8dY8kMvLk5HbHzX3GWLfa1Z//wfnusE/h/cYoshJBI+zPp+VD+Q49k/sY5uq1k/TeH7I/6fpxQ1MRxHKY6Z2zzAKEUOJRfeHZ+nuHeGMyYYpTRHRYHAiC9TIu4vN0HlHrpaVcH8a+dB77Jrf1sLT+B4yrX5xuojB1vHsYevaZYBgC60JLhtFobwSlJVFJMd53AxQpijfD8TAFjkfR/Yw99qDbg9W3+YscPAc7QG+Z8c5+jnbEk6r1bomKu28KorqLO4MRGOP9e9tMUAwIqGjnhtko2uZB5WWopPpZ2zv95V3bRYvWZ9Eh6k4ejxt2FdXDYw7PiZc/bXuwZLS4EAHrmE4S3rHTh777zE7mgdQ50lVwbhLi4jaf2F2jS3efBn+lZ5WbFiGQix6z8VMIcQa1ayYRUhVPXHGz4Rcmc6FdFdiM/huM2ItfzHq3kED0i7fwv5ERyPas1Px1a2CfW9j9B5v/F6j9N6ITd94ynPgj/EqoanEh2eZQCgW3LuyifOfPa9ZIUkHRruWZohiTJd0WgCAO1WFGJ3KjYQd8IHoLtUbiXGtvr7BQGAprnU1RgHarbpiigwtXYPkAIzZYmxUmDQrh8kBThxClZSgKQt33NMlZJJDQF1lShpxMud2jI3GxDwdm4RCLCumJ0l4DD/zhXgVllRiojI4LhN9O6gnD9+XGN+a4MMkfEb6w0kgLr9hyOE4zYh4db4k9Dj6W3ywyuCzPyN9QsSQIFEwT+6ENP9JfKq5D3AK1nB5F/kPT8BHPOb9XiQZ1l54OqUZQCgzgguA9WawfQhLs/5l9E+PVZOQWefJgAwB6ZdGxZYypRTMz6R1yAAaIHHTtQSXGX7MOBea7wNHrl/AnjoGKjBiPW+AQ==`, `base64`)).toString();
    return patch6;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-compat-virtual-f9d90af7d7\1\packages\plugin-compat\sources\index.ts
  var PATCHES2 = new Map([
    [structUtils_exports.makeIdent(null, `fsevents`).identHash, getPatch4],
    [structUtils_exports.makeIdent(null, `resolve`).identHash, getPatch5],
    [structUtils_exports.makeIdent(null, `typescript`).identHash, getPatch6]
  ]);

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-75c55dc7be\1\packages\plugin-dlx\sources\commands\create.ts
  var CreateCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.pkg = options_exports.String(`-p,--package`, {
        description: `The package to run the provided command from`
      });
      this.quiet = options_exports.Boolean(`-q,--quiet`, false, {
        description: `Only report critical errors instead of printing the full install logs`
      });
      this.command = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      const flags = [];
      if (this.pkg)
        flags.push(`--package`, this.pkg);
      if (this.quiet)
        flags.push(`--quiet`);
      const ident = structUtils_exports.parseIdent(this.command);
      const modified = structUtils_exports.makeIdent(ident.scope, `create-${ident.name}`);
      return this.cli.run([`dlx`, ...flags, structUtils_exports.stringifyIdent(modified), ...this.args]);
    }
  };
  CreateCommand2.paths = [
    [`create`]
  ];
  var create_default2 = CreateCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-dlx-virtual-75c55dc7be\1\packages\plugin-dlx\sources\commands\dlx.ts
  var DlxCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.pkg = options_exports.String(`-p,--package`, {
        description: `The package to run the provided command from`
      });
      this.quiet = options_exports.Boolean(`-q,--quiet`, false, {
        description: `Only report critical errors instead of printing the full install logs`
      });
      this.command = options_exports.String();
      this.args = options_exports.Proxy();
    }
    async execute() {
      Configuration.telemetry = null;
      return await xfs.mktempPromise(async (baseDir) => {
        const tmpDir = ppath.join(baseDir, `dlx-${process.pid}`);
        await xfs.mkdirPromise(tmpDir);
        await xfs.writeFilePromise(ppath.join(tmpDir, `package.json`), `{}
`);
        await xfs.writeFilePromise(ppath.join(tmpDir, `yarn.lock`), ``);
        const targetYarnrc = ppath.join(tmpDir, `.yarnrc.yml`);
        const projectCwd = await Configuration.findProjectCwd(this.context.cwd, Filename.lockfile);
        const sourceYarnrc = projectCwd !== null ? ppath.join(projectCwd, `.yarnrc.yml`) : null;
        if (sourceYarnrc !== null && xfs.existsSync(sourceYarnrc)) {
          await xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
          await Configuration.updateConfiguration(tmpDir, (current) => {
            const nextConfiguration = {
              ...current,
              enableGlobalCache: true,
              enableTelemetry: false
            };
            if (Array.isArray(current.plugins)) {
              nextConfiguration.plugins = current.plugins.map((plugin23) => {
                const sourcePath = typeof plugin23 === `string` ? plugin23 : plugin23.path;
                const remapPath = npath.isAbsolute(sourcePath) ? sourcePath : npath.resolve(npath.fromPortablePath(projectCwd), sourcePath);
                if (typeof plugin23 === `string`) {
                  return remapPath;
                } else {
                  return {path: remapPath, spec: plugin23.spec};
                }
              });
            }
            return nextConfiguration;
          });
        } else {
          await xfs.writeFilePromise(targetYarnrc, `enableGlobalCache: true
enableTelemetry: false
`);
        }
        const pkgs = typeof this.pkg !== `undefined` ? [this.pkg] : [this.command];
        const command = structUtils_exports.parseDescriptor(this.command).name;
        const addExitCode = await this.cli.run([`add`, `--`, ...pkgs], {cwd: tmpDir, quiet: this.quiet});
        if (addExitCode !== 0)
          return addExitCode;
        if (!this.quiet)
          this.context.stdout.write(`
`);
        const configuration = await Configuration.find(tmpDir, this.context.plugins);
        const {project, workspace} = await Project.find(configuration, tmpDir);
        if (workspace === null)
          throw new WorkspaceRequiredError2(project.cwd, tmpDir);
        await project.restoreInstallState();
        return await scriptUtils_exports.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr
        });
      });
    }
  };
  DlxCommand2.paths = [
    [`dlx`]
  ];
  DlxCommand2.usage = Command.Usage({
    description: `run a package in a temporary environment`,
    details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
    examples: [[
      `Use create-react-app to create a new React app`,
      `yarn dlx create-react-app ./my-app`
    ]]
  });
  var dlx_default2 = DlxCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-init-virtual-39bcb727de\1\packages\plugin-init\sources\commands\init.ts
  var import_merge2 = __toModule(require_merge4());
  var import_util14 = __toModule(require("util"));
  var InitCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.private = options_exports.Boolean(`-p,--private`, false, {
        description: `Initialize a private package`
      });
      this.workspace = options_exports.Boolean(`-w,--workspace`, false, {
        description: `Initialize a workspace root with a \`packages/\` directory`
      });
      this.install = options_exports.String(`-i,--install`, false, {
        tolerateBoolean: true,
        description: `Initialize a package with a specific bundle that will be locked in the project`
      });
      this.usev2 = options_exports.Boolean(`-2`, false, {hidden: true});
      this.yes = options_exports.Boolean(`-y,--yes`, {hidden: true});
      this.assumeFreshProject = options_exports.Boolean(`--assume-fresh-project`, false, {hidden: true});
    }
    async execute() {
      if (xfs.existsSync(ppath.join(this.context.cwd, Manifest.fileName)))
        throw new UsageError(`A package.json already exists in the specified directory`);
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const install = this.install ? this.install === true ? `latest` : this.install : null;
      if (install !== null) {
        return await this.executeProxy(configuration, install);
      } else {
        return await this.executeRegular(configuration);
      }
    }
    async executeProxy(configuration, version) {
      if (configuration.get(`yarnPath`) !== null)
        throw new UsageError(`Cannot use the --install flag when the current directory already uses yarnPath (from ${configuration.sources.get(`yarnPath`)})`);
      if (configuration.projectCwd !== null)
        throw new UsageError(`Cannot use the --install flag when the current directory is already part of a project`);
      if (!xfs.existsSync(this.context.cwd))
        await xfs.mkdirPromise(this.context.cwd, {recursive: true});
      const lockfilePath = ppath.join(this.context.cwd, configuration.get(`lockfileFilename`));
      if (!xfs.existsSync(lockfilePath))
        await xfs.writeFilePromise(lockfilePath, ``);
      const versionExitCode = await this.cli.run([`set`, `version`, version]);
      if (versionExitCode !== 0)
        return versionExitCode;
      this.context.stdout.write(`
`);
      const args = [`--assume-fresh-project`];
      if (this.private)
        args.push(`-p`);
      if (this.workspace)
        args.push(`-w`);
      if (this.yes)
        args.push(`-y`);
      return await xfs.mktempPromise(async (binFolder) => {
        const {code} = await execUtils_exports.pipevp(`yarn`, [`init`, ...args], {
          cwd: this.context.cwd,
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr,
          env: await scriptUtils_exports.makeScriptEnv({binFolder})
        });
        return code;
      });
    }
    async executeRegular(configuration) {
      let existingProject = null;
      if (!this.assumeFreshProject) {
        try {
          existingProject = await Project.find(configuration, this.context.cwd);
        } catch {
          existingProject = null;
        }
      }
      if (!xfs.existsSync(this.context.cwd))
        await xfs.mkdirPromise(this.context.cwd, {recursive: true});
      const manifest = new Manifest();
      const fields = Object.fromEntries(configuration.get(`initFields`).entries());
      manifest.load(fields);
      manifest.name = structUtils_exports.makeIdent(configuration.get(`initScope`), ppath.basename(this.context.cwd));
      manifest.private = this.private || this.workspace;
      if (this.workspace) {
        await xfs.mkdirPromise(ppath.join(this.context.cwd, `packages`), {recursive: true});
        manifest.workspaceDefinitions = [{
          pattern: `packages/*`
        }];
      }
      const serialized = {};
      manifest.exportTo(serialized);
      import_util14.inspect.styles.name = `cyan`;
      this.context.stdout.write(`${import_util14.inspect(serialized, {
        depth: Infinity,
        colors: true,
        compact: false
      })}
`);
      const manifestPath = ppath.join(this.context.cwd, Manifest.fileName);
      await xfs.changeFilePromise(manifestPath, `${JSON.stringify(serialized, null, 2)}
`);
      const readmePath = ppath.join(this.context.cwd, `README.md`);
      if (!xfs.existsSync(readmePath))
        await xfs.writeFilePromise(readmePath, `# ${structUtils_exports.stringifyIdent(manifest.name)}
`);
      if (!existingProject) {
        const lockfilePath = ppath.join(this.context.cwd, Filename.lockfile);
        await xfs.writeFilePromise(lockfilePath, ``);
        const gitattributesLines = [
          `/.yarn/** linguist-vendored`
        ];
        const gitattributesBody = gitattributesLines.map((line) => {
          return `${line}
`;
        }).join(``);
        const gitattributesPath = ppath.join(this.context.cwd, `.gitattributes`);
        if (!xfs.existsSync(gitattributesPath))
          await xfs.writeFilePromise(gitattributesPath, gitattributesBody);
        const gitignoreLines = [
          `/.yarn/*`,
          `!/.yarn/releases`,
          `!/.yarn/plugins`,
          `!/.yarn/sdks`,
          ``,
          `# Swap the comments on the following lines if you don't wish to use zero-installs`,
          `# Documentation here: https://yarnpkg.com/features/zero-installs`,
          `!/.yarn/cache`,
          `#/.pnp.*`
        ];
        const gitignoreBody = gitignoreLines.map((line) => {
          return `${line}
`;
        }).join(``);
        const gitignorePath = ppath.join(this.context.cwd, `.gitignore`);
        if (!xfs.existsSync(gitignorePath))
          await xfs.writeFilePromise(gitignorePath, gitignoreBody);
        const editorConfigProperties = {
          [`*`]: {
            endOfLine: `lf`,
            insertFinalNewline: true
          },
          [`*.{js,json,yml}`]: {
            charset: `utf-8`,
            indentStyle: `space`,
            indentSize: 2
          }
        };
        import_merge2.default(editorConfigProperties, configuration.get(`initEditorConfig`));
        let editorConfigBody = `root = true
`;
        for (const [selector, props] of Object.entries(editorConfigProperties)) {
          editorConfigBody += `
[${selector}]
`;
          for (const [propName, propValue] of Object.entries(props)) {
            const snakeCaseName = propName.replace(/[A-Z]/g, ($0) => `_${$0.toLowerCase()}`);
            editorConfigBody += `${snakeCaseName} = ${propValue}
`;
          }
        }
        const editorConfigPath = ppath.join(this.context.cwd, `.editorconfig`);
        if (!xfs.existsSync(editorConfigPath))
          await xfs.writeFilePromise(editorConfigPath, editorConfigBody);
        await execUtils_exports.execvp(`git`, [`init`], {
          cwd: this.context.cwd
        });
      }
    }
  };
  InitCommand2.paths = [
    [`init`]
  ];
  InitCommand2.usage = Command.Usage({
    description: `create a new package`,
    details: `
      This command will setup a new package in your local directory.

      If the \`-p,--private\` or \`-w,--workspace\` options are set, the package will be private by default.

      If the \`-w,--workspace\` option is set, the package will be configured to accept a set of workspaces in the \`packages/\` directory.

      If the \`-i,--install\` option is given a value, Yarn will first download it using \`yarn set version\` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be \`latest\`.

      The initial settings of the manifest can be changed by using the \`initScope\` and \`initFields\` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via \`initEditorConfig\`, and will initialize a Git repository in the current directory.
    `,
    examples: [[
      `Create a new package in the local directory`,
      `yarn init`
    ], [
      `Create a new private package in the local directory`,
      `yarn init -p`
    ], [
      `Create a new package and store the Yarn release inside`,
      `yarn init -i=latest`
    ], [
      `Create a new private package and defines it as a workspace root`,
      `yarn init -w`
    ]]
  });
  var init_default2 = InitCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-init-virtual-39bcb727de\1\packages\plugin-init\sources\index.ts
  var plugin13 = {
    configuration: {
      initScope: {
        description: `Scope used when creating packages via the init command`,
        type: SettingsType.STRING,
        default: null
      },
      initFields: {
        description: `Additional fields to set when creating packages via the init command`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.ANY
        }
      },
      initEditorConfig: {
        description: `Extra rules to define in the generator editorconfig`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.ANY
        }
      }
    },
    commands: [
      init_default2
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\index.ts
  var import_semver21 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\jsInstallUtils.ts
  var jsInstallUtils_exports2 = {};
  __export(jsInstallUtils_exports2, {
    checkAndReportManifestCompatibility: () => checkAndReportManifestCompatibility2,
    extractBuildScripts: () => extractBuildScripts2,
    getExtractHint: () => getExtractHint2,
    hasBindingGyp: () => hasBindingGyp2
  });
  function checkAndReportManifestCompatibility2(pkg, requirements, label, {configuration, report}) {
    if (!Manifest.isManifestFieldCompatible(requirements.manifest.os, process.platform)) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.INCOMPATIBLE_OS, `${structUtils_exports.prettyLocator(configuration, pkg)} The platform ${process.platform} is incompatible with this module, ${label} skipped.`);
      return false;
    }
    if (!Manifest.isManifestFieldCompatible(requirements.manifest.cpu, process.arch)) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.INCOMPATIBLE_CPU, `${structUtils_exports.prettyLocator(configuration, pkg)} The CPU architecture ${process.arch} is incompatible with this module, ${label} skipped.`);
      return false;
    }
    return true;
  }
  function extractBuildScripts2(pkg, requirements, dependencyMeta, {configuration, report}) {
    const buildScripts = [];
    for (const scriptName of [`preinstall`, `install`, `postinstall`])
      if (requirements.manifest.scripts.has(scriptName))
        buildScripts.push([BuildType.SCRIPT, scriptName]);
    if (!requirements.manifest.scripts.has(`install`) && requirements.misc.hasBindingGyp)
      buildScripts.push([BuildType.SHELLCODE, `node-gyp rebuild`]);
    if (buildScripts.length === 0)
      return [];
    if (!configuration.get(`enableScripts`) && !dependencyMeta.built) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.DISABLED_BUILD_SCRIPTS, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
      return [];
    }
    if (pkg.linkType !== LinkType.HARD) {
      report == null ? void 0 : report.reportWarningOnce(MessageName.SOFT_LINK_BUILD, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
      return [];
    }
    if (dependencyMeta && dependencyMeta.built === false) {
      report == null ? void 0 : report.reportInfoOnce(MessageName.BUILD_DISABLED, `${structUtils_exports.prettyLocator(configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
      return [];
    }
    const isManifestCompatible = checkAndReportManifestCompatibility2(pkg, requirements, `build`, {configuration, report});
    if (!isManifestCompatible)
      return [];
    return buildScripts;
  }
  var FORCED_EXTRACT_FILETYPES2 = new Set([
    `.exe`,
    `.h`,
    `.hh`,
    `.hpp`,
    `.c`,
    `.cc`,
    `.cpp`,
    `.java`,
    `.jar`,
    `.node`
  ]);
  function getExtractHint2(fetchResult) {
    return fetchResult.packageFs.getExtractHint({relevantExtensions: FORCED_EXTRACT_FILETYPES2});
  }
  function hasBindingGyp2(fetchResult) {
    const bindingFilePath = ppath.join(fetchResult.prefixPath, `binding.gyp`);
    return fetchResult.packageFs.existsSync(bindingFilePath);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\pnpUtils.ts
  function getUnpluggedPath2(locator, {configuration}) {
    return ppath.resolve(configuration.get(`pnpUnpluggedFolder`), structUtils_exports.slugifyLocator(locator));
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\PnpLinker.ts
  var FORCED_UNPLUG_PACKAGES2 = new Set([
    structUtils_exports.makeIdent(null, `nan`).identHash,
    structUtils_exports.makeIdent(null, `node-gyp`).identHash,
    structUtils_exports.makeIdent(null, `node-pre-gyp`).identHash,
    structUtils_exports.makeIdent(null, `node-addon-api`).identHash,
    structUtils_exports.makeIdent(null, `fsevents`).identHash
  ]);
  var PnpLinker2 = class {
    constructor() {
      this.mode = `strict`;
    }
    supportsPackage(pkg, opts) {
      if (opts.project.configuration.get(`nodeLinker`) !== `pnp`)
        return false;
      if (opts.project.configuration.get(`pnpMode`) !== this.mode)
        return false;
      return true;
    }
    async findPackageLocation(locator, opts) {
      const pnpPath = getPnpPath2(opts.project).cjs;
      if (!xfs.existsSync(pnpPath))
        throw new UsageError(`The project in ${formatUtils_exports.pretty(opts.project.configuration, `${opts.project.cwd}/package.json`, formatUtils_exports.Type.PATH)} doesn't seem to have been installed - running an install there might help`);
      const pnpFile = miscUtils10.dynamicRequireNoCache(pnpPath);
      const packageLocator = {name: structUtils_exports.stringifyIdent(locator), reference: locator.reference};
      const packageInformation = pnpFile.getPackageInformation(packageLocator);
      if (!packageInformation)
        throw new UsageError(`Couldn't find ${structUtils_exports.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
      return npath.toPortablePath(packageInformation.packageLocation);
    }
    async findPackageLocator(location, opts) {
      const pnpPath = getPnpPath2(opts.project).cjs;
      if (!xfs.existsSync(pnpPath))
        return null;
      const pnpFile = miscUtils10.dynamicRequireNoCache(pnpPath);
      const locator = pnpFile.findPackageLocator(npath.fromPortablePath(location));
      if (!locator)
        return null;
      return structUtils_exports.makeLocator(structUtils_exports.parseIdent(locator.name), locator.reference);
    }
    makeInstaller(opts) {
      return new PnpInstaller2(opts);
    }
  };
  var PnpInstaller2 = class {
    constructor(opts) {
      this.opts = opts;
      this.mode = `strict`;
      this.packageRegistry = new Map();
      this.virtualTemplates = new Map();
      this.customData = {
        store: new Map()
      };
      this.unpluggedPaths = new Set();
      this.opts = opts;
    }
    getCustomDataKey() {
      return JSON.stringify({
        name: `PnpInstaller`,
        version: 1
      });
    }
    attachCustomData(customData) {
      this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
      const key1 = structUtils_exports.stringifyIdent(pkg);
      const key2 = pkg.reference;
      const isWorkspace = !!this.opts.project.tryWorkspaceByLocator(pkg);
      const hasVirtualInstances = pkg.peerDependencies.size > 0 && !structUtils_exports.isVirtualLocator(pkg);
      const mayNeedToBeBuilt = !hasVirtualInstances && !isWorkspace;
      const mayNeedToBeUnplugged = !hasVirtualInstances && pkg.linkType !== LinkType.SOFT;
      let customPackageData = this.customData.store.get(pkg.locatorHash);
      if (typeof customPackageData === `undefined`) {
        customPackageData = await extractCustomPackageData3(pkg, fetchResult);
        if (pkg.linkType === LinkType.HARD) {
          this.customData.store.set(pkg.locatorHash, customPackageData);
        }
      }
      const dependencyMeta = this.opts.project.getDependencyMeta(pkg, pkg.version);
      const buildScripts = mayNeedToBeBuilt ? extractBuildScripts2(pkg, customPackageData, dependencyMeta, {configuration: this.opts.project.configuration, report: this.opts.report}) : [];
      const packageFs = mayNeedToBeUnplugged ? await this.unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) : fetchResult.packageFs;
      if (ppath.isAbsolute(fetchResult.prefixPath))
        throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
      const packageRawLocation = ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
      const packageLocation = normalizeDirectoryPath2(this.opts.project.cwd, packageRawLocation);
      const packageDependencies = new Map();
      const packagePeers = new Set();
      if (structUtils_exports.isVirtualLocator(pkg)) {
        for (const descriptor of pkg.peerDependencies.values()) {
          packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), null);
          packagePeers.add(structUtils_exports.stringifyIdent(descriptor));
        }
        if (!this.opts.project.tryWorkspaceByLocator(pkg)) {
          const devirtualized = structUtils_exports.devirtualizeLocator(pkg);
          this.virtualTemplates.set(devirtualized.locatorHash, {
            location: normalizeDirectoryPath2(this.opts.project.cwd, VirtualFS.resolveVirtual(packageRawLocation)),
            locator: devirtualized
          });
        }
      }
      miscUtils10.getMapWithDefault(this.packageRegistry, key1).set(key2, {
        packageLocation,
        packageDependencies,
        packagePeers,
        linkType: pkg.linkType,
        discardFromLookup: fetchResult.discardFromLookup || false
      });
      return {
        packageLocation: packageRawLocation,
        buildDirective: buildScripts.length > 0 ? buildScripts : null
      };
    }
    async attachInternalDependencies(locator, dependencies) {
      const packageInformation = this.getPackageInformation(locator);
      for (const [descriptor, locator2] of dependencies) {
        const target = !structUtils_exports.areIdentsEqual(descriptor, locator2) ? [structUtils_exports.stringifyIdent(locator2), locator2.reference] : locator2.reference;
        packageInformation.packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), target);
      }
    }
    async attachExternalDependents(locator, dependentPaths) {
      for (const dependentPath of dependentPaths) {
        const packageInformation = this.getDiskInformation(dependentPath);
        packageInformation.packageDependencies.set(structUtils_exports.stringifyIdent(locator), locator.reference);
      }
    }
    async finalizeInstall() {
      const blacklistedPaths = new Set();
      for (const {locator, location} of this.virtualTemplates.values()) {
        miscUtils10.getMapWithDefault(this.packageRegistry, structUtils_exports.stringifyIdent(locator)).set(locator.reference, {
          packageLocation: location,
          packageDependencies: new Map(),
          packagePeers: new Set(),
          linkType: LinkType.SOFT,
          discardFromLookup: false
        });
      }
      this.packageRegistry.set(null, new Map([
        [null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)]
      ]));
      const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
      const blacklistedLocations = blacklistedPaths;
      const dependencyTreeRoots = this.opts.project.workspaces.map(({anchoredLocator}) => ({name: structUtils_exports.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference}));
      const enableTopLevelFallback = pnpFallbackMode !== `none`;
      const fallbackExclusionList = [];
      const fallbackPool = new Map();
      const ignorePattern = miscUtils10.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
      const packageRegistry = this.packageRegistry;
      const shebang = this.opts.project.configuration.get(`pnpShebang`);
      if (pnpFallbackMode === `dependencies-only`) {
        for (const pkg of this.opts.project.storedPackages.values())
          if (this.opts.project.tryWorkspaceByLocator(pkg))
            fallbackExclusionList.push({name: structUtils_exports.stringifyIdent(pkg), reference: pkg.reference});
      }
      await this.finalizeInstallWithPnp({
        blacklistedLocations,
        dependencyTreeRoots,
        enableTopLevelFallback,
        fallbackExclusionList,
        fallbackPool,
        ignorePattern,
        packageRegistry,
        shebang
      });
      return {
        customData: this.customData
      };
    }
    async transformPnpSettings(pnpSettings) {
    }
    async finalizeInstallWithPnp(pnpSettings) {
      if (this.opts.project.configuration.get(`pnpMode`) !== this.mode)
        return;
      const pnpPath = getPnpPath2(this.opts.project);
      const pnpDataPath = this.opts.project.configuration.get(`pnpDataPath`);
      if (xfs.existsSync(pnpPath.cjsLegacy)) {
        this.opts.report.reportWarning(MessageName.UNNAMED, `Removing the old ${formatUtils_exports.pretty(this.opts.project.configuration, Filename.pnpJs, formatUtils_exports.Type.PATH)} file. You might need to manually update existing references to reference the new ${formatUtils_exports.pretty(this.opts.project.configuration, Filename.pnpCjs, formatUtils_exports.Type.PATH)} file. If you use PnPify SDKs, you'll have to rerun ${formatUtils_exports.pretty(this.opts.project.configuration, `yarn pnpify --sdk`, formatUtils_exports.Type.CODE)}.`);
        await xfs.removePromise(pnpPath.cjsLegacy);
      }
      if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
        await xfs.removePromise(pnpPath.cjs);
        await xfs.removePromise(pnpDataPath);
        return;
      }
      const nodeModules = await this.locateNodeModules(pnpSettings.ignorePattern);
      if (nodeModules.length > 0) {
        this.opts.report.reportWarning(MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);
        for (const nodeModulesPath of nodeModules) {
          await xfs.removePromise(nodeModulesPath);
        }
      }
      await this.transformPnpSettings(pnpSettings);
      if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
        const loaderFile = generateInlinedScript(pnpSettings);
        await xfs.changeFilePromise(pnpPath.cjs, loaderFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpPath.cjs, 493);
        await xfs.removePromise(pnpDataPath);
      } else {
        const dataLocation = ppath.relative(ppath.dirname(pnpPath.cjs), pnpDataPath);
        const {dataFile, loaderFile} = generateSplitScript({...pnpSettings, dataLocation});
        await xfs.changeFilePromise(pnpPath.cjs, loaderFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpPath.cjs, 493);
        await xfs.changeFilePromise(pnpDataPath, dataFile, {automaticNewlines: true});
        await xfs.chmodPromise(pnpDataPath, 420);
      }
      const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);
      if (this.unpluggedPaths.size === 0) {
        await xfs.removePromise(pnpUnpluggedFolder);
      } else {
        for (const entry of await xfs.readdirPromise(pnpUnpluggedFolder)) {
          const unpluggedPath = ppath.resolve(pnpUnpluggedFolder, entry);
          if (!this.unpluggedPaths.has(unpluggedPath)) {
            await xfs.removePromise(unpluggedPath);
          }
        }
      }
    }
    async locateNodeModules(ignorePattern) {
      const nodeModules = [];
      const ignoreRegExp = ignorePattern ? new RegExp(ignorePattern) : null;
      for (const workspace of this.opts.project.workspaces) {
        const nodeModulesPath = ppath.join(workspace.cwd, `node_modules`);
        if (ignoreRegExp && ignoreRegExp.test(ppath.relative(this.opts.project.cwd, workspace.cwd)) || !xfs.existsSync(nodeModulesPath))
          continue;
        const directoryListing = await xfs.readdirPromise(nodeModulesPath, {
          withFileTypes: true
        });
        const nonCacheEntries = directoryListing.filter((entry) => {
          return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
        });
        if (nonCacheEntries.length === directoryListing.length) {
          nodeModules.push(nodeModulesPath);
        } else {
          for (const entry of nonCacheEntries) {
            nodeModules.push(ppath.join(nodeModulesPath, entry.name));
          }
        }
      }
      return nodeModules;
    }
    async unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) {
      if (this.shouldBeUnplugged(pkg, customPackageData, dependencyMeta)) {
        return this.unplugPackage(pkg, fetchResult);
      } else {
        return fetchResult.packageFs;
      }
    }
    shouldBeUnplugged(pkg, customPackageData, dependencyMeta) {
      if (typeof dependencyMeta.unplugged !== `undefined`)
        return dependencyMeta.unplugged;
      if (FORCED_UNPLUG_PACKAGES2.has(pkg.identHash))
        return true;
      if (customPackageData.manifest.preferUnplugged !== null)
        return customPackageData.manifest.preferUnplugged;
      if (extractBuildScripts2(pkg, customPackageData, dependencyMeta, {configuration: this.opts.project.configuration}).length > 0 || customPackageData.misc.extractHint)
        return true;
      return false;
    }
    async unplugPackage(locator, fetchResult) {
      const unplugPath = getUnpluggedPath2(locator, {configuration: this.opts.project.configuration});
      this.unpluggedPaths.add(unplugPath);
      const readyFile = ppath.join(unplugPath, fetchResult.prefixPath, `.ready`);
      if (await xfs.existsPromise(readyFile))
        return new CwdFS(unplugPath);
      await xfs.mkdirPromise(unplugPath, {recursive: true});
      await xfs.copyPromise(unplugPath, PortablePath2.dot, {baseFs: fetchResult.packageFs, overwrite: false});
      await xfs.writeFilePromise(readyFile, ``);
      return new CwdFS(unplugPath);
    }
    getPackageInformation(locator) {
      const key1 = structUtils_exports.stringifyIdent(locator);
      const key2 = locator.reference;
      const packageInformationStore = this.packageRegistry.get(key1);
      if (!packageInformationStore)
        throw new Error(`Assertion failed: The package information store should have been available (for ${structUtils_exports.prettyIdent(this.opts.project.configuration, locator)})`);
      const packageInformation = packageInformationStore.get(key2);
      if (!packageInformation)
        throw new Error(`Assertion failed: The package information should have been available (for ${structUtils_exports.prettyLocator(this.opts.project.configuration, locator)})`);
      return packageInformation;
    }
    getDiskInformation(path6) {
      const packageStore = miscUtils10.getMapWithDefault(this.packageRegistry, `@@disk`);
      const normalizedPath = normalizeDirectoryPath2(this.opts.project.cwd, path6);
      return miscUtils10.getFactoryWithDefault(packageStore, normalizedPath, () => ({
        packageLocation: normalizedPath,
        packageDependencies: new Map(),
        packagePeers: new Set(),
        linkType: LinkType.SOFT,
        discardFromLookup: false
      }));
    }
  };
  function normalizeDirectoryPath2(root, folder) {
    let relativeFolder = ppath.relative(root, folder);
    if (!relativeFolder.match(/^\.{0,2}\//))
      relativeFolder = `./${relativeFolder}`;
    return relativeFolder.replace(/\/?$/, `/`);
  }
  async function extractCustomPackageData3(pkg, fetchResult) {
    var _a2;
    const manifest = (_a2 = await Manifest.tryFind(fetchResult.prefixPath, {baseFs: fetchResult.packageFs})) != null ? _a2 : new Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
      if (!preservedScripts.has(scriptName))
        manifest.scripts.delete(scriptName);
    return {
      manifest: {
        os: manifest.os,
        cpu: manifest.cpu,
        scripts: manifest.scripts,
        preferUnplugged: manifest.preferUnplugged
      },
      misc: {
        extractHint: getExtractHint2(fetchResult),
        hasBindingGyp: hasBindingGyp2(fetchResult)
      }
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\commands\unplug.ts
  var import_micromatch12 = __toModule(require_micromatch());
  var import_semver20 = __toModule(require_semver2());
  var UnplugCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Unplug direct dependencies from the entire project`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Unplug both direct and transitive dependencies`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.patterns = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      if (configuration.get(`nodeLinker`) !== `pnp`)
        throw new UsageError(`This command can only be used if the \`nodeLinker\` option is set to \`pnp\``);
      await project.restoreInstallState();
      const unreferencedPatterns = new Set(this.patterns);
      const matchers = this.patterns.map((pattern) => {
        const patternDescriptor = structUtils_exports.parseDescriptor(pattern);
        const pseudoDescriptor = patternDescriptor.range !== `unknown` ? patternDescriptor : structUtils_exports.makeDescriptor(patternDescriptor, `*`);
        if (!import_semver20.default.validRange(pseudoDescriptor.range))
          throw new UsageError(`The range of the descriptor patterns must be a valid semver range (${structUtils_exports.prettyDescriptor(configuration, pseudoDescriptor)})`);
        return (pkg) => {
          const stringifiedIdent = structUtils_exports.stringifyIdent(pkg);
          if (!import_micromatch12.default.isMatch(stringifiedIdent, structUtils_exports.stringifyIdent(pseudoDescriptor)))
            return false;
          if (pkg.version && !semverUtils_exports.satisfiesWithPrereleases(pkg.version, pseudoDescriptor.range))
            return false;
          unreferencedPatterns.delete(pattern);
          return true;
        };
      });
      const getAllMatchingPackages = () => {
        const selection2 = [];
        for (const pkg of project.storedPackages.values())
          if (!project.tryWorkspaceByLocator(pkg) && !structUtils_exports.isVirtualLocator(pkg) && matchers.some((matcher) => matcher(pkg)))
            selection2.push(pkg);
        return selection2;
      };
      const getSelectedPackages = (roots) => {
        const seen = new Set();
        const selection2 = [];
        const traverse = (pkg, depth) => {
          if (seen.has(pkg.locatorHash))
            return;
          seen.add(pkg.locatorHash);
          if (!project.tryWorkspaceByLocator(pkg) && matchers.some((matcher) => matcher(pkg)))
            selection2.push(pkg);
          if (depth > 0 && !this.recursive)
            return;
          for (const dependency of pkg.dependencies.values()) {
            const resolution = project.storedResolutions.get(dependency.descriptorHash);
            if (!resolution)
              throw new Error(`Assertion failed: The resolution should have been registered`);
            const nextPkg = project.storedPackages.get(resolution);
            if (!nextPkg)
              throw new Error(`Assertion failed: The package should have been registered`);
            traverse(nextPkg, depth + 1);
          }
        };
        for (const workspace2 of roots) {
          const pkg = project.storedPackages.get(workspace2.anchoredLocator.locatorHash);
          if (!pkg)
            throw new Error(`Assertion failed: The package should have been registered`);
          traverse(pkg, 0);
        }
        return selection2;
      };
      let selection;
      let projectOrWorkspaces;
      if (this.all && this.recursive) {
        selection = getAllMatchingPackages();
        projectOrWorkspaces = `the project`;
      } else if (this.all) {
        selection = getSelectedPackages(project.workspaces);
        projectOrWorkspaces = `any workspace`;
      } else {
        selection = getSelectedPackages([workspace]);
        projectOrWorkspaces = `this workspace`;
      }
      if (unreferencedPatterns.size > 1)
        throw new UsageError(`Patterns ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, formatUtils_exports.Type.CODE)} don't match any packages referenced by ${projectOrWorkspaces}`);
      if (unreferencedPatterns.size > 0)
        throw new UsageError(`Pattern ${formatUtils_exports.prettyList(configuration, unreferencedPatterns, formatUtils_exports.Type.CODE)} doesn't match any packages referenced by ${projectOrWorkspaces}`);
      selection = miscUtils10.sortMap(selection, (pkg) => {
        return structUtils_exports.stringifyLocator(pkg);
      });
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        json: this.json
      }, async (report2) => {
        var _a2;
        for (const pkg of selection) {
          const version = (_a2 = pkg.version) != null ? _a2 : `unknown`;
          const dependencyMeta = project.topLevelWorkspace.manifest.ensureDependencyMeta(structUtils_exports.makeDescriptor(pkg, version));
          dependencyMeta.unplugged = true;
          report2.reportInfo(MessageName.UNNAMED, `Will unpack ${structUtils_exports.prettyLocator(configuration, pkg)} to ${formatUtils_exports.pretty(configuration, getUnpluggedPath2(pkg, {configuration}), formatUtils_exports.Type.PATH)}`);
          report2.reportJson({
            locator: structUtils_exports.stringifyLocator(pkg),
            version
          });
        }
        await project.topLevelWorkspace.persistManifest();
        report2.reportSeparator();
        await project.install({cache: cache2, report: report2});
      });
      return report.exitCode();
    }
  };
  UnplugCommand2.paths = [
    [`unplug`]
  ];
  UnplugCommand2.usage = Command.Usage({
    description: `force the unpacking of a list of packages`,
    details: `
      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.

      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via \`pnpUnpluggedFolder\`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).

      Running the command will set a persistent flag inside your top-level \`package.json\`, in the \`dependenciesMeta\` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run \`yarn install\` to apply the modification.

      By default, only direct dependencies from the current workspace are affected. If \`-A,--all\` is set, direct dependencies from the entire project are affected. Using the \`-R,--recursive\` flag will affect transitive dependencies as well as direct ones.

      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.
    `,
    examples: [[
      `Unplug the lodash dependency from the active workspace`,
      `yarn unplug lodash`
    ], [
      `Unplug all instances of lodash referenced by any workspace`,
      `yarn unplug lodash -A`
    ], [
      `Unplug all instances of lodash referenced by the active workspace and its dependencies`,
      `yarn unplug lodash -R`
    ], [
      `Unplug all instances of lodash, anywhere`,
      `yarn unplug lodash -AR`
    ], [
      `Unplug one specific version of lodash`,
      `yarn unplug lodash@1.2.3`
    ], [
      `Unplug all packages with the \`@babel\` scope`,
      `yarn unplug '@babel/*'`
    ], [
      `Unplug all packages (only for testing, not recommended)`,
      `yarn unplug -R '*'`
    ]]
  });
  var unplug_default2 = UnplugCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pnp-virtual-8020577487\1\packages\plugin-pnp\sources\index.ts
  var getPnpPath2 = (project) => {
    return {
      cjs: ppath.join(project.cwd, Filename.pnpCjs),
      cjsLegacy: ppath.join(project.cwd, Filename.pnpJs)
    };
  };
  var quotePathIfNeeded2 = (path6) => {
    return /\s/.test(path6) ? JSON.stringify(path6) : path6;
  };
  async function setupScriptEnvironment2(project, env, makePathWrapper2) {
    const pnpPath = getPnpPath2(project).cjs;
    const pnpRequire = `--require ${quotePathIfNeeded2(npath.fromPortablePath(pnpPath))}`;
    if (pnpPath.includes(` `) && import_semver21.default.lt(process.versions.node, `12.0.0`))
      throw new Error(`Expected the build location to not include spaces when using Node < 12.0.0 (${process.versions.node})`);
    if (xfs.existsSync(pnpPath)) {
      let nodeOptions = env.NODE_OPTIONS || ``;
      const pnpRegularExpression = /\s*--require\s+\S*\.pnp\.c?js\s*/g;
      nodeOptions = nodeOptions.replace(pnpRegularExpression, ` `).trim();
      nodeOptions = nodeOptions ? `${pnpRequire} ${nodeOptions}` : pnpRequire;
      env.NODE_OPTIONS = nodeOptions;
    }
  }
  async function populateYarnPaths2(project, definePath) {
    definePath(getPnpPath2(project).cjs);
    definePath(project.configuration.get(`pnpDataPath`));
    definePath(project.configuration.get(`pnpUnpluggedFolder`));
  }
  var plugin14 = {
    hooks: {
      populateYarnPaths: populateYarnPaths2,
      setupScriptEnvironment: setupScriptEnvironment2
    },
    configuration: {
      nodeLinker: {
        description: `The linker used for installing Node packages, one of: "pnp", "node-modules"`,
        type: SettingsType.STRING,
        default: `pnp`
      },
      pnpMode: {
        description: `If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.`,
        type: SettingsType.STRING,
        default: `strict`
      },
      pnpShebang: {
        description: `String to prepend to the generated PnP script`,
        type: SettingsType.STRING,
        default: `#!/usr/bin/env node`
      },
      pnpIgnorePatterns: {
        description: `Array of glob patterns; files matching them will use the classic resolution`,
        type: SettingsType.STRING,
        default: [],
        isArray: true
      },
      pnpEnableInlining: {
        description: `If true, the PnP data will be inlined along with the generated loader`,
        type: SettingsType.BOOLEAN,
        default: true
      },
      pnpFallbackMode: {
        description: `If true, the generated PnP loader will follow the top-level fallback rule`,
        type: SettingsType.STRING,
        default: `dependencies-only`
      },
      pnpUnpluggedFolder: {
        description: `Folder where the unplugged packages must be stored`,
        type: SettingsType.ABSOLUTE_PATH,
        default: `./.yarn/unplugged`
      },
      pnpDataPath: {
        description: `Path of the file where the PnP data (used by the loader) must be written`,
        type: SettingsType.ABSOLUTE_PATH,
        default: `./.pnp.data.json`
      }
    },
    linkers: [
      PnpLinker2
    ],
    commands: [
      unplug_default2
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-9af797eaca\1\packages\plugin-node-modules\sources\NodeModulesLinker.ts
  var import_cmd_shim2 = __toModule(require_cmd_shim());
  var import_fs12 = __toModule(require("fs"));
  var STATE_FILE_VERSION2 = 1;
  var NODE_MODULES4 = `node_modules`;
  var DOT_BIN2 = `.bin`;
  var INSTALL_STATE_FILE2 = `.yarn-state.yml`;
  var NodeModulesLinker2 = class {
    supportsPackage(pkg, opts) {
      return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
    }
    async findPackageLocation(locator, opts) {
      const workspace = opts.project.tryWorkspaceByLocator(locator);
      if (workspace)
        return workspace.cwd;
      const installState = await findInstallState2(opts.project, {unrollAliases: true});
      if (installState === null)
        throw new UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
      const locatorInfo = installState.locatorMap.get(structUtils_exports.stringifyLocator(locator));
      if (!locatorInfo) {
        const err = new UsageError(`Couldn't find ${structUtils_exports.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
        err.code = `LOCATOR_NOT_INSTALLED`;
        throw err;
      }
      return locatorInfo.locations[0];
    }
    async findPackageLocator(location, opts) {
      const installState = await findInstallState2(opts.project, {unrollAliases: true});
      if (installState === null)
        return null;
      const {locationRoot, segments} = parseLocation2(ppath.resolve(location), {skipPrefix: opts.project.cwd});
      let locationNode = installState.locationTree.get(locationRoot);
      if (!locationNode)
        return null;
      let locator = locationNode.locator;
      for (const segment of segments) {
        locationNode = locationNode.children.get(segment);
        if (!locationNode)
          break;
        locator = locationNode.locator || locator;
      }
      return structUtils_exports.parseLocator(locator);
    }
    makeInstaller(opts) {
      return new NodeModulesInstaller2(opts);
    }
  };
  var NodeModulesInstaller2 = class {
    constructor(opts) {
      this.opts = opts;
      this.localStore = new Map();
      this.customData = {
        store: new Map()
      };
    }
    getCustomDataKey() {
      return JSON.stringify({
        name: `NodeModulesInstaller`,
        version: 1
      });
    }
    attachCustomData(customData) {
      this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
      var _a2;
      const packageLocation = ppath.resolve(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
      let customPackageData = this.customData.store.get(pkg.locatorHash);
      if (typeof customPackageData === `undefined`) {
        customPackageData = await extractCustomPackageData4(pkg, fetchResult);
        if (pkg.linkType === LinkType.HARD) {
          this.customData.store.set(pkg.locatorHash, customPackageData);
        }
      }
      if (!jsInstallUtils_exports2.checkAndReportManifestCompatibility(pkg, customPackageData, `link`, {configuration: this.opts.project.configuration, report: this.opts.report}))
        return {packageLocation: null, buildDirective: null};
      const packageDependencies = new Map();
      const packagePeers = new Set();
      if (!packageDependencies.has(structUtils_exports.stringifyIdent(pkg)))
        packageDependencies.set(structUtils_exports.stringifyIdent(pkg), pkg.reference);
      if (structUtils_exports.isVirtualLocator(pkg)) {
        for (const descriptor of pkg.peerDependencies.values()) {
          packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), null);
          packagePeers.add(structUtils_exports.stringifyIdent(descriptor));
        }
      }
      const pnpNode = {
        packageLocation: `${npath.fromPortablePath(packageLocation)}/`,
        packageDependencies,
        packagePeers,
        linkType: pkg.linkType,
        discardFromLookup: (_a2 = fetchResult.discardFromLookup) != null ? _a2 : false
      };
      this.localStore.set(pkg.locatorHash, {
        pkg,
        customPackageData,
        dependencyMeta: this.opts.project.getDependencyMeta(pkg, pkg.version),
        pnpNode
      });
      return {
        packageLocation,
        buildDirective: null
      };
    }
    async attachInternalDependencies(locator, dependencies) {
      const slot = this.localStore.get(locator.locatorHash);
      if (typeof slot === `undefined`)
        throw new Error(`Assertion failed: Expected information object to have been registered`);
      for (const [descriptor, locator2] of dependencies) {
        const target = !structUtils_exports.areIdentsEqual(descriptor, locator2) ? [structUtils_exports.stringifyIdent(locator2), locator2.reference] : locator2.reference;
        slot.pnpNode.packageDependencies.set(structUtils_exports.stringifyIdent(descriptor), target);
      }
    }
    async attachExternalDependents(locator, dependentPaths) {
      throw new Error(`External dependencies haven't been implemented for the node-modules linker`);
    }
    async finalizeInstall() {
      if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`)
        return void 0;
      const defaultFsLayer = new VirtualFS({
        baseFs: new ZipOpenFS({
          libzip: await getLibzipPromise(),
          maxOpenFiles: 80,
          readOnlyArchives: true
        })
      });
      let preinstallState = await findInstallState2(this.opts.project);
      if (preinstallState === null) {
        const bstatePath = this.opts.project.configuration.get(`bstatePath`);
        if (await xfs.existsPromise(bstatePath))
          await xfs.unlinkPromise(bstatePath);
        preinstallState = {locatorMap: new Map(), binSymlinks: new Map(), locationTree: new Map()};
      }
      const hoistingLimitsByCwd = new Map(this.opts.project.workspaces.map((workspace) => {
        var _a2, _b;
        let hoistingLimits = this.opts.project.configuration.get(`nmHoistingLimits`);
        try {
          hoistingLimits = miscUtils10.validateEnum(NodeModulesHoistingLimits, (_b = (_a2 = workspace.manifest.installConfig) == null ? void 0 : _a2.hoistingLimits) != null ? _b : hoistingLimits);
        } catch (e) {
          const workspaceName = structUtils_exports.prettyWorkspace(this.opts.project.configuration, workspace);
          this.opts.report.reportWarning(MessageName.INVALID_MANIFEST, `${workspaceName}: Invalid 'installConfig.hoistingLimits' value. Expected one of ${Object.values(NodeModulesHoistingLimits).join(`, `)}, using default: "${hoistingLimits}"`);
        }
        return [workspace.relativeCwd, hoistingLimits];
      }));
      const pnpApi = {
        VERSIONS: {
          std: 1
        },
        topLevel: {
          name: null,
          reference: null
        },
        getLocator: (name, referencish) => {
          if (Array.isArray(referencish)) {
            return {name: referencish[0], reference: referencish[1]};
          } else {
            return {name, reference: referencish};
          }
        },
        getDependencyTreeRoots: () => {
          return this.opts.project.workspaces.map((workspace) => {
            const anchoredLocator = workspace.anchoredLocator;
            return {name: structUtils_exports.stringifyIdent(workspace.locator), reference: anchoredLocator.reference};
          });
        },
        getPackageInformation: (pnpLocator) => {
          const locator = pnpLocator.reference === null ? this.opts.project.topLevelWorkspace.anchoredLocator : structUtils_exports.makeLocator(structUtils_exports.parseIdent(pnpLocator.name), pnpLocator.reference);
          const slot = this.localStore.get(locator.locatorHash);
          if (typeof slot === `undefined`)
            throw new Error(`Assertion failed: Expected the package reference to have been registered`);
          return slot.pnpNode;
        },
        findPackageLocator: (location) => {
          const workspace = this.opts.project.tryWorkspaceByCwd(npath.toPortablePath(location));
          if (workspace !== null) {
            const anchoredLocator = workspace.anchoredLocator;
            return {name: structUtils_exports.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference};
          }
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveToUnqualified: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveUnqualified: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveRequest: () => {
          throw new Error(`Assertion failed: Unimplemented`);
        },
        resolveVirtual: (path6) => {
          return npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(path6)));
        }
      };
      const nmTree = buildNodeModulesTree(pnpApi, {pnpifyFs: false, hoistingLimitsByCwd, project: this.opts.project});
      const locatorMap = buildLocatorMap(nmTree);
      await persistNodeModules2(preinstallState, locatorMap, {
        baseFs: defaultFsLayer,
        project: this.opts.project,
        report: this.opts.report,
        loadManifest: async (locatorKey) => {
          const locator = structUtils_exports.parseLocator(locatorKey);
          const slot = this.localStore.get(locator.locatorHash);
          if (typeof slot === `undefined`)
            throw new Error(`Assertion failed: Expected the slot to exist`);
          return slot.customPackageData.manifest;
        }
      });
      const installStatuses = [];
      for (const [locatorKey, installRecord] of locatorMap.entries()) {
        if (isLinkLocator2(locatorKey))
          continue;
        const locator = structUtils_exports.parseLocator(locatorKey);
        const slot = this.localStore.get(locator.locatorHash);
        if (typeof slot === `undefined`)
          throw new Error(`Assertion failed: Expected the slot to exist`);
        const buildScripts = jsInstallUtils_exports2.extractBuildScripts(slot.pkg, slot.customPackageData, slot.dependencyMeta, {configuration: this.opts.project.configuration, report: this.opts.report});
        if (buildScripts.length === 0)
          continue;
        installStatuses.push({
          buildLocations: installRecord.locations,
          locatorHash: locator.locatorHash,
          buildDirective: buildScripts
        });
      }
      return {
        customData: this.customData,
        records: installStatuses
      };
    }
  };
  async function extractCustomPackageData4(pkg, fetchResult) {
    var _a2;
    const manifest = (_a2 = await Manifest.tryFind(fetchResult.prefixPath, {baseFs: fetchResult.packageFs})) != null ? _a2 : new Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
      if (!preservedScripts.has(scriptName))
        manifest.scripts.delete(scriptName);
    return {
      manifest: {
        bin: manifest.bin,
        os: manifest.os,
        cpu: manifest.cpu,
        scripts: manifest.scripts
      },
      misc: {
        extractHint: jsInstallUtils_exports2.getExtractHint(fetchResult),
        hasBindingGyp: jsInstallUtils_exports2.hasBindingGyp(fetchResult)
      }
    };
  }
  async function writeInstallState2(project, locatorMap, binSymlinks) {
    let locatorState = ``;
    locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will
`;
    locatorState += `# cause your node_modules installation to become invalidated.
`;
    locatorState += `
`;
    locatorState += `__metadata:
`;
    locatorState += `  version: ${STATE_FILE_VERSION2}
`;
    const locators = Array.from(locatorMap.keys()).sort();
    const topLevelLocator = structUtils_exports.stringifyLocator(project.topLevelWorkspace.anchoredLocator);
    for (const locator of locators) {
      const installRecord = locatorMap.get(locator);
      locatorState += `
`;
      locatorState += `${JSON.stringify(locator)}:
`;
      locatorState += `  locations:
`;
      for (const location of installRecord.locations) {
        const internalPath = ppath.contains(project.cwd, location);
        if (internalPath === null)
          throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
        locatorState += `    - ${JSON.stringify(internalPath)}
`;
      }
      if (installRecord.aliases.length > 0) {
        locatorState += `  aliases:
`;
        for (const alias of installRecord.aliases) {
          locatorState += `    - ${JSON.stringify(alias)}
`;
        }
      }
      if (locator === topLevelLocator && binSymlinks.size > 0) {
        locatorState += `  bin:
`;
        for (const [location, symlinks] of binSymlinks) {
          const internalPath = ppath.contains(project.cwd, location);
          if (internalPath === null)
            throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
          locatorState += `    ${JSON.stringify(internalPath)}:
`;
          for (const [name, target] of symlinks) {
            const relativePath = ppath.relative(ppath.join(location, NODE_MODULES4), target);
            locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}
`;
          }
        }
      }
    }
    const rootPath = project.cwd;
    const installStatePath = ppath.join(rootPath, NODE_MODULES4, INSTALL_STATE_FILE2);
    await xfs.changeFilePromise(installStatePath, locatorState, {
      automaticNewlines: true
    });
  }
  async function findInstallState2(project, {unrollAliases = false} = {}) {
    const rootPath = project.cwd;
    const installStatePath = ppath.join(rootPath, NODE_MODULES4, INSTALL_STATE_FILE2);
    if (!xfs.existsSync(installStatePath))
      return null;
    const locatorState = parseSyml(await xfs.readFilePromise(installStatePath, `utf8`));
    if (locatorState.__metadata.version > STATE_FILE_VERSION2)
      return null;
    const locatorMap = new Map();
    const binSymlinks = new Map();
    delete locatorState.__metadata;
    for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
      const locations = installRecord.locations.map((location) => {
        return ppath.join(rootPath, location);
      });
      const recordSymlinks = installRecord.bin;
      if (recordSymlinks) {
        for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
          const location = ppath.join(rootPath, npath.toPortablePath(relativeLocation));
          const symlinks = miscUtils10.getMapWithDefault(binSymlinks, location);
          for (const [name, target] of Object.entries(locationSymlinks)) {
            symlinks.set(toFilename(name), npath.toPortablePath([location, NODE_MODULES4, target].join(ppath.delimiter)));
          }
        }
      }
      locatorMap.set(locatorStr, {
        target: PortablePath2.dot,
        linkType: LinkType.HARD,
        locations,
        aliases: installRecord.aliases || []
      });
      if (unrollAliases && installRecord.aliases) {
        for (const reference of installRecord.aliases) {
          const {scope, name} = structUtils_exports.parseLocator(locatorStr);
          const alias = structUtils_exports.makeLocator(structUtils_exports.makeIdent(scope, name), reference);
          const aliasStr = structUtils_exports.stringifyLocator(alias);
          locatorMap.set(aliasStr, {
            target: PortablePath2.dot,
            linkType: LinkType.HARD,
            locations,
            aliases: []
          });
        }
      }
    }
    return {locatorMap, binSymlinks, locationTree: buildLocationTree2(locatorMap, {skipPrefix: project.cwd})};
  }
  var removeDir2 = async (dir, options) => {
    if (dir.split(ppath.sep).indexOf(NODE_MODULES4) < 0)
      throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);
    try {
      if (!options.innerLoop) {
        const stats = await xfs.lstatPromise(dir);
        if (stats.isSymbolicLink()) {
          await xfs.unlinkPromise(dir);
          return;
        }
      }
      const entries = await xfs.readdirPromise(dir, {withFileTypes: true});
      for (const entry of entries) {
        const targetPath = ppath.join(dir, toFilename(entry.name));
        if (entry.isDirectory()) {
          if (entry.name !== NODE_MODULES4 || options && options.innerLoop) {
            await removeDir2(targetPath, {innerLoop: true, contentsOnly: false});
          }
        } else {
          await xfs.unlinkPromise(targetPath);
        }
      }
      if (!options.contentsOnly) {
        await xfs.rmdirPromise(dir);
      }
    } catch (e) {
      if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
        throw e;
      }
    }
  };
  var CONCURRENT_OPERATION_LIMIT2 = 4;
  var parseLocation2 = (location, {skipPrefix}) => {
    const projectRelativePath = ppath.contains(skipPrefix, location);
    if (projectRelativePath === null)
      throw new Error(`Assertion failed: Cannot process a path that isn't part of the requested prefix (${location} isn't within ${skipPrefix})`);
    const allSegments = projectRelativePath.split(ppath.sep).filter((segment) => segment !== ``);
    const nmIndex = allSegments.indexOf(NODE_MODULES4);
    const relativeRoot = allSegments.slice(0, nmIndex).join(ppath.sep);
    const locationRoot = ppath.join(skipPrefix, relativeRoot);
    const segments = allSegments.slice(nmIndex);
    return {locationRoot, segments};
  };
  var buildLocationTree2 = (locatorMap, {skipPrefix}) => {
    const locationTree = new Map();
    if (locatorMap === null)
      return locationTree;
    const makeNode2 = () => ({
      children: new Map(),
      linkType: LinkType.HARD
    });
    for (const [locator, info] of locatorMap.entries()) {
      if (info.linkType === LinkType.SOFT) {
        const internalPath = ppath.contains(skipPrefix, info.target);
        if (internalPath !== null) {
          const node = miscUtils10.getFactoryWithDefault(locationTree, info.target, makeNode2);
          node.locator = locator;
          node.linkType = info.linkType;
        }
      }
      for (const location of info.locations) {
        const {locationRoot, segments} = parseLocation2(location, {skipPrefix});
        let node = miscUtils10.getFactoryWithDefault(locationTree, locationRoot, makeNode2);
        for (let idx = 0; idx < segments.length; ++idx) {
          const segment = segments[idx];
          if (segment !== `.`) {
            const nextNode = miscUtils10.getFactoryWithDefault(node.children, segment, makeNode2);
            node.children.set(segment, nextNode);
            node = nextNode;
          }
          if (idx === segments.length - 1) {
            node.locator = locator;
            node.linkType = info.linkType;
          }
        }
      }
    }
    return locationTree;
  };
  var symlinkPromise2 = async (srcPath, dstPath) => {
    let stats;
    try {
      if (process.platform === `win32`) {
        stats = xfs.lstatSync(srcPath);
      }
    } catch (e) {
    }
    if (process.platform == `win32` && (!stats || stats.isDirectory())) {
      xfs.symlinkPromise(srcPath, dstPath, `junction`);
    } else {
      xfs.symlinkPromise(ppath.relative(ppath.dirname(dstPath), srcPath), dstPath);
    }
  };
  var copyPromise3 = async (dstDir, srcDir, {baseFs, innerLoop}) => {
    await xfs.mkdirPromise(dstDir, {recursive: true});
    const entries = await baseFs.readdirPromise(srcDir, {withFileTypes: true});
    const copy = async (dstPath, srcPath, srcType) => {
      if (srcType.isFile()) {
        const stat = await baseFs.lstatPromise(srcPath);
        await baseFs.copyFilePromise(srcPath, dstPath);
        const mode = stat.mode & 511;
        if (mode !== 420) {
          await xfs.chmodPromise(dstPath, mode);
        }
      } else if (srcType.isSymbolicLink()) {
        const target = await baseFs.readlinkPromise(srcPath);
        await symlinkPromise2(ppath.resolve(ppath.dirname(dstPath), target), dstPath);
      } else {
        throw new Error(`Unsupported file type (file: ${srcPath}, mode: 0o${await xfs.statSync(srcPath).mode.toString(8).padStart(6, `0`)})`);
      }
    };
    for (const entry of entries) {
      const srcPath = ppath.join(srcDir, toFilename(entry.name));
      const dstPath = ppath.join(dstDir, toFilename(entry.name));
      if (entry.isDirectory()) {
        if (entry.name !== NODE_MODULES4 || innerLoop) {
          await copyPromise3(dstPath, srcPath, {baseFs, innerLoop: true});
        }
      } else {
        await copy(dstPath, srcPath, entry);
      }
    }
  };
  function refineNodeModulesRoots2(locationTree, binSymlinks) {
    const refinedLocationTree = new Map([...locationTree]);
    const refinedBinSymlinks = new Map([...binSymlinks]);
    for (const [workspaceRoot, node] of locationTree) {
      const nodeModulesRoot = ppath.join(workspaceRoot, NODE_MODULES4);
      if (!xfs.existsSync(nodeModulesRoot)) {
        node.children.delete(NODE_MODULES4);
        for (const location of refinedBinSymlinks.keys()) {
          if (ppath.contains(nodeModulesRoot, location) !== null) {
            refinedBinSymlinks.delete(location);
          }
        }
      }
    }
    return {locationTree: refinedLocationTree, binSymlinks: refinedBinSymlinks};
  }
  function isLinkLocator2(locatorKey) {
    let descriptor = structUtils_exports.parseDescriptor(locatorKey);
    if (structUtils_exports.isVirtualDescriptor(descriptor))
      descriptor = structUtils_exports.devirtualizeDescriptor(descriptor);
    return descriptor.range.startsWith(`link:`);
  }
  async function createBinSymlinkMap2(installState, locationTree, projectRoot, {loadManifest}) {
    const locatorScriptMap = new Map();
    for (const [locatorKey, {locations}] of installState) {
      const manifest = !isLinkLocator2(locatorKey) ? await loadManifest(locatorKey, locations[0]) : null;
      const bin = new Map();
      if (manifest) {
        for (const [name, value] of manifest.bin) {
          const target = ppath.join(locations[0], value);
          if (value !== `` && xfs.existsSync(target)) {
            bin.set(name, value);
          }
        }
      }
      locatorScriptMap.set(locatorKey, bin);
    }
    const binSymlinks = new Map();
    const getBinSymlinks = (location, parentLocatorLocation, node) => {
      const symlinks = new Map();
      const internalPath = ppath.contains(projectRoot, location);
      if (node.locator && internalPath !== null) {
        const binScripts = locatorScriptMap.get(node.locator);
        for (const [filename, scriptPath] of binScripts) {
          const symlinkTarget = ppath.join(location, npath.toPortablePath(scriptPath));
          symlinks.set(toFilename(filename), symlinkTarget);
        }
        for (const [childLocation, childNode] of node.children) {
          const absChildLocation = ppath.join(location, childLocation);
          const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);
          if (childSymlinks.size > 0) {
            binSymlinks.set(location, new Map([...binSymlinks.get(location) || new Map(), ...childSymlinks]));
          }
        }
      } else {
        for (const [childLocation, childNode] of node.children) {
          const childSymlinks = getBinSymlinks(ppath.join(location, childLocation), parentLocatorLocation, childNode);
          for (const [name, symlinkTarget] of childSymlinks) {
            symlinks.set(name, symlinkTarget);
          }
        }
      }
      return symlinks;
    };
    for (const [location, node] of locationTree) {
      const symlinks = getBinSymlinks(location, location, node);
      if (symlinks.size > 0) {
        binSymlinks.set(location, new Map([...binSymlinks.get(location) || new Map(), ...symlinks]));
      }
    }
    return binSymlinks;
  }
  var areRealLocatorsEqual2 = (locatorKey1, locatorKey2) => {
    if (!locatorKey1 || !locatorKey2)
      return locatorKey1 === locatorKey2;
    let locator1 = structUtils_exports.parseLocator(locatorKey1);
    if (structUtils_exports.isVirtualLocator(locator1))
      locator1 = structUtils_exports.devirtualizeLocator(locator1);
    let locator2 = structUtils_exports.parseLocator(locatorKey2);
    if (structUtils_exports.isVirtualLocator(locator2))
      locator2 = structUtils_exports.devirtualizeLocator(locator2);
    return structUtils_exports.areLocatorsEqual(locator1, locator2);
  };
  async function persistNodeModules2(preinstallState, installState, {baseFs, project, report, loadManifest}) {
    const rootNmDirPath = ppath.join(project.cwd, NODE_MODULES4);
    const {locationTree: prevLocationTree, binSymlinks: prevBinSymlinks} = refineNodeModulesRoots2(preinstallState.locationTree, preinstallState.binSymlinks);
    const locationTree = buildLocationTree2(installState, {skipPrefix: project.cwd});
    const addQueue = [];
    const addModule = async ({srcDir, dstDir, linkType}) => {
      const promise = (async () => {
        try {
          if (linkType === LinkType.SOFT) {
            await xfs.mkdirPromise(ppath.dirname(dstDir), {recursive: true});
            await symlinkPromise2(ppath.resolve(srcDir), dstDir);
          } else {
            await copyPromise3(dstDir, srcDir, {baseFs});
          }
        } catch (e) {
          e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
          throw e;
        } finally {
          progress.tick();
        }
      })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
      addQueue.push(promise);
      if (addQueue.length > CONCURRENT_OPERATION_LIMIT2) {
        await Promise.race(addQueue);
      }
    };
    const cloneModule = async (srcDir, dstDir, options) => {
      const promise = (async () => {
        const cloneDir = async (srcDir2, dstDir2, options2) => {
          try {
            if (!options2 || !options2.innerLoop)
              await xfs.mkdirPromise(dstDir2, {recursive: true});
            const entries = await xfs.readdirPromise(srcDir2, {withFileTypes: true});
            for (const entry of entries) {
              if ((!options2 || !options2.innerLoop) && entry.name === DOT_BIN2)
                continue;
              const src = ppath.join(srcDir2, entry.name);
              const dst = ppath.join(dstDir2, entry.name);
              if (entry.isDirectory()) {
                if (entry.name !== NODE_MODULES4 || options2 && options2.innerLoop) {
                  await xfs.mkdirPromise(dst, {recursive: true});
                  await cloneDir(src, dst, {innerLoop: true});
                }
              } else {
                await xfs.copyFilePromise(src, dst, import_fs12.default.constants.COPYFILE_FICLONE);
              }
            }
          } catch (e) {
            if (!options2 || !options2.innerLoop)
              e.message = `While cloning ${srcDir2} -> ${dstDir2} ${e.message}`;
            throw e;
          } finally {
            if (!options2 || !options2.innerLoop) {
              progress.tick();
            }
          }
        };
        await cloneDir(srcDir, dstDir, options);
      })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));
      addQueue.push(promise);
      if (addQueue.length > CONCURRENT_OPERATION_LIMIT2) {
        await Promise.race(addQueue);
      }
    };
    const removeOutdatedDirs = async (location, prevNode, node) => {
      if (!node) {
        if (prevNode.children.has(NODE_MODULES4))
          await removeDir2(ppath.join(location, NODE_MODULES4), {contentsOnly: false});
        await removeDir2(location, {contentsOnly: location === rootNmDirPath});
      } else {
        for (const [segment, prevChildNode] of prevNode.children) {
          const childNode = node.children.get(segment);
          await removeOutdatedDirs(ppath.join(location, segment), prevChildNode, childNode);
        }
      }
    };
    for (const [location, prevNode] of prevLocationTree) {
      const node = locationTree.get(location);
      for (const [segment, prevChildNode] of prevNode.children) {
        if (segment === `.`)
          continue;
        const childNode = node ? node.children.get(segment) : node;
        await removeOutdatedDirs(ppath.join(location, segment), prevChildNode, childNode);
      }
    }
    const cleanNewDirs = async (location, node, prevNode) => {
      if (!prevNode) {
        if (node.children.has(NODE_MODULES4))
          await removeDir2(ppath.join(location, NODE_MODULES4), {contentsOnly: true});
        await removeDir2(location, {contentsOnly: node.linkType === LinkType.HARD});
      } else {
        if (!areRealLocatorsEqual2(node.locator, prevNode.locator))
          await removeDir2(location, {contentsOnly: node.linkType === LinkType.HARD});
        for (const [segment, childNode] of node.children) {
          const prevChildNode = prevNode.children.get(segment);
          await cleanNewDirs(ppath.join(location, segment), childNode, prevChildNode);
        }
      }
    };
    for (const [location, node] of locationTree) {
      const prevNode = prevLocationTree.get(location);
      for (const [segment, childNode] of node.children) {
        if (segment === `.`)
          continue;
        const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
        await cleanNewDirs(ppath.join(location, segment), childNode, prevChildNode);
      }
    }
    const addList = [];
    for (const [prevLocator, {locations}] of preinstallState.locatorMap.entries()) {
      for (const location of locations) {
        const {locationRoot, segments} = parseLocation2(location, {
          skipPrefix: project.cwd
        });
        let node = locationTree.get(locationRoot);
        let curLocation = locationRoot;
        if (node) {
          for (const segment of segments) {
            curLocation = ppath.join(curLocation, segment);
            node = node.children.get(segment);
            if (!node) {
              break;
            }
          }
          if (node && !areRealLocatorsEqual2(node.locator, prevLocator)) {
            const info = installState.get(node.locator);
            const srcDir = info.target;
            const dstDir = curLocation;
            const linkType = info.linkType;
            if (srcDir !== dstDir) {
              addList.push({srcDir, dstDir, linkType});
            }
          }
        }
      }
    }
    for (const [locator, {locations}] of installState.entries()) {
      for (const location of locations) {
        const {locationRoot, segments} = parseLocation2(location, {
          skipPrefix: project.cwd
        });
        let prevTreeNode = prevLocationTree.get(locationRoot);
        let node = locationTree.get(locationRoot);
        let curLocation = locationRoot;
        const info = installState.get(locator);
        const srcDir = info.target;
        const dstDir = location;
        if (srcDir === dstDir)
          continue;
        const linkType = info.linkType;
        for (const segment of segments)
          node = node.children.get(segment);
        if (!prevTreeNode) {
          addList.push({srcDir, dstDir, linkType});
        } else {
          for (const segment of segments) {
            curLocation = ppath.join(curLocation, segment);
            prevTreeNode = prevTreeNode.children.get(segment);
            if (!prevTreeNode) {
              addList.push({srcDir, dstDir, linkType});
              break;
            }
          }
        }
      }
    }
    const progress = Report.progressViaCounter(addList.length);
    const reportedProgress = report.reportProgress(progress);
    try {
      const persistedLocations = new Map();
      for (const entry of addList) {
        if (entry.linkType === LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
          persistedLocations.set(entry.srcDir, entry.dstDir);
          await addModule({...entry});
        }
      }
      await Promise.all(addQueue);
      addQueue.length = 0;
      for (const entry of addList) {
        const persistedDir = persistedLocations.get(entry.srcDir);
        if (entry.linkType !== LinkType.SOFT && entry.dstDir !== persistedDir) {
          await cloneModule(persistedDir, entry.dstDir);
        }
      }
      await Promise.all(addQueue);
      await xfs.mkdirPromise(rootNmDirPath, {recursive: true});
      const binSymlinks = await createBinSymlinkMap2(installState, locationTree, project.cwd, {loadManifest});
      await persistBinSymlinks2(prevBinSymlinks, binSymlinks);
      await writeInstallState2(project, installState, binSymlinks);
    } finally {
      reportedProgress.stop();
    }
  }
  async function persistBinSymlinks2(previousBinSymlinks, binSymlinks) {
    for (const location of previousBinSymlinks.keys()) {
      if (!binSymlinks.has(location)) {
        const binDir = ppath.join(location, NODE_MODULES4, DOT_BIN2);
        await xfs.removePromise(binDir);
      }
    }
    for (const [location, symlinks] of binSymlinks) {
      const binDir = ppath.join(location, NODE_MODULES4, DOT_BIN2);
      const prevSymlinks = previousBinSymlinks.get(location) || new Map();
      await xfs.mkdirPromise(binDir, {recursive: true});
      for (const name of prevSymlinks.keys()) {
        if (!symlinks.has(name)) {
          await xfs.removePromise(ppath.join(binDir, name));
          if (process.platform === `win32`) {
            await xfs.removePromise(ppath.join(binDir, toFilename(`${name}.cmd`)));
          }
        }
      }
      for (const [name, target] of symlinks) {
        const prevTarget = prevSymlinks.get(name);
        const symlinkPath = ppath.join(binDir, name);
        if (prevTarget === target)
          continue;
        if (process.platform === `win32`) {
          await import_cmd_shim2.default(npath.fromPortablePath(target), npath.fromPortablePath(symlinkPath), {createPwshFile: false});
        } else {
          await xfs.removePromise(symlinkPath);
          await symlinkPromise2(target, symlinkPath);
          await xfs.chmodPromise(target, 493);
        }
      }
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-9af797eaca\1\packages\plugin-node-modules\sources\PnpLooseLinker.ts
  var PnpLooseLinker2 = class extends PnpLinker2 {
    constructor() {
      super(...arguments);
      this.mode = `loose`;
    }
    makeInstaller(opts) {
      return new PnpLooseInstaller2(opts);
    }
  };
  var PnpLooseInstaller2 = class extends PnpInstaller2 {
    constructor() {
      super(...arguments);
      this.mode = `loose`;
    }
    async transformPnpSettings(pnpSettings) {
      const defaultFsLayer = new VirtualFS({
        baseFs: new ZipOpenFS({
          libzip: await getLibzipPromise(),
          maxOpenFiles: 80,
          readOnlyArchives: true
        })
      });
      const pnp2 = makeRuntimeApi(pnpSettings, this.opts.project.cwd, defaultFsLayer);
      const nmTree = buildNodeModulesTree(pnp2, {pnpifyFs: false, project: this.opts.project});
      const fallbackPool = new Map();
      pnpSettings.fallbackPool = fallbackPool;
      const registerFallback = (name, entry2) => {
        const locator = structUtils_exports.parseLocator(entry2.locator);
        const identStr = structUtils_exports.stringifyIdent(locator);
        if (identStr === name) {
          fallbackPool.set(name, locator.reference);
        } else {
          fallbackPool.set(name, [identStr, locator.reference]);
        }
      };
      const root = ppath.join(this.opts.project.cwd, Filename.nodeModules);
      const entry = nmTree.get(root);
      if (typeof entry === `undefined`)
        throw new Error(`Assertion failed: Expected a root junction point`);
      if (`target` in entry)
        throw new Error(`Assertion failed: Expected the root junction point to be a directory`);
      for (const childName of entry.dirList) {
        const childP = ppath.join(root, childName);
        const child = nmTree.get(childP);
        if (typeof child === `undefined`)
          throw new Error(`Assertion failed: Expected the child to have been registered`);
        if (`target` in child) {
          registerFallback(childName, child);
        } else {
          for (const subChildName of child.dirList) {
            const subChildP = ppath.join(childP, subChildName);
            const subChild = nmTree.get(subChildP);
            if (typeof subChild === `undefined`)
              throw new Error(`Assertion failed: Expected the subchild to have been registered`);
            if (`target` in subChild) {
              registerFallback(`${childName}/${subChildName}`, subChild);
            } else {
              throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
            }
          }
        }
      }
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-node-modules-virtual-9af797eaca\1\packages\plugin-node-modules\sources\index.ts
  var plugin15 = {
    configuration: {
      nmHoistingLimits: {
        description: `Prevent packages can be hoisted past specific levels`,
        type: SettingsType.STRING,
        values: [
          NodeModulesHoistingLimits.WORKSPACES,
          NodeModulesHoistingLimits.DEPENDENCIES,
          NodeModulesHoistingLimits.NONE
        ],
        default: `none`
      }
    },
    linkers: [
      NodeModulesLinker2,
      PnpLooseLinker2
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmHttpFetcher.ts
  var import_semver22 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\constants.ts
  var PROTOCOL3 = `npm:`;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\npmHttpUtils.ts
  var npmHttpUtils_exports2 = {};
  __export(npmHttpUtils_exports2, {
    AuthType: () => AuthType2,
    del: () => del3,
    get: () => get3,
    getIdentUrl: () => getIdentUrl2,
    handleInvalidAuthenticationError: () => handleInvalidAuthenticationError2,
    post: () => post3,
    put: () => put3
  });
  var import_enquirer6 = __toModule(require_enquirer());
  var import_url8 = __toModule(require("url"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\npmConfigUtils.ts
  var npmConfigUtils_exports2 = {};
  __export(npmConfigUtils_exports2, {
    RegistryType: () => RegistryType2,
    getAuthConfiguration: () => getAuthConfiguration2,
    getDefaultRegistry: () => getDefaultRegistry2,
    getPublishRegistry: () => getPublishRegistry2,
    getRegistryConfiguration: () => getRegistryConfiguration2,
    getScopeConfiguration: () => getScopeConfiguration2,
    getScopeRegistry: () => getScopeRegistry2,
    normalizeRegistry: () => normalizeRegistry2
  });
  var RegistryType2;
  (function(RegistryType3) {
    RegistryType3["FETCH_REGISTRY"] = `npmRegistryServer`;
    RegistryType3["PUBLISH_REGISTRY"] = `npmPublishRegistry`;
  })(RegistryType2 || (RegistryType2 = {}));
  function normalizeRegistry2(registry) {
    return registry.replace(/\/$/, ``);
  }
  function getPublishRegistry2(manifest, {configuration}) {
    if (manifest.publishConfig && manifest.publishConfig.registry)
      return normalizeRegistry2(manifest.publishConfig.registry);
    if (manifest.name)
      return getScopeRegistry2(manifest.name.scope, {configuration, type: RegistryType2.PUBLISH_REGISTRY});
    return getDefaultRegistry2({configuration, type: RegistryType2.PUBLISH_REGISTRY});
  }
  function getScopeRegistry2(scope, {configuration, type = RegistryType2.FETCH_REGISTRY}) {
    const scopeConfiguration = getScopeConfiguration2(scope, {configuration});
    if (scopeConfiguration === null)
      return getDefaultRegistry2({configuration, type});
    const scopeRegistry = scopeConfiguration.get(type);
    if (scopeRegistry === null)
      return getDefaultRegistry2({configuration, type});
    return normalizeRegistry2(scopeRegistry);
  }
  function getDefaultRegistry2({configuration, type = RegistryType2.FETCH_REGISTRY}) {
    const defaultRegistry = configuration.get(type);
    if (defaultRegistry !== null)
      return normalizeRegistry2(defaultRegistry);
    return normalizeRegistry2(configuration.get(RegistryType2.FETCH_REGISTRY));
  }
  function getRegistryConfiguration2(registry, {configuration}) {
    const registryConfigurations = configuration.get(`npmRegistries`);
    const exactEntry = registryConfigurations.get(registry);
    if (typeof exactEntry !== `undefined`)
      return exactEntry;
    const noProtocolEntry = registryConfigurations.get(registry.replace(/^[a-z]+:/, ``));
    if (typeof noProtocolEntry !== `undefined`)
      return noProtocolEntry;
    return null;
  }
  function getScopeConfiguration2(scope, {configuration}) {
    if (scope === null)
      return null;
    const scopeConfigurations = configuration.get(`npmScopes`);
    const scopeConfiguration = scopeConfigurations.get(scope);
    if (!scopeConfiguration)
      return null;
    return scopeConfiguration;
  }
  function getAuthConfiguration2(registry, {configuration, ident}) {
    const scopeConfiguration = ident && getScopeConfiguration2(ident.scope, {configuration});
    if ((scopeConfiguration == null ? void 0 : scopeConfiguration.get(`npmAuthIdent`)) || (scopeConfiguration == null ? void 0 : scopeConfiguration.get(`npmAuthToken`)))
      return scopeConfiguration;
    const registryConfiguration = getRegistryConfiguration2(registry, {configuration});
    return registryConfiguration || configuration;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\npmHttpUtils.ts
  var AuthType2;
  (function(AuthType3) {
    AuthType3[AuthType3["NO_AUTH"] = 0] = "NO_AUTH";
    AuthType3[AuthType3["BEST_EFFORT"] = 1] = "BEST_EFFORT";
    AuthType3[AuthType3["CONFIGURATION"] = 2] = "CONFIGURATION";
    AuthType3[AuthType3["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
  })(AuthType2 || (AuthType2 = {}));
  async function handleInvalidAuthenticationError2(error, {attemptedAs, registry, headers, configuration}) {
    if (error.name === `HTTPError` && error.response.statusCode === 401) {
      throw new ReportError(MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami2(registry, headers, {configuration})}` : `attempted as ${attemptedAs}`})`);
    }
  }
  function getIdentUrl2(ident) {
    if (ident.scope) {
      return `/@${ident.scope}%2f${ident.name}`;
    } else {
      return `/${ident.name}`;
    }
  }
  async function get3(path6, {configuration, headers, ident, authType, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry2(ident.scope, {configuration});
    if (ident && ident.scope && typeof authType === `undefined`)
      authType = 1;
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader2(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    let url;
    try {
      url = new import_url8.URL(path6);
    } catch (e) {
      url = new import_url8.URL(registry + path6);
    }
    try {
      return await httpUtils_exports.get(url.href, {configuration, headers, ...rest});
    } catch (error) {
      await handleInvalidAuthenticationError2(error, {registry, configuration, headers});
      throw error;
    }
  }
  async function post3(path6, body, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry2(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader2(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.post(registry + path6, body, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError2(error)) {
        await handleInvalidAuthenticationError2(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp2();
      const headersWithOtp = {...headers, ...getOtpHeaders2(otp)};
      try {
        return await httpUtils_exports.post(`${registry}${path6}`, body, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError2(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  async function put3(path6, body, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry2(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader2(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.put(registry + path6, body, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError2(error)) {
        await handleInvalidAuthenticationError2(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp2();
      const headersWithOtp = {...headers, ...getOtpHeaders2(otp)};
      try {
        return await httpUtils_exports.put(`${registry}${path6}`, body, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError2(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  async function del3(path6, {attemptedAs, configuration, headers, ident, authType = 3, registry, ...rest}) {
    if (ident && typeof registry === `undefined`)
      registry = getScopeRegistry2(ident.scope, {configuration});
    if (typeof registry !== `string`)
      throw new Error(`Assertion failed: The registry should be a string`);
    const auth = getAuthenticationHeader2(registry, {authType, configuration, ident});
    if (auth)
      headers = {...headers, authorization: auth};
    try {
      return await httpUtils_exports.del(registry + path6, {configuration, headers, ...rest});
    } catch (error) {
      if (!isOtpError2(error)) {
        await handleInvalidAuthenticationError2(error, {attemptedAs, registry, configuration, headers});
        throw error;
      }
      const otp = await askForOtp2();
      const headersWithOtp = {...headers, ...getOtpHeaders2(otp)};
      try {
        return await httpUtils_exports.del(`${registry}${path6}`, {configuration, headers: headersWithOtp, ...rest});
      } catch (error2) {
        await handleInvalidAuthenticationError2(error2, {attemptedAs, registry, configuration, headers});
        throw error2;
      }
    }
  }
  function getAuthenticationHeader2(registry, {authType = 2, configuration, ident}) {
    const effectiveConfiguration = getAuthConfiguration2(registry, {configuration, ident});
    const mustAuthenticate = shouldAuthenticate2(effectiveConfiguration, authType);
    if (!mustAuthenticate)
      return null;
    if (effectiveConfiguration.get(`npmAuthToken`))
      return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
    if (effectiveConfiguration.get(`npmAuthIdent`))
      return `Basic ${effectiveConfiguration.get(`npmAuthIdent`)}`;
    if (mustAuthenticate && authType !== 1) {
      throw new ReportError(MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
    } else {
      return null;
    }
  }
  function shouldAuthenticate2(authConfiguration, authType) {
    switch (authType) {
      case 2:
        return authConfiguration.get(`npmAlwaysAuth`);
      case 1:
      case 3:
        return true;
      case 0:
        return false;
      default:
        throw new Error(`Unreachable`);
    }
  }
  async function whoami2(registry, headers, {configuration}) {
    var _a2;
    if (typeof headers === `undefined` || typeof headers.authorization === `undefined`)
      return `an anonymous user`;
    try {
      const response = await httpUtils_exports.get(new import_url8.URL(`${registry}/-/whoami`).href, {
        configuration,
        headers,
        jsonResponse: true
      });
      return (_a2 = response.username) != null ? _a2 : `an unknown user`;
    } catch {
      return `an unknown user`;
    }
  }
  async function askForOtp2() {
    if (process.env.TEST_ENV)
      return process.env.TEST_NPM_2FA_TOKEN || ``;
    const {otp} = await import_enquirer6.prompt({
      type: `password`,
      name: `otp`,
      message: `One-time password:`,
      required: true,
      onCancel: () => process.exit(130)
    });
    return otp;
  }
  function isOtpError2(error) {
    if (error.name !== `HTTPError`)
      return false;
    try {
      const authMethods = error.response.headers[`www-authenticate`].split(/,\s*/).map((s) => s.toLowerCase());
      return authMethods.includes(`otp`);
    } catch (e) {
      return false;
    }
  }
  function getOtpHeaders2(otp) {
    return {
      [`npm-otp`]: otp
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmHttpFetcher.ts
  var NpmHttpFetcher2 = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL3))
        return false;
      const {selector, params} = structUtils_exports.parseRange(locator.reference);
      if (!import_semver22.default.valid(selector))
        return false;
      if (params === null || typeof params.__archiveUrl !== `string`)
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      const {params} = structUtils_exports.parseRange(locator.reference);
      if (params === null || typeof params.__archiveUrl !== `string`)
        throw new Error(`Assertion failed: The archiveUrl querystring parameter should have been available`);
      const sourceBuffer = await get3(params.__archiveUrl, {
        configuration: opts.project.configuration,
        ident: locator
      });
      return await tgzUtils_exports.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmRemapResolver.ts
  var NpmRemapResolver2 = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL3))
        return false;
      if (!structUtils_exports.tryParseDescriptor(descriptor.range.slice(PROTOCOL3.length), true))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL3.length), true);
      return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL3.length), true);
      return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
    }
    async getSatisfying(descriptor, references, opts) {
      const nextDescriptor = structUtils_exports.parseDescriptor(descriptor.range.slice(PROTOCOL3.length), true);
      return opts.resolver.getSatisfying(nextDescriptor, references, opts);
    }
    resolve(locator, opts) {
      throw new Error(`Unreachable`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmSemverFetcher.ts
  var import_semver23 = __toModule(require_semver2());
  var import_url9 = __toModule(require("url"));
  var NpmSemverFetcher2 = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL3))
        return false;
      const url = new import_url9.URL(locator.reference);
      if (!import_semver23.default.valid(url.pathname))
        return false;
      if (url.searchParams.has(`__archiveUrl`))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
        loader: () => this.fetchFromNetwork(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        checksum
      };
    }
    async fetchFromNetwork(locator, opts) {
      let sourceBuffer;
      try {
        sourceBuffer = await get3(NpmSemverFetcher2.getLocatorUrl(locator), {
          configuration: opts.project.configuration,
          ident: locator
        });
      } catch (error) {
        sourceBuffer = await get3(NpmSemverFetcher2.getLocatorUrl(locator).replace(/%2f/g, `/`), {
          configuration: opts.project.configuration,
          ident: locator
        });
      }
      return await tgzUtils_exports.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }
    static isConventionalTarballUrl(locator, url, {configuration}) {
      let registry = getScopeRegistry2(locator.scope, {configuration});
      const path6 = NpmSemverFetcher2.getLocatorUrl(locator);
      url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`);
      registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
      url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
      if (url === registry + path6)
        return true;
      if (url === registry + path6.replace(/%2f/g, `/`))
        return true;
      return false;
    }
    static getLocatorUrl(locator) {
      const version = import_semver23.default.clean(locator.reference.slice(PROTOCOL3.length));
      if (version === null)
        throw new ReportError(MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
      return `${getIdentUrl2(locator)}/-/${locator.name}-${version}.tgz`;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmSemverResolver.ts
  var import_semver24 = __toModule(require_semver2());
  var NODE_GYP_IDENT2 = structUtils_exports.makeIdent(null, `node-gyp`);
  var NODE_GYP_MATCH2 = /\b(node-gyp|prebuild-install)\b/;
  var NpmSemverResolver2 = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL3))
        return false;
      return !!semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL3.length));
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(PROTOCOL3))
        return false;
      const {selector} = structUtils_exports.parseRange(locator.reference);
      if (!import_semver24.default.valid(selector))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const range = semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL3.length));
      if (range === null)
        throw new Error(`Expected a valid range, got ${descriptor.range.slice(PROTOCOL3.length)}`);
      const registryData = await get3(getIdentUrl2(descriptor), {
        configuration: opts.project.configuration,
        ident: descriptor,
        jsonResponse: true
      });
      const candidates = miscUtils10.mapAndFilter(Object.keys(registryData.versions), (version) => {
        try {
          const candidate = new semverUtils_exports.SemVer(version);
          if (range.test(candidate)) {
            return candidate;
          }
        } catch {
        }
        return miscUtils10.mapAndFilter.skip;
      });
      const noDeprecatedCandidates = candidates.filter((version) => {
        return !registryData.versions[version.raw].deprecated;
      });
      const finalCandidates = noDeprecatedCandidates.length > 0 ? noDeprecatedCandidates : candidates;
      finalCandidates.sort((a, b) => {
        return -a.compare(b);
      });
      return finalCandidates.map((version) => {
        const versionLocator = structUtils_exports.makeLocator(descriptor, `${PROTOCOL3}${version.raw}`);
        const archiveUrl = registryData.versions[version.raw].dist.tarball;
        if (NpmSemverFetcher2.isConventionalTarballUrl(versionLocator, archiveUrl, {configuration: opts.project.configuration})) {
          return versionLocator;
        } else {
          return structUtils_exports.bindLocator(versionLocator, {__archiveUrl: archiveUrl});
        }
      });
    }
    async getSatisfying(descriptor, references, opts) {
      const range = semverUtils_exports.validRange(descriptor.range.slice(PROTOCOL3.length));
      if (range === null)
        throw new Error(`Expected a valid range, got ${descriptor.range.slice(PROTOCOL3.length)}`);
      return references.map((reference) => {
        try {
          return new semverUtils_exports.SemVer(reference.slice(PROTOCOL3.length));
        } catch {
          return null;
        }
      }).filter((version) => version !== null).filter((version) => range.test(version)).sort((a, b) => -a.compare(b)).map((version) => structUtils_exports.makeLocator(descriptor, `${PROTOCOL3}${version.raw}`));
    }
    async resolve(locator, opts) {
      const {selector} = structUtils_exports.parseRange(locator.reference);
      const version = import_semver24.default.clean(selector);
      if (version === null)
        throw new ReportError(MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
      const registryData = await get3(getIdentUrl2(locator), {
        configuration: opts.project.configuration,
        ident: locator,
        jsonResponse: true
      });
      if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
        throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
      if (!Object.prototype.hasOwnProperty.call(registryData.versions, version))
        throw new ReportError(MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
      const manifest = new Manifest();
      manifest.load(registryData.versions[version]);
      if (!manifest.dependencies.has(NODE_GYP_IDENT2.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT2.identHash)) {
        for (const value of manifest.scripts.values()) {
          if (value.match(NODE_GYP_MATCH2)) {
            manifest.dependencies.set(NODE_GYP_IDENT2.identHash, structUtils_exports.makeDescriptor(NODE_GYP_IDENT2, `latest`));
            opts.report.reportWarning(MessageName.NODE_GYP_INJECTED, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
            break;
          }
        }
      }
      if (typeof manifest.raw.deprecated === `string`)
        opts.report.reportWarning(MessageName.DEPRECATED_PACKAGE, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
      return {
        ...locator,
        version,
        languageName: `node`,
        linkType: LinkType.HARD,
        dependencies: manifest.dependencies,
        peerDependencies: manifest.peerDependencies,
        dependenciesMeta: manifest.dependenciesMeta,
        peerDependenciesMeta: manifest.peerDependenciesMeta,
        bin: manifest.bin
      };
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\NpmTagResolver.ts
  var NpmTagResolver2 = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(PROTOCOL3))
        return false;
      if (!TAG_REGEXP.test(descriptor.range.slice(PROTOCOL3.length)))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      return false;
    }
    shouldPersistResolution(locator, opts) {
      throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
      return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
      const tag = descriptor.range.slice(PROTOCOL3.length);
      const registryData = await get3(getIdentUrl2(descriptor), {
        configuration: opts.project.configuration,
        ident: descriptor,
        jsonResponse: true
      });
      if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`))
        throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
      const distTags = registryData[`dist-tags`];
      if (!Object.prototype.hasOwnProperty.call(distTags, tag))
        throw new ReportError(MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
      const version = distTags[tag];
      const versionLocator = structUtils_exports.makeLocator(descriptor, `${PROTOCOL3}${version}`);
      const archiveUrl = registryData.versions[version].dist.tarball;
      if (NpmSemverFetcher2.isConventionalTarballUrl(versionLocator, archiveUrl, {configuration: opts.project.configuration})) {
        return [versionLocator];
      } else {
        return [structUtils_exports.bindLocator(versionLocator, {__archiveUrl: archiveUrl})];
      }
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      throw new Error(`Unreachable`);
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\npmPublishUtils.ts
  var npmPublishUtils_exports = {};
  __export(npmPublishUtils_exports, {
    makePublishBody: () => makePublishBody
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-9b262587dd\1\packages\plugin-pack\sources\packUtils.ts
  var packUtils_exports = {};
  __export(packUtils_exports, {
    genPackList: () => genPackList,
    genPackStream: () => genPackStream,
    genPackageManifest: () => genPackageManifest,
    hasPackScripts: () => hasPackScripts,
    prepareForPack: () => prepareForPack
  });
  var import_micromatch13 = __toModule(require_micromatch());
  var import_tar_stream = __toModule(require_tar_stream());
  var import_zlib3 = __toModule(require("zlib"));
  var NEVER_IGNORE = [
    `/package.json`,
    `/readme`,
    `/readme.*`,
    `/license`,
    `/license.*`,
    `/licence`,
    `/licence.*`,
    `/changelog`,
    `/changelog.*`
  ];
  var ALWAYS_IGNORE = [
    `/package.tgz`,
    `.github`,
    `.git`,
    `.hg`,
    `node_modules`,
    `.npmignore`,
    `.gitignore`,
    `.#*`,
    `.DS_Store`
  ];
  async function hasPackScripts(workspace) {
    if (scriptUtils_exports.hasWorkspaceScript(workspace, `prepack`))
      return true;
    if (scriptUtils_exports.hasWorkspaceScript(workspace, `postpack`))
      return true;
    return false;
  }
  async function prepareForPack(workspace, {report}, cb) {
    await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `prepack`, {report});
    try {
      await cb();
    } finally {
      await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `postpack`, {report});
    }
  }
  async function genPackStream(workspace, files) {
    var _a2, _b;
    if (typeof files === `undefined`)
      files = await genPackList(workspace);
    const executableFiles = new Set();
    for (const value of (_b = (_a2 = workspace.manifest.publishConfig) == null ? void 0 : _a2.executableFiles) != null ? _b : new Set())
      executableFiles.add(ppath.normalize(value));
    for (const value of workspace.manifest.bin.values())
      executableFiles.add(ppath.normalize(value));
    const pack = import_tar_stream.default.pack();
    process.nextTick(async () => {
      for (const fileRequest of files) {
        const file = ppath.normalize(fileRequest);
        const source = ppath.resolve(workspace.cwd, file);
        const dest = ppath.join(`package`, file);
        const stat = await xfs.lstatPromise(source);
        const opts = {name: dest, mtime: new Date(3155328e5)};
        const mode = executableFiles.has(file) ? 493 : 420;
        let resolveFn;
        let rejectFn;
        const awaitTarget = new Promise((resolve, reject) => {
          resolveFn = resolve;
          rejectFn = reject;
        });
        const cb = (error) => {
          if (error) {
            rejectFn(error);
          } else {
            resolveFn();
          }
        };
        if (stat.isFile()) {
          let content;
          if (file === `package.json`)
            content = Buffer.from(JSON.stringify(await genPackageManifest(workspace), null, 2));
          else
            content = await xfs.readFilePromise(source);
          pack.entry({...opts, mode, type: `file`}, content, cb);
        } else if (stat.isSymbolicLink()) {
          pack.entry({...opts, mode, type: `symlink`, linkname: await xfs.readlinkPromise(source)}, cb);
        } else {
          cb(new Error(`Unsupported file type ${stat.mode} for ${npath.fromPortablePath(file)}`));
        }
        await awaitTarget;
      }
      pack.finalize();
    });
    const tgz = import_zlib3.createGzip();
    pack.pipe(tgz);
    return tgz;
  }
  async function genPackageManifest(workspace) {
    const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
    await workspace.project.configuration.triggerHook((hooks) => hooks.beforeWorkspacePacking, workspace, data);
    return data;
  }
  async function genPackList(workspace) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const project = workspace.project;
    const configuration = project.configuration;
    const globalList = {
      accept: [],
      reject: []
    };
    for (const pattern of ALWAYS_IGNORE)
      globalList.reject.push(pattern);
    for (const pattern of NEVER_IGNORE)
      globalList.accept.push(pattern);
    globalList.reject.push(configuration.get(`rcFilename`));
    const maybeRejectPath = (path6) => {
      if (path6 === null || !path6.startsWith(`${workspace.cwd}/`))
        return;
      const workspaceRelativePath = ppath.relative(workspace.cwd, path6);
      const workspaceAbsolutePath = ppath.resolve(PortablePath2.root, workspaceRelativePath);
      globalList.reject.push(workspaceAbsolutePath);
    };
    maybeRejectPath(ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
    maybeRejectPath(configuration.get(`bstatePath`));
    maybeRejectPath(configuration.get(`cacheFolder`));
    maybeRejectPath(configuration.get(`globalFolder`));
    maybeRejectPath(configuration.get(`installStatePath`));
    maybeRejectPath(configuration.get(`virtualFolder`));
    maybeRejectPath(configuration.get(`yarnPath`));
    await configuration.triggerHook((hooks) => {
      return hooks.populateYarnPaths;
    }, project, (path6) => {
      maybeRejectPath(path6);
    });
    for (const otherWorkspace of project.workspaces) {
      const rel = ppath.relative(workspace.cwd, otherWorkspace.cwd);
      if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
        globalList.reject.push(`/${rel}`);
      }
    }
    const ignoreList = {
      accept: [],
      reject: []
    };
    const main3 = (_b = (_a2 = workspace.manifest.publishConfig) == null ? void 0 : _a2.main) != null ? _b : workspace.manifest.main;
    const module2 = (_d = (_c = workspace.manifest.publishConfig) == null ? void 0 : _c.module) != null ? _d : workspace.manifest.module;
    const browser = (_f = (_e = workspace.manifest.publishConfig) == null ? void 0 : _e.browser) != null ? _f : workspace.manifest.browser;
    const bins = (_h = (_g = workspace.manifest.publishConfig) == null ? void 0 : _g.bin) != null ? _h : workspace.manifest.bin;
    if (main3 != null)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, main3));
    if (module2 != null)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, module2));
    if (typeof browser === `string`)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, browser));
    for (const path6 of bins.values())
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, path6));
    if (browser instanceof Map) {
      for (const [original, replacement] of browser.entries()) {
        ignoreList.accept.push(ppath.resolve(PortablePath2.root, original));
        if (typeof replacement === `string`) {
          ignoreList.accept.push(ppath.resolve(PortablePath2.root, replacement));
        }
      }
    }
    const hasExplicitFileList = workspace.manifest.files !== null;
    if (hasExplicitFileList) {
      ignoreList.reject.push(`/*`);
      for (const pattern of workspace.manifest.files) {
        addIgnorePattern(ignoreList.accept, pattern, {cwd: PortablePath2.root});
      }
    }
    return await walk(workspace.cwd, {
      hasExplicitFileList,
      globalList,
      ignoreList
    });
  }
  async function walk(initialCwd, {hasExplicitFileList, globalList, ignoreList}) {
    const list = [];
    const cwdFs = new JailFS(initialCwd);
    const cwdList = [[PortablePath2.root, [ignoreList]]];
    while (cwdList.length > 0) {
      const [cwd, ignoreLists] = cwdList.pop();
      const stat = await cwdFs.lstatPromise(cwd);
      if (isIgnored(cwd, {globalList, ignoreLists: stat.isDirectory() ? null : ignoreLists}))
        continue;
      if (stat.isDirectory()) {
        const entries = await cwdFs.readdirPromise(cwd);
        let hasGitIgnore = false;
        let hasNpmIgnore = false;
        if (!hasExplicitFileList || cwd !== PortablePath2.root) {
          for (const entry of entries) {
            hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
            hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
          }
        }
        const localIgnoreList = hasNpmIgnore ? await loadIgnoreList(cwdFs, cwd, `.npmignore`) : hasGitIgnore ? await loadIgnoreList(cwdFs, cwd, `.gitignore`) : null;
        let nextIgnoreLists = localIgnoreList !== null ? [localIgnoreList].concat(ignoreLists) : ignoreLists;
        if (isIgnored(cwd, {globalList, ignoreLists}))
          nextIgnoreLists = [...ignoreLists, {accept: [], reject: [`**/*`]}];
        for (const entry of entries) {
          cwdList.push([ppath.resolve(cwd, entry), nextIgnoreLists]);
        }
      } else if (stat.isFile() || stat.isSymbolicLink()) {
        list.push(ppath.relative(PortablePath2.root, cwd));
      }
    }
    return list.sort();
  }
  async function loadIgnoreList(fs9, cwd, filename) {
    const ignoreList = {
      accept: [],
      reject: []
    };
    const data = await fs9.readFilePromise(ppath.join(cwd, filename), `utf8`);
    for (const pattern of data.split(/\n/g))
      addIgnorePattern(ignoreList.reject, pattern, {cwd});
    return ignoreList;
  }
  function normalizePattern(pattern, {cwd}) {
    const negated = pattern[0] === `!`;
    if (negated)
      pattern = pattern.slice(1);
    if (pattern.match(/\.{0,1}\//))
      pattern = ppath.resolve(cwd, pattern);
    if (negated)
      pattern = `!${pattern}`;
    return pattern;
  }
  function addIgnorePattern(target, pattern, {cwd}) {
    const trimed = pattern.trim();
    if (trimed === `` || trimed[0] === `#`)
      return;
    target.push(normalizePattern(trimed, {cwd}));
  }
  function isIgnored(cwd, {globalList, ignoreLists}) {
    if (isMatch(cwd, globalList.accept))
      return false;
    if (isMatch(cwd, globalList.reject))
      return true;
    if (ignoreLists !== null) {
      for (const ignoreList of ignoreLists) {
        if (isMatch(cwd, ignoreList.accept))
          return false;
        if (isMatch(cwd, ignoreList.reject)) {
          return true;
        }
      }
    }
    return false;
  }
  function isMatch(path6, patterns) {
    let inclusives = patterns;
    const exclusives = [];
    for (let t7 = 0; t7 < patterns.length; ++t7) {
      if (patterns[t7][0] !== `!`) {
        if (inclusives !== patterns) {
          inclusives.push(patterns[t7]);
        }
      } else {
        if (inclusives === patterns)
          inclusives = patterns.slice(0, t7);
        exclusives.push(patterns[t7].slice(1));
      }
    }
    if (isMatchBasename(path6, exclusives))
      return false;
    if (isMatchBasename(path6, inclusives))
      return true;
    return false;
  }
  function isMatchBasename(path6, patterns) {
    let paths = patterns;
    const basenames = [];
    for (let t7 = 0; t7 < patterns.length; ++t7) {
      if (patterns[t7].includes(`/`)) {
        if (paths !== patterns) {
          paths.push(patterns[t7]);
        }
      } else {
        if (paths === patterns)
          paths = patterns.slice(0, t7);
        basenames.push(patterns[t7]);
      }
    }
    if (import_micromatch13.default.isMatch(path6, paths, {dot: true, nocase: true}))
      return true;
    if (import_micromatch13.default.isMatch(path6, basenames, {dot: true, basename: true, nocase: true}))
      return true;
    return false;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-9b262587dd\1\packages\plugin-pack\sources\commands\pack.ts
  var PackCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.installIfNeeded = options_exports.Boolean(`--install-if-needed`, false, {
        description: `Run a preliminary \`yarn install\` if the package contains build scripts`
      });
      this.dryRun = options_exports.Boolean(`-n,--dry-run`, false, {
        description: `Print the file paths without actually generating the package archive`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.out = options_exports.String(`-o,--out`, {
        description: `Create the archive at the specified path`
      });
      this.filename = options_exports.String(`--filename`, {hidden: true});
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      if (await hasPackScripts(workspace)) {
        if (this.installIfNeeded) {
          await project.install({
            cache: await Cache.find(configuration),
            report: new ThrowReport()
          });
        } else {
          await project.restoreInstallState();
        }
      }
      const out = (_a2 = this.out) != null ? _a2 : this.filename;
      const target = typeof out !== `undefined` ? ppath.resolve(this.context.cwd, interpolateOutputName(out, {workspace})) : ppath.resolve(workspace.cwd, `package.tgz`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        json: this.json
      }, async (report2) => {
        await prepareForPack(workspace, {report: report2}, async () => {
          report2.reportJson({base: workspace.cwd});
          const files = await genPackList(workspace);
          for (const file of files) {
            report2.reportInfo(null, file);
            report2.reportJson({location: file});
          }
          if (!this.dryRun) {
            const pack = await genPackStream(workspace, files);
            const write = xfs.createWriteStream(target);
            pack.pipe(write);
            await new Promise((resolve) => {
              write.on(`finish`, resolve);
            });
          }
        });
        if (!this.dryRun) {
          report2.reportInfo(MessageName.UNNAMED, `Package archive generated in ${formatUtils_exports.pretty(configuration, target, formatUtils_exports.Type.PATH)}`);
          report2.reportJson({output: target});
        }
      });
      return report.exitCode();
    }
  };
  PackCommand.paths = [
    [`pack`]
  ];
  PackCommand.usage = Command.Usage({
    description: `generate a tarball from the active workspace`,
    details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
    examples: [[
      `Create an archive from the active workspace`,
      `yarn pack`
    ], [
      `List the files that would be made part of the workspace's archive`,
      `yarn pack --dry-run`
    ], [
      `Name and output the archive in a dedicated folder`,
      `yarn pack --out /artifacts/%s-%v.tgz`
    ]]
  });
  var pack_default = PackCommand;
  function interpolateOutputName(name, {workspace}) {
    const interpolated = name.replace(`%s`, prettyWorkspaceIdent(workspace)).replace(`%v`, prettyWorkspaceVersion(workspace));
    return npath.toPortablePath(interpolated);
  }
  function prettyWorkspaceIdent(workspace) {
    if (workspace.manifest.name !== null) {
      return structUtils_exports.slugifyIdent(workspace.manifest.name);
    } else {
      return `package`;
    }
  }
  function prettyWorkspaceVersion(workspace) {
    if (workspace.manifest.version !== null) {
      return workspace.manifest.version;
    } else {
      return `unknown`;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\npmPublishUtils.ts
  var import_crypto3 = __toModule(require("crypto"));
  var import_ssri = __toModule(require_ssri());
  var import_url10 = __toModule(require("url"));
  async function makePublishBody(workspace, buffer, {access, tag, registry}) {
    const configuration = workspace.project.configuration;
    const ident = workspace.manifest.name;
    const version = workspace.manifest.version;
    const name = structUtils_exports.stringifyIdent(ident);
    const shasum = import_crypto3.createHash(`sha1`).update(buffer).digest(`hex`);
    const integrity = import_ssri.default.fromData(buffer).toString();
    if (typeof access === `undefined`) {
      if (workspace.manifest.publishConfig && typeof workspace.manifest.publishConfig.access === `string`) {
        access = workspace.manifest.publishConfig.access;
      } else if (configuration.get(`npmPublishAccess`) !== null) {
        access = configuration.get(`npmPublishAccess`);
      } else if (ident.scope) {
        access = `restricted`;
      } else {
        access = `public`;
      }
    }
    const raw = await packUtils_exports.genPackageManifest(workspace);
    const tarballName = `${name}-${version}.tgz`;
    const tarballURL = new import_url10.URL(`${name}/-/${tarballName}`, registry);
    return {
      _id: name,
      _attachments: {
        [tarballName]: {
          [`content_type`]: `application/octet-stream`,
          data: buffer.toString(`base64`),
          length: buffer.length
        }
      },
      name,
      access,
      [`dist-tags`]: {
        [tag]: version
      },
      versions: {
        [version]: {
          ...raw,
          _id: `${name}@${version}`,
          name,
          version,
          dist: {
            shasum,
            integrity,
            tarball: tarballURL.toString()
          }
        }
      }
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-e1403461d9\1\packages\plugin-npm\sources\index.ts
  var authSettings = {
    npmAlwaysAuth: {
      description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    npmAuthIdent: {
      description: `Authentication identity for the npm registry (_auth in npm and yarn v1)`,
      type: SettingsType.SECRET,
      default: null
    },
    npmAuthToken: {
      description: `Authentication token for the npm registry (_authToken in npm and yarn v1)`,
      type: SettingsType.SECRET,
      default: null
    }
  };
  var registrySettings = {
    npmPublishRegistry: {
      description: `Registry to push packages to`,
      type: SettingsType.STRING,
      default: null
    },
    npmRegistryServer: {
      description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
      type: SettingsType.STRING,
      default: `https://registry.yarnpkg.com`
    }
  };
  var plugin16 = {
    configuration: {
      ...authSettings,
      ...registrySettings,
      npmScopes: {
        description: `Settings per package scope`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.SHAPE,
          properties: {
            ...authSettings,
            ...registrySettings
          }
        }
      },
      npmRegistries: {
        description: `Settings per registry`,
        type: SettingsType.MAP,
        normalizeKeys: normalizeRegistry2,
        valueDefinition: {
          description: ``,
          type: SettingsType.SHAPE,
          properties: {
            ...authSettings
          }
        }
      }
    },
    fetchers: [
      NpmHttpFetcher2,
      NpmSemverFetcher2
    ],
    resolvers: [
      NpmRemapResolver2,
      NpmSemverResolver2,
      NpmTagResolver2
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\audit.ts
  var t5 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\npmAuditTypes.ts
  var Environment;
  (function(Environment3) {
    Environment3["All"] = `all`;
    Environment3["Production"] = `production`;
    Environment3["Development"] = `development`;
  })(Environment || (Environment = {}));
  var Severity;
  (function(Severity3) {
    Severity3["Info"] = `info`;
    Severity3["Low"] = `low`;
    Severity3["Moderate"] = `moderate`;
    Severity3["High"] = `high`;
    Severity3["Critical"] = `critical`;
  })(Severity || (Severity = {}));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\npmAuditUtils.ts
  var allSeverities = [
    Severity.Info,
    Severity.Low,
    Severity.Moderate,
    Severity.High,
    Severity.Critical
  ];
  function getTransitiveDependencies(project, roots) {
    const queue = [];
    const descriptorHashes = new Set();
    const enqueue = (descriptorHash) => {
      if (descriptorHashes.has(descriptorHash))
        return;
      descriptorHashes.add(descriptorHash);
      queue.push(descriptorHash);
    };
    for (const root of roots)
      enqueue(root);
    const transitiveDependencies = new Set();
    while (queue.length > 0) {
      const descriptorHash = queue.shift();
      const locatorHash = project.storedResolutions.get(descriptorHash);
      if (typeof locatorHash === `undefined`)
        throw new Error(`Assertion failed: Expected the resolution to have been registered`);
      const pkg = project.storedPackages.get(locatorHash);
      if (!pkg)
        continue;
      transitiveDependencies.add(descriptorHash);
      for (const dependency of pkg.dependencies.values()) {
        enqueue(dependency.descriptorHash);
      }
    }
    return transitiveDependencies;
  }
  function setDifference(x, y) {
    return new Set([...x].filter((value) => !y.has(value)));
  }
  function getTransitiveDevDependencies(project, workspace, {all}) {
    const workspaces = all ? project.workspaces : [workspace];
    const manifests = workspaces.map((workspace2) => {
      return workspace2.manifest;
    });
    const productionDependencyIdentSet = new Set(manifests.map((manifest) => [...manifest.dependencies].map(([identHash, descriptor]) => identHash)).flat());
    const developmentDependencyIdentSet = new Set(manifests.map((manifest) => [...manifest.devDependencies].map(([identHash, descriptor]) => identHash)).flat());
    const workspaceDependencies = workspaces.map((workspace2) => [...workspace2.dependencies.values()]).flat();
    const productionRoots = workspaceDependencies.filter((dependency) => productionDependencyIdentSet.has(dependency.identHash)).map((dependency) => dependency.descriptorHash);
    const developmentRoots = workspaceDependencies.filter((dependency) => developmentDependencyIdentSet.has(dependency.identHash)).map((dependency) => dependency.descriptorHash);
    const productionDependencies = getTransitiveDependencies(project, productionRoots);
    const developmentDependencies = getTransitiveDependencies(project, developmentRoots);
    return setDifference(developmentDependencies, productionDependencies);
  }
  function transformDescriptorIterableToRequiresObject(descriptors) {
    const data = {};
    for (const descriptor of descriptors)
      data[structUtils_exports.stringifyIdent(descriptor)] = structUtils_exports.parseRange(descriptor.range).selector;
    return data;
  }
  function getSeverityInclusions(severity) {
    if (typeof severity === `undefined`)
      return new Set();
    const severityIndex = allSeverities.indexOf(severity);
    const severities = allSeverities.slice(severityIndex);
    return new Set(severities);
  }
  function filterVulnerabilities(vulnerabilities, severity) {
    const inclusions = getSeverityInclusions(severity);
    const filteredVulnerabilities = {};
    for (const key of inclusions)
      filteredVulnerabilities[key] = vulnerabilities[key];
    return filteredVulnerabilities;
  }
  function isError(vulnerabilities, severity) {
    var _a2;
    const filteredVulnerabilities = filterVulnerabilities(vulnerabilities, severity);
    for (const key of Object.keys(filteredVulnerabilities))
      if ((_a2 = filteredVulnerabilities[key]) != null ? _a2 : 0 > 0)
        return true;
    return false;
  }
  function getReportTree(result, severity) {
    const auditTreeChildren = {};
    const auditTree = {children: auditTreeChildren};
    let advisories = Object.values(result.advisories);
    if (severity != null) {
      const inclusions = getSeverityInclusions(severity);
      advisories = advisories.filter((advisory) => inclusions.has(advisory.severity));
    }
    for (const advisory of miscUtils10.sortMap(advisories, (advisory2) => advisory2.module_name)) {
      auditTreeChildren[advisory.module_name] = {
        label: advisory.module_name,
        value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.findings.map((finding) => finding.version).join(`, `)),
        children: {
          Issue: {
            label: `Issue`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.title)
          },
          URL: {
            label: `URL`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.URL, advisory.url)
          },
          Severity: {
            label: `Severity`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.severity)
          },
          [`Vulnerable Versions`]: {
            label: `Vulnerable Versions`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.vulnerable_versions)
          },
          [`Patched Versions`]: {
            label: `Patched Versions`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.patched_versions)
          },
          Via: {
            label: `Via`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, Array.from(new Set(advisory.findings.map((finding) => finding.paths).flat().map((path6) => path6.split(`>`)[0]))).join(`, `))
          },
          Recommendation: {
            label: `Recommendation`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.recommendation.replace(/\n/g, ` `))
          }
        }
      };
    }
    return auditTree;
  }
  function getRequires(project, workspace, {all, environment}) {
    const workspaces = all ? project.workspaces : [workspace];
    const includeDependencies = [
      Environment.All,
      Environment.Production
    ].includes(environment);
    const requiredDependencies = [];
    if (includeDependencies)
      for (const workspace2 of workspaces)
        for (const dependency of workspace2.manifest.dependencies.values())
          requiredDependencies.push(dependency);
    const includeDevDependencies = [
      Environment.All,
      Environment.Development
    ].includes(environment);
    const requiredDevDependencies = [];
    if (includeDevDependencies)
      for (const workspace2 of workspaces)
        for (const dependency of workspace2.manifest.devDependencies.values())
          requiredDevDependencies.push(dependency);
    return transformDescriptorIterableToRequiresObject([
      ...requiredDependencies,
      ...requiredDevDependencies
    ].filter((dependency) => {
      return structUtils_exports.parseRange(dependency.range).protocol === null;
    }));
  }
  function getDependencies(project, workspace, {all}) {
    var _a2;
    const transitiveDevDependencies = getTransitiveDevDependencies(project, workspace, {all});
    const data = {};
    for (const pkg of project.storedPackages.values()) {
      data[structUtils_exports.stringifyIdent(pkg)] = {
        version: (_a2 = pkg.version) != null ? _a2 : `0.0.0`,
        integrity: pkg.identHash,
        requires: transformDescriptorIterableToRequiresObject(pkg.dependencies.values()),
        dev: transitiveDevDependencies.has(structUtils_exports.convertLocatorToDescriptor(pkg).descriptorHash)
      };
    }
    return data;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\audit.ts
  var AuditCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Audit dependencies from all workspaces`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Audit transitive dependencies as well`
      });
      this.environment = options_exports.String(`--environment`, Environment.All, {
        description: `Which environments to cover`,
        validator: t5.isEnum(Environment)
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.severity = options_exports.String(`--severity`, Severity.Info, {
        description: `Minimal severity requested for packages to be displayed`,
        validator: t5.isEnum(Severity)
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const requires = getRequires(project, workspace, {all: this.all, environment: this.environment});
      const dependencies = getDependencies(project, workspace, {all: this.all});
      if (!this.recursive) {
        for (const key of Object.keys(dependencies)) {
          if (!Object.prototype.hasOwnProperty.call(requires, key)) {
            delete dependencies[key];
          } else {
            dependencies[key].requires = {};
          }
        }
      }
      const body = {
        requires,
        dependencies
      };
      const registry = npmConfigUtils_exports2.getPublishRegistry(workspace.manifest, {
        configuration
      });
      let result;
      const httpReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout
      }, async () => {
        try {
          result = await npmHttpUtils_exports2.post(`/-/npm/v1/security/audits/quick`, body, {
            authType: npmHttpUtils_exports2.AuthType.NO_AUTH,
            configuration,
            jsonResponse: true,
            registry
          });
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else {
            throw new ReportError(MessageName.EXCEPTION, err.toString());
          }
        }
      });
      if (httpReport.hasErrors())
        return httpReport.exitCode();
      const hasError = isError(result.metadata.vulnerabilities, this.severity);
      if (!this.json && hasError) {
        treeUtils_exports.emitTree(getReportTree(result, this.severity), {
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          separators: 2
        });
        return 1;
      }
      const outReport = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report) => {
        report.reportJson(result);
        if (!hasError) {
          report.reportInfo(MessageName.EXCEPTION, `No audit suggestions`);
        }
      });
      return outReport.exitCode();
    }
  };
  AuditCommand.paths = [
    [`npm`, `audit`]
  ];
  AuditCommand.usage = Command.Usage({
    description: `perform a vulnerability audit against the installed packages`,
    details: `
      This command checks for known security reports on the packages you use. The reports are by default extracted from the npm registry, and may or may not be relevant to your actual program (not all vulnerabilities affect all code paths).

      For consistency with our other commands the default is to only check the direct dependencies for the active workspace. To extend this search to all workspaces, use \`-A,--all\`. To extend this search to both direct and transitive dependencies, use \`-R,--recursive\`.

      Applying the \`--severity\` flag will limit the audit table to vulnerabilities of the corresponding severity and above. Valid values are ${allSeverities.map((value) => `\`${value}\``).join(`, `)}.

      If the \`--json\` flag is set, Yarn will print the output exactly as received from the registry. Regardless of this flag, the process will exit with a non-zero exit code if a report is found for the selected packages.

      To understand the dependency tree requiring vulnerable packages, check the raw report with the \`--json\` flag or use \`yarn why <package>\` to get more information as to who depends on them.
    `,
    examples: [[
      `Checks for known security issues with the installed packages. The output is a list of known issues.`,
      `yarn npm audit`
    ], [
      `Audit dependencies in all workspaces`,
      `yarn npm audit --all`
    ], [
      `Limit auditing to \`dependencies\` (excludes \`devDependencies\`)`,
      `yarn npm audit --environment production`
    ], [
      `Show audit report as valid JSON`,
      `yarn npm audit --json`
    ], [
      `Audit all direct and transitive dependencies`,
      `yarn npm audit --recursive`
    ], [
      `Output moderate (or more severe) vulnerabilities`,
      `yarn npm audit --severity moderate`
    ]]
  });
  var audit_default = AuditCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\info.ts
  var import_path19 = __toModule(require("path"));
  var import_semver25 = __toModule(require_semver2());
  var import_util15 = __toModule(require("util"));
  var InfoCommand3 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.fields = options_exports.String(`-f,--fields`, {
        description: `A comma-separated list of manifest fields that should be displayed`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.packages = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const fields = typeof this.fields !== `undefined` ? new Set([`name`, ...this.fields.split(/\s*,\s*/)]) : null;
      const infos = [];
      let leadWithSeparator = false;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const identStr of this.packages) {
          let descriptor;
          if (identStr === `.`) {
            const workspace = project.topLevelWorkspace;
            if (!workspace.manifest.name)
              throw new UsageError(`Missing 'name' field in ${import_path19.default.join(workspace.cwd, `package.json`)}`);
            descriptor = structUtils_exports.makeDescriptor(workspace.manifest.name, `unknown`);
          } else {
            descriptor = structUtils_exports.parseDescriptor(identStr);
          }
          const identUrl = npmHttpUtils_exports2.getIdentUrl(descriptor);
          let result;
          try {
            result = clean(await npmHttpUtils_exports2.get(identUrl, {
              configuration,
              ident: descriptor,
              jsonResponse: true
            }));
          } catch (err) {
            if (err.name !== `HTTPError`) {
              throw err;
            } else if (err.response.statusCode === 404) {
              throw new ReportError(MessageName.EXCEPTION, `Package not found`);
            } else {
              throw new ReportError(MessageName.EXCEPTION, err.toString());
            }
          }
          const versions = Object.keys(result.versions).sort(import_semver25.default.compareLoose);
          const fallbackVersion = result[`dist-tags`].latest || versions[versions.length - 1];
          let version = fallbackVersion;
          if (import_semver25.default.validRange(descriptor.range)) {
            const maxSatisfyingVersion = import_semver25.default.maxSatisfying(versions, descriptor.range);
            if (maxSatisfyingVersion !== null) {
              version = maxSatisfyingVersion;
            } else {
              report2.reportWarning(MessageName.UNNAMED, `Unmet range ${structUtils_exports.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
              leadWithSeparator = true;
            }
          } else if (descriptor.range !== `unknown`) {
            report2.reportWarning(MessageName.UNNAMED, `Invalid range ${structUtils_exports.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
            leadWithSeparator = true;
          }
          const release = result.versions[version];
          const packageInformation = {
            ...result,
            ...release,
            version,
            versions
          };
          let serialized;
          if (fields !== null) {
            serialized = {};
            for (const field of fields) {
              const value = packageInformation[field];
              if (typeof value !== `undefined`) {
                serialized[field] = value;
              } else {
                report2.reportWarning(MessageName.EXCEPTION, `The '${field}' field doesn't exist inside ${structUtils_exports.prettyIdent(configuration, descriptor)}'s informations`);
                leadWithSeparator = true;
                continue;
              }
            }
          } else {
            if (!this.json) {
              delete packageInformation.dist;
              delete packageInformation.readme;
              delete packageInformation.users;
            }
            serialized = packageInformation;
          }
          report2.reportJson(serialized);
          if (!this.json) {
            infos.push(serialized);
          }
        }
      });
      import_util15.inspect.styles.name = `cyan`;
      for (const serialized of infos) {
        if (serialized !== infos[0] || leadWithSeparator)
          this.context.stdout.write(`
`);
        this.context.stdout.write(`${import_util15.inspect(serialized, {
          depth: Infinity,
          colors: true,
          compact: false
        })}
`);
      }
      return report.exitCode();
    }
  };
  InfoCommand3.paths = [
    [`npm`, `info`]
  ];
  InfoCommand3.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `show information about a package`,
    details: `
      This command will fetch information about a package from the npm registry, and prints it in a tree format.

      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).

      Append \`@<range>\` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.

      If the \`-f,--fields\` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.

      By default, this command won't return the \`dist\`, \`readme\`, and \`users\` fields, since they are often very long. To explicitly request those fields, explicitly list them with the \`--fields\` flag or request the output in JSON mode.
    `,
    examples: [[
      `Show all available information about react (except the \`dist\`, \`readme\`, and \`users\` fields)`,
      `yarn npm info react`
    ], [
      `Show all available information about react as valid JSON (including the \`dist\`, \`readme\`, and \`users\` fields)`,
      `yarn npm info react --json`
    ], [
      `Show all available information about react 16.12.0`,
      `yarn npm info react@16.12.0`
    ], [
      `Show the description of react`,
      `yarn npm info react --fields description`
    ], [
      `Show all available versions of react`,
      `yarn npm info react --fields versions`
    ], [
      `Show the readme of react`,
      `yarn npm info react --fields readme`
    ], [
      `Show a few fields of react`,
      `yarn npm info react --fields homepage,repository`
    ]]
  });
  var info_default3 = InfoCommand3;
  function clean(value) {
    if (Array.isArray(value)) {
      const result = [];
      for (let item of value) {
        item = clean(item);
        if (item) {
          result.push(item);
        }
      }
      return result;
    } else if (typeof value === `object` && value !== null) {
      const result = {};
      for (const key of Object.keys(value)) {
        if (key.startsWith(`_`))
          continue;
        const item = clean(value[key]);
        if (item) {
          result[key] = item;
        }
      }
      return result;
    } else if (value) {
      return value;
    } else {
      return null;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\login.ts
  var import_enquirer7 = __toModule(require_enquirer());
  var NpmLoginCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Login to the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Login to the publish registry`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const registry = await getRegistry({
        configuration,
        cwd: this.context.cwd,
        publish: this.publish,
        scope: this.scope
      });
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const credentials = await getCredentials({
          registry,
          report: report2,
          stdin: this.context.stdin,
          stdout: this.context.stdout
        });
        const url = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
        const response = await npmHttpUtils_exports2.put(url, credentials, {
          attemptedAs: credentials.name,
          configuration,
          registry,
          jsonResponse: true,
          authType: npmHttpUtils_exports2.AuthType.NO_AUTH
        });
        await setAuthToken(registry, response.token, {configuration, scope: this.scope});
        return report2.reportInfo(MessageName.UNNAMED, `Successfully logged in`);
      });
      return report.exitCode();
    }
  };
  NpmLoginCommand.paths = [
    [`npm`, `login`]
  ];
  NpmLoginCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `store new login info to access the npm registry`,
    details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
    examples: [[
      `Login to the default registry`,
      `yarn npm login`
    ], [
      `Login to the registry linked to the @my-scope registry`,
      `yarn npm login --scope my-scope`
    ], [
      `Login to the publish registry for the current package`,
      `yarn npm login --publish`
    ]]
  });
  var login_default = NpmLoginCommand;
  async function getRegistry({scope, publish, configuration, cwd}) {
    if (scope && publish)
      return npmConfigUtils_exports2.getScopeRegistry(scope, {configuration, type: npmConfigUtils_exports2.RegistryType.PUBLISH_REGISTRY});
    if (scope)
      return npmConfigUtils_exports2.getScopeRegistry(scope, {configuration});
    if (publish)
      return npmConfigUtils_exports2.getPublishRegistry((await openWorkspace2(configuration, cwd)).manifest, {configuration});
    return npmConfigUtils_exports2.getDefaultRegistry({configuration});
  }
  async function setAuthToken(registry, npmAuthToken, {configuration, scope}) {
    const makeUpdater = (entryName) => (unknownStore) => {
      const store = miscUtils10.isIndexableObject(unknownStore) ? unknownStore : {};
      const entryUnknown = store[entryName];
      const entry = miscUtils10.isIndexableObject(entryUnknown) ? entryUnknown : {};
      return {
        ...store,
        [entryName]: {
          ...entry,
          npmAuthToken
        }
      };
    };
    const update = scope ? {npmScopes: makeUpdater(scope)} : {npmRegistries: makeUpdater(registry)};
    return await Configuration.updateHomeConfiguration(update);
  }
  async function getCredentials({registry, report, stdin, stdout}) {
    if (process.env.TEST_ENV) {
      return {
        name: process.env.TEST_NPM_USER || ``,
        password: process.env.TEST_NPM_PASSWORD || ``
      };
    }
    report.reportInfo(MessageName.UNNAMED, `Logging in to ${registry}`);
    let isToken = false;
    if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
      report.reportInfo(MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
      isToken = true;
    }
    report.reportSeparator();
    const {username, password} = await import_enquirer7.prompt([{
      type: `input`,
      name: `username`,
      message: `Username:`,
      required: true,
      onCancel: () => process.exit(130),
      stdin,
      stdout
    }, {
      type: `password`,
      name: `password`,
      message: isToken ? `Token:` : `Password:`,
      required: true,
      onCancel: () => process.exit(130),
      stdin,
      stdout
    }]);
    report.reportSeparator();
    return {
      name: username,
      password
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\logout.ts
  var LOGOUT_KEYS = new Set([
    `npmAuthIdent`,
    `npmAuthToken`
  ]);
  var NpmLogoutCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Logout of the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Logout of the publish registry`
      });
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Logout of all registries`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const checkLogout = async () => {
        var _a2;
        const registry = await getRegistry({
          configuration,
          cwd: this.context.cwd,
          publish: this.publish,
          scope: this.scope
        });
        const refreshedConfiguration = await Configuration.find(this.context.cwd, this.context.plugins);
        const fakeIdent = structUtils_exports.makeIdent((_a2 = this.scope) != null ? _a2 : null, `pkg`);
        const authConfiguration = npmConfigUtils_exports2.getAuthConfiguration(registry, {
          configuration: refreshedConfiguration,
          ident: fakeIdent
        });
        return !authConfiguration.get(`npmAuthToken`);
      };
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        if (this.all) {
          await logoutFromEverything();
          report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from everything`);
        }
        if (this.scope) {
          await logoutFrom(`npmScopes`, this.scope);
          if (await checkLogout())
            report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from ${this.scope}`);
          else
            report2.reportWarning(MessageName.UNNAMED, `Scope authentication settings removed, but some other ones settings still apply to it`);
          return;
        }
        const registry = await getRegistry({
          configuration,
          cwd: this.context.cwd,
          publish: this.publish
        });
        await logoutFrom(`npmRegistries`, registry);
        if (await checkLogout()) {
          report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from ${registry}`);
        } else {
          report2.reportWarning(MessageName.UNNAMED, `Registry authentication settings removed, but some other ones settings still apply to it`);
        }
      });
      return report.exitCode();
    }
  };
  NpmLogoutCommand.paths = [
    [`npm`, `logout`]
  ];
  NpmLogoutCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `logout of the npm registry`,
    details: `
      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.

      Adding the \`-s,--scope\` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the deletion to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).

      Adding the \`-A,--all\` flag will cause the deletion to be done against all registries and scopes.
    `,
    examples: [[
      `Logout of the default registry`,
      `yarn npm logout`
    ], [
      `Logout of the @my-scope scope`,
      `yarn npm logout --scope my-scope`
    ], [
      `Logout of the publish registry for the current package`,
      `yarn npm logout --publish`
    ], [
      `Logout of all registries`,
      `yarn npm logout --all`
    ]]
  });
  var logout_default = NpmLogoutCommand;
  function removeTokenFromStore(nextStore, entryName) {
    const entry = nextStore[entryName];
    if (!miscUtils10.isIndexableObject(entry))
      return false;
    const keys = new Set(Object.keys(entry));
    if ([...LOGOUT_KEYS].every((key) => !keys.has(key)))
      return false;
    for (const key of LOGOUT_KEYS)
      keys.delete(key);
    if (keys.size === 0) {
      nextStore[entryName] = void 0;
      return true;
    }
    const nextEntry = {...entry};
    for (const key of LOGOUT_KEYS)
      delete nextEntry[key];
    nextStore[entryName] = nextEntry;
    return true;
  }
  async function logoutFromEverything() {
    const updater = (unknownStore) => {
      let updated = false;
      const nextStore = miscUtils10.isIndexableObject(unknownStore) ? {...unknownStore} : {};
      if (nextStore.npmAuthToken) {
        delete nextStore.npmAuthToken;
        updated = true;
      }
      for (const entryName of Object.keys(nextStore))
        if (removeTokenFromStore(nextStore, entryName))
          updated = true;
      if (Object.keys(nextStore).length === 0)
        return void 0;
      if (updated) {
        return nextStore;
      } else {
        return unknownStore;
      }
    };
    return await Configuration.updateHomeConfiguration({
      npmRegistries: updater,
      npmScopes: updater
    });
  }
  async function logoutFrom(entryType, entryName) {
    return await Configuration.updateHomeConfiguration({
      [entryType]: (unknownStore) => {
        const nextStore = miscUtils10.isIndexableObject(unknownStore) ? unknownStore : {};
        if (!Object.prototype.hasOwnProperty.call(nextStore, entryName))
          return unknownStore;
        const unknownEntry = nextStore[entryName];
        const nextEntry = miscUtils10.isIndexableObject(unknownEntry) ? unknownEntry : {};
        const keys = new Set(Object.keys(nextEntry));
        if ([...LOGOUT_KEYS].every((key) => !keys.has(key)))
          return unknownStore;
        for (const key of LOGOUT_KEYS)
          keys.delete(key);
        if (keys.size === 0) {
          if (Object.keys(nextStore).length === 1)
            return void 0;
          return {
            ...nextStore,
            [entryName]: void 0
          };
        }
        const eraser = {};
        for (const key of LOGOUT_KEYS)
          eraser[key] = void 0;
        return {
          ...nextStore,
          [entryName]: {
            ...nextEntry,
            ...eraser
          }
        };
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\publish.ts
  var NpmPublishCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.access = options_exports.String(`--access`, {
        description: `The access for the published package (public or restricted)`
      });
      this.tag = options_exports.String(`--tag`, `latest`, {
        description: `The tag on the registry that the package should be attached to`
      });
      this.tolerateRepublish = options_exports.Boolean(`--tolerate-republish`, false, {
        description: `Warn and exit when republishing an already existing version of a package`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      if (workspace.manifest.private)
        throw new UsageError(`Private workspaces cannot be published`);
      if (workspace.manifest.name === null || workspace.manifest.version === null)
        throw new UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
      await project.restoreInstallState();
      const ident = workspace.manifest.name;
      const version = workspace.manifest.version;
      const registry = npmConfigUtils_exports2.getPublishRegistry(workspace.manifest, {configuration});
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        if (this.tolerateRepublish) {
          try {
            const registryData = await npmHttpUtils_exports2.get(npmHttpUtils_exports2.getIdentUrl(ident), {
              configuration,
              registry,
              ident,
              jsonResponse: true
            });
            if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
              throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
            if (Object.prototype.hasOwnProperty.call(registryData.versions, version)) {
              report2.reportWarning(MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
              return;
            }
          } catch (error) {
            if (error.name !== `HTTPError`) {
              throw error;
            } else if (error.response.statusCode !== 404) {
              throw new ReportError(MessageName.NETWORK_ERROR, `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`);
            }
          }
        }
        await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `prepublish`, {report: report2});
        await packUtils_exports.prepareForPack(workspace, {report: report2}, async () => {
          const files = await packUtils_exports.genPackList(workspace);
          for (const file of files)
            report2.reportInfo(null, file);
          const pack = await packUtils_exports.genPackStream(workspace, files);
          const buffer = await miscUtils10.bufferStream(pack);
          const body = await npmPublishUtils_exports.makePublishBody(workspace, buffer, {
            access: this.access,
            tag: this.tag,
            registry
          });
          try {
            await npmHttpUtils_exports2.put(npmHttpUtils_exports2.getIdentUrl(ident), body, {
              configuration,
              registry,
              ident,
              jsonResponse: true
            });
          } catch (error) {
            if (error.name !== `HTTPError`) {
              throw error;
            } else {
              const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
              report2.reportError(MessageName.NETWORK_ERROR, message);
            }
          }
        });
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Package archive published`);
        }
      });
      return report.exitCode();
    }
  };
  NpmPublishCommand.paths = [
    [`npm`, `publish`]
  ];
  NpmPublishCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `publish the active workspace to the npm registry`,
    details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
    examples: [[
      `Publish the active workspace`,
      `yarn npm publish`
    ]]
  });
  var publish_default = NpmPublishCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\tag\add.ts
  var import_semver26 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\tag\list.ts
  var NpmTagListCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.package = options_exports.String({required: false});
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      let ident;
      if (typeof this.package !== `undefined`) {
        ident = structUtils_exports.parseIdent(this.package);
      } else {
        if (!workspace)
          throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
        if (!workspace.manifest.name)
          throw new UsageError(`Missing 'name' field in ${ppath.join(workspace.cwd, Filename.manifest)}`);
        ident = workspace.manifest.name;
      }
      const distTags = await getDistTags(ident, configuration);
      const distTagEntries = miscUtils10.sortMap(Object.entries(distTags), ([tag]) => tag);
      const tree = {
        children: distTagEntries.map(([tag, version]) => ({
          value: formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
            descriptor: structUtils_exports.makeDescriptor(ident, tag),
            locator: structUtils_exports.makeLocator(ident, version)
          })
        }))
      };
      return treeUtils_exports.emitTree(tree, {
        configuration,
        json: this.json,
        stdout: this.context.stdout
      });
    }
  };
  NpmTagListCommand.paths = [
    [`npm`, `tag`, `list`]
  ];
  NpmTagListCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `list all dist-tags of a package`,
    details: `
      This command will list all tags of a package from the npm registry.

      If the package is not specified, Yarn will default to the current workspace.
    `,
    examples: [[
      `List all tags of package \`my-pkg\``,
      `yarn npm tag list my-pkg`
    ]]
  });
  var list_default5 = NpmTagListCommand;
  async function getDistTags(ident, configuration) {
    const url = `/-/package${npmHttpUtils_exports2.getIdentUrl(ident)}/dist-tags`;
    return npmHttpUtils_exports2.get(url, {
      configuration,
      ident,
      jsonResponse: true
    }).catch((err) => {
      if (err.name !== `HTTPError`) {
        throw err;
      } else if (err.response.statusCode === 404) {
        throw new ReportError(MessageName.EXCEPTION, `Package not found`);
      } else {
        throw new ReportError(MessageName.EXCEPTION, err.toString());
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\tag\add.ts
  var NpmTagAddCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
      this.tag = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const descriptor = structUtils_exports.parseDescriptor(this.package, true);
      const version = descriptor.range;
      if (!import_semver26.default.valid(version))
        throw new UsageError(`The range ${formatUtils_exports.pretty(configuration, descriptor.range, formatUtils_exports.Type.RANGE)} must be a valid semver version`);
      const registry = npmConfigUtils_exports2.getPublishRegistry(workspace.manifest, {configuration});
      const prettyIdent2 = formatUtils_exports.pretty(configuration, descriptor, formatUtils_exports.Type.IDENT);
      const prettyVersion = formatUtils_exports.pretty(configuration, version, formatUtils_exports.Type.RANGE);
      const prettyTag = formatUtils_exports.pretty(configuration, this.tag, formatUtils_exports.Type.CODE);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const distTags = await getDistTags(descriptor, configuration);
        if (Object.prototype.hasOwnProperty.call(distTags, this.tag) && distTags[this.tag] === version)
          report2.reportWarning(MessageName.UNNAMED, `Tag ${prettyTag} is already set to version ${prettyVersion}`);
        try {
          const url = `/-/package${npmHttpUtils_exports2.getIdentUrl(descriptor)}/dist-tags/${encodeURIComponent(this.tag)}`;
          await npmHttpUtils_exports2.put(url, version, {
            configuration,
            registry,
            ident: descriptor,
            jsonRequest: true,
            jsonResponse: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report2.reportError(MessageName.NETWORK_ERROR, message);
          }
        }
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Tag ${prettyTag} added to version ${prettyVersion} of package ${prettyIdent2}`);
        }
      });
      return report.exitCode();
    }
  };
  NpmTagAddCommand.paths = [
    [`npm`, `tag`, `add`]
  ];
  NpmTagAddCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `add a tag for a specific version of a package`,
    details: `
      This command will add a tag to the npm registry for a specific version of a package. If the tag already exists, it will be overwritten.
    `,
    examples: [[
      `Add a \`beta\` tag for version \`2.3.4-beta.4\` of package \`my-pkg\``,
      `yarn npm tag add my-pkg@2.3.4-beta.4 beta`
    ]]
  });
  var add_default3 = NpmTagAddCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\tag\remove.ts
  var NpmTagRemoveCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
      this.tag = options_exports.String();
    }
    async execute() {
      if (this.tag === `latest`)
        throw new UsageError(`The 'latest' tag cannot be removed.`);
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      const ident = structUtils_exports.parseIdent(this.package);
      const registry = npmConfigUtils_exports2.getPublishRegistry(workspace.manifest, {configuration});
      const prettyTag = formatUtils_exports.pretty(configuration, this.tag, formatUtils_exports.Type.CODE);
      const prettyIdent2 = formatUtils_exports.pretty(configuration, ident, formatUtils_exports.Type.IDENT);
      const distTags = await getDistTags(ident, configuration);
      if (!Object.prototype.hasOwnProperty.call(distTags, this.tag))
        throw new UsageError(`${prettyTag} is not a tag of package ${prettyIdent2}`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        try {
          const url = `/-/package${npmHttpUtils_exports2.getIdentUrl(ident)}/dist-tags/${encodeURIComponent(this.tag)}`;
          await npmHttpUtils_exports2.del(url, {
            configuration,
            registry,
            ident,
            jsonResponse: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report2.reportError(MessageName.NETWORK_ERROR, message);
          }
        }
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Tag ${prettyTag} removed from package ${prettyIdent2}`);
        }
      });
      return report.exitCode();
    }
  };
  NpmTagRemoveCommand.paths = [
    [`npm`, `tag`, `remove`]
  ];
  NpmTagRemoveCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `remove a tag from a package`,
    details: `
      This command will remove a tag from a package from the npm registry.
    `,
    examples: [[
      `Remove the \`beta\` tag from package \`my-pkg\``,
      `yarn npm tag remove my-pkg beta`
    ]]
  });
  var remove_default5 = NpmTagRemoveCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\commands\npm\whoami.ts
  var NpmWhoamiCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Print username for the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Print username for the publish registry`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      let registry;
      if (this.scope && this.publish)
        registry = npmConfigUtils_exports2.getScopeRegistry(this.scope, {configuration, type: npmConfigUtils_exports2.RegistryType.PUBLISH_REGISTRY});
      else if (this.scope)
        registry = npmConfigUtils_exports2.getScopeRegistry(this.scope, {configuration});
      else if (this.publish)
        registry = npmConfigUtils_exports2.getPublishRegistry((await openWorkspace2(configuration, this.context.cwd)).manifest, {configuration});
      else
        registry = npmConfigUtils_exports2.getDefaultRegistry({configuration});
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        try {
          const response = await npmHttpUtils_exports2.get(`/-/whoami`, {
            configuration,
            registry,
            authType: npmHttpUtils_exports2.AuthType.ALWAYS_AUTH,
            jsonResponse: true,
            ident: this.scope ? structUtils_exports.makeIdent(this.scope, ``) : void 0
          });
          report2.reportInfo(MessageName.UNNAMED, response.username);
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else if (err.response.statusCode === 401 || err.response.statusCode === 403) {
            report2.reportError(MessageName.AUTHENTICATION_INVALID, `Authentication failed - your credentials may have expired`);
          } else {
            report2.reportError(MessageName.AUTHENTICATION_INVALID, err.toString());
          }
        }
      });
      return report.exitCode();
    }
  };
  NpmWhoamiCommand.paths = [
    [`npm`, `whoami`]
  ];
  NpmWhoamiCommand.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `display the name of the authenticated user`,
    details: `
      Print the username associated with the current authentication settings to the standard output.

      When using \`-s,--scope\`, the username printed will be the one that matches the authentication settings of the registry associated with the given scope (those settings can be overriden using the \`npmRegistries\` map, and the registry associated with the scope is configured via the \`npmScopes\` map).

      When using \`--publish\`, the registry we'll select will by default be the one used when publishing packages (\`publishConfig.registry\` or \`npmPublishRegistry\` if available, otherwise we'll fallback to the regular \`npmRegistryServer\`).
    `,
    examples: [[
      `Print username for the default registry`,
      `yarn npm whoami`
    ], [
      `Print username for the registry on a given scope`,
      `yarn npm whoami --scope company`
    ]]
  });
  var whoami_default = NpmWhoamiCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-408798360e\1\packages\plugin-npm-cli\sources\index.ts
  var plugin17 = {
    configuration: {
      npmPublishAccess: {
        description: `Default access of the published packages`,
        type: SettingsType.STRING,
        default: null
      }
    },
    commands: [
      audit_default,
      info_default3,
      login_default,
      logout_default,
      publish_default,
      add_default3,
      list_default5,
      remove_default5,
      whoami_default
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\tools\UnmatchedHunkError.ts
  var UnmatchedHunkError = class extends Error {
    constructor(index, hunk) {
      super(`Cannot apply hunk #${index + 1}`);
      this.hunk = hunk;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\tools\parse.ts
  var HEADER_REGEXP = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/;
  function getPath5(p) {
    return ppath.relative(PortablePath2.root, ppath.resolve(PortablePath2.root, npath.toPortablePath(p)));
  }
  function parseHunkHeaderLine(headerLine) {
    const match2 = headerLine.trim().match(HEADER_REGEXP);
    if (!match2)
      throw new Error(`Bad header line: '${headerLine}'`);
    return {
      original: {
        start: Math.max(Number(match2[1]), 1),
        length: Number(match2[3] || 1)
      },
      patched: {
        start: Math.max(Number(match2[4]), 1),
        length: Number(match2[6] || 1)
      }
    };
  }
  var NON_EXECUTABLE_FILE_MODE = 420;
  var EXECUTABLE_FILE_MODE = 493;
  var PatchMutationType;
  (function(PatchMutationType3) {
    PatchMutationType3["Context"] = `context`;
    PatchMutationType3["Insertion"] = `insertion`;
    PatchMutationType3["Deletion"] = `deletion`;
  })(PatchMutationType || (PatchMutationType = {}));
  var emptyFilePatch = () => ({
    semverExclusivity: null,
    diffLineFromPath: null,
    diffLineToPath: null,
    oldMode: null,
    newMode: null,
    deletedFileMode: null,
    newFileMode: null,
    renameFrom: null,
    renameTo: null,
    beforeHash: null,
    afterHash: null,
    fromPath: null,
    toPath: null,
    hunks: null
  });
  var emptyHunk = (headerLine) => ({
    header: parseHunkHeaderLine(headerLine),
    parts: []
  });
  var hunkLinetypes = {
    [`@`]: `header`,
    [`-`]: PatchMutationType.Deletion,
    [`+`]: PatchMutationType.Insertion,
    [` `]: PatchMutationType.Context,
    [`\\`]: `pragma`,
    undefined: PatchMutationType.Context
  };
  function parsePatchLines(lines) {
    const result = [];
    let currentFilePatch = emptyFilePatch();
    let state = `parsing header`;
    let currentHunk = null;
    let currentHunkMutationPart = null;
    function commitHunk() {
      if (currentHunk) {
        if (currentHunkMutationPart) {
          currentHunk.parts.push(currentHunkMutationPart);
          currentHunkMutationPart = null;
        }
        currentFilePatch.hunks.push(currentHunk);
        currentHunk = null;
      }
    }
    function commitFilePatch() {
      commitHunk();
      result.push(currentFilePatch);
      currentFilePatch = emptyFilePatch();
    }
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (state === `parsing header`) {
        if (line.startsWith(`@@`)) {
          state = `parsing hunks`;
          currentFilePatch.hunks = [];
          i -= 1;
        } else if (line.startsWith(`diff --git `)) {
          if (currentFilePatch && currentFilePatch.diffLineFromPath)
            commitFilePatch();
          const match2 = line.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);
          if (!match2)
            throw new Error(`Bad diff line: ${line}`);
          currentFilePatch.diffLineFromPath = match2[1];
          currentFilePatch.diffLineToPath = match2[2];
        } else if (line.startsWith(`old mode `)) {
          currentFilePatch.oldMode = line.slice(`old mode `.length).trim();
        } else if (line.startsWith(`new mode `)) {
          currentFilePatch.newMode = line.slice(`new mode `.length).trim();
        } else if (line.startsWith(`deleted file mode `)) {
          currentFilePatch.deletedFileMode = line.slice(`deleted file mode `.length).trim();
        } else if (line.startsWith(`new file mode `)) {
          currentFilePatch.newFileMode = line.slice(`new file mode `.length).trim();
        } else if (line.startsWith(`rename from `)) {
          currentFilePatch.renameFrom = line.slice(`rename from `.length).trim();
        } else if (line.startsWith(`rename to `)) {
          currentFilePatch.renameTo = line.slice(`rename to `.length).trim();
        } else if (line.startsWith(`index `)) {
          const match2 = line.match(/(\w+)\.\.(\w+)/);
          if (!match2)
            continue;
          currentFilePatch.beforeHash = match2[1];
          currentFilePatch.afterHash = match2[2];
        } else if (line.startsWith(`semver exclusivity `)) {
          currentFilePatch.semverExclusivity = line.slice(`semver exclusivity `.length).trim();
        } else if (line.startsWith(`--- `)) {
          currentFilePatch.fromPath = line.slice(`--- a/`.length).trim();
        } else if (line.startsWith(`+++ `)) {
          currentFilePatch.toPath = line.slice(`+++ b/`.length).trim();
        }
      } else {
        const lineType = hunkLinetypes[line[0]] || null;
        switch (lineType) {
          case `header`:
            {
              commitHunk();
              currentHunk = emptyHunk(line);
            }
            break;
          case null:
            {
              state = `parsing header`;
              commitFilePatch();
              i -= 1;
            }
            break;
          case `pragma`:
            {
              if (!line.startsWith(`\\ No newline at end of file`))
                throw new Error(`Unrecognized pragma in patch file: ${line}`);
              if (!currentHunkMutationPart)
                throw new Error(`Bad parser state: No newline at EOF pragma encountered without context`);
              currentHunkMutationPart.noNewlineAtEndOfFile = true;
            }
            break;
          case PatchMutationType.Context:
          case PatchMutationType.Deletion:
          case PatchMutationType.Insertion:
            {
              if (!currentHunk)
                throw new Error(`Bad parser state: Hunk lines encountered before hunk header`);
              if (currentHunkMutationPart && currentHunkMutationPart.type !== lineType) {
                currentHunk.parts.push(currentHunkMutationPart);
                currentHunkMutationPart = null;
              }
              if (!currentHunkMutationPart) {
                currentHunkMutationPart = {
                  type: lineType,
                  lines: [],
                  noNewlineAtEndOfFile: false
                };
              }
              currentHunkMutationPart.lines.push(line.slice(1));
            }
            break;
          default:
            {
              miscUtils10.assertNever(lineType);
            }
            break;
        }
      }
    }
    commitFilePatch();
    for (const {hunks} of result)
      if (hunks)
        for (const hunk of hunks)
          verifyHunkIntegrity(hunk);
    return result;
  }
  function interpretParsedPatchFile(files) {
    const result = [];
    for (const file of files) {
      const {
        semverExclusivity,
        diffLineFromPath,
        diffLineToPath,
        oldMode,
        newMode,
        deletedFileMode,
        newFileMode,
        renameFrom,
        renameTo,
        beforeHash,
        afterHash,
        fromPath,
        toPath,
        hunks
      } = file;
      const type = renameFrom ? `rename` : deletedFileMode ? `file deletion` : newFileMode ? `file creation` : hunks && hunks.length > 0 ? `patch` : `mode change`;
      let destinationFilePath = null;
      switch (type) {
        case `rename`:
          {
            if (!renameFrom || !renameTo)
              throw new Error(`Bad parser state: rename from & to not given`);
            result.push({
              type: `rename`,
              semverExclusivity,
              fromPath: getPath5(renameFrom),
              toPath: getPath5(renameTo)
            });
            destinationFilePath = renameTo;
          }
          break;
        case `file deletion`:
          {
            const path6 = diffLineFromPath || fromPath;
            if (!path6)
              throw new Error(`Bad parse state: no path given for file deletion`);
            result.push({
              type: `file deletion`,
              semverExclusivity,
              hunk: hunks && hunks[0] || null,
              path: getPath5(path6),
              mode: parseFileMode(deletedFileMode),
              hash: beforeHash
            });
          }
          break;
        case `file creation`:
          {
            const path6 = diffLineToPath || toPath;
            if (!path6)
              throw new Error(`Bad parse state: no path given for file creation`);
            result.push({
              type: `file creation`,
              semverExclusivity,
              hunk: hunks && hunks[0] || null,
              path: getPath5(path6),
              mode: parseFileMode(newFileMode),
              hash: afterHash
            });
          }
          break;
        case `patch`:
        case `mode change`:
          {
            destinationFilePath = toPath || diffLineToPath;
          }
          break;
        default:
          {
            miscUtils10.assertNever(type);
          }
          break;
      }
      if (destinationFilePath && oldMode && newMode && oldMode !== newMode) {
        result.push({
          type: `mode change`,
          semverExclusivity,
          path: getPath5(destinationFilePath),
          oldMode: parseFileMode(oldMode),
          newMode: parseFileMode(newMode)
        });
      }
      if (destinationFilePath && hunks && hunks.length) {
        result.push({
          type: `patch`,
          semverExclusivity,
          path: getPath5(destinationFilePath),
          hunks,
          beforeHash,
          afterHash
        });
      }
    }
    return result;
  }
  function parseFileMode(mode) {
    const parsedMode = parseInt(mode, 8) & 511;
    if (parsedMode !== NON_EXECUTABLE_FILE_MODE && parsedMode !== EXECUTABLE_FILE_MODE)
      throw new Error(`Unexpected file mode string: ${mode}`);
    return parsedMode;
  }
  function parsePatchFile(file) {
    const lines = file.split(/\n/g);
    if (lines[lines.length - 1] === ``)
      lines.pop();
    return interpretParsedPatchFile(parsePatchLines(lines));
  }
  function verifyHunkIntegrity(hunk) {
    let originalLength = 0;
    let patchedLength = 0;
    for (const {type, lines} of hunk.parts) {
      switch (type) {
        case PatchMutationType.Context:
          {
            patchedLength += lines.length;
            originalLength += lines.length;
          }
          break;
        case PatchMutationType.Deletion:
          {
            originalLength += lines.length;
          }
          break;
        case PatchMutationType.Insertion:
          {
            patchedLength += lines.length;
          }
          break;
        default:
          {
            miscUtils10.assertNever(type);
          }
          break;
      }
    }
    if (originalLength !== hunk.header.original.length || patchedLength !== hunk.header.patched.length) {
      const format = (n) => n < 0 ? n : `+${n}`;
      throw new Error(`hunk header integrity check failed (expected @@ ${format(hunk.header.original.length)} ${format(hunk.header.patched.length)} @@, got @@ ${format(originalLength)} ${format(patchedLength)} @@)`);
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\tools\apply.ts
  var DEFAULT_TIME = 315532800;
  async function preserveTime(baseFs, p, cb) {
    const stat = await baseFs.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    if (baseFs.lutimesPromise) {
      await baseFs.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await baseFs.utimesPromise(p, stat.atime, stat.mtime);
    } else {
      throw new Error(`Cannot preserve the time values of a symlink`);
    }
  }
  async function applyPatchFile(effects, {baseFs = new NodeFS(), dryRun = false, version = null} = {}) {
    for (const eff of effects) {
      if (eff.semverExclusivity !== null && version !== null) {
        if (!semverUtils_exports.satisfiesWithPrereleases(version, eff.semverExclusivity))
          continue;
      }
      switch (eff.type) {
        case `file deletion`:
          {
            if (dryRun) {
              if (!baseFs.existsSync(eff.path)) {
                throw new Error(`Trying to delete a file that doesn't exist: ${eff.path}`);
              }
            } else {
              await preserveTime(baseFs, ppath.dirname(eff.path), async () => {
                await baseFs.unlinkPromise(eff.path);
              });
            }
          }
          break;
        case `rename`:
          {
            if (dryRun) {
              if (!baseFs.existsSync(eff.fromPath)) {
                throw new Error(`Trying to move a file that doesn't exist: ${eff.fromPath}`);
              }
            } else {
              await preserveTime(baseFs, ppath.dirname(eff.fromPath), async () => {
                await preserveTime(baseFs, ppath.dirname(eff.toPath), async () => {
                  await preserveTime(baseFs, eff.fromPath, async () => {
                    await baseFs.movePromise(eff.fromPath, eff.toPath);
                    return eff.toPath;
                  });
                });
              });
            }
          }
          break;
        case `file creation`:
          {
            if (dryRun) {
              if (baseFs.existsSync(eff.path)) {
                throw new Error(`Trying to create a file that already exists: ${eff.path}`);
              }
            } else {
              const fileContents = eff.hunk ? eff.hunk.parts[0].lines.join(`
`) + (eff.hunk.parts[0].noNewlineAtEndOfFile ? `` : `
`) : ``;
              await baseFs.mkdirpPromise(ppath.dirname(eff.path), {chmod: 493, utimes: [DEFAULT_TIME, DEFAULT_TIME]});
              await baseFs.writeFilePromise(eff.path, fileContents, {mode: eff.mode});
              await baseFs.utimesPromise(eff.path, DEFAULT_TIME, DEFAULT_TIME);
            }
          }
          break;
        case `patch`:
          {
            await preserveTime(baseFs, eff.path, async () => {
              await applyPatch(eff, {baseFs, dryRun});
            });
          }
          break;
        case `mode change`:
          {
            const currentStat = await baseFs.statPromise(eff.path);
            const currentMode = currentStat.mode;
            if (isExecutable(eff.newMode) !== isExecutable(currentMode))
              continue;
            await preserveTime(baseFs, eff.path, async () => {
              await baseFs.chmodPromise(eff.path, eff.newMode);
            });
          }
          break;
        default:
          {
            miscUtils10.assertNever(eff);
          }
          break;
      }
    }
  }
  function isExecutable(fileMode) {
    return (fileMode & 64) > 0;
  }
  function trimRight(s) {
    return s.replace(/\s+$/, ``);
  }
  function linesAreEqual(a, b) {
    return trimRight(a) === trimRight(b);
  }
  async function applyPatch({hunks, path: path6}, {baseFs, dryRun = false}) {
    const mode = await baseFs.statSync(path6).mode;
    const fileContents = await baseFs.readFileSync(path6, `utf8`);
    const fileLines = fileContents.split(/\n/);
    const result = [];
    let fixupOffset = 0;
    let maxFrozenLine = 0;
    for (const hunk of hunks) {
      const firstGuess = Math.max(maxFrozenLine, hunk.header.patched.start + fixupOffset);
      const maxPrefixFuzz = Math.max(0, firstGuess - maxFrozenLine);
      const maxSuffixFuzz = Math.max(0, fileLines.length - firstGuess - hunk.header.original.length);
      const maxFuzz = Math.max(maxPrefixFuzz, maxSuffixFuzz);
      let offset = 0;
      let location = 0;
      let modifications = null;
      while (offset <= maxFuzz) {
        if (offset <= maxPrefixFuzz) {
          location = firstGuess - offset;
          modifications = evaluateHunk(hunk, fileLines, location);
          if (modifications !== null) {
            offset = -offset;
            break;
          }
        }
        if (offset <= maxSuffixFuzz) {
          location = firstGuess + offset;
          modifications = evaluateHunk(hunk, fileLines, location);
          if (modifications !== null) {
            break;
          }
        }
        offset += 1;
      }
      if (modifications === null)
        throw new UnmatchedHunkError(hunks.indexOf(hunk), hunk);
      result.push(modifications);
      fixupOffset += offset;
      maxFrozenLine = location + hunk.header.original.length;
    }
    if (dryRun)
      return;
    let diffOffset = 0;
    for (const modifications of result) {
      for (const modification of modifications) {
        switch (modification.type) {
          case `splice`:
            {
              const firstLine = modification.index + diffOffset;
              fileLines.splice(firstLine, modification.numToDelete, ...modification.linesToInsert);
              diffOffset += modification.linesToInsert.length - modification.numToDelete;
            }
            break;
          case `pop`:
            {
              fileLines.pop();
            }
            break;
          case `push`:
            {
              fileLines.push(modification.line);
            }
            break;
          default:
            {
              miscUtils10.assertNever(modification);
            }
            break;
        }
      }
    }
    await baseFs.writeFilePromise(path6, fileLines.join(`
`), {mode});
  }
  function evaluateHunk(hunk, fileLines, offset) {
    const result = [];
    for (const part of hunk.parts) {
      switch (part.type) {
        case PatchMutationType.Context:
        case PatchMutationType.Deletion:
          {
            for (const line of part.lines) {
              const originalLine = fileLines[offset];
              if (originalLine == null || !linesAreEqual(originalLine, line))
                return null;
              offset += 1;
            }
            if (part.type === PatchMutationType.Deletion) {
              result.push({
                type: `splice`,
                index: offset - part.lines.length,
                numToDelete: part.lines.length,
                linesToInsert: []
              });
              if (part.noNewlineAtEndOfFile) {
                result.push({
                  type: `push`,
                  line: ``
                });
              }
            }
          }
          break;
        case PatchMutationType.Insertion:
          {
            result.push({
              type: `splice`,
              index: offset,
              numToDelete: 0,
              linesToInsert: part.lines
            });
            if (part.noNewlineAtEndOfFile) {
              result.push({type: `pop`});
            }
          }
          break;
        default:
          {
            miscUtils10.assertNever(part.type);
          }
          break;
      }
    }
    return result;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\patchUtils.ts
  var BUILTIN_REGEXP = /^builtin<([^>]+)>$/;
  function parseSpec2(spec, sourceParser) {
    const {source, selector, params} = structUtils_exports.parseRange(spec);
    if (source === null)
      throw new Error(`Patch locators must explicitly define their source`);
    const patchPaths = selector ? selector.split(/&/).map((path6) => npath.toPortablePath(path6)) : [];
    const parentLocator = params && typeof params.locator === `string` ? structUtils_exports.parseLocator(params.locator) : null;
    const sourceVersion = params && typeof params.version === `string` ? params.version : null;
    const sourceItem = sourceParser(source);
    return {parentLocator, sourceItem, patchPaths, sourceVersion};
  }
  function parseDescriptor2(descriptor) {
    const {sourceItem, ...rest} = parseSpec2(descriptor.range, structUtils_exports.parseDescriptor);
    return {...rest, sourceDescriptor: sourceItem};
  }
  function parseLocator2(locator) {
    const {sourceItem, ...rest} = parseSpec2(locator.reference, structUtils_exports.parseLocator);
    return {...rest, sourceLocator: sourceItem};
  }
  function makeSpec2({parentLocator, sourceItem, patchPaths, sourceVersion, patchHash}, sourceStringifier) {
    const parentLocatorSpread = parentLocator !== null ? {locator: structUtils_exports.stringifyLocator(parentLocator)} : {};
    const sourceVersionSpread = typeof sourceVersion !== `undefined` ? {version: sourceVersion} : {};
    const patchHashSpread = typeof patchHash !== `undefined` ? {hash: patchHash} : {};
    return structUtils_exports.makeRange({
      protocol: `patch:`,
      source: sourceStringifier(sourceItem),
      selector: patchPaths.join(`&`),
      params: {
        ...sourceVersionSpread,
        ...patchHashSpread,
        ...parentLocatorSpread
      }
    });
  }
  function makeLocator4(ident, {parentLocator, sourcePackage, patchPaths, patchHash}) {
    return structUtils_exports.makeLocator(ident, makeSpec2({parentLocator, sourceItem: sourcePackage, sourceVersion: sourcePackage.version, patchPaths, patchHash}, structUtils_exports.stringifyLocator));
  }
  function visitPatchPath({onAbsolute, onRelative, onBuiltin}, patchPath) {
    const builtinMatch = patchPath.match(BUILTIN_REGEXP);
    if (builtinMatch !== null)
      return onBuiltin(builtinMatch[1]);
    if (ppath.isAbsolute(patchPath)) {
      return onAbsolute(patchPath);
    } else {
      return onRelative(patchPath);
    }
  }
  function isParentRequired(patchPath) {
    return visitPatchPath({
      onAbsolute: () => false,
      onRelative: () => true,
      onBuiltin: () => false
    }, patchPath);
  }
  async function loadPatchFiles(parentLocator, patchPaths, opts) {
    const parentFetch = parentLocator !== null ? await opts.fetcher.fetch(parentLocator, opts) : null;
    const effectiveParentFetch = parentFetch && parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
    if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
      parentFetch.releaseFs();
    const patchFiles = await miscUtils10.releaseAfterUseAsync(async () => {
      return await Promise.all(patchPaths.map(async (patchPath) => visitPatchPath({
        onAbsolute: async () => {
          return await xfs.readFilePromise(patchPath, `utf8`);
        },
        onRelative: async () => {
          if (parentFetch === null)
            throw new Error(`Assertion failed: The parent locator should have been fetched`);
          return await parentFetch.packageFs.readFilePromise(patchPath, `utf8`);
        },
        onBuiltin: async (name) => {
          return await opts.project.configuration.firstHook((hooks) => {
            return hooks.getBuiltinPatch;
          }, opts.project, name);
        }
      }, patchPath)));
    });
    return patchFiles.map((definition) => {
      if (typeof definition === `string`) {
        return definition.replace(/\r\n?/g, `
`);
      } else {
        return definition;
      }
    });
  }
  async function extractPackageToDisk(locator, {cache: cache2, project}) {
    const checksums = project.storedChecksums;
    const report = new ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const fetchResult = await fetcher.fetch(locator, {cache: cache2, project, fetcher, checksums, report});
    const temp = await xfs.mktempPromise();
    await xfs.copyPromise(temp, fetchResult.prefixPath, {
      baseFs: fetchResult.packageFs
    });
    await xfs.writeJsonPromise(ppath.join(temp, `.yarn-patch.json`), {
      locator: structUtils_exports.stringifyLocator(locator)
    });
    xfs.detachTemp(temp);
    return temp;
  }
  async function diffFolders(folderA, folderB) {
    const folderAN = npath.fromPortablePath(folderA).replace(/\\/g, `/`);
    const folderBN = npath.fromPortablePath(folderB).replace(/\\/g, `/`);
    const {stdout, stderr} = await execUtils_exports.execvp(`git`, [`diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, folderAN, folderBN], {
      cwd: npath.toPortablePath(process.cwd())
    });
    if (stderr.length > 0)
      throw new Error(`Unable to diff directories. Make sure you have a recent version of 'git' available in PATH.
The following error was reported by 'git':
${stderr}`);
    const normalizePath = folderAN.startsWith(`/`) ? (p) => p.slice(1) : (p) => p;
    return stdout.replace(new RegExp(`(a|b)(${miscUtils10.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`).replace(new RegExp(`(a|b)${miscUtils10.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`).replace(new RegExp(miscUtils10.escapeRegExp(`${folderAN}/`), `g`), ``).replace(new RegExp(miscUtils10.escapeRegExp(`${folderBN}/`), `g`), ``);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\tools\format.ts
  function reportHunk(hunk, {configuration, report}) {
    for (const part of hunk.parts) {
      for (const line of part.lines) {
        switch (part.type) {
          case PatchMutationType.Context:
            {
              report.reportInfo(null, `  ${formatUtils_exports.pretty(configuration, line, `grey`)}`);
            }
            break;
          case PatchMutationType.Deletion:
            {
              report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `- ${formatUtils_exports.pretty(configuration, line, formatUtils_exports.Type.REMOVED)}`);
            }
            break;
          case PatchMutationType.Insertion:
            {
              report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `+ ${formatUtils_exports.pretty(configuration, line, formatUtils_exports.Type.ADDED)}`);
            }
            break;
          default: {
            miscUtils10.assertNever(part.type);
          }
        }
      }
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\PatchFetcher.ts
  var PatchFetcher = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(`patch:`))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
        loader: () => this.patchPackage(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        localPath: this.getLocalPath(locator, opts),
        checksum
      };
    }
    async patchPackage(locator, opts) {
      const {parentLocator, sourceLocator, sourceVersion, patchPaths} = parseLocator2(locator);
      const patchFiles = await loadPatchFiles(parentLocator, patchPaths, opts);
      const tmpDir = await xfs.mktempPromise();
      const tmpFile = ppath.join(tmpDir, `patched.zip`);
      const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
      const prefixPath = structUtils_exports.getIdentVendorPath(locator);
      const libzip = await getLibzipPromise();
      const patchedPackage = new ZipFS(tmpFile, {
        libzip,
        create: true,
        level: opts.project.configuration.get(`compressionLevel`)
      });
      await patchedPackage.mkdirpPromise(prefixPath);
      await miscUtils10.releaseAfterUseAsync(async () => {
        await patchedPackage.copyPromise(prefixPath, sourceFetch.prefixPath, {baseFs: sourceFetch.packageFs, stableSort: true});
      }, sourceFetch.releaseFs);
      const patchFs3 = new CwdFS(ppath.resolve(PortablePath2.root, prefixPath), {baseFs: patchedPackage});
      for (const patchFile of patchFiles) {
        if (patchFile !== null) {
          try {
            await applyPatchFile(parsePatchFile(patchFile), {
              baseFs: patchFs3,
              version: sourceVersion
            });
          } catch (err) {
            if (!(err instanceof UnmatchedHunkError))
              throw err;
            const enableInlineHunks = opts.project.configuration.get(`enableInlineHunks`);
            const suggestion = !enableInlineHunks ? ` (set enableInlineHunks for details)` : ``;
            throw new ReportError(MessageName.PATCH_HUNK_FAILED, err.message + suggestion, (report) => {
              if (!enableInlineHunks)
                return;
              reportHunk(err.hunk, {
                configuration: opts.project.configuration,
                report
              });
            });
          }
        }
      }
      return patchedPackage;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\PatchResolver.ts
  var CACHE_VERSION3 = 2;
  var PatchResolver = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(`patch:`))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(`patch:`))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      const {patchPaths} = parseDescriptor2(descriptor);
      if (patchPaths.every((patchPath) => !isParentRequired(patchPath)))
        return descriptor;
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      const {sourceDescriptor} = parseDescriptor2(descriptor);
      return [sourceDescriptor];
    }
    async getCandidates(descriptor, dependencies, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const {parentLocator, sourceDescriptor, patchPaths} = parseDescriptor2(descriptor);
      const patchFiles = await loadPatchFiles(parentLocator, patchPaths, opts.fetchOptions);
      const sourcePackage = dependencies.get(sourceDescriptor.descriptorHash);
      if (typeof sourcePackage === `undefined`)
        throw new Error(`Assertion failed: The dependency should have been resolved`);
      const patchHash = hashUtils_exports.makeHash(`${CACHE_VERSION3}`, ...patchFiles).slice(0, 6);
      return [makeLocator4(descriptor, {parentLocator, sourcePackage, patchPaths, patchHash})];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      const {sourceLocator} = parseLocator2(locator);
      const sourcePkg = await opts.resolver.resolve(sourceLocator, opts);
      return {...sourcePkg, ...locator};
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\commands\patchCommit.ts
  var PatchCommitCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.patchFolder = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const folderPath = ppath.resolve(this.context.cwd, npath.toPortablePath(this.patchFolder));
      const metaPath = ppath.join(folderPath, `.yarn-patch.json`);
      if (!xfs.existsSync(metaPath))
        throw new UsageError(`The argument folder didn't get created by 'yarn patch'`);
      const meta = await xfs.readJsonPromise(metaPath);
      const locator = structUtils_exports.parseLocator(meta.locator, true);
      if (!project.storedPackages.has(locator.locatorHash))
        throw new UsageError(`No package found in the project for the given locator`);
      const originalPath = await extractPackageToDisk(locator, {cache: cache2, project});
      this.context.stdout.write(await diffFolders(originalPath, folderPath));
    }
  };
  PatchCommitCommand.paths = [
    [`patch-commit`]
  ];
  PatchCommitCommand.usage = Command.Usage({
    description: `
      This will print a patchfile based on the diff between the folder passed in and the original version of the package.
      Such file is suitable for consumption with the \`patch:\` protocol.

      Only folders generated through \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `
  });
  var patchCommit_default = PatchCommitCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\commands\patch.ts
  var PatchCommand = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      let locator = structUtils_exports.parseLocator(this.package);
      if (locator.reference === `unknown`) {
        const candidateLocators = miscUtils10.mapAndFilter([...project.storedPackages.values()], (pkg) => {
          if (pkg.identHash !== locator.identHash)
            return miscUtils10.mapAndFilter.skip;
          if (structUtils_exports.isVirtualLocator(pkg))
            return miscUtils10.mapAndFilter.skip;
          return pkg;
        });
        if (candidateLocators.length === 0)
          throw new UsageError(`No package found in the project for the given locator`);
        if (candidateLocators.length > 1)
          throw new UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):
${candidateLocators.map((locator2) => `
- ${structUtils_exports.prettyLocator(configuration, locator2)}`).join(``)}`);
        locator = candidateLocators[0];
      }
      if (!project.storedPackages.has(locator.locatorHash))
        throw new UsageError(`No package found in the project for the given locator`);
      await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report) => {
        const temp = await extractPackageToDisk(locator, {cache: cache2, project});
        report.reportInfo(MessageName.UNNAMED, `Package ${structUtils_exports.prettyLocator(configuration, locator)} got extracted with success!`);
        report.reportInfo(MessageName.UNNAMED, `You can now edit the following folder: ${formatUtils_exports.pretty(configuration, npath.fromPortablePath(temp), `magenta`)}`);
        report.reportInfo(MessageName.UNNAMED, `Once you are done run ${formatUtils_exports.pretty(configuration, `yarn patch-commit ${npath.fromPortablePath(temp)}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
      });
    }
  };
  PatchCommand.paths = [
    [`patch`]
  ];
  PatchCommand.usage = Command.Usage({
    description: `
      This command will cause a package to be extracted in a temporary directory (under a folder named "patch-workdir"). This folder will be editable at will; running \`yarn patch\` inside it will then cause Yarn to generate a patchfile and register it into your top-level manifest (cf the \`patch:\` protocol).
    `
  });
  var patch_default = PatchCommand;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-be81121af4\1\packages\plugin-patch\sources\index.ts
  var plugin18 = {
    configuration: {
      enableInlineHunks: {
        description: `If true, the installs will print unmatched patch hunks`,
        type: SettingsType.BOOLEAN,
        default: false
      }
    },
    commands: [
      patchCommit_default,
      patch_default
    ],
    fetchers: [
      PatchFetcher
    ],
    resolvers: [
      PatchResolver
    ]
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\openWorkspace.ts
  async function openWorkspace2(configuration, cwd) {
    const {project, workspace} = await Project.find(configuration, cwd);
    if (!workspace)
      throw new WorkspaceRequiredError2(project.cwd, cwd);
    return workspace;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\main.ts
  var import_child_process2 = __toModule(require("child_process"));
  var import_ci_info5 = __toModule(require_ci_info());
  var import_fs13 = __toModule(require("fs"));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\pluginCommands.ts
  var pluginCommands2 = new Map([
    [`constraints`, [
      [`constraints`, `query`],
      [`constraints`, `source`],
      [`constraints`]
    ]],
    [`exec`, []],
    [`interactive-tools`, [
      [`search`],
      [`upgrade-interactive`]
    ]],
    [`stage`, [
      [`stage`]
    ]],
    [`typescript`, []],
    [`version`, [
      [`version`, `apply`],
      [`version`, `check`],
      [`version`]
    ]],
    [`workspace-tools`, [
      [`workspaces`, `focus`],
      [`workspaces`, `foreach`]
    ]]
  ]);

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-cli-virtual-cd2af72718\1\packages\yarnpkg-cli\sources\tools\WelcomeCommand.ts
  var getMessage2 = (configuration) => `
${formatUtils_exports.pretty(configuration, `Welcome on Yarn 2!`, `bold`)} \u{1F389} Thanks for helping us shape our vision of how projects
should be managed going forward.

Being still in RC, Yarn 2 isn't completely stable yet. Some features might be
missing, and some behaviors may have received major overhaul. In case of doubt,
use the following URLs to get some insight:

  - The changelog:
    ${formatUtils_exports.pretty(configuration, `https://github.com/yarnpkg/berry/tree/CHANGELOG.md`, `cyan`)}

  - Our issue tracker:
    ${formatUtils_exports.pretty(configuration, `https://github.com/yarnpkg/berry`, `cyan`)}

  - Our Discord server:
    ${formatUtils_exports.pretty(configuration, `https://discord.gg/yarnpkg`, `cyan`)}

We're hoping you will enjoy the experience. For now, a good start is to run
the two following commands:

  ${formatUtils_exports.pretty(configuration, `find . -name node_modules -prune -exec rm -r {} \\;`, `magenta`)}
  ${formatUtils_exports.pretty(configuration, `yarn install`, `magenta`)}

One last trick! If you need at some point to upgrade Yarn to a nightly build,
the following command will install the CLI straight from master:

  ${formatUtils_exports.pretty(configuration, `yarn set version from sources`, `magenta`)}

See you later \u{1F44B}
`;
  var WelcomeCommand2 = class extends BaseCommand2 {
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      this.context.stdout.write(`${getMessage2(configuration).trim()}
`);
    }
  };
  WelcomeCommand2.paths = [
    [`--welcome`]
  ];

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-42b46eedf7\1\packages\plugin-pack\sources\packUtils.ts
  var packUtils_exports2 = {};
  __export(packUtils_exports2, {
    genPackList: () => genPackList2,
    genPackStream: () => genPackStream2,
    genPackageManifest: () => genPackageManifest2,
    hasPackScripts: () => hasPackScripts2,
    prepareForPack: () => prepareForPack2
  });
  var import_micromatch14 = __toModule(require_micromatch());
  var import_tar_stream2 = __toModule(require_tar_stream());
  var import_zlib4 = __toModule(require("zlib"));
  var NEVER_IGNORE2 = [
    `/package.json`,
    `/readme`,
    `/readme.*`,
    `/license`,
    `/license.*`,
    `/licence`,
    `/licence.*`,
    `/changelog`,
    `/changelog.*`
  ];
  var ALWAYS_IGNORE2 = [
    `/package.tgz`,
    `.github`,
    `.git`,
    `.hg`,
    `node_modules`,
    `.npmignore`,
    `.gitignore`,
    `.#*`,
    `.DS_Store`
  ];
  async function hasPackScripts2(workspace) {
    if (scriptUtils_exports.hasWorkspaceScript(workspace, `prepack`))
      return true;
    if (scriptUtils_exports.hasWorkspaceScript(workspace, `postpack`))
      return true;
    return false;
  }
  async function prepareForPack2(workspace, {report}, cb) {
    await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `prepack`, {report});
    try {
      await cb();
    } finally {
      await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `postpack`, {report});
    }
  }
  async function genPackStream2(workspace, files) {
    var _a2, _b;
    if (typeof files === `undefined`)
      files = await genPackList2(workspace);
    const executableFiles = new Set();
    for (const value of (_b = (_a2 = workspace.manifest.publishConfig) == null ? void 0 : _a2.executableFiles) != null ? _b : new Set())
      executableFiles.add(ppath.normalize(value));
    for (const value of workspace.manifest.bin.values())
      executableFiles.add(ppath.normalize(value));
    const pack = import_tar_stream2.default.pack();
    process.nextTick(async () => {
      for (const fileRequest of files) {
        const file = ppath.normalize(fileRequest);
        const source = ppath.resolve(workspace.cwd, file);
        const dest = ppath.join(`package`, file);
        const stat = await xfs.lstatPromise(source);
        const opts = {name: dest, mtime: new Date(3155328e5)};
        const mode = executableFiles.has(file) ? 493 : 420;
        let resolveFn;
        let rejectFn;
        const awaitTarget = new Promise((resolve, reject) => {
          resolveFn = resolve;
          rejectFn = reject;
        });
        const cb = (error) => {
          if (error) {
            rejectFn(error);
          } else {
            resolveFn();
          }
        };
        if (stat.isFile()) {
          let content;
          if (file === `package.json`)
            content = Buffer.from(JSON.stringify(await genPackageManifest2(workspace), null, 2));
          else
            content = await xfs.readFilePromise(source);
          pack.entry({...opts, mode, type: `file`}, content, cb);
        } else if (stat.isSymbolicLink()) {
          pack.entry({...opts, mode, type: `symlink`, linkname: await xfs.readlinkPromise(source)}, cb);
        } else {
          cb(new Error(`Unsupported file type ${stat.mode} for ${npath.fromPortablePath(file)}`));
        }
        await awaitTarget;
      }
      pack.finalize();
    });
    const tgz = import_zlib4.createGzip();
    pack.pipe(tgz);
    return tgz;
  }
  async function genPackageManifest2(workspace) {
    const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
    await workspace.project.configuration.triggerHook((hooks) => hooks.beforeWorkspacePacking, workspace, data);
    return data;
  }
  async function genPackList2(workspace) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const project = workspace.project;
    const configuration = project.configuration;
    const globalList = {
      accept: [],
      reject: []
    };
    for (const pattern of ALWAYS_IGNORE2)
      globalList.reject.push(pattern);
    for (const pattern of NEVER_IGNORE2)
      globalList.accept.push(pattern);
    globalList.reject.push(configuration.get(`rcFilename`));
    const maybeRejectPath = (path6) => {
      if (path6 === null || !path6.startsWith(`${workspace.cwd}/`))
        return;
      const workspaceRelativePath = ppath.relative(workspace.cwd, path6);
      const workspaceAbsolutePath = ppath.resolve(PortablePath2.root, workspaceRelativePath);
      globalList.reject.push(workspaceAbsolutePath);
    };
    maybeRejectPath(ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
    maybeRejectPath(configuration.get(`bstatePath`));
    maybeRejectPath(configuration.get(`cacheFolder`));
    maybeRejectPath(configuration.get(`globalFolder`));
    maybeRejectPath(configuration.get(`installStatePath`));
    maybeRejectPath(configuration.get(`virtualFolder`));
    maybeRejectPath(configuration.get(`yarnPath`));
    await configuration.triggerHook((hooks) => {
      return hooks.populateYarnPaths;
    }, project, (path6) => {
      maybeRejectPath(path6);
    });
    for (const otherWorkspace of project.workspaces) {
      const rel = ppath.relative(workspace.cwd, otherWorkspace.cwd);
      if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
        globalList.reject.push(`/${rel}`);
      }
    }
    const ignoreList = {
      accept: [],
      reject: []
    };
    const main3 = (_b = (_a2 = workspace.manifest.publishConfig) == null ? void 0 : _a2.main) != null ? _b : workspace.manifest.main;
    const module2 = (_d = (_c = workspace.manifest.publishConfig) == null ? void 0 : _c.module) != null ? _d : workspace.manifest.module;
    const browser = (_f = (_e = workspace.manifest.publishConfig) == null ? void 0 : _e.browser) != null ? _f : workspace.manifest.browser;
    const bins = (_h = (_g = workspace.manifest.publishConfig) == null ? void 0 : _g.bin) != null ? _h : workspace.manifest.bin;
    if (main3 != null)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, main3));
    if (module2 != null)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, module2));
    if (typeof browser === `string`)
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, browser));
    for (const path6 of bins.values())
      ignoreList.accept.push(ppath.resolve(PortablePath2.root, path6));
    if (browser instanceof Map) {
      for (const [original, replacement] of browser.entries()) {
        ignoreList.accept.push(ppath.resolve(PortablePath2.root, original));
        if (typeof replacement === `string`) {
          ignoreList.accept.push(ppath.resolve(PortablePath2.root, replacement));
        }
      }
    }
    const hasExplicitFileList = workspace.manifest.files !== null;
    if (hasExplicitFileList) {
      ignoreList.reject.push(`/*`);
      for (const pattern of workspace.manifest.files) {
        addIgnorePattern2(ignoreList.accept, pattern, {cwd: PortablePath2.root});
      }
    }
    return await walk2(workspace.cwd, {
      hasExplicitFileList,
      globalList,
      ignoreList
    });
  }
  async function walk2(initialCwd, {hasExplicitFileList, globalList, ignoreList}) {
    const list = [];
    const cwdFs = new JailFS(initialCwd);
    const cwdList = [[PortablePath2.root, [ignoreList]]];
    while (cwdList.length > 0) {
      const [cwd, ignoreLists] = cwdList.pop();
      const stat = await cwdFs.lstatPromise(cwd);
      if (isIgnored2(cwd, {globalList, ignoreLists: stat.isDirectory() ? null : ignoreLists}))
        continue;
      if (stat.isDirectory()) {
        const entries = await cwdFs.readdirPromise(cwd);
        let hasGitIgnore = false;
        let hasNpmIgnore = false;
        if (!hasExplicitFileList || cwd !== PortablePath2.root) {
          for (const entry of entries) {
            hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
            hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
          }
        }
        const localIgnoreList = hasNpmIgnore ? await loadIgnoreList2(cwdFs, cwd, `.npmignore`) : hasGitIgnore ? await loadIgnoreList2(cwdFs, cwd, `.gitignore`) : null;
        let nextIgnoreLists = localIgnoreList !== null ? [localIgnoreList].concat(ignoreLists) : ignoreLists;
        if (isIgnored2(cwd, {globalList, ignoreLists}))
          nextIgnoreLists = [...ignoreLists, {accept: [], reject: [`**/*`]}];
        for (const entry of entries) {
          cwdList.push([ppath.resolve(cwd, entry), nextIgnoreLists]);
        }
      } else if (stat.isFile() || stat.isSymbolicLink()) {
        list.push(ppath.relative(PortablePath2.root, cwd));
      }
    }
    return list.sort();
  }
  async function loadIgnoreList2(fs9, cwd, filename) {
    const ignoreList = {
      accept: [],
      reject: []
    };
    const data = await fs9.readFilePromise(ppath.join(cwd, filename), `utf8`);
    for (const pattern of data.split(/\n/g))
      addIgnorePattern2(ignoreList.reject, pattern, {cwd});
    return ignoreList;
  }
  function normalizePattern2(pattern, {cwd}) {
    const negated = pattern[0] === `!`;
    if (negated)
      pattern = pattern.slice(1);
    if (pattern.match(/\.{0,1}\//))
      pattern = ppath.resolve(cwd, pattern);
    if (negated)
      pattern = `!${pattern}`;
    return pattern;
  }
  function addIgnorePattern2(target, pattern, {cwd}) {
    const trimed = pattern.trim();
    if (trimed === `` || trimed[0] === `#`)
      return;
    target.push(normalizePattern2(trimed, {cwd}));
  }
  function isIgnored2(cwd, {globalList, ignoreLists}) {
    if (isMatch2(cwd, globalList.accept))
      return false;
    if (isMatch2(cwd, globalList.reject))
      return true;
    if (ignoreLists !== null) {
      for (const ignoreList of ignoreLists) {
        if (isMatch2(cwd, ignoreList.accept))
          return false;
        if (isMatch2(cwd, ignoreList.reject)) {
          return true;
        }
      }
    }
    return false;
  }
  function isMatch2(path6, patterns) {
    let inclusives = patterns;
    const exclusives = [];
    for (let t7 = 0; t7 < patterns.length; ++t7) {
      if (patterns[t7][0] !== `!`) {
        if (inclusives !== patterns) {
          inclusives.push(patterns[t7]);
        }
      } else {
        if (inclusives === patterns)
          inclusives = patterns.slice(0, t7);
        exclusives.push(patterns[t7].slice(1));
      }
    }
    if (isMatchBasename2(path6, exclusives))
      return false;
    if (isMatchBasename2(path6, inclusives))
      return true;
    return false;
  }
  function isMatchBasename2(path6, patterns) {
    let paths = patterns;
    const basenames = [];
    for (let t7 = 0; t7 < patterns.length; ++t7) {
      if (patterns[t7].includes(`/`)) {
        if (paths !== patterns) {
          paths.push(patterns[t7]);
        }
      } else {
        if (paths === patterns)
          paths = patterns.slice(0, t7);
        basenames.push(patterns[t7]);
      }
    }
    if (import_micromatch14.default.isMatch(path6, paths, {dot: true, nocase: true}))
      return true;
    if (import_micromatch14.default.isMatch(path6, basenames, {dot: true, basename: true, nocase: true}))
      return true;
    return false;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-42b46eedf7\1\packages\plugin-pack\sources\commands\pack.ts
  var PackCommand2 = class extends BaseCommand2 {
    constructor() {
      super(...arguments);
      this.installIfNeeded = options_exports.Boolean(`--install-if-needed`, false, {
        description: `Run a preliminary \`yarn install\` if the package contains build scripts`
      });
      this.dryRun = options_exports.Boolean(`-n,--dry-run`, false, {
        description: `Print the file paths without actually generating the package archive`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.out = options_exports.String(`-o,--out`, {
        description: `Create the archive at the specified path`
      });
      this.filename = options_exports.String(`--filename`, {hidden: true});
    }
    async execute() {
      var _a2;
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError2(project.cwd, this.context.cwd);
      if (await hasPackScripts2(workspace)) {
        if (this.installIfNeeded) {
          await project.install({
            cache: await Cache.find(configuration),
            report: new ThrowReport()
          });
        } else {
          await project.restoreInstallState();
        }
      }
      const out = (_a2 = this.out) != null ? _a2 : this.filename;
      const target = typeof out !== `undefined` ? ppath.resolve(this.context.cwd, interpolateOutputName2(out, {workspace})) : ppath.resolve(workspace.cwd, `package.tgz`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        json: this.json
      }, async (report2) => {
        await prepareForPack2(workspace, {report: report2}, async () => {
          report2.reportJson({base: workspace.cwd});
          const files = await genPackList2(workspace);
          for (const file of files) {
            report2.reportInfo(null, file);
            report2.reportJson({location: file});
          }
          if (!this.dryRun) {
            const pack = await genPackStream2(workspace, files);
            const write = xfs.createWriteStream(target);
            pack.pipe(write);
            await new Promise((resolve) => {
              write.on(`finish`, resolve);
            });
          }
        });
        if (!this.dryRun) {
          report2.reportInfo(MessageName.UNNAMED, `Package archive generated in ${formatUtils_exports.pretty(configuration, target, formatUtils_exports.Type.PATH)}`);
          report2.reportJson({output: target});
        }
      });
      return report.exitCode();
    }
  };
  PackCommand2.paths = [
    [`pack`]
  ];
  PackCommand2.usage = Command.Usage({
    description: `generate a tarball from the active workspace`,
    details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
    examples: [[
      `Create an archive from the active workspace`,
      `yarn pack`
    ], [
      `List the files that would be made part of the workspace's archive`,
      `yarn pack --dry-run`
    ], [
      `Name and output the archive in a dedicated folder`,
      `yarn pack --out /artifacts/%s-%v.tgz`
    ]]
  });
  var pack_default2 = PackCommand2;
  function interpolateOutputName2(name, {workspace}) {
    const interpolated = name.replace(`%s`, prettyWorkspaceIdent2(workspace)).replace(`%v`, prettyWorkspaceVersion2(workspace));
    return npath.toPortablePath(interpolated);
  }
  function prettyWorkspaceIdent2(workspace) {
    if (workspace.manifest.name !== null) {
      return structUtils_exports.slugifyIdent(workspace.manifest.name);
    } else {
      return `package`;
    }
  }
  function prettyWorkspaceVersion2(workspace) {
    if (workspace.manifest.version !== null) {
      return workspace.manifest.version;
    } else {
      return `unknown`;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-pack-virtual-42b46eedf7\1\packages\plugin-pack\sources\index.ts
  var DEPENDENCY_TYPES = [`dependencies`, `devDependencies`, `peerDependencies`];
  var WORKSPACE_PROTOCOL = `workspace:`;
  var beforeWorkspacePacking = (workspace, rawManifest) => {
    if (rawManifest.publishConfig) {
      if (rawManifest.publishConfig.main)
        rawManifest.main = rawManifest.publishConfig.main;
      if (rawManifest.publishConfig.browser)
        rawManifest.browser = rawManifest.publishConfig.browser;
      if (rawManifest.publishConfig.module)
        rawManifest.module = rawManifest.publishConfig.module;
      if (rawManifest.publishConfig.browser)
        rawManifest.browser = rawManifest.publishConfig.browser;
      if (rawManifest.publishConfig.bin) {
        rawManifest.bin = rawManifest.publishConfig.bin;
      }
    }
    const project = workspace.project;
    for (const dependencyType of DEPENDENCY_TYPES) {
      for (const descriptor of workspace.manifest.getForScope(dependencyType).values()) {
        const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
        const range = structUtils_exports.parseRange(descriptor.range);
        if (range.protocol !== WORKSPACE_PROTOCOL)
          continue;
        if (matchingWorkspace === null) {
          if (project.tryWorkspaceByIdent(descriptor) === null) {
            throw new ReportError(MessageName.WORKSPACE_NOT_FOUND, `${structUtils_exports.prettyDescriptor(project.configuration, descriptor)}: No local workspace found for this range`);
          }
        } else {
          let versionToWrite;
          if (structUtils_exports.areDescriptorsEqual(descriptor, matchingWorkspace.anchoredDescriptor) || range.selector === `*`)
            versionToWrite = matchingWorkspace.manifest.version;
          else
            versionToWrite = range.selector;
          rawManifest[dependencyType][structUtils_exports.stringifyIdent(descriptor)] = versionToWrite;
        }
      }
    }
  };
  var plugin19 = {
    hooks: {
      beforeWorkspacePacking
    },
    commands: [
      pack_default2
    ]
  };
  var sources_default16 = plugin19;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\npmPublishUtils.ts
  var import_crypto4 = __toModule(require("crypto"));
  var import_ssri2 = __toModule(require_ssri());
  var import_url11 = __toModule(require("url"));
  async function makePublishBody2(workspace, buffer, {access, tag, registry}) {
    const configuration = workspace.project.configuration;
    const ident = workspace.manifest.name;
    const version = workspace.manifest.version;
    const name = structUtils_exports.stringifyIdent(ident);
    const shasum = import_crypto4.createHash(`sha1`).update(buffer).digest(`hex`);
    const integrity = import_ssri2.default.fromData(buffer).toString();
    if (typeof access === `undefined`) {
      if (workspace.manifest.publishConfig && typeof workspace.manifest.publishConfig.access === `string`) {
        access = workspace.manifest.publishConfig.access;
      } else if (configuration.get(`npmPublishAccess`) !== null) {
        access = configuration.get(`npmPublishAccess`);
      } else if (ident.scope) {
        access = `restricted`;
      } else {
        access = `public`;
      }
    }
    const raw = await packUtils_exports2.genPackageManifest(workspace);
    const tarballName = `${name}-${version}.tgz`;
    const tarballURL = new import_url11.URL(`${name}/-/${tarballName}`, registry);
    return {
      _id: name,
      _attachments: {
        [tarballName]: {
          [`content_type`]: `application/octet-stream`,
          data: buffer.toString(`base64`),
          length: buffer.length
        }
      },
      name,
      access,
      [`dist-tags`]: {
        [tag]: version
      },
      versions: {
        [version]: {
          ...raw,
          _id: `${name}@${version}`,
          name,
          version,
          dist: {
            shasum,
            integrity,
            tarball: tarballURL.toString()
          }
        }
      }
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-virtual-ac09774f7e\1\packages\plugin-npm\sources\index.ts
  var authSettings2 = {
    npmAlwaysAuth: {
      description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
      type: SettingsType.BOOLEAN,
      default: false
    },
    npmAuthIdent: {
      description: `Authentication identity for the npm registry (_auth in npm and yarn v1)`,
      type: SettingsType.SECRET,
      default: null
    },
    npmAuthToken: {
      description: `Authentication token for the npm registry (_authToken in npm and yarn v1)`,
      type: SettingsType.SECRET,
      default: null
    }
  };
  var registrySettings2 = {
    npmPublishRegistry: {
      description: `Registry to push packages to`,
      type: SettingsType.STRING,
      default: null
    },
    npmRegistryServer: {
      description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
      type: SettingsType.STRING,
      default: `https://registry.yarnpkg.com`
    }
  };
  var plugin20 = {
    configuration: {
      ...authSettings2,
      ...registrySettings2,
      npmScopes: {
        description: `Settings per package scope`,
        type: SettingsType.MAP,
        valueDefinition: {
          description: ``,
          type: SettingsType.SHAPE,
          properties: {
            ...authSettings2,
            ...registrySettings2
          }
        }
      },
      npmRegistries: {
        description: `Settings per registry`,
        type: SettingsType.MAP,
        normalizeKeys: normalizeRegistry,
        valueDefinition: {
          description: ``,
          type: SettingsType.SHAPE,
          properties: {
            ...authSettings2
          }
        }
      }
    },
    fetchers: [
      NpmHttpFetcher,
      NpmSemverFetcher
    ],
    resolvers: [
      NpmRemapResolver,
      NpmSemverResolver,
      NpmTagResolver
    ]
  };
  var sources_default17 = plugin20;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\index.ts
  var sources_exports30 = {};
  __export(sources_exports30, {
    default: () => sources_default18
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\audit.ts
  var t6 = __toModule(require_lib());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\npmAuditTypes.ts
  var Environment2;
  (function(Environment3) {
    Environment3["All"] = `all`;
    Environment3["Production"] = `production`;
    Environment3["Development"] = `development`;
  })(Environment2 || (Environment2 = {}));
  var Severity2;
  (function(Severity3) {
    Severity3["Info"] = `info`;
    Severity3["Low"] = `low`;
    Severity3["Moderate"] = `moderate`;
    Severity3["High"] = `high`;
    Severity3["Critical"] = `critical`;
  })(Severity2 || (Severity2 = {}));

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\npmAuditUtils.ts
  var allSeverities2 = [
    Severity2.Info,
    Severity2.Low,
    Severity2.Moderate,
    Severity2.High,
    Severity2.Critical
  ];
  function getTransitiveDependencies2(project, roots) {
    const queue = [];
    const descriptorHashes = new Set();
    const enqueue = (descriptorHash) => {
      if (descriptorHashes.has(descriptorHash))
        return;
      descriptorHashes.add(descriptorHash);
      queue.push(descriptorHash);
    };
    for (const root of roots)
      enqueue(root);
    const transitiveDependencies = new Set();
    while (queue.length > 0) {
      const descriptorHash = queue.shift();
      const locatorHash = project.storedResolutions.get(descriptorHash);
      if (typeof locatorHash === `undefined`)
        throw new Error(`Assertion failed: Expected the resolution to have been registered`);
      const pkg = project.storedPackages.get(locatorHash);
      if (!pkg)
        continue;
      transitiveDependencies.add(descriptorHash);
      for (const dependency of pkg.dependencies.values()) {
        enqueue(dependency.descriptorHash);
      }
    }
    return transitiveDependencies;
  }
  function setDifference2(x, y) {
    return new Set([...x].filter((value) => !y.has(value)));
  }
  function getTransitiveDevDependencies2(project, workspace, {all}) {
    const workspaces = all ? project.workspaces : [workspace];
    const manifests = workspaces.map((workspace2) => {
      return workspace2.manifest;
    });
    const productionDependencyIdentSet = new Set(manifests.map((manifest) => [...manifest.dependencies].map(([identHash, descriptor]) => identHash)).flat());
    const developmentDependencyIdentSet = new Set(manifests.map((manifest) => [...manifest.devDependencies].map(([identHash, descriptor]) => identHash)).flat());
    const workspaceDependencies = workspaces.map((workspace2) => [...workspace2.dependencies.values()]).flat();
    const productionRoots = workspaceDependencies.filter((dependency) => productionDependencyIdentSet.has(dependency.identHash)).map((dependency) => dependency.descriptorHash);
    const developmentRoots = workspaceDependencies.filter((dependency) => developmentDependencyIdentSet.has(dependency.identHash)).map((dependency) => dependency.descriptorHash);
    const productionDependencies = getTransitiveDependencies2(project, productionRoots);
    const developmentDependencies = getTransitiveDependencies2(project, developmentRoots);
    return setDifference2(developmentDependencies, productionDependencies);
  }
  function transformDescriptorIterableToRequiresObject2(descriptors) {
    const data = {};
    for (const descriptor of descriptors)
      data[structUtils_exports.stringifyIdent(descriptor)] = structUtils_exports.parseRange(descriptor.range).selector;
    return data;
  }
  function getSeverityInclusions2(severity) {
    if (typeof severity === `undefined`)
      return new Set();
    const severityIndex = allSeverities2.indexOf(severity);
    const severities = allSeverities2.slice(severityIndex);
    return new Set(severities);
  }
  function filterVulnerabilities2(vulnerabilities, severity) {
    const inclusions = getSeverityInclusions2(severity);
    const filteredVulnerabilities = {};
    for (const key of inclusions)
      filteredVulnerabilities[key] = vulnerabilities[key];
    return filteredVulnerabilities;
  }
  function isError2(vulnerabilities, severity) {
    var _a2;
    const filteredVulnerabilities = filterVulnerabilities2(vulnerabilities, severity);
    for (const key of Object.keys(filteredVulnerabilities))
      if ((_a2 = filteredVulnerabilities[key]) != null ? _a2 : 0 > 0)
        return true;
    return false;
  }
  function getReportTree2(result, severity) {
    const auditTreeChildren = {};
    const auditTree = {children: auditTreeChildren};
    let advisories = Object.values(result.advisories);
    if (severity != null) {
      const inclusions = getSeverityInclusions2(severity);
      advisories = advisories.filter((advisory) => inclusions.has(advisory.severity));
    }
    for (const advisory of miscUtils10.sortMap(advisories, (advisory2) => advisory2.module_name)) {
      auditTreeChildren[advisory.module_name] = {
        label: advisory.module_name,
        value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.findings.map((finding) => finding.version).join(`, `)),
        children: {
          Issue: {
            label: `Issue`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.title)
          },
          URL: {
            label: `URL`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.URL, advisory.url)
          },
          Severity: {
            label: `Severity`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.severity)
          },
          [`Vulnerable Versions`]: {
            label: `Vulnerable Versions`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.vulnerable_versions)
          },
          [`Patched Versions`]: {
            label: `Patched Versions`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.RANGE, advisory.patched_versions)
          },
          Via: {
            label: `Via`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, Array.from(new Set(advisory.findings.map((finding) => finding.paths).flat().map((path6) => path6.split(`>`)[0]))).join(`, `))
          },
          Recommendation: {
            label: `Recommendation`,
            value: formatUtils_exports.tuple(formatUtils_exports.Type.NO_HINT, advisory.recommendation.replace(/\n/g, ` `))
          }
        }
      };
    }
    return auditTree;
  }
  function getRequires2(project, workspace, {all, environment}) {
    const workspaces = all ? project.workspaces : [workspace];
    const includeDependencies = [
      Environment2.All,
      Environment2.Production
    ].includes(environment);
    const requiredDependencies = [];
    if (includeDependencies)
      for (const workspace2 of workspaces)
        for (const dependency of workspace2.manifest.dependencies.values())
          requiredDependencies.push(dependency);
    const includeDevDependencies = [
      Environment2.All,
      Environment2.Development
    ].includes(environment);
    const requiredDevDependencies = [];
    if (includeDevDependencies)
      for (const workspace2 of workspaces)
        for (const dependency of workspace2.manifest.devDependencies.values())
          requiredDevDependencies.push(dependency);
    return transformDescriptorIterableToRequiresObject2([
      ...requiredDependencies,
      ...requiredDevDependencies
    ].filter((dependency) => {
      return structUtils_exports.parseRange(dependency.range).protocol === null;
    }));
  }
  function getDependencies2(project, workspace, {all}) {
    var _a2;
    const transitiveDevDependencies = getTransitiveDevDependencies2(project, workspace, {all});
    const data = {};
    for (const pkg of project.storedPackages.values()) {
      data[structUtils_exports.stringifyIdent(pkg)] = {
        version: (_a2 = pkg.version) != null ? _a2 : `0.0.0`,
        integrity: pkg.identHash,
        requires: transformDescriptorIterableToRequiresObject2(pkg.dependencies.values()),
        dev: transitiveDevDependencies.has(structUtils_exports.convertLocatorToDescriptor(pkg).descriptorHash)
      };
    }
    return data;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\audit.ts
  var AuditCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Audit dependencies from all workspaces`
      });
      this.recursive = options_exports.Boolean(`-R,--recursive`, false, {
        description: `Audit transitive dependencies as well`
      });
      this.environment = options_exports.String(`--environment`, Environment2.All, {
        description: `Which environments to cover`,
        validator: t6.isEnum(Environment2)
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.severity = options_exports.String(`--severity`, Severity2.Info, {
        description: `Minimal severity requested for packages to be displayed`,
        validator: t6.isEnum(Severity2)
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const requires = getRequires2(project, workspace, {all: this.all, environment: this.environment});
      const dependencies = getDependencies2(project, workspace, {all: this.all});
      if (!this.recursive) {
        for (const key of Object.keys(dependencies)) {
          if (!Object.prototype.hasOwnProperty.call(requires, key)) {
            delete dependencies[key];
          } else {
            dependencies[key].requires = {};
          }
        }
      }
      const body = {
        requires,
        dependencies
      };
      const registry = npmConfigUtils_exports.getPublishRegistry(workspace.manifest, {
        configuration
      });
      let result;
      const httpReport = await LightReport.start({
        configuration,
        stdout: this.context.stdout
      }, async () => {
        try {
          result = await npmHttpUtils_exports.post(`/-/npm/v1/security/audits/quick`, body, {
            authType: npmHttpUtils_exports.AuthType.NO_AUTH,
            configuration,
            jsonResponse: true,
            registry
          });
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else {
            throw new ReportError(MessageName.EXCEPTION, err.toString());
          }
        }
      });
      if (httpReport.hasErrors())
        return httpReport.exitCode();
      const hasError = isError2(result.metadata.vulnerabilities, this.severity);
      if (!this.json && hasError) {
        treeUtils_exports.emitTree(getReportTree2(result, this.severity), {
          configuration,
          json: this.json,
          stdout: this.context.stdout,
          separators: 2
        });
        return 1;
      }
      const outReport = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report) => {
        report.reportJson(result);
        if (!hasError) {
          report.reportInfo(MessageName.EXCEPTION, `No audit suggestions`);
        }
      });
      return outReport.exitCode();
    }
  };
  AuditCommand2.paths = [
    [`npm`, `audit`]
  ];
  AuditCommand2.usage = Command.Usage({
    description: `perform a vulnerability audit against the installed packages`,
    details: `
      This command checks for known security reports on the packages you use. The reports are by default extracted from the npm registry, and may or may not be relevant to your actual program (not all vulnerabilities affect all code paths).

      For consistency with our other commands the default is to only check the direct dependencies for the active workspace. To extend this search to all workspaces, use \`-A,--all\`. To extend this search to both direct and transitive dependencies, use \`-R,--recursive\`.

      Applying the \`--severity\` flag will limit the audit table to vulnerabilities of the corresponding severity and above. Valid values are ${allSeverities2.map((value) => `\`${value}\``).join(`, `)}.

      If the \`--json\` flag is set, Yarn will print the output exactly as received from the registry. Regardless of this flag, the process will exit with a non-zero exit code if a report is found for the selected packages.

      To understand the dependency tree requiring vulnerable packages, check the raw report with the \`--json\` flag or use \`yarn why <package>\` to get more information as to who depends on them.
    `,
    examples: [[
      `Checks for known security issues with the installed packages. The output is a list of known issues.`,
      `yarn npm audit`
    ], [
      `Audit dependencies in all workspaces`,
      `yarn npm audit --all`
    ], [
      `Limit auditing to \`dependencies\` (excludes \`devDependencies\`)`,
      `yarn npm audit --environment production`
    ], [
      `Show audit report as valid JSON`,
      `yarn npm audit --json`
    ], [
      `Audit all direct and transitive dependencies`,
      `yarn npm audit --recursive`
    ], [
      `Output moderate (or more severe) vulnerabilities`,
      `yarn npm audit --severity moderate`
    ]]
  });
  var audit_default2 = AuditCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\info.ts
  var import_path20 = __toModule(require("path"));
  var import_semver27 = __toModule(require_semver2());
  var import_util16 = __toModule(require("util"));
  var InfoCommand4 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.fields = options_exports.String(`-f,--fields`, {
        description: `A comma-separated list of manifest fields that should be displayed`
      });
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.packages = options_exports.Rest();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project} = await Project.find(configuration, this.context.cwd);
      const fields = typeof this.fields !== `undefined` ? new Set([`name`, ...this.fields.split(/\s*,\s*/)]) : null;
      const infos = [];
      let leadWithSeparator = false;
      const report = await StreamReport.start({
        configuration,
        includeFooter: false,
        json: this.json,
        stdout: this.context.stdout
      }, async (report2) => {
        for (const identStr of this.packages) {
          let descriptor;
          if (identStr === `.`) {
            const workspace = project.topLevelWorkspace;
            if (!workspace.manifest.name)
              throw new UsageError(`Missing 'name' field in ${import_path20.default.join(workspace.cwd, `package.json`)}`);
            descriptor = structUtils_exports.makeDescriptor(workspace.manifest.name, `unknown`);
          } else {
            descriptor = structUtils_exports.parseDescriptor(identStr);
          }
          const identUrl = npmHttpUtils_exports.getIdentUrl(descriptor);
          let result;
          try {
            result = clean2(await npmHttpUtils_exports.get(identUrl, {
              configuration,
              ident: descriptor,
              jsonResponse: true
            }));
          } catch (err) {
            if (err.name !== `HTTPError`) {
              throw err;
            } else if (err.response.statusCode === 404) {
              throw new ReportError(MessageName.EXCEPTION, `Package not found`);
            } else {
              throw new ReportError(MessageName.EXCEPTION, err.toString());
            }
          }
          const versions = Object.keys(result.versions).sort(import_semver27.default.compareLoose);
          const fallbackVersion = result[`dist-tags`].latest || versions[versions.length - 1];
          let version = fallbackVersion;
          if (import_semver27.default.validRange(descriptor.range)) {
            const maxSatisfyingVersion = import_semver27.default.maxSatisfying(versions, descriptor.range);
            if (maxSatisfyingVersion !== null) {
              version = maxSatisfyingVersion;
            } else {
              report2.reportWarning(MessageName.UNNAMED, `Unmet range ${structUtils_exports.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
              leadWithSeparator = true;
            }
          } else if (descriptor.range !== `unknown`) {
            report2.reportWarning(MessageName.UNNAMED, `Invalid range ${structUtils_exports.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
            leadWithSeparator = true;
          }
          const release = result.versions[version];
          const packageInformation = {
            ...result,
            ...release,
            version,
            versions
          };
          let serialized;
          if (fields !== null) {
            serialized = {};
            for (const field of fields) {
              const value = packageInformation[field];
              if (typeof value !== `undefined`) {
                serialized[field] = value;
              } else {
                report2.reportWarning(MessageName.EXCEPTION, `The '${field}' field doesn't exist inside ${structUtils_exports.prettyIdent(configuration, descriptor)}'s informations`);
                leadWithSeparator = true;
                continue;
              }
            }
          } else {
            if (!this.json) {
              delete packageInformation.dist;
              delete packageInformation.readme;
              delete packageInformation.users;
            }
            serialized = packageInformation;
          }
          report2.reportJson(serialized);
          if (!this.json) {
            infos.push(serialized);
          }
        }
      });
      import_util16.inspect.styles.name = `cyan`;
      for (const serialized of infos) {
        if (serialized !== infos[0] || leadWithSeparator)
          this.context.stdout.write(`
`);
        this.context.stdout.write(`${import_util16.inspect(serialized, {
          depth: Infinity,
          colors: true,
          compact: false
        })}
`);
      }
      return report.exitCode();
    }
  };
  InfoCommand4.paths = [
    [`npm`, `info`]
  ];
  InfoCommand4.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `show information about a package`,
    details: `
      This command will fetch information about a package from the npm registry, and prints it in a tree format.

      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).

      Append \`@<range>\` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.

      If the \`-f,--fields\` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.

      By default, this command won't return the \`dist\`, \`readme\`, and \`users\` fields, since they are often very long. To explicitly request those fields, explicitly list them with the \`--fields\` flag or request the output in JSON mode.
    `,
    examples: [[
      `Show all available information about react (except the \`dist\`, \`readme\`, and \`users\` fields)`,
      `yarn npm info react`
    ], [
      `Show all available information about react as valid JSON (including the \`dist\`, \`readme\`, and \`users\` fields)`,
      `yarn npm info react --json`
    ], [
      `Show all available information about react 16.12.0`,
      `yarn npm info react@16.12.0`
    ], [
      `Show the description of react`,
      `yarn npm info react --fields description`
    ], [
      `Show all available versions of react`,
      `yarn npm info react --fields versions`
    ], [
      `Show the readme of react`,
      `yarn npm info react --fields readme`
    ], [
      `Show a few fields of react`,
      `yarn npm info react --fields homepage,repository`
    ]]
  });
  var info_default4 = InfoCommand4;
  function clean2(value) {
    if (Array.isArray(value)) {
      const result = [];
      for (let item of value) {
        item = clean2(item);
        if (item) {
          result.push(item);
        }
      }
      return result;
    } else if (typeof value === `object` && value !== null) {
      const result = {};
      for (const key of Object.keys(value)) {
        if (key.startsWith(`_`))
          continue;
        const item = clean2(value[key]);
        if (item) {
          result[key] = item;
        }
      }
      return result;
    } else if (value) {
      return value;
    } else {
      return null;
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\login.ts
  var import_enquirer8 = __toModule(require_enquirer());
  var NpmLoginCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Login to the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Login to the publish registry`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const registry = await getRegistry2({
        configuration,
        cwd: this.context.cwd,
        publish: this.publish,
        scope: this.scope
      });
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const credentials = await getCredentials2({
          registry,
          report: report2,
          stdin: this.context.stdin,
          stdout: this.context.stdout
        });
        const url = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
        const response = await npmHttpUtils_exports.put(url, credentials, {
          attemptedAs: credentials.name,
          configuration,
          registry,
          jsonResponse: true,
          authType: npmHttpUtils_exports.AuthType.NO_AUTH
        });
        await setAuthToken2(registry, response.token, {configuration, scope: this.scope});
        return report2.reportInfo(MessageName.UNNAMED, `Successfully logged in`);
      });
      return report.exitCode();
    }
  };
  NpmLoginCommand2.paths = [
    [`npm`, `login`]
  ];
  NpmLoginCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `store new login info to access the npm registry`,
    details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
    examples: [[
      `Login to the default registry`,
      `yarn npm login`
    ], [
      `Login to the registry linked to the @my-scope registry`,
      `yarn npm login --scope my-scope`
    ], [
      `Login to the publish registry for the current package`,
      `yarn npm login --publish`
    ]]
  });
  var login_default2 = NpmLoginCommand2;
  async function getRegistry2({scope, publish, configuration, cwd}) {
    if (scope && publish)
      return npmConfigUtils_exports.getScopeRegistry(scope, {configuration, type: npmConfigUtils_exports.RegistryType.PUBLISH_REGISTRY});
    if (scope)
      return npmConfigUtils_exports.getScopeRegistry(scope, {configuration});
    if (publish)
      return npmConfigUtils_exports.getPublishRegistry((await openWorkspace(configuration, cwd)).manifest, {configuration});
    return npmConfigUtils_exports.getDefaultRegistry({configuration});
  }
  async function setAuthToken2(registry, npmAuthToken, {configuration, scope}) {
    const makeUpdater = (entryName) => (unknownStore) => {
      const store = miscUtils10.isIndexableObject(unknownStore) ? unknownStore : {};
      const entryUnknown = store[entryName];
      const entry = miscUtils10.isIndexableObject(entryUnknown) ? entryUnknown : {};
      return {
        ...store,
        [entryName]: {
          ...entry,
          npmAuthToken
        }
      };
    };
    const update = scope ? {npmScopes: makeUpdater(scope)} : {npmRegistries: makeUpdater(registry)};
    return await Configuration.updateHomeConfiguration(update);
  }
  async function getCredentials2({registry, report, stdin, stdout}) {
    if (process.env.TEST_ENV) {
      return {
        name: process.env.TEST_NPM_USER || ``,
        password: process.env.TEST_NPM_PASSWORD || ``
      };
    }
    report.reportInfo(MessageName.UNNAMED, `Logging in to ${registry}`);
    let isToken = false;
    if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
      report.reportInfo(MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
      isToken = true;
    }
    report.reportSeparator();
    const {username, password} = await import_enquirer8.prompt([{
      type: `input`,
      name: `username`,
      message: `Username:`,
      required: true,
      onCancel: () => process.exit(130),
      stdin,
      stdout
    }, {
      type: `password`,
      name: `password`,
      message: isToken ? `Token:` : `Password:`,
      required: true,
      onCancel: () => process.exit(130),
      stdin,
      stdout
    }]);
    report.reportSeparator();
    return {
      name: username,
      password
    };
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\logout.ts
  var LOGOUT_KEYS2 = new Set([
    `npmAuthIdent`,
    `npmAuthToken`
  ]);
  var NpmLogoutCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Logout of the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Logout of the publish registry`
      });
      this.all = options_exports.Boolean(`-A,--all`, false, {
        description: `Logout of all registries`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const checkLogout = async () => {
        var _a2;
        const registry = await getRegistry2({
          configuration,
          cwd: this.context.cwd,
          publish: this.publish,
          scope: this.scope
        });
        const refreshedConfiguration = await Configuration.find(this.context.cwd, this.context.plugins);
        const fakeIdent = structUtils_exports.makeIdent((_a2 = this.scope) != null ? _a2 : null, `pkg`);
        const authConfiguration = npmConfigUtils_exports.getAuthConfiguration(registry, {
          configuration: refreshedConfiguration,
          ident: fakeIdent
        });
        return !authConfiguration.get(`npmAuthToken`);
      };
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        if (this.all) {
          await logoutFromEverything2();
          report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from everything`);
        }
        if (this.scope) {
          await logoutFrom2(`npmScopes`, this.scope);
          if (await checkLogout())
            report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from ${this.scope}`);
          else
            report2.reportWarning(MessageName.UNNAMED, `Scope authentication settings removed, but some other ones settings still apply to it`);
          return;
        }
        const registry = await getRegistry2({
          configuration,
          cwd: this.context.cwd,
          publish: this.publish
        });
        await logoutFrom2(`npmRegistries`, registry);
        if (await checkLogout()) {
          report2.reportInfo(MessageName.UNNAMED, `Successfully logged out from ${registry}`);
        } else {
          report2.reportWarning(MessageName.UNNAMED, `Registry authentication settings removed, but some other ones settings still apply to it`);
        }
      });
      return report.exitCode();
    }
  };
  NpmLogoutCommand2.paths = [
    [`npm`, `logout`]
  ];
  NpmLogoutCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `logout of the npm registry`,
    details: `
      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.

      Adding the \`-s,--scope\` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the deletion to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).

      Adding the \`-A,--all\` flag will cause the deletion to be done against all registries and scopes.
    `,
    examples: [[
      `Logout of the default registry`,
      `yarn npm logout`
    ], [
      `Logout of the @my-scope scope`,
      `yarn npm logout --scope my-scope`
    ], [
      `Logout of the publish registry for the current package`,
      `yarn npm logout --publish`
    ], [
      `Logout of all registries`,
      `yarn npm logout --all`
    ]]
  });
  var logout_default2 = NpmLogoutCommand2;
  function removeTokenFromStore2(nextStore, entryName) {
    const entry = nextStore[entryName];
    if (!miscUtils10.isIndexableObject(entry))
      return false;
    const keys = new Set(Object.keys(entry));
    if ([...LOGOUT_KEYS2].every((key) => !keys.has(key)))
      return false;
    for (const key of LOGOUT_KEYS2)
      keys.delete(key);
    if (keys.size === 0) {
      nextStore[entryName] = void 0;
      return true;
    }
    const nextEntry = {...entry};
    for (const key of LOGOUT_KEYS2)
      delete nextEntry[key];
    nextStore[entryName] = nextEntry;
    return true;
  }
  async function logoutFromEverything2() {
    const updater = (unknownStore) => {
      let updated = false;
      const nextStore = miscUtils10.isIndexableObject(unknownStore) ? {...unknownStore} : {};
      if (nextStore.npmAuthToken) {
        delete nextStore.npmAuthToken;
        updated = true;
      }
      for (const entryName of Object.keys(nextStore))
        if (removeTokenFromStore2(nextStore, entryName))
          updated = true;
      if (Object.keys(nextStore).length === 0)
        return void 0;
      if (updated) {
        return nextStore;
      } else {
        return unknownStore;
      }
    };
    return await Configuration.updateHomeConfiguration({
      npmRegistries: updater,
      npmScopes: updater
    });
  }
  async function logoutFrom2(entryType, entryName) {
    return await Configuration.updateHomeConfiguration({
      [entryType]: (unknownStore) => {
        const nextStore = miscUtils10.isIndexableObject(unknownStore) ? unknownStore : {};
        if (!Object.prototype.hasOwnProperty.call(nextStore, entryName))
          return unknownStore;
        const unknownEntry = nextStore[entryName];
        const nextEntry = miscUtils10.isIndexableObject(unknownEntry) ? unknownEntry : {};
        const keys = new Set(Object.keys(nextEntry));
        if ([...LOGOUT_KEYS2].every((key) => !keys.has(key)))
          return unknownStore;
        for (const key of LOGOUT_KEYS2)
          keys.delete(key);
        if (keys.size === 0) {
          if (Object.keys(nextStore).length === 1)
            return void 0;
          return {
            ...nextStore,
            [entryName]: void 0
          };
        }
        const eraser = {};
        for (const key of LOGOUT_KEYS2)
          eraser[key] = void 0;
        return {
          ...nextStore,
          [entryName]: {
            ...nextEntry,
            ...eraser
          }
        };
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\publish.ts
  var NpmPublishCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.access = options_exports.String(`--access`, {
        description: `The access for the published package (public or restricted)`
      });
      this.tag = options_exports.String(`--tag`, `latest`, {
        description: `The tag on the registry that the package should be attached to`
      });
      this.tolerateRepublish = options_exports.Boolean(`--tolerate-republish`, false, {
        description: `Warn and exit when republishing an already existing version of a package`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      if (workspace.manifest.private)
        throw new UsageError(`Private workspaces cannot be published`);
      if (workspace.manifest.name === null || workspace.manifest.version === null)
        throw new UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
      await project.restoreInstallState();
      const ident = workspace.manifest.name;
      const version = workspace.manifest.version;
      const registry = npmConfigUtils_exports.getPublishRegistry(workspace.manifest, {configuration});
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        if (this.tolerateRepublish) {
          try {
            const registryData = await npmHttpUtils_exports.get(npmHttpUtils_exports.getIdentUrl(ident), {
              configuration,
              registry,
              ident,
              jsonResponse: true
            });
            if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
              throw new ReportError(MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
            if (Object.prototype.hasOwnProperty.call(registryData.versions, version)) {
              report2.reportWarning(MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
              return;
            }
          } catch (error) {
            if (error.name !== `HTTPError`) {
              throw error;
            } else if (error.response.statusCode !== 404) {
              throw new ReportError(MessageName.NETWORK_ERROR, `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`);
            }
          }
        }
        await scriptUtils_exports.maybeExecuteWorkspaceLifecycleScript(workspace, `prepublish`, {report: report2});
        await packUtils_exports2.prepareForPack(workspace, {report: report2}, async () => {
          const files = await packUtils_exports2.genPackList(workspace);
          for (const file of files)
            report2.reportInfo(null, file);
          const pack = await packUtils_exports2.genPackStream(workspace, files);
          const buffer = await miscUtils10.bufferStream(pack);
          const body = await npmPublishUtils_exports2.makePublishBody(workspace, buffer, {
            access: this.access,
            tag: this.tag,
            registry
          });
          try {
            await npmHttpUtils_exports.put(npmHttpUtils_exports.getIdentUrl(ident), body, {
              configuration,
              registry,
              ident,
              jsonResponse: true
            });
          } catch (error) {
            if (error.name !== `HTTPError`) {
              throw error;
            } else {
              const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
              report2.reportError(MessageName.NETWORK_ERROR, message);
            }
          }
        });
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Package archive published`);
        }
      });
      return report.exitCode();
    }
  };
  NpmPublishCommand2.paths = [
    [`npm`, `publish`]
  ];
  NpmPublishCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `publish the active workspace to the npm registry`,
    details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
    examples: [[
      `Publish the active workspace`,
      `yarn npm publish`
    ]]
  });
  var publish_default2 = NpmPublishCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\tag\add.ts
  var import_semver28 = __toModule(require_semver2());

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\tag\list.ts
  var NpmTagListCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.json = options_exports.Boolean(`--json`, false, {
        description: `Format the output as an NDJSON stream`
      });
      this.package = options_exports.String({required: false});
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      let ident;
      if (typeof this.package !== `undefined`) {
        ident = structUtils_exports.parseIdent(this.package);
      } else {
        if (!workspace)
          throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (!workspace.manifest.name)
          throw new UsageError(`Missing 'name' field in ${ppath.join(workspace.cwd, Filename.manifest)}`);
        ident = workspace.manifest.name;
      }
      const distTags = await getDistTags2(ident, configuration);
      const distTagEntries = miscUtils10.sortMap(Object.entries(distTags), ([tag]) => tag);
      const tree = {
        children: distTagEntries.map(([tag, version]) => ({
          value: formatUtils_exports.tuple(formatUtils_exports.Type.RESOLUTION, {
            descriptor: structUtils_exports.makeDescriptor(ident, tag),
            locator: structUtils_exports.makeLocator(ident, version)
          })
        }))
      };
      return treeUtils_exports.emitTree(tree, {
        configuration,
        json: this.json,
        stdout: this.context.stdout
      });
    }
  };
  NpmTagListCommand2.paths = [
    [`npm`, `tag`, `list`]
  ];
  NpmTagListCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `list all dist-tags of a package`,
    details: `
      This command will list all tags of a package from the npm registry.

      If the package is not specified, Yarn will default to the current workspace.
    `,
    examples: [[
      `List all tags of package \`my-pkg\``,
      `yarn npm tag list my-pkg`
    ]]
  });
  var list_default6 = NpmTagListCommand2;
  async function getDistTags2(ident, configuration) {
    const url = `/-/package${npmHttpUtils_exports.getIdentUrl(ident)}/dist-tags`;
    return npmHttpUtils_exports.get(url, {
      configuration,
      ident,
      jsonResponse: true
    }).catch((err) => {
      if (err.name !== `HTTPError`) {
        throw err;
      } else if (err.response.statusCode === 404) {
        throw new ReportError(MessageName.EXCEPTION, `Package not found`);
      } else {
        throw new ReportError(MessageName.EXCEPTION, err.toString());
      }
    });
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\tag\add.ts
  var NpmTagAddCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
      this.tag = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const descriptor = structUtils_exports.parseDescriptor(this.package, true);
      const version = descriptor.range;
      if (!import_semver28.default.valid(version))
        throw new UsageError(`The range ${formatUtils_exports.pretty(configuration, descriptor.range, formatUtils_exports.Type.RANGE)} must be a valid semver version`);
      const registry = npmConfigUtils_exports.getPublishRegistry(workspace.manifest, {configuration});
      const prettyIdent2 = formatUtils_exports.pretty(configuration, descriptor, formatUtils_exports.Type.IDENT);
      const prettyVersion = formatUtils_exports.pretty(configuration, version, formatUtils_exports.Type.RANGE);
      const prettyTag = formatUtils_exports.pretty(configuration, this.tag, formatUtils_exports.Type.CODE);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        const distTags = await getDistTags2(descriptor, configuration);
        if (Object.prototype.hasOwnProperty.call(distTags, this.tag) && distTags[this.tag] === version)
          report2.reportWarning(MessageName.UNNAMED, `Tag ${prettyTag} is already set to version ${prettyVersion}`);
        try {
          const url = `/-/package${npmHttpUtils_exports.getIdentUrl(descriptor)}/dist-tags/${encodeURIComponent(this.tag)}`;
          await npmHttpUtils_exports.put(url, version, {
            configuration,
            registry,
            ident: descriptor,
            jsonRequest: true,
            jsonResponse: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report2.reportError(MessageName.NETWORK_ERROR, message);
          }
        }
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Tag ${prettyTag} added to version ${prettyVersion} of package ${prettyIdent2}`);
        }
      });
      return report.exitCode();
    }
  };
  NpmTagAddCommand2.paths = [
    [`npm`, `tag`, `add`]
  ];
  NpmTagAddCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `add a tag for a specific version of a package`,
    details: `
      This command will add a tag to the npm registry for a specific version of a package. If the tag already exists, it will be overwritten.
    `,
    examples: [[
      `Add a \`beta\` tag for version \`2.3.4-beta.4\` of package \`my-pkg\``,
      `yarn npm tag add my-pkg@2.3.4-beta.4 beta`
    ]]
  });
  var add_default4 = NpmTagAddCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\tag\remove.ts
  var NpmTagRemoveCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
      this.tag = options_exports.String();
    }
    async execute() {
      if (this.tag === `latest`)
        throw new UsageError(`The 'latest' tag cannot be removed.`);
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      const ident = structUtils_exports.parseIdent(this.package);
      const registry = npmConfigUtils_exports.getPublishRegistry(workspace.manifest, {configuration});
      const prettyTag = formatUtils_exports.pretty(configuration, this.tag, formatUtils_exports.Type.CODE);
      const prettyIdent2 = formatUtils_exports.pretty(configuration, ident, formatUtils_exports.Type.IDENT);
      const distTags = await getDistTags2(ident, configuration);
      if (!Object.prototype.hasOwnProperty.call(distTags, this.tag))
        throw new UsageError(`${prettyTag} is not a tag of package ${prettyIdent2}`);
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        try {
          const url = `/-/package${npmHttpUtils_exports.getIdentUrl(ident)}/dist-tags/${encodeURIComponent(this.tag)}`;
          await npmHttpUtils_exports.del(url, {
            configuration,
            registry,
            ident,
            jsonResponse: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report2.reportError(MessageName.NETWORK_ERROR, message);
          }
        }
        if (!report2.hasErrors()) {
          report2.reportInfo(MessageName.UNNAMED, `Tag ${prettyTag} removed from package ${prettyIdent2}`);
        }
      });
      return report.exitCode();
    }
  };
  NpmTagRemoveCommand2.paths = [
    [`npm`, `tag`, `remove`]
  ];
  NpmTagRemoveCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `remove a tag from a package`,
    details: `
      This command will remove a tag from a package from the npm registry.
    `,
    examples: [[
      `Remove the \`beta\` tag from package \`my-pkg\``,
      `yarn npm tag remove my-pkg beta`
    ]]
  });
  var remove_default6 = NpmTagRemoveCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\commands\npm\whoami.ts
  var NpmWhoamiCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.scope = options_exports.String(`-s,--scope`, {
        description: `Print username for the registry configured for a given scope`
      });
      this.publish = options_exports.Boolean(`--publish`, false, {
        description: `Print username for the publish registry`
      });
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      let registry;
      if (this.scope && this.publish)
        registry = npmConfigUtils_exports.getScopeRegistry(this.scope, {configuration, type: npmConfigUtils_exports.RegistryType.PUBLISH_REGISTRY});
      else if (this.scope)
        registry = npmConfigUtils_exports.getScopeRegistry(this.scope, {configuration});
      else if (this.publish)
        registry = npmConfigUtils_exports.getPublishRegistry((await openWorkspace(configuration, this.context.cwd)).manifest, {configuration});
      else
        registry = npmConfigUtils_exports.getDefaultRegistry({configuration});
      const report = await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report2) => {
        try {
          const response = await npmHttpUtils_exports.get(`/-/whoami`, {
            configuration,
            registry,
            authType: npmHttpUtils_exports.AuthType.ALWAYS_AUTH,
            jsonResponse: true,
            ident: this.scope ? structUtils_exports.makeIdent(this.scope, ``) : void 0
          });
          report2.reportInfo(MessageName.UNNAMED, response.username);
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else if (err.response.statusCode === 401 || err.response.statusCode === 403) {
            report2.reportError(MessageName.AUTHENTICATION_INVALID, `Authentication failed - your credentials may have expired`);
          } else {
            report2.reportError(MessageName.AUTHENTICATION_INVALID, err.toString());
          }
        }
      });
      return report.exitCode();
    }
  };
  NpmWhoamiCommand2.paths = [
    [`npm`, `whoami`]
  ];
  NpmWhoamiCommand2.usage = Command.Usage({
    category: `Npm-related commands`,
    description: `display the name of the authenticated user`,
    details: `
      Print the username associated with the current authentication settings to the standard output.

      When using \`-s,--scope\`, the username printed will be the one that matches the authentication settings of the registry associated with the given scope (those settings can be overriden using the \`npmRegistries\` map, and the registry associated with the scope is configured via the \`npmScopes\` map).

      When using \`--publish\`, the registry we'll select will by default be the one used when publishing packages (\`publishConfig.registry\` or \`npmPublishRegistry\` if available, otherwise we'll fallback to the regular \`npmRegistryServer\`).
    `,
    examples: [[
      `Print username for the default registry`,
      `yarn npm whoami`
    ], [
      `Print username for the registry on a given scope`,
      `yarn npm whoami --scope company`
    ]]
  });
  var whoami_default2 = NpmWhoamiCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-npm-cli-virtual-2e644aaeac\1\packages\plugin-npm-cli\sources\index.ts
  var plugin21 = {
    configuration: {
      npmPublishAccess: {
        description: `Default access of the published packages`,
        type: SettingsType.STRING,
        default: null
      }
    },
    commands: [
      audit_default2,
      info_default4,
      login_default2,
      logout_default2,
      publish_default2,
      add_default4,
      list_default6,
      remove_default6,
      whoami_default2
    ]
  };
  var sources_default18 = plugin21;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\index.ts
  var sources_exports31 = {};
  __export(sources_exports31, {
    default: () => sources_default19,
    patchUtils: () => patchUtils_exports2
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\patchUtils.ts
  var patchUtils_exports2 = {};
  __export(patchUtils_exports2, {
    applyPatchFile: () => applyPatchFile2,
    diffFolders: () => diffFolders2,
    extractPackageToDisk: () => extractPackageToDisk2,
    isParentRequired: () => isParentRequired2,
    loadPatchFiles: () => loadPatchFiles2,
    makeDescriptor: () => makeDescriptor2,
    makeLocator: () => makeLocator5,
    parseDescriptor: () => parseDescriptor3,
    parseLocator: () => parseLocator3,
    parsePatchFile: () => parsePatchFile2
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\tools\UnmatchedHunkError.ts
  var UnmatchedHunkError2 = class extends Error {
    constructor(index, hunk) {
      super(`Cannot apply hunk #${index + 1}`);
      this.hunk = hunk;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\tools\parse.ts
  var HEADER_REGEXP2 = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/;
  function getPath6(p) {
    return ppath.relative(PortablePath2.root, ppath.resolve(PortablePath2.root, npath.toPortablePath(p)));
  }
  function parseHunkHeaderLine2(headerLine) {
    const match2 = headerLine.trim().match(HEADER_REGEXP2);
    if (!match2)
      throw new Error(`Bad header line: '${headerLine}'`);
    return {
      original: {
        start: Math.max(Number(match2[1]), 1),
        length: Number(match2[3] || 1)
      },
      patched: {
        start: Math.max(Number(match2[4]), 1),
        length: Number(match2[6] || 1)
      }
    };
  }
  var NON_EXECUTABLE_FILE_MODE2 = 420;
  var EXECUTABLE_FILE_MODE2 = 493;
  var PatchMutationType2;
  (function(PatchMutationType3) {
    PatchMutationType3["Context"] = `context`;
    PatchMutationType3["Insertion"] = `insertion`;
    PatchMutationType3["Deletion"] = `deletion`;
  })(PatchMutationType2 || (PatchMutationType2 = {}));
  var emptyFilePatch2 = () => ({
    semverExclusivity: null,
    diffLineFromPath: null,
    diffLineToPath: null,
    oldMode: null,
    newMode: null,
    deletedFileMode: null,
    newFileMode: null,
    renameFrom: null,
    renameTo: null,
    beforeHash: null,
    afterHash: null,
    fromPath: null,
    toPath: null,
    hunks: null
  });
  var emptyHunk2 = (headerLine) => ({
    header: parseHunkHeaderLine2(headerLine),
    parts: []
  });
  var hunkLinetypes2 = {
    [`@`]: `header`,
    [`-`]: PatchMutationType2.Deletion,
    [`+`]: PatchMutationType2.Insertion,
    [` `]: PatchMutationType2.Context,
    [`\\`]: `pragma`,
    undefined: PatchMutationType2.Context
  };
  function parsePatchLines2(lines) {
    const result = [];
    let currentFilePatch = emptyFilePatch2();
    let state = `parsing header`;
    let currentHunk = null;
    let currentHunkMutationPart = null;
    function commitHunk() {
      if (currentHunk) {
        if (currentHunkMutationPart) {
          currentHunk.parts.push(currentHunkMutationPart);
          currentHunkMutationPart = null;
        }
        currentFilePatch.hunks.push(currentHunk);
        currentHunk = null;
      }
    }
    function commitFilePatch() {
      commitHunk();
      result.push(currentFilePatch);
      currentFilePatch = emptyFilePatch2();
    }
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (state === `parsing header`) {
        if (line.startsWith(`@@`)) {
          state = `parsing hunks`;
          currentFilePatch.hunks = [];
          i -= 1;
        } else if (line.startsWith(`diff --git `)) {
          if (currentFilePatch && currentFilePatch.diffLineFromPath)
            commitFilePatch();
          const match2 = line.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);
          if (!match2)
            throw new Error(`Bad diff line: ${line}`);
          currentFilePatch.diffLineFromPath = match2[1];
          currentFilePatch.diffLineToPath = match2[2];
        } else if (line.startsWith(`old mode `)) {
          currentFilePatch.oldMode = line.slice(`old mode `.length).trim();
        } else if (line.startsWith(`new mode `)) {
          currentFilePatch.newMode = line.slice(`new mode `.length).trim();
        } else if (line.startsWith(`deleted file mode `)) {
          currentFilePatch.deletedFileMode = line.slice(`deleted file mode `.length).trim();
        } else if (line.startsWith(`new file mode `)) {
          currentFilePatch.newFileMode = line.slice(`new file mode `.length).trim();
        } else if (line.startsWith(`rename from `)) {
          currentFilePatch.renameFrom = line.slice(`rename from `.length).trim();
        } else if (line.startsWith(`rename to `)) {
          currentFilePatch.renameTo = line.slice(`rename to `.length).trim();
        } else if (line.startsWith(`index `)) {
          const match2 = line.match(/(\w+)\.\.(\w+)/);
          if (!match2)
            continue;
          currentFilePatch.beforeHash = match2[1];
          currentFilePatch.afterHash = match2[2];
        } else if (line.startsWith(`semver exclusivity `)) {
          currentFilePatch.semverExclusivity = line.slice(`semver exclusivity `.length).trim();
        } else if (line.startsWith(`--- `)) {
          currentFilePatch.fromPath = line.slice(`--- a/`.length).trim();
        } else if (line.startsWith(`+++ `)) {
          currentFilePatch.toPath = line.slice(`+++ b/`.length).trim();
        }
      } else {
        const lineType = hunkLinetypes2[line[0]] || null;
        switch (lineType) {
          case `header`:
            {
              commitHunk();
              currentHunk = emptyHunk2(line);
            }
            break;
          case null:
            {
              state = `parsing header`;
              commitFilePatch();
              i -= 1;
            }
            break;
          case `pragma`:
            {
              if (!line.startsWith(`\\ No newline at end of file`))
                throw new Error(`Unrecognized pragma in patch file: ${line}`);
              if (!currentHunkMutationPart)
                throw new Error(`Bad parser state: No newline at EOF pragma encountered without context`);
              currentHunkMutationPart.noNewlineAtEndOfFile = true;
            }
            break;
          case PatchMutationType2.Context:
          case PatchMutationType2.Deletion:
          case PatchMutationType2.Insertion:
            {
              if (!currentHunk)
                throw new Error(`Bad parser state: Hunk lines encountered before hunk header`);
              if (currentHunkMutationPart && currentHunkMutationPart.type !== lineType) {
                currentHunk.parts.push(currentHunkMutationPart);
                currentHunkMutationPart = null;
              }
              if (!currentHunkMutationPart) {
                currentHunkMutationPart = {
                  type: lineType,
                  lines: [],
                  noNewlineAtEndOfFile: false
                };
              }
              currentHunkMutationPart.lines.push(line.slice(1));
            }
            break;
          default:
            {
              miscUtils10.assertNever(lineType);
            }
            break;
        }
      }
    }
    commitFilePatch();
    for (const {hunks} of result)
      if (hunks)
        for (const hunk of hunks)
          verifyHunkIntegrity2(hunk);
    return result;
  }
  function interpretParsedPatchFile2(files) {
    const result = [];
    for (const file of files) {
      const {
        semverExclusivity,
        diffLineFromPath,
        diffLineToPath,
        oldMode,
        newMode,
        deletedFileMode,
        newFileMode,
        renameFrom,
        renameTo,
        beforeHash,
        afterHash,
        fromPath,
        toPath,
        hunks
      } = file;
      const type = renameFrom ? `rename` : deletedFileMode ? `file deletion` : newFileMode ? `file creation` : hunks && hunks.length > 0 ? `patch` : `mode change`;
      let destinationFilePath = null;
      switch (type) {
        case `rename`:
          {
            if (!renameFrom || !renameTo)
              throw new Error(`Bad parser state: rename from & to not given`);
            result.push({
              type: `rename`,
              semverExclusivity,
              fromPath: getPath6(renameFrom),
              toPath: getPath6(renameTo)
            });
            destinationFilePath = renameTo;
          }
          break;
        case `file deletion`:
          {
            const path6 = diffLineFromPath || fromPath;
            if (!path6)
              throw new Error(`Bad parse state: no path given for file deletion`);
            result.push({
              type: `file deletion`,
              semverExclusivity,
              hunk: hunks && hunks[0] || null,
              path: getPath6(path6),
              mode: parseFileMode2(deletedFileMode),
              hash: beforeHash
            });
          }
          break;
        case `file creation`:
          {
            const path6 = diffLineToPath || toPath;
            if (!path6)
              throw new Error(`Bad parse state: no path given for file creation`);
            result.push({
              type: `file creation`,
              semverExclusivity,
              hunk: hunks && hunks[0] || null,
              path: getPath6(path6),
              mode: parseFileMode2(newFileMode),
              hash: afterHash
            });
          }
          break;
        case `patch`:
        case `mode change`:
          {
            destinationFilePath = toPath || diffLineToPath;
          }
          break;
        default:
          {
            miscUtils10.assertNever(type);
          }
          break;
      }
      if (destinationFilePath && oldMode && newMode && oldMode !== newMode) {
        result.push({
          type: `mode change`,
          semverExclusivity,
          path: getPath6(destinationFilePath),
          oldMode: parseFileMode2(oldMode),
          newMode: parseFileMode2(newMode)
        });
      }
      if (destinationFilePath && hunks && hunks.length) {
        result.push({
          type: `patch`,
          semverExclusivity,
          path: getPath6(destinationFilePath),
          hunks,
          beforeHash,
          afterHash
        });
      }
    }
    return result;
  }
  function parseFileMode2(mode) {
    const parsedMode = parseInt(mode, 8) & 511;
    if (parsedMode !== NON_EXECUTABLE_FILE_MODE2 && parsedMode !== EXECUTABLE_FILE_MODE2)
      throw new Error(`Unexpected file mode string: ${mode}`);
    return parsedMode;
  }
  function parsePatchFile2(file) {
    const lines = file.split(/\n/g);
    if (lines[lines.length - 1] === ``)
      lines.pop();
    return interpretParsedPatchFile2(parsePatchLines2(lines));
  }
  function verifyHunkIntegrity2(hunk) {
    let originalLength = 0;
    let patchedLength = 0;
    for (const {type, lines} of hunk.parts) {
      switch (type) {
        case PatchMutationType2.Context:
          {
            patchedLength += lines.length;
            originalLength += lines.length;
          }
          break;
        case PatchMutationType2.Deletion:
          {
            originalLength += lines.length;
          }
          break;
        case PatchMutationType2.Insertion:
          {
            patchedLength += lines.length;
          }
          break;
        default:
          {
            miscUtils10.assertNever(type);
          }
          break;
      }
    }
    if (originalLength !== hunk.header.original.length || patchedLength !== hunk.header.patched.length) {
      const format = (n) => n < 0 ? n : `+${n}`;
      throw new Error(`hunk header integrity check failed (expected @@ ${format(hunk.header.original.length)} ${format(hunk.header.patched.length)} @@, got @@ ${format(originalLength)} ${format(patchedLength)} @@)`);
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\tools\apply.ts
  var DEFAULT_TIME2 = 315532800;
  async function preserveTime2(baseFs, p, cb) {
    const stat = await baseFs.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    if (baseFs.lutimesPromise) {
      await baseFs.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await baseFs.utimesPromise(p, stat.atime, stat.mtime);
    } else {
      throw new Error(`Cannot preserve the time values of a symlink`);
    }
  }
  async function applyPatchFile2(effects, {baseFs = new NodeFS(), dryRun = false, version = null} = {}) {
    for (const eff of effects) {
      if (eff.semverExclusivity !== null && version !== null) {
        if (!semverUtils_exports.satisfiesWithPrereleases(version, eff.semverExclusivity))
          continue;
      }
      switch (eff.type) {
        case `file deletion`:
          {
            if (dryRun) {
              if (!baseFs.existsSync(eff.path)) {
                throw new Error(`Trying to delete a file that doesn't exist: ${eff.path}`);
              }
            } else {
              await preserveTime2(baseFs, ppath.dirname(eff.path), async () => {
                await baseFs.unlinkPromise(eff.path);
              });
            }
          }
          break;
        case `rename`:
          {
            if (dryRun) {
              if (!baseFs.existsSync(eff.fromPath)) {
                throw new Error(`Trying to move a file that doesn't exist: ${eff.fromPath}`);
              }
            } else {
              await preserveTime2(baseFs, ppath.dirname(eff.fromPath), async () => {
                await preserveTime2(baseFs, ppath.dirname(eff.toPath), async () => {
                  await preserveTime2(baseFs, eff.fromPath, async () => {
                    await baseFs.movePromise(eff.fromPath, eff.toPath);
                    return eff.toPath;
                  });
                });
              });
            }
          }
          break;
        case `file creation`:
          {
            if (dryRun) {
              if (baseFs.existsSync(eff.path)) {
                throw new Error(`Trying to create a file that already exists: ${eff.path}`);
              }
            } else {
              const fileContents = eff.hunk ? eff.hunk.parts[0].lines.join(`
`) + (eff.hunk.parts[0].noNewlineAtEndOfFile ? `` : `
`) : ``;
              await baseFs.mkdirpPromise(ppath.dirname(eff.path), {chmod: 493, utimes: [DEFAULT_TIME2, DEFAULT_TIME2]});
              await baseFs.writeFilePromise(eff.path, fileContents, {mode: eff.mode});
              await baseFs.utimesPromise(eff.path, DEFAULT_TIME2, DEFAULT_TIME2);
            }
          }
          break;
        case `patch`:
          {
            await preserveTime2(baseFs, eff.path, async () => {
              await applyPatch2(eff, {baseFs, dryRun});
            });
          }
          break;
        case `mode change`:
          {
            const currentStat = await baseFs.statPromise(eff.path);
            const currentMode = currentStat.mode;
            if (isExecutable2(eff.newMode) !== isExecutable2(currentMode))
              continue;
            await preserveTime2(baseFs, eff.path, async () => {
              await baseFs.chmodPromise(eff.path, eff.newMode);
            });
          }
          break;
        default:
          {
            miscUtils10.assertNever(eff);
          }
          break;
      }
    }
  }
  function isExecutable2(fileMode) {
    return (fileMode & 64) > 0;
  }
  function trimRight2(s) {
    return s.replace(/\s+$/, ``);
  }
  function linesAreEqual2(a, b) {
    return trimRight2(a) === trimRight2(b);
  }
  async function applyPatch2({hunks, path: path6}, {baseFs, dryRun = false}) {
    const mode = await baseFs.statSync(path6).mode;
    const fileContents = await baseFs.readFileSync(path6, `utf8`);
    const fileLines = fileContents.split(/\n/);
    const result = [];
    let fixupOffset = 0;
    let maxFrozenLine = 0;
    for (const hunk of hunks) {
      const firstGuess = Math.max(maxFrozenLine, hunk.header.patched.start + fixupOffset);
      const maxPrefixFuzz = Math.max(0, firstGuess - maxFrozenLine);
      const maxSuffixFuzz = Math.max(0, fileLines.length - firstGuess - hunk.header.original.length);
      const maxFuzz = Math.max(maxPrefixFuzz, maxSuffixFuzz);
      let offset = 0;
      let location = 0;
      let modifications = null;
      while (offset <= maxFuzz) {
        if (offset <= maxPrefixFuzz) {
          location = firstGuess - offset;
          modifications = evaluateHunk2(hunk, fileLines, location);
          if (modifications !== null) {
            offset = -offset;
            break;
          }
        }
        if (offset <= maxSuffixFuzz) {
          location = firstGuess + offset;
          modifications = evaluateHunk2(hunk, fileLines, location);
          if (modifications !== null) {
            break;
          }
        }
        offset += 1;
      }
      if (modifications === null)
        throw new UnmatchedHunkError2(hunks.indexOf(hunk), hunk);
      result.push(modifications);
      fixupOffset += offset;
      maxFrozenLine = location + hunk.header.original.length;
    }
    if (dryRun)
      return;
    let diffOffset = 0;
    for (const modifications of result) {
      for (const modification of modifications) {
        switch (modification.type) {
          case `splice`:
            {
              const firstLine = modification.index + diffOffset;
              fileLines.splice(firstLine, modification.numToDelete, ...modification.linesToInsert);
              diffOffset += modification.linesToInsert.length - modification.numToDelete;
            }
            break;
          case `pop`:
            {
              fileLines.pop();
            }
            break;
          case `push`:
            {
              fileLines.push(modification.line);
            }
            break;
          default:
            {
              miscUtils10.assertNever(modification);
            }
            break;
        }
      }
    }
    await baseFs.writeFilePromise(path6, fileLines.join(`
`), {mode});
  }
  function evaluateHunk2(hunk, fileLines, offset) {
    const result = [];
    for (const part of hunk.parts) {
      switch (part.type) {
        case PatchMutationType2.Context:
        case PatchMutationType2.Deletion:
          {
            for (const line of part.lines) {
              const originalLine = fileLines[offset];
              if (originalLine == null || !linesAreEqual2(originalLine, line))
                return null;
              offset += 1;
            }
            if (part.type === PatchMutationType2.Deletion) {
              result.push({
                type: `splice`,
                index: offset - part.lines.length,
                numToDelete: part.lines.length,
                linesToInsert: []
              });
              if (part.noNewlineAtEndOfFile) {
                result.push({
                  type: `push`,
                  line: ``
                });
              }
            }
          }
          break;
        case PatchMutationType2.Insertion:
          {
            result.push({
              type: `splice`,
              index: offset,
              numToDelete: 0,
              linesToInsert: part.lines
            });
            if (part.noNewlineAtEndOfFile) {
              result.push({type: `pop`});
            }
          }
          break;
        default:
          {
            miscUtils10.assertNever(part.type);
          }
          break;
      }
    }
    return result;
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\patchUtils.ts
  var BUILTIN_REGEXP2 = /^builtin<([^>]+)>$/;
  function parseSpec3(spec, sourceParser) {
    const {source, selector, params} = structUtils_exports.parseRange(spec);
    if (source === null)
      throw new Error(`Patch locators must explicitly define their source`);
    const patchPaths = selector ? selector.split(/&/).map((path6) => npath.toPortablePath(path6)) : [];
    const parentLocator = params && typeof params.locator === `string` ? structUtils_exports.parseLocator(params.locator) : null;
    const sourceVersion = params && typeof params.version === `string` ? params.version : null;
    const sourceItem = sourceParser(source);
    return {parentLocator, sourceItem, patchPaths, sourceVersion};
  }
  function parseDescriptor3(descriptor) {
    const {sourceItem, ...rest} = parseSpec3(descriptor.range, structUtils_exports.parseDescriptor);
    return {...rest, sourceDescriptor: sourceItem};
  }
  function parseLocator3(locator) {
    const {sourceItem, ...rest} = parseSpec3(locator.reference, structUtils_exports.parseLocator);
    return {...rest, sourceLocator: sourceItem};
  }
  function makeSpec3({parentLocator, sourceItem, patchPaths, sourceVersion, patchHash}, sourceStringifier) {
    const parentLocatorSpread = parentLocator !== null ? {locator: structUtils_exports.stringifyLocator(parentLocator)} : {};
    const sourceVersionSpread = typeof sourceVersion !== `undefined` ? {version: sourceVersion} : {};
    const patchHashSpread = typeof patchHash !== `undefined` ? {hash: patchHash} : {};
    return structUtils_exports.makeRange({
      protocol: `patch:`,
      source: sourceStringifier(sourceItem),
      selector: patchPaths.join(`&`),
      params: {
        ...sourceVersionSpread,
        ...patchHashSpread,
        ...parentLocatorSpread
      }
    });
  }
  function makeDescriptor2(ident, {parentLocator, sourceDescriptor, patchPaths}) {
    return structUtils_exports.makeLocator(ident, makeSpec3({parentLocator, sourceItem: sourceDescriptor, patchPaths}, structUtils_exports.stringifyDescriptor));
  }
  function makeLocator5(ident, {parentLocator, sourcePackage, patchPaths, patchHash}) {
    return structUtils_exports.makeLocator(ident, makeSpec3({parentLocator, sourceItem: sourcePackage, sourceVersion: sourcePackage.version, patchPaths, patchHash}, structUtils_exports.stringifyLocator));
  }
  function visitPatchPath2({onAbsolute, onRelative, onBuiltin}, patchPath) {
    const builtinMatch = patchPath.match(BUILTIN_REGEXP2);
    if (builtinMatch !== null)
      return onBuiltin(builtinMatch[1]);
    if (ppath.isAbsolute(patchPath)) {
      return onAbsolute(patchPath);
    } else {
      return onRelative(patchPath);
    }
  }
  function isParentRequired2(patchPath) {
    return visitPatchPath2({
      onAbsolute: () => false,
      onRelative: () => true,
      onBuiltin: () => false
    }, patchPath);
  }
  async function loadPatchFiles2(parentLocator, patchPaths, opts) {
    const parentFetch = parentLocator !== null ? await opts.fetcher.fetch(parentLocator, opts) : null;
    const effectiveParentFetch = parentFetch && parentFetch.localPath ? {packageFs: new CwdFS(PortablePath2.root), prefixPath: ppath.relative(PortablePath2.root, parentFetch.localPath)} : parentFetch;
    if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
      parentFetch.releaseFs();
    const patchFiles = await miscUtils10.releaseAfterUseAsync(async () => {
      return await Promise.all(patchPaths.map(async (patchPath) => visitPatchPath2({
        onAbsolute: async () => {
          return await xfs.readFilePromise(patchPath, `utf8`);
        },
        onRelative: async () => {
          if (parentFetch === null)
            throw new Error(`Assertion failed: The parent locator should have been fetched`);
          return await parentFetch.packageFs.readFilePromise(patchPath, `utf8`);
        },
        onBuiltin: async (name) => {
          return await opts.project.configuration.firstHook((hooks) => {
            return hooks.getBuiltinPatch;
          }, opts.project, name);
        }
      }, patchPath)));
    });
    return patchFiles.map((definition) => {
      if (typeof definition === `string`) {
        return definition.replace(/\r\n?/g, `
`);
      } else {
        return definition;
      }
    });
  }
  async function extractPackageToDisk2(locator, {cache: cache2, project}) {
    const checksums = project.storedChecksums;
    const report = new ThrowReport();
    const fetcher = project.configuration.makeFetcher();
    const fetchResult = await fetcher.fetch(locator, {cache: cache2, project, fetcher, checksums, report});
    const temp = await xfs.mktempPromise();
    await xfs.copyPromise(temp, fetchResult.prefixPath, {
      baseFs: fetchResult.packageFs
    });
    await xfs.writeJsonPromise(ppath.join(temp, `.yarn-patch.json`), {
      locator: structUtils_exports.stringifyLocator(locator)
    });
    xfs.detachTemp(temp);
    return temp;
  }
  async function diffFolders2(folderA, folderB) {
    const folderAN = npath.fromPortablePath(folderA).replace(/\\/g, `/`);
    const folderBN = npath.fromPortablePath(folderB).replace(/\\/g, `/`);
    const {stdout, stderr} = await execUtils_exports.execvp(`git`, [`diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, folderAN, folderBN], {
      cwd: npath.toPortablePath(process.cwd())
    });
    if (stderr.length > 0)
      throw new Error(`Unable to diff directories. Make sure you have a recent version of 'git' available in PATH.
The following error was reported by 'git':
${stderr}`);
    const normalizePath = folderAN.startsWith(`/`) ? (p) => p.slice(1) : (p) => p;
    return stdout.replace(new RegExp(`(a|b)(${miscUtils10.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`).replace(new RegExp(`(a|b)${miscUtils10.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`).replace(new RegExp(miscUtils10.escapeRegExp(`${folderAN}/`), `g`), ``).replace(new RegExp(miscUtils10.escapeRegExp(`${folderBN}/`), `g`), ``);
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\tools\format.ts
  function reportHunk2(hunk, {configuration, report}) {
    for (const part of hunk.parts) {
      for (const line of part.lines) {
        switch (part.type) {
          case PatchMutationType2.Context:
            {
              report.reportInfo(null, `  ${formatUtils_exports.pretty(configuration, line, `grey`)}`);
            }
            break;
          case PatchMutationType2.Deletion:
            {
              report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `- ${formatUtils_exports.pretty(configuration, line, formatUtils_exports.Type.REMOVED)}`);
            }
            break;
          case PatchMutationType2.Insertion:
            {
              report.reportError(MessageName.FROZEN_LOCKFILE_EXCEPTION, `+ ${formatUtils_exports.pretty(configuration, line, formatUtils_exports.Type.ADDED)}`);
            }
            break;
          default: {
            miscUtils10.assertNever(part.type);
          }
        }
      }
    }
  }

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\PatchFetcher.ts
  var PatchFetcher2 = class {
    supports(locator, opts) {
      if (!locator.reference.startsWith(`patch:`))
        return false;
      return true;
    }
    getLocalPath(locator, opts) {
      return null;
    }
    async fetch(locator, opts) {
      const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
      const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
        onHit: () => opts.report.reportCacheHit(locator),
        onMiss: () => opts.report.reportCacheMiss(locator, `${structUtils_exports.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
        loader: () => this.patchPackage(locator, opts),
        skipIntegrityCheck: opts.skipIntegrityCheck
      });
      return {
        packageFs,
        releaseFs,
        prefixPath: structUtils_exports.getIdentVendorPath(locator),
        localPath: this.getLocalPath(locator, opts),
        checksum
      };
    }
    async patchPackage(locator, opts) {
      const {parentLocator, sourceLocator, sourceVersion, patchPaths} = parseLocator3(locator);
      const patchFiles = await loadPatchFiles2(parentLocator, patchPaths, opts);
      const tmpDir = await xfs.mktempPromise();
      const tmpFile = ppath.join(tmpDir, `patched.zip`);
      const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
      const prefixPath = structUtils_exports.getIdentVendorPath(locator);
      const libzip = await getLibzipPromise();
      const patchedPackage = new ZipFS(tmpFile, {
        libzip,
        create: true,
        level: opts.project.configuration.get(`compressionLevel`)
      });
      await patchedPackage.mkdirpPromise(prefixPath);
      await miscUtils10.releaseAfterUseAsync(async () => {
        await patchedPackage.copyPromise(prefixPath, sourceFetch.prefixPath, {baseFs: sourceFetch.packageFs, stableSort: true});
      }, sourceFetch.releaseFs);
      const patchFs3 = new CwdFS(ppath.resolve(PortablePath2.root, prefixPath), {baseFs: patchedPackage});
      for (const patchFile of patchFiles) {
        if (patchFile !== null) {
          try {
            await applyPatchFile2(parsePatchFile2(patchFile), {
              baseFs: patchFs3,
              version: sourceVersion
            });
          } catch (err) {
            if (!(err instanceof UnmatchedHunkError2))
              throw err;
            const enableInlineHunks = opts.project.configuration.get(`enableInlineHunks`);
            const suggestion = !enableInlineHunks ? ` (set enableInlineHunks for details)` : ``;
            throw new ReportError(MessageName.PATCH_HUNK_FAILED, err.message + suggestion, (report) => {
              if (!enableInlineHunks)
                return;
              reportHunk2(err.hunk, {
                configuration: opts.project.configuration,
                report
              });
            });
          }
        }
      }
      return patchedPackage;
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\PatchResolver.ts
  var CACHE_VERSION4 = 2;
  var PatchResolver2 = class {
    supportsDescriptor(descriptor, opts) {
      if (!descriptor.range.startsWith(`patch:`))
        return false;
      return true;
    }
    supportsLocator(locator, opts) {
      if (!locator.reference.startsWith(`patch:`))
        return false;
      return true;
    }
    shouldPersistResolution(locator, opts) {
      return false;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
      const {patchPaths} = parseDescriptor3(descriptor);
      if (patchPaths.every((patchPath) => !isParentRequired2(patchPath)))
        return descriptor;
      return structUtils_exports.bindDescriptor(descriptor, {
        locator: structUtils_exports.stringifyLocator(fromLocator)
      });
    }
    getResolutionDependencies(descriptor, opts) {
      const {sourceDescriptor} = parseDescriptor3(descriptor);
      return [sourceDescriptor];
    }
    async getCandidates(descriptor, dependencies, opts) {
      if (!opts.fetchOptions)
        throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
      const {parentLocator, sourceDescriptor, patchPaths} = parseDescriptor3(descriptor);
      const patchFiles = await loadPatchFiles2(parentLocator, patchPaths, opts.fetchOptions);
      const sourcePackage = dependencies.get(sourceDescriptor.descriptorHash);
      if (typeof sourcePackage === `undefined`)
        throw new Error(`Assertion failed: The dependency should have been resolved`);
      const patchHash = hashUtils_exports.makeHash(`${CACHE_VERSION4}`, ...patchFiles).slice(0, 6);
      return [makeLocator5(descriptor, {parentLocator, sourcePackage, patchPaths, patchHash})];
    }
    async getSatisfying(descriptor, references, opts) {
      return null;
    }
    async resolve(locator, opts) {
      const {sourceLocator} = parseLocator3(locator);
      const sourcePkg = await opts.resolver.resolve(sourceLocator, opts);
      return {...sourcePkg, ...locator};
    }
  };

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\commands\patchCommit.ts
  var PatchCommitCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.patchFolder = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      const folderPath = ppath.resolve(this.context.cwd, npath.toPortablePath(this.patchFolder));
      const metaPath = ppath.join(folderPath, `.yarn-patch.json`);
      if (!xfs.existsSync(metaPath))
        throw new UsageError(`The argument folder didn't get created by 'yarn patch'`);
      const meta = await xfs.readJsonPromise(metaPath);
      const locator = structUtils_exports.parseLocator(meta.locator, true);
      if (!project.storedPackages.has(locator.locatorHash))
        throw new UsageError(`No package found in the project for the given locator`);
      const originalPath = await extractPackageToDisk2(locator, {cache: cache2, project});
      this.context.stdout.write(await diffFolders2(originalPath, folderPath));
    }
  };
  PatchCommitCommand2.paths = [
    [`patch-commit`]
  ];
  PatchCommitCommand2.usage = Command.Usage({
    description: `
      This will print a patchfile based on the diff between the folder passed in and the original version of the package.
      Such file is suitable for consumption with the \`patch:\` protocol.

      Only folders generated through \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `
  });
  var patchCommit_default2 = PatchCommitCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\commands\patch.ts
  var PatchCommand2 = class extends BaseCommand {
    constructor() {
      super(...arguments);
      this.package = options_exports.String();
    }
    async execute() {
      const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
      const {project, workspace} = await Project.find(configuration, this.context.cwd);
      const cache2 = await Cache.find(configuration);
      if (!workspace)
        throw new WorkspaceRequiredError(project.cwd, this.context.cwd);
      await project.restoreInstallState();
      let locator = structUtils_exports.parseLocator(this.package);
      if (locator.reference === `unknown`) {
        const candidateLocators = miscUtils10.mapAndFilter([...project.storedPackages.values()], (pkg) => {
          if (pkg.identHash !== locator.identHash)
            return miscUtils10.mapAndFilter.skip;
          if (structUtils_exports.isVirtualLocator(pkg))
            return miscUtils10.mapAndFilter.skip;
          return pkg;
        });
        if (candidateLocators.length === 0)
          throw new UsageError(`No package found in the project for the given locator`);
        if (candidateLocators.length > 1)
          throw new UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):
${candidateLocators.map((locator2) => `
- ${structUtils_exports.prettyLocator(configuration, locator2)}`).join(``)}`);
        locator = candidateLocators[0];
      }
      if (!project.storedPackages.has(locator.locatorHash))
        throw new UsageError(`No package found in the project for the given locator`);
      await StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async (report) => {
        const temp = await extractPackageToDisk2(locator, {cache: cache2, project});
        report.reportInfo(MessageName.UNNAMED, `Package ${structUtils_exports.prettyLocator(configuration, locator)} got extracted with success!`);
        report.reportInfo(MessageName.UNNAMED, `You can now edit the following folder: ${formatUtils_exports.pretty(configuration, npath.fromPortablePath(temp), `magenta`)}`);
        report.reportInfo(MessageName.UNNAMED, `Once you are done run ${formatUtils_exports.pretty(configuration, `yarn patch-commit ${npath.fromPortablePath(temp)}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
      });
    }
  };
  PatchCommand2.paths = [
    [`patch`]
  ];
  PatchCommand2.usage = Command.Usage({
    description: `
      This command will cause a package to be extracted in a temporary directory (under a folder named "patch-workdir"). This folder will be editable at will; running \`yarn patch\` inside it will then cause Yarn to generate a patchfile and register it into your top-level manifest (cf the \`patch:\` protocol).
    `
  });
  var patch_default2 = PatchCommand2;

  // pnp:d:\temp\yarnpkg-sources\d0a670\.yarn\$$virtual\@yarnpkg-plugin-patch-virtual-8a5ab312c8\1\packages\plugin-patch\sources\index.ts
  var plugin22 = {
    configuration: {
      enableInlineHunks: {
        description: `If true, the installs will print unmatched patch hunks`,
        type: SettingsType.BOOLEAN,
        default: false
      }
    },
    commands: [
      patchCommit_default2,
      patch_default2
    ],
    fetchers: [
      PatchFetcher2
    ],
    resolvers: [
      PatchResolver2
    ]
  };
  var sources_default19 = plugin22;

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\tools\getPluginConfiguration.ts
  var getPluginConfiguration = () => ({
    modules: new Map([
      ["@yarnpkg/cli", sources_exports5],
      ["@yarnpkg/core", sources_exports4],
      ["@yarnpkg/fslib", sources_exports],
      ["@yarnpkg/libzip", sync_exports],
      ["@yarnpkg/parsers", sources_exports2],
      ["@yarnpkg/shell", sources_exports3],
      ["clipanion", advanced_exports],
      ["semver", _72],
      ["typanion", _82],
      ["@yarnpkg/plugin-essentials", sources_exports6],
      ["@yarnpkg/plugin-compat", sources_exports7],
      ["@yarnpkg/plugin-dlx", sources_exports8],
      ["@yarnpkg/plugin-file", sources_exports9],
      ["@yarnpkg/plugin-git", sources_exports10],
      ["@yarnpkg/plugin-github", sources_exports11],
      ["@yarnpkg/plugin-http", sources_exports12],
      ["@yarnpkg/plugin-init", sources_exports13],
      ["@yarnpkg/plugin-link", sources_exports14],
      ["@yarnpkg/plugin-node-modules", sources_exports16],
      ["@yarnpkg/plugin-npm", sources_exports29],
      ["@yarnpkg/plugin-npm-cli", sources_exports30],
      ["@yarnpkg/plugin-pack", sources_exports28],
      ["@yarnpkg/plugin-patch", sources_exports31],
      ["@yarnpkg/plugin-pnp", sources_exports15]
    ]),
    plugins: new Set([
      "@yarnpkg/plugin-essentials",
      "@yarnpkg/plugin-compat",
      "@yarnpkg/plugin-dlx",
      "@yarnpkg/plugin-file",
      "@yarnpkg/plugin-git",
      "@yarnpkg/plugin-github",
      "@yarnpkg/plugin-http",
      "@yarnpkg/plugin-init",
      "@yarnpkg/plugin-link",
      "@yarnpkg/plugin-node-modules",
      "@yarnpkg/plugin-npm",
      "@yarnpkg/plugin-npm-cli",
      "@yarnpkg/plugin-pack",
      "@yarnpkg/plugin-patch",
      "@yarnpkg/plugin-pnp"
    ])
  });

  // pnp:d:\temp\yarnpkg-sources\d0a670\packages\yarnpkg-cli\sources\cli.ts
  main({
    binaryVersion: YarnVersion || `<unknown>`,
    pluginConfiguration: getPluginConfiguration()
  });
})();
